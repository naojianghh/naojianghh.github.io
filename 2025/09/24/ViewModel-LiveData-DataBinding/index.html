
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>ViewModel+LiveData+DataBinding | NaoJianghh</title>
    <meta name="author" content="脑浆糊" />
    <meta name="description" content="Welcome to My Blog" />
    <meta name="keywords" content="学习" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="NaoJianghh" type="application/atom+xml">
</head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>NAOJIANGHH</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;NAOJIANGHH</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>ViewModel+LiveData+DataBinding</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/24
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/Android/" style="color: #00bcd4">
                    Android
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p> ViewModel + LiveData + DataBinding 是 Android 官方推荐的 MVVM 架构核心组合，三者协同实现了<strong>数据驱动 UI</strong>、<strong>生命周期安全</strong>和<strong>双向绑定</strong>，彻底解决了传统 MVC 架构的内存泄漏和代码耦合问题。 </p>
<span id="more"></span>

<h4 id="一、核心组件解析"><a href="#一、核心组件解析" class="headerlink" title="一、核心组件解析"></a>一、核心组件解析</h4><h5 id="1-ViewModel"><a href="#1-ViewModel" class="headerlink" title="1. ViewModel"></a>1. ViewModel</h5><ul>
<li><strong>作用</strong>：存储与 UI 相关的数据，生命周期独立于 Activity&#x2F;Fragment，屏幕旋转等配置变化时不会重建，避免数据丢失。</li>
<li>核心特性：<ul>
<li>不持有 View 引用（Activity&#x2F;Fragment），通过 LiveData 通知 UI 更新</li>
<li>可通过 <code>AndroidViewModel</code> 子类获取 Application 上下文（需谨慎使用）</li>
<li>自带 <code>viewModelScope</code> 协程作用域，自动在销毁时取消任务</li>
</ul>
</li>
</ul>
<pre><code class="kotlin">// 基础 ViewModel
class MainViewModel : ViewModel() &#123;
    private val _userName = MutableLiveData&lt;String&gt;(&quot;默认名称&quot;)
    val userName: LiveData&lt;String&gt; = _userName // 对外暴露只读LiveData

    fun updateName(newName: String) &#123;
        _userName.value = newName // 主线程更新
        // 子线程用 _userName.postValue(newName)
    &#125;
&#125;

// 需上下文的 AndroidViewModel（继承自 ViewModel）
class MyAndroidViewModel(application: Application) : AndroidViewModel(application) &#123;
    fun getAppVersion(): String &#123;
        return getApplication&lt;Application&gt;().packageManager
            .getPackageInfo(getApplication&lt;Application&gt;().packageName, 0).versionName
    &#125;
&#125;
</code></pre>
<h5 id="2-LiveData"><a href="#2-LiveData" class="headerlink" title="2. LiveData"></a>2. LiveData</h5><ul>
<li><strong>作用</strong>：可观察的数据持有者，感知 Activity&#x2F;Fragment 生命周期，仅在活跃状态（STARTED&#x2F;RESUMED）通知更新，避免内存泄漏。</li>
<li>核心子类：<ul>
<li><code>MutableLiveData</code>：可修改数据（内部使用），提供 <code>setValue()</code>（主线程）和 <code>postValue()</code>（子线程）</li>
<li><code>Transformations</code>：数据转换工具类，如 <code>map</code>（转换数据格式）、<code>switchMap</code>（根据数据切换观察目标）</li>
</ul>
</li>
</ul>
<pre><code class="kotlin">
// 一般定义方式
private val _data = MutableLiveData&lt;String&gt;() // 内部可变
val data: LiveData&lt;String&gt; = _data // 外部只读


// 数据转换示例
class UserViewModel : ViewModel() &#123;
    private val _userId = MutableLiveData&lt;String&gt;(&quot;1001&quot;)
    val userInfo: LiveData&lt;String&gt; = Transformations.map(_userId) &#123; id -&gt;
        &quot;用户ID: $id，名称: 张三&quot; // 将userId转换为用户信息字符串
    &#125;

    fun changeUserId(newId: String) &#123;
        _userId.value = newId // 触发userInfo自动更新
    &#125;
&#125;
</code></pre>
<h5 id="3-DataBinding"><a href="#3-DataBinding" class="headerlink" title="3. DataBinding"></a>3. DataBinding</h5><ul>
<li><strong>作用</strong>：将布局文件与数据直接绑定，省去 <code>findViewById</code> 和手动更新 UI 的代码，支持双向绑定。</li>
<li>核心特性：<ul>
<li>布局文件以 <code>&lt;layout&gt;</code> 为根标签，可声明变量和表达式</li>
<li>支持 <code>@&#123;variable&#125;</code> 单向绑定和 <code>@=&#123;variable&#125;</code> 双向绑定</li>
<li>自动关联 LiveData，数据变化时 UI 自动刷新</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;!-- activity_main.xml --&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;data&gt;
        &lt;variable name=&quot;viewModel&quot; type=&quot;com.example.MyViewModel&quot; /&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;!-- 单向绑定：UI展示ViewModel数据 --&gt;
        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@&#123;viewModel.userName&#125;&quot; /&gt;

        &lt;!-- 双向绑定：UI输入同步到ViewModel --&gt;
        &lt;EditText
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@=&#123;viewModel.inputText&#125;&quot; /&gt;

    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<h4 id="二、Activity-中使用流程"><a href="#二、Activity-中使用流程" class="headerlink" title="二、Activity 中使用流程"></a>二、Activity 中使用流程</h4><ol>
<li><p>开启 DataBinding</p>
<p>在<code>build.gradle.kts</code>中启用：</p>
</li>
</ol>
<pre><code class="kotlin">android &#123;
    buildFeatures &#123;
        dataBinding = true
    &#125;
&#125;
</code></pre>
<ol>
<li><strong>初始化绑定与 ViewModel</strong></li>
</ol>
<pre><code class="kotlin">class MainActivity : AppCompatActivity() &#123;
    private lateinit var binding: ActivityMainBinding
    private val viewModel: MainViewModel by viewModels() // 委托初始化

    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        
        // 初始化DataBinding
        binding = DataBindingUtil.setContentView(this, R.layout.activity_main)
        // 绑定ViewModel到布局
        binding.viewModel = viewModel
        // 关键：让DataBinding感知生命周期，自动处理LiveData
        binding.lifecycleOwner = this
    &#125;
&#125;
</code></pre>
<h4 id="三、Fragment-中使用流程"><a href="#三、Fragment-中使用流程" class="headerlink" title="三、Fragment 中使用流程"></a>三、Fragment 中使用流程</h4><p>Fragment 中获取 ViewModel 需注意<strong>共享范围</strong>：默认是 Fragment 自身，如需与宿主 Activity 共享，需指定 <code>ViewModelStoreOwner</code> 为 Activity。</p>
<pre><code class="kotlin">class MyFragment : Fragment() &#123;
    private lateinit var binding: FragmentMyBinding
    // 方案1：Fragment独立ViewModel
    private val fragmentViewModel: MyFragmentViewModel by viewModels()
    
    // 方案2：与Activity共享ViewModel
    private val sharedViewModel: SharedViewModel by activityViewModels()

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View &#123;
        // 初始化Fragment布局绑定
        binding = DataBindingUtil.inflate(inflater, R.layout.fragment_my, container, false)
        // 绑定ViewModel
        binding.fragmentVm = fragmentViewModel
        binding.sharedVm = sharedViewModel
        // 绑定生命周期所有者（Fragment自身）
        binding.lifecycleOwner = viewLifecycleOwner
        return binding.root
    &#125;
&#125;
</code></pre>
<h4 id="四、双向绑定进阶（以登录为例）"><a href="#四、双向绑定进阶（以登录为例）" class="headerlink" title="四、双向绑定进阶（以登录为例）"></a>四、双向绑定进阶（以登录为例）</h4><ol>
<li><strong>ViewModel 定义可观察数据</strong></li>
</ol>
<pre><code class="kotlin">class LoginViewModel : ViewModel() &#123;
    val username = MutableLiveData&lt;String&gt;(&quot;&quot;)
    val password = MutableLiveData&lt;String&gt;(&quot;&quot;)

    // 登录按钮状态（根据输入是否为空决定）
    val loginEnabled: LiveData&lt;Boolean&gt; = Transformations.map(username) &#123;
        it.isNotEmpty() &amp;&amp; password.value?.isNotEmpty() == true
    &#125;

    fun login() &#123;
        // 处理登录逻辑
    &#125;
&#125;
</code></pre>
<ol>
<li><strong>布局中双向绑定与事件绑定</strong></li>
</ol>
<pre><code class="xml">&lt;layout&gt;
    &lt;data&gt;
        &lt;variable name=&quot;vm&quot; type=&quot;com.example.LoginViewModel&quot; /&gt;
    &lt;/data&gt;

    &lt;EditText
        android:hint=&quot;用户名&quot;
        android:text=&quot;@=&#123;vm.username&#125;&quot; /&gt; &lt;!-- 双向绑定 --&gt;

    &lt;EditText
        android:hint=&quot;密码&quot;
        android:inputType=&quot;textPassword&quot;
        android:text=&quot;@=&#123;vm.password&#125;&quot; /&gt; &lt;!-- 双向绑定 --&gt;

    &lt;Button
        android:text=&quot;登录&quot;
        android:enabled=&quot;@&#123;vm.loginEnabled&#125;&quot; &lt;!-- 按钮状态随数据变化 --&gt;
        android:onClick=&quot;@&#123;() -&gt; vm.login()&#125;&quot; /&gt; &lt;!-- 点击事件绑定 --&gt;
&lt;/layout&gt;
</code></pre>
<h4 id="五、最佳实践"><a href="#五、最佳实践" class="headerlink" title="五、最佳实践"></a>五、最佳实践</h4><ol>
<li><p><strong>数据单向流动原则</strong>：</p>
<ul>
<li>UI 事件（点击、输入）→ ViewModel 处理 → 更新 LiveData → UI 自动刷新</li>
<li>禁止 ViewModel 直接操作 UI 组件</li>
</ul>
</li>
<li><p><strong>ViewModel 与 Repository 分层</strong>：</p>
<pre><code class="kotlin">class UserViewModel(private val repo: UserRepository) : ViewModel() &#123;
    fun loadUser() &#123;
        viewModelScope.launch &#123;
            val user = repo.fetchUser() // 数据层操作（网络/数据库）
            _user.value = user
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>避免过度使用双向绑定</strong>：仅在用户输入场景（如表单）使用，其他场景优先单向绑定，减少数据流向复杂性。</p>
</li>
<li><p><strong>Fragment 与 Activity 通信</strong>：通过共享 ViewModel 实现，避免使用接口回调。</p>
</li>
</ol>
<h4 id="六、UI组件监听的实现"><a href="#六、UI组件监听的实现" class="headerlink" title="六、UI组件监听的实现"></a>六、UI组件监听的实现</h4><p>组件监听（如点击、文本变化）应在 View 层（Activity&#x2F;Fragment）处理，然后通过调用 ViewModel 的方法将事件 “转发” 给 ViewModel，由 ViewModel 处理业务逻辑并更新 LiveData，最终通过 DataBinding 自动反映到 UI 上。</p>
<h5 id="示例：EditText-文本变化监听"><a href="#示例：EditText-文本变化监听" class="headerlink" title="示例：EditText 文本变化监听"></a>示例：EditText 文本变化监听</h5><pre><code class="kotlin">// ViewModel（只处理数据逻辑，不涉及任何View）
class SearchViewModel : ViewModel() &#123;
    private val _searchText = MutableLiveData&lt;String&gt;(&quot;&quot;)
    val searchText: LiveData&lt;String&gt; = _searchText

    // 处理文本变化的业务逻辑（如过滤、搜索）
    fun onTextChanged(newText: String) &#123;
        _searchText.value = newText
        // 其他逻辑：如防抖搜索、过滤条件判断等
    &#125;
&#125;

// Activity（View层，负责组件监听并转发事件）
class SearchActivity : AppCompatActivity() &#123;
    private val viewModel: SearchViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        val binding = ActivitySearchBinding.inflate(layoutInflater)
        setContentView(binding.root)
        binding.lifecycleOwner = this
        binding.vm = viewModel

        // 组件监听在View层实现，调用ViewModel方法转发事件
        binding.searchEt.addTextChangedListener(object : TextWatcher &#123;
            override fun afterTextChanged(s: Editable?) &#123;
                // 将文本变化事件转发给ViewModel
                viewModel.onTextChanged(s?.toString() ?: &quot;&quot;)
            &#125;
            // 其他方法省略...
        &#125;)
    &#125;
&#125;
</code></pre>
<h4 id="七、ViewModel委托初始化"><a href="#七、ViewModel委托初始化" class="headerlink" title="七、ViewModel委托初始化"></a>七、ViewModel委托初始化</h4><h5 id="核心委托方式：viewModels-与-activityViewModels"><a href="#核心委托方式：viewModels-与-activityViewModels" class="headerlink" title="核心委托方式：viewModels() 与 activityViewModels()"></a>核心委托方式：<code>viewModels()</code> 与 <code>activityViewModels()</code></h5><p>AndroidX 提供了 <strong><code>androidx.activity.viewModels</code></strong> 和 <strong><code>androidx.fragment.app.viewModels</code></strong> 扩展函数，通过委托自动处理 <code>AndroidViewModel</code> 的初始化，无需手动创建 <code>ViewModelProvider.Factory</code>。</p>
<p>确保 <code>build.gradle.kts</code> 中包含 ViewModel 扩展库（通常已默认包含）：</p>
<pre><code class="kotlin">dependencies &#123;
    implementation(&quot;androidx.activity:activity-ktx:1.8.0&quot;) // 提供Activity的viewModels()
    implementation(&quot;androidx.fragment:fragment-ktx:1.6.2&quot;) // 提供Fragment的viewModels()
&#125;
</code></pre>
<pre><code class="kotlin"> private val viewModel: MyAndroidViewModel by viewModels()
</code></pre>
<h4 id="八、MutableLiveData：-setValue-（主线程）和-postValue-（子线程）"><a href="#八、MutableLiveData：-setValue-（主线程）和-postValue-（子线程）" class="headerlink" title="八、MutableLiveData： setValue()（主线程）和 postValue()（子线程）"></a>八、<code>MutableLiveData</code>： <code>setValue()</code>（主线程）和 <code>postValue()</code>（子线程）</h4><h5 id="1-调用线程限制"><a href="#1-调用线程限制" class="headerlink" title="1. 调用线程限制"></a>1. 调用线程限制</h5><ul>
<li>**<code>setValue</code>**：要求必须在主线程（UI 线程）中调用。因为<code>LiveData</code>主要用于和 UI 交互，在主线程更新数据可以保证 UI 的及时更新以及线程安全，避免多线程并发访问导致的 UI 错乱等问题。如果在子线程中调用<code>setValue</code>，会抛出<code>IllegalStateException</code>异常。例如：</li>
</ul>
<pre><code class="kotlin">import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel

class MyViewModel : ViewModel() &#123;
    private val _data = MutableLiveData&lt;String&gt;(&quot;初始值&quot;)
    val data: MutableLiveData&lt;String&gt; = _data

    fun updateDataOnMainThread() &#123;
        // 正确，在主线程调用setValue
        _data.setValue(&quot;更新后的值&quot;) 
    &#125;
&#125;
</code></pre>
<ul>
<li>**<code>postValue</code>**：没有线程限制，可以在子线程中调用。它内部会通过<code>Handler</code>机制将数据更新操作切换到主线程执行，从而实现子线程更新<code>LiveData</code>数据。这在进行异步操作（如网络请求、数据库操作）后更新数据时非常有用。示例如下：</li>
</ul>
<pre><code class="kotlin">import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

class AnotherViewModel : ViewModel() &#123;
    private val _result = MutableLiveData&lt;String&gt;()
    val result: MutableLiveData&lt;String&gt; = _result

    fun fetchData() &#123;
        runBlocking &#123;
            launch(Dispatchers.IO) &#123;
                val data = &quot;从子线程获取的数据&quot;
                // 在子线程中使用postValue更新LiveData
                _result.postValue(data) 
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="2-更新时机与方式"><a href="#2-更新时机与方式" class="headerlink" title="2. 更新时机与方式"></a>2. 更新时机与方式</h5><ul>
<li>**<code>setValue</code>**：会立即更新<code>LiveData</code>所持有的值，并通知所有处于活跃状态（<code>STARTED</code> 或 <code>RESUMED</code> 状态）的观察者，让它们可以及时更新 UI 或执行相应逻辑。</li>
<li>**<code>postValue</code>**：不会立即更新数据，而是将更新操作发送到主线程的消息队列中。当主线程空闲时，才会从消息队列中取出该操作并执行，进而更新<code>LiveData</code>的值并通知观察者。如果在短时间内多次调用<code>postValue</code>，<code>LiveData</code>只会保留最后一次设置的值，并在合适的时候进行更新。比如：</li>
</ul>
<pre><code class="kotlin">class TestViewModel : ViewModel() &#123;
    private val _number = MutableLiveData&lt;Int&gt;()
    val number: MutableLiveData&lt;Int&gt; = _number

    fun multiplePostValue() &#123;
        // 短时间内多次调用postValue
        for (i in 1..3) &#123;
            _number.postValue(i)
        &#125;
        // 最终LiveData的值是3
    &#125;
&#125;
</code></pre>
<h5 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h5><ul>
<li>**<code>setValue</code>**：适用于在主线程中，当数据的更新是由主线程中的操作（如按钮点击事件）触发，并且希望数据能立即更新并通知观察者的场景。</li>
<li>**<code>postValue</code>**：适用于在异步任务（如网络请求、读取文件等）完成后，需要更新<code>LiveData</code>数据并通知 UI 的场景，因为异步任务通常在子线程中执行。</li>
</ul>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 NaoJianghh
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;脑浆糊
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="naojianghh/naojianghh.github.io"
    data-repo-id="R_kgDON0mDmw"
    data-category="Announcements"
    data-category-id="DIC_kwDON0mDm84CoLx1"
    data-mapping="url"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





    
</body>
<canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>

<canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
</html>

