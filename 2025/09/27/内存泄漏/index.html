
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>内存泄漏 | NaoJianghh</title>
    <meta name="author" content="脑浆糊" />
    <meta name="description" content="Welcome to My Blog" />
    <meta name="keywords" content="学习" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="NaoJianghh" type="application/atom+xml">
</head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>NAOJIANGHH</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;NAOJIANGHH</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>内存泄漏</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/9/27
        </span>
        
        <span class="category">
            <a href="/categories/Android/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Android
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/java/" style="color: #03a9f4">
                    java
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p> 在 Android 开发中，内存泄露是一个常见且棘手的问题，它指的是程序中不再使用的对象无法被垃圾回收器回收，导致内存占用持续增加，最终可能引发应用崩溃（OOM：OutOfMemoryError）。</p>
<span id="more"></span>

<p>内存泄漏（Memory Leak）是指在程序运行过程中，<strong>不再需要使用的内存空间无法被系统回收</strong>，导致这部分内存被永久占用，最终可能引发内存耗尽（OOM，OutOfMemoryError）的现象。</p>
<p>从技术角度更精确地说：当一个对象<strong>已经失去了所有使用价值</strong>（即程序中没有任何活跃的引用指向它），但由于某种原因，<strong>垃圾回收器（Garbage Collector，GC）无法识别这种状态</strong>，导致该对象仍然被保留在内存中，就形成了内存泄漏。</p>
<h3 id="内存泄漏的核心特征："><a href="#内存泄漏的核心特征：" class="headerlink" title="内存泄漏的核心特征："></a>内存泄漏的核心特征：</h3><ol>
<li><strong>无用性</strong>：泄漏的对象已经不再被程序的任何部分使用（没有实际业务意义）。</li>
<li><strong>不可回收性</strong>：由于引用链未断裂等原因，垃圾回收器无法将其判定为 “可回收对象”，导致内存无法释放。</li>
<li><strong>累积性</strong>：单个内存泄漏可能影响微小，但长期运行或高频触发下，泄漏的内存会持续累积，最终耗尽可用内存。</li>
</ol>
<h3 id="与相关概念的区别："><a href="#与相关概念的区别：" class="headerlink" title="与相关概念的区别："></a>与相关概念的区别：</h3><ul>
<li><strong>内存溢出（OOM）</strong>：内存泄漏是原因之一，OOM 是结果（内存耗尽时抛出的错误）。</li>
<li><strong>内存占用高</strong>：合理的内存占用是程序正常运行所需，而内存泄漏是 “无效占用”。</li>
</ul>
<h3 id="为什么会发生内存泄漏？"><a href="#为什么会发生内存泄漏？" class="headerlink" title="为什么会发生内存泄漏？"></a>为什么会发生内存泄漏？</h3><p>现代编程语言（如 Java、Kotlin）都有自动垃圾回收机制，但仍可能因<strong>错误的引用管理</strong>导致内存泄漏。例如：</p>
<ul>
<li>长生命周期对象（如单例）持有短生命周期对象（如 Activity）的强引用。</li>
<li>未及时移除的监听器、回调或事件订阅。</li>
<li>缓存中的对象未设置过期策略，导致无用对象长期驻留。</li>
</ul>
<p>这些场景会形成 “无效引用链”，让垃圾回收器误认为对象仍在使用，从而无法回收。</p>
<h3 id="常见的内存泄露场景"><a href="#常见的内存泄露场景" class="headerlink" title="常见的内存泄露场景"></a>常见的内存泄露场景</h3><ol>
<li><p><strong>静态 Activity&#x2F;Context 引用</strong></p>
<p>Activity 或 Context 包含大量资源（如视图、Bitmap 等），若被静态变量引用，会导致 Activity 无法被回收，即使页面已关闭。</p>
<pre><code class="java">// 错误示例
public class MyActivity extends AppCompatActivity &#123;
    private static Context sContext; // 静态引用
    
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        sContext = this; // 持有Activity引用
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>长生命周期对象持有短生命周期对象</strong></p>
<p>例如，单例模式（全局生命周期）持有 Activity（页面生命周期）的引用，会导致 Activity 无法释放。</p>
<pre><code class="java">// 错误示例
public class Singleton &#123;
    private static Singleton sInstance;
    private Context mContext;
    
    private Singleton(Context context) &#123;
        mContext = context; // 若传入Activity，会导致泄露
    &#125;
    
    public static Singleton getInstance(Context context) &#123;
        if (sInstance == null) &#123;
            sInstance = new Singleton(context);
        &#125;
        return sInstance;
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>未取消的监听器 &#x2F; 回调</strong></p>
<p>如注册了系统服务监听器（如传感器、广播）、EventBus 事件等，未在适当时候取消注册，会导致监听器持有 Activity 引用。</p>
</li>
<li><p><strong>Handler 内存泄露</strong></p>
<p>Handler 若为非静态内部类，会隐式持有外部类（如 Activity）的引用。若 Handler 发送的消息在消息队列中未处理完，Activity 会被一直持有。</p>
<pre><code class="java">// 错误示例
public class MyActivity extends AppCompatActivity &#123;
    private Handler mHandler = new Handler() &#123; // 非静态内部类
        @Override
        public void handleMessage(Message msg) &#123;
            // 处理消息
        &#125;
    &#125;;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        mHandler.postDelayed(new Runnable() &#123;
            @Override
            public void run() &#123; /* 延迟任务 */ &#125;
        &#125;, 10000); // 若10秒内关闭页面，Activity会被泄露
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>资源未关闭</strong></p>
<p>如文件流（FileInputStream）、数据库连接（SQLiteDatabase）、网络连接等未关闭，会导致资源无法释放。</p>
</li>
<li><p><strong>WebView 泄露</strong></p>
<p>WebView 本身容易内存泄露，若不妥善处理（如在单独进程中使用，或销毁时移除并置空），可能导致整个 Activity 无法回收。</p>
</li>
</ol>
<h3 id="Android-Studio-检测内存泄露的工具"><a href="#Android-Studio-检测内存泄露的工具" class="headerlink" title="Android Studio 检测内存泄露的工具"></a>Android Studio 检测内存泄露的工具</h3><ol>
<li><strong>Profiler（内存分析器）</strong><ul>
<li>路径：<code>View &gt; Tool Windows &gt; Profiler</code></li>
<li>功能：实时监控应用内存使用情况，手动触发 GC（垃圾回收），记录内存快照（Heap Dump）。</li>
<li>操作：在内存波动异常时，点击 “Dump Java Heap” 生成快照，分析对象引用链，定位泄露根源。</li>
</ul>
</li>
<li><strong>LeakCanary（第三方库，推荐集成）</strong><ul>
<li>由 Square 开发的内存泄露检测库，可自动检测 Activity&#x2F;Fragment 的泄露并生成详细报告。</li>
<li>集成后，应用运行时若发生泄露，会在通知栏提示，并展示引用链（如 “Activity 被 Singleton 持有”）。</li>
</ul>
</li>
<li><strong>Lint 静态检查</strong><ul>
<li>Android Studio 内置的代码检查工具，可识别潜在的内存泄露风险（如静态 Context 引用）。</li>
<li>路径：<code>Analyze &gt; Inspect Code</code>，在结果中查看 “Memory issues” 相关警告。</li>
</ul>
</li>
</ol>
<h3 id="避免内存泄露的最佳实践"><a href="#避免内存泄露的最佳实践" class="headerlink" title="避免内存泄露的最佳实践"></a>避免内存泄露的最佳实践</h3><ol>
<li><p><strong>减少静态引用</strong></p>
<ul>
<li>避免静态变量持有 Activity&#x2F;Context，若需使用 Context，优先用 <code>getApplicationContext()</code>（生命周期与应用一致）。</li>
</ul>
</li>
<li><p><strong>使用弱引用（WeakReference）</strong></p>
<p>对短生命周期对象（如 Activity）使用弱引用，避免强引用导致无法回收：</p>
<pre><code class="java">// 正确示例：Handler + 弱引用
private static class MyHandler extends Handler &#123;
    private final WeakReference&lt;MyActivity&gt; mActivityRef;
    
    public MyHandler(MyActivity activity) &#123;
        mActivityRef = new WeakReference&lt;&gt;(activity);
    &#125;
    
    @Override
    public void handleMessage(Message msg) &#123;
        MyActivity activity = mActivityRef.get();
        if (activity != null) &#123;
            // 处理消息（需判断Activity是否已回收）
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>及时取消注册 &#x2F; 释放资源</strong></p>
<ul>
<li><p>在<code>onDestroy()</code>中取消监听器、EventBus 注册、Handler 消息等：</p>
<pre><code class="java">@Override
protected void onDestroy() &#123;
    super.onDestroy();
    mHandler.removeCallbacksAndMessages(null); // 移除所有消息
    EventBus.getDefault().unregister(this); // 取消EventBus注册
&#125;
</code></pre>
</li>
<li><p>关闭文件流、数据库连接等资源（可使用 try-with-resources 自动关闭）。</p>
</li>
</ul>
</li>
<li><p><strong>单例模式优化</strong></p>
<p>单例若需 Context，应传入 Application Context：</p>
<pre><code class="java">public static Singleton getInstance(Context context) &#123;
    if (sInstance == null) &#123;
        sInstance = new Singleton(context.getApplicationContext()); // 用Application Context
    &#125;
    return sInstance;
&#125;
</code></pre>
</li>
<li><p><strong>WebView 处理</strong></p>
<ul>
<li><p>尽量在单独进程中使用 WebView（在 Manifest 中配置 <code>android:process</code>）。</p>
</li>
<li><p>销毁时移除父布局并置空：</p>
<pre><code class="java">@Override
protected void onDestroy() &#123;
    if (mWebView != null) &#123;
        mWebView.removeAllViews();
        mWebView.destroy();
        mWebView = null;
    &#125;
    super.onDestroy();
&#125;
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2><h3 id="传入Application与Activity的区别"><a href="#传入Application与Activity的区别" class="headerlink" title="传入Application与Activity的区别"></a>传入Application与Activity的区别</h3><h4 id="一、本质区别：生命周期与作用范围"><a href="#一、本质区别：生命周期与作用范围" class="headerlink" title="一、本质区别：生命周期与作用范围"></a>一、本质区别：生命周期与作用范围</h4><ol>
<li><strong>Application</strong><ul>
<li><strong>生命周期</strong>：与应用进程一致，从应用启动到进程被杀死（如系统回收资源时），全局唯一且贯穿整个应用生命周期。</li>
<li><strong>作用范围</strong>：代表整个应用，是全局上下文，不与任何特定页面绑定。</li>
<li><strong>特性</strong>：内存占用稳定，不会因页面切换而销毁。</li>
</ul>
</li>
<li><strong>Activity</strong><ul>
<li><strong>生命周期</strong>：与页面绑定，随用户操作（如打开、关闭、旋转屏幕）经历 <code>onCreate()</code> 到 <code>onDestroy()</code> 的完整周期，可能被频繁创建和销毁。</li>
<li><strong>作用范围</strong>：代表单个页面，包含页面相关的视图、资源和状态。</li>
<li><strong>特性</strong>：持有大量页面相关资源（如布局、控件、图片等），内存占用较大。</li>
</ul>
</li>
</ol>
<h4 id="二、传入作为-Context-时的核心差异"><a href="#二、传入作为-Context-时的核心差异" class="headerlink" title="二、传入作为 Context 时的核心差异"></a>二、传入作为 Context 时的核心差异</h4><p>当需要传递 <code>Context</code> 时（如初始化工具类、单例、系统服务调用等），选择 <code>Application</code> 还是 <code>Activity</code> 会直接影响内存管理：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>传入 Application Context</th>
<th>传入 Activity Context</th>
</tr>
</thead>
<tbody><tr>
<td><strong>生命周期匹配</strong></td>
<td>适合长生命周期对象（如单例、全局工具类），生命周期一致。</td>
<td>仅适合与 Activity 生命周期绑定的场景（如弹出对话框、加载布局）。</td>
</tr>
<tr>
<td><strong>内存泄漏风险</strong></td>
<td>无风险，因为其生命周期与应用一致，不会因页面销毁而导致泄露。</td>
<td>高风险！若被长生命周期对象（如单例）持有，会导致 Activity 无法回收，引发内存泄漏。</td>
</tr>
<tr>
<td><strong>功能限制</strong></td>
<td>无法用于与页面相关的操作（如启动 Dialog、创建菜单），因缺少页面窗口信息。</td>
<td>可用于所有需要 Context 的场景，包括页面相关操作（如 <code>startActivity()</code>、<code>setContentView()</code>）。</td>
</tr>
</tbody></table>
<h4 id="三、典型使用场景对比"><a href="#三、典型使用场景对比" class="headerlink" title="三、典型使用场景对比"></a>三、典型使用场景对比</h4><ol>
<li><p><strong>单例模式中使用 Context</strong></p>
<ul>
<li><p>错误示例：传入 Activity 导致内存泄漏</p>
<pre><code class="java">// 单例（长生命周期）持有 Activity（短生命周期）引用 → 内存泄漏
public class DataManager &#123;
    private static DataManager sInstance;
    private Context mContext;
    
    private DataManager(Context context) &#123;
        mContext = context; // 若传入 Activity，会导致 Activity 无法回收
    &#125;
    
    public static DataManager getInstance(Context context) &#123;
        if (sInstance == null) &#123;
            sInstance = new DataManager(context); 
        &#125;
        return sInstance;
    &#125;
&#125;
</code></pre>
</li>
<li><p>正确示例：传入 Application Context</p>
<pre><code class="java">public static DataManager getInstance(Context context) &#123;
    if (sInstance == null) &#123;
        // 传入 Application Context，避免持有 Activity 引用
        sInstance = new DataManager(context.getApplicationContext()); 
    &#125;
    return sInstance;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>显示对话框（必须用 Activity Context）</strong></p>
<p>对话框需要依附于某个页面的窗口，必须使用 Activity Context：</p>
<pre><code class="java">// 正确：使用 Activity 作为 Context 显示对话框
new AlertDialog.Builder(this) // this 指向当前 Activity
    .setMessage(&quot;提示&quot;)
    .show();

// 错误：使用 Application Context 会崩溃（无窗口依附）
new AlertDialog.Builder(getApplicationContext()) 
    .setMessage(&quot;提示&quot;)
    .show(); // 崩溃：android.view.WindowManager$BadTokenException
</code></pre>
</li>
</ol>
<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><ul>
<li><strong>优先原则</strong>：若场景允许（如全局工具类、单例），尽量使用 <code>Application Context</code>，避免内存泄漏。</li>
<li><strong>限制场景</strong>：涉及页面交互（如对话框、启动新 Activity、加载布局）时，必须使用 <code>Activity Context</code>，但需注意避免被长生命周期对象持有。</li>
<li><strong>核心区别</strong>：<code>Application</code> 是全局上下文，生命周期与应用一致；<code>Activity</code> 是页面上下文，生命周期与页面绑定，滥用会导致内存泄漏。</li>
</ul>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 NaoJianghh
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;脑浆糊
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="naojianghh/naojianghh.github.io"
    data-repo-id="R_kgDON0mDmw"
    data-category="Announcements"
    data-category-id="DIC_kwDON0mDm84CoLx1"
    data-mapping="url"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin
    async
></script>





    
</body>
<canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>

<canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
</html>

