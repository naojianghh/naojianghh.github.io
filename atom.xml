<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NaoJianghh</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-10-30T15:34:38.666Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>脑浆糊</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线段树与序列树</title>
    <link href="http://example.com/2025/10/30/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%BA%8F%E5%88%97%E6%A0%91/"/>
    <id>http://example.com/2025/10/30/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%BA%8F%E5%88%97%E6%A0%91/</id>
    <published>2025-10-30T15:10:36.000Z</published>
    <updated>2025-10-30T15:34:38.666Z</updated>
    
    <content type="html"><![CDATA[<p>QAQ</p><span id="more"></span><h1 id="线段树与序列树详解"><a href="#线段树与序列树详解" class="headerlink" title="线段树与序列树详解"></a>线段树与序列树详解</h1><h2 id="线段树（Segment-Tree）"><a href="#线段树（Segment-Tree）" class="headerlink" title="线段树（Segment Tree）"></a>线段树（Segment Tree）</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p><strong>线段树</strong>是一种二叉树数据结构，主要用于解决<strong>区间查询</strong>和<strong>区间更新</strong>问题。</p><h3 id="二、核心特性"><a href="#二、核心特性" class="headerlink" title="二、核心特性"></a>二、核心特性</h3><ul><li><strong>适用场景</strong>：区间求和、区间最值、区间更新等</li><li><strong>时间复杂度</strong>：<ul><li>建树：O(n)</li><li>区间查询：O(log n)</li><li>单点更新：O(log n)</li><li>区间更新：O(log n)（使用懒惰传播）</li></ul></li><li><strong>空间复杂度</strong>：O(4n)（数组实现）</li></ul><h3 id="三、数据结构定义"><a href="#三、数据结构定义" class="headerlink" title="三、数据结构定义"></a>三、数据结构定义</h3><pre><code class="c++">class SegmentTree &#123;private:    vector&lt;int&gt; tree;  // 线段树数组    vector&lt;int&gt; arr;   // 原始数组    vector&lt;int&gt; lazy;  // 懒惰标记数组（用于区间更新）    int n;    public:    SegmentTree(vector&lt;int&gt;&amp; nums) &#123;        n = nums.size();        arr = nums;        tree.resize(4 * n);        lazy.resize(4 * n, 0);        build(0, n-1, 0);    &#125;&#125;;</code></pre><h3 id="四、建树过程"><a href="#四、建树过程" class="headerlink" title="四、建树过程"></a>四、建树过程</h3><pre><code class="c++">// 递归建树void build(int start, int end, int node) &#123;    if (start == end) &#123;        // 叶子节点，存储单个元素        tree[node] = arr[start];        return;    &#125;        int mid = (start + end) / 2;    int leftNode = 2 * node + 1;    int rightNode = 2 * node + 2;        // 递归构建左右子树    build(start, mid, leftNode);    build(mid + 1, end, rightNode);        // 合并左右子树结果（这里是求和）    tree[node] = tree[leftNode] + tree[rightNode];&#125;</code></pre><h3 id="五、区间查询"><a href="#五、区间查询" class="headerlink" title="五、区间查询"></a>五、区间查询</h3><pre><code class="c++">// 查询区间 [l, r] 的和int query(int l, int r, int start, int end, int node) &#123;    if (l &lt;= start &amp;&amp; end &lt;= r) &#123;        // 当前区间完全在查询范围内        return tree[node];    &#125;        int mid = (start + end) / 2;    int leftNode = 2 * node + 1;    int rightNode = 2 * node + 2;    int sum = 0;        if (l &lt;= mid) &#123;        sum += query(l, r, start, mid, leftNode);    &#125;    if (r &gt; mid) &#123;        sum += query(l, r, mid + 1, end, rightNode);    &#125;        return sum;&#125;// 对外接口int queryRange(int l, int r) &#123;    return query(l, r, 0, n-1, 0);&#125;</code></pre><h3 id="六、单点更新"><a href="#六、单点更新" class="headerlink" title="六、单点更新"></a>六、单点更新</h3><pre><code class="c++">// 更新单个元素void update(int index, int value, int start, int end, int node) &#123;    if (start == end) &#123;        // 找到目标叶子节点        arr[index] = value;        tree[node] = value;        return;    &#125;        int mid = (start + end) / 2;    int leftNode = 2 * node + 1;    int rightNode = 2 * node + 2;        if (index &lt;= mid) &#123;        update(index, value, start, mid, leftNode);    &#125; else &#123;        update(index, value, mid + 1, end, rightNode);    &#125;        // 更新父节点    tree[node] = tree[leftNode] + tree[rightNode];&#125;</code></pre><h3 id="七、懒惰传播（区间更新）"><a href="#七、懒惰传播（区间更新）" class="headerlink" title="七、懒惰传播（区间更新）"></a>七、懒惰传播（区间更新）</h3><pre><code class="c++">// 懒惰传播更新void updateLazy(int l, int r, int value, int start, int end, int node) &#123;    // 先处理懒惰标记    if (lazy[node] != 0) &#123;        tree[node] += (end - start + 1) * lazy[node];        if (start != end) &#123;            // 将懒惰标记传递给子节点            lazy[2*node+1] += lazy[node];            lazy[2*node+2] += lazy[node];        &#125;        lazy[node] = 0;    &#125;        if (start &gt; r || end &lt; l) return; // 完全不重叠        if (l &lt;= start &amp;&amp; end &lt;= r) &#123;        // 当前区间完全在更新范围内        tree[node] += (end - start + 1) * value;        if (start != end) &#123;            lazy[2*node+1] += value;            lazy[2*node+2] += value;        &#125;        return;    &#125;        int mid = (start + end) / 2;    updateLazy(l, r, value, start, mid, 2*node+1);    updateLazy(l, r, value, mid+1, end, 2*node+2);    tree[node] = tree[2*node+1] + tree[2*node+2];&#125;</code></pre><h2 id="序列树（树状数组）"><a href="#序列树（树状数组）" class="headerlink" title="序列树（树状数组）"></a>序列树（树状数组）</h2><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-什么是序列树？"><a href="#1-1-什么是序列树？" class="headerlink" title="1.1 什么是序列树？"></a>1.1 什么是序列树？</h3><p><strong>序列树（Fenwick Tree &#x2F; Binary Indexed Tree）</strong> 是一种用于高效处理<strong>前缀和查询</strong>和<strong>单点更新</strong>的数据结构。</p><h3 id="1-2-核心思想"><a href="#1-2-核心思想" class="headerlink" title="1.2 核心思想"></a>1.2 核心思想</h3><p>利用<strong>二进制表示</strong>的特性，将前缀和分解为多个子区间的和，从而实现：</p><ul><li><strong>前缀和查询</strong>：O(log n)</li><li><strong>单点更新</strong>：O(log n)</li></ul><h2 id="二、核心原理-Lowbit操作"><a href="#二、核心原理-Lowbit操作" class="headerlink" title="二、核心原理 - Lowbit操作"></a>二、核心原理 - Lowbit操作</h2><h3 id="2-1-Lowbit定义"><a href="#2-1-Lowbit定义" class="headerlink" title="2.1 Lowbit定义"></a>2.1 Lowbit定义</h3><p>**Lowbit(x)**：获取x的二进制表示中最低位的1所代表的数值</p><pre><code class="c++">int lowbit(int x) &#123;    return x &amp; (-x);&#125;</code></pre><h3 id="2-2-Lowbit示例"><a href="#2-2-Lowbit示例" class="headerlink" title="2.2 Lowbit示例"></a>2.2 Lowbit示例</h3><pre><code>x = 6  (二进制: 110)  → lowbit(6) = 2  (二进制: 010)x = 12 (二进制: 1100) → lowbit(12) = 4 (二进制: 0100)x = 7  (二进制: 111)  → lowbit(7) = 1  (二进制: 001)</code></pre><h2 id="三、序列树的结构原理"><a href="#三、序列树的结构原理" class="headerlink" title="三、序列树的结构原理"></a>三、序列树的结构原理</h2><h3 id="3-1-基本结构"><a href="#3-1-基本结构" class="headerlink" title="3.1 基本结构"></a>3.1 基本结构</h3><p>序列树不是一棵显式的树，而是通过数组和下标关系隐含的树形结构。</p><p><strong>数组下标从1开始</strong>（重要！）</p><ul><li><code>tree[i]</code>：存储区间<code>[i - lowbit(i) + 1, i]</code>的和</li></ul><h3 id="3-2-存储区间示意图"><a href="#3-2-存储区间示意图" class="headerlink" title="3.2 存储区间示意图"></a>3.2 存储区间示意图</h3><p>对于长度为8的数组：</p><pre><code>tree[1] = arr[1]                                          [1,1]tree[2] = arr[1] + arr[2]                                 [1,2]  tree[3] = arr[3]                                          [3,3]tree[4] = arr[1] + arr[2] + arr[3] + arr[4]               [1,4]tree[5] = arr[5]                                          [5,5]tree[6] = arr[5] + arr[6]                                 [5,6]tree[7] = arr[7]                                          [7,7]tree[8] = arr[1] + arr[2] + ... + arr[8]                  [1,8]</code></pre><h3 id="3-3-树形结构关系"><a href="#3-3-树形结构关系" class="headerlink" title="3.3 树形结构关系"></a>3.3 树形结构关系</h3><pre><code>                tree[8]               /       \          tree[4]     tree[6]   tree[7]          /     \     /          tree[2] tree[3] tree[5]      /tree[1]</code></pre><h2 id="四、关键操作原理"><a href="#四、关键操作原理" class="headerlink" title="四、关键操作原理"></a>四、关键操作原理</h2><h3 id="4-1-单点更新原理"><a href="#4-1-单点更新原理" class="headerlink" title="4.1 单点更新原理"></a>4.1 单点更新原理</h3><p><strong>目标</strong>：更新<code>arr[i]</code>时，更新所有包含<code>arr[i]</code>的<code>tree</code>节点</p><p><strong>更新路径</strong>：沿着二进制下标不断加上lowbit(i)</p><ul><li>从<code>i</code>开始</li><li><code>i = i + lowbit(i)</code></li><li>重复直到<code>i &gt; n</code></li></ul><pre><code class="C++">void update(int index, int value) &#123;    int i = index + 1;  // 序列树下标从1开始    while (i &lt;= n) &#123;        tree[i] += value;        i += lowbit(i);  // 跳到父节点    &#125;&#125;</code></pre><h4 id="更新示例：更新arr-3-（即tree-4-中的元素）"><a href="#更新示例：更新arr-3-（即tree-4-中的元素）" class="headerlink" title="更新示例：更新arr[3]（即tree[4]中的元素）"></a>更新示例：更新arr[3]（即tree[4]中的元素）</h4><p>更新路径：3 → 4 → 8</p><pre><code>更新arr[3] = 5:1. tree[3] += 5    (包含arr[3])2. tree[4] += 5    (包含arr[1]-arr[4])  3. tree[8] += 5    (包含arr[1]-arr[8])</code></pre><h3 id="4-2-前缀和查询原理"><a href="#4-2-前缀和查询原理" class="headerlink" title="4.2 前缀和查询原理"></a>4.2 前缀和查询原理</h3><p><strong>目标</strong>：计算<code>arr[1] + arr[2] + ... + arr[i]</code>的和</p><p><strong>查询路径</strong>：沿着二进制下标不断减去lowbit(i)</p><ul><li>从<code>i</code>开始</li><li><code>i = i - lowbit(i)</code></li><li>重复直到<code>i == 0</code></li></ul><pre><code>int query(int index) &#123;    int sum = 0;    int i = index + 1;  // 序列树下标从1开始    while (i &gt; 0) &#123;        sum += tree[i];        i -= lowbit(i);  // 跳到前一个区间    &#125;    return sum;&#125;</code></pre><h4 id="查询示例：查询前缀和-1-7"><a href="#查询示例：查询前缀和-1-7" class="headerlink" title="查询示例：查询前缀和[1,7]"></a>查询示例：查询前缀和[1,7]</h4><p>查询路径：7 → 6 → 4 → 结束</p><pre><code>查询前缀和[1,7]:sum = tree[7] + tree[6] + tree[4]tree[7] = arr[7]                    [7,7]tree[6] = arr[5] + arr[6]           [5,6]  tree[4] = arr[1] + arr[2] + arr[3] + arr[4]  [1,4]总和 = arr[1]到arr[7]的和</code></pre><h2 id="五、数学原理深度解析"><a href="#五、数学原理深度解析" class="headerlink" title="五、数学原理深度解析"></a>五、数学原理深度解析</h2><h3 id="5-1-二进制分解原理"><a href="#5-1-二进制分解原理" class="headerlink" title="5.1 二进制分解原理"></a>5.1 二进制分解原理</h3><p><strong>关键观察</strong>：任何数字都可以表示为2的幂次之和</p><pre><code>7 = 4 + 2 + 113 = 8 + 4 + 1</code></pre><p>序列树利用这个性质将前缀和分解：</p><pre><code>sum[1,7] = sum[1,4] + sum[5,6] + sum[7,7]         = tree[4] + tree[6] + tree[7]</code></pre><h3 id="5-2-区间覆盖证明"><a href="#5-2-区间覆盖证明" class="headerlink" title="5.2 区间覆盖证明"></a>5.2 区间覆盖证明</h3><p><strong>定理</strong>：对于任意i，区间<code>[i-lowbit(i)+1, i]</code>的长度正好是<code>lowbit(i)</code></p><p><strong>证明</strong>：</p><ul><li>设<code>i</code>的二进制为：<code>xxxx100...0</code>（最后k个0）</li><li><code>lowbit(i) = 2^k</code></li><li><code>i - lowbit(i) = xxxx000...0</code></li><li>区间长度 &#x3D; <code>i - (i - lowbit(i)) = lowbit(i)</code></li></ul><h3 id="5-3-操作正确性证明"><a href="#5-3-操作正确性证明" class="headerlink" title="5.3 操作正确性证明"></a>5.3 操作正确性证明</h3><p><strong>更新正确性</strong>：每个被更新的节点确实包含目标元素</p><ul><li>因为更新路径是不断加上lowbit，覆盖的区间越来越大</li><li>每个父节点都包含子节点的区间</li></ul><p><strong>查询正确性</strong>：所有子区间正好覆盖<code>[1, i]</code></p><ul><li>每次减去lowbit，得到不相交的区间</li><li>这些区间的并集正好是<code>[1, i]</code></li></ul><h2 id="六、完整实现与示例"><a href="#六、完整实现与示例" class="headerlink" title="六、完整实现与示例"></a>六、完整实现与示例</h2><h3 id="6-1-完整序列树实现"><a href="#6-1-完整序列树实现" class="headerlink" title="6.1 完整序列树实现"></a>6.1 完整序列树实现</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class FenwickTree &#123;private:    vector&lt;int&gt; tree;    int n;        int lowbit(int x) &#123;        return x &amp; (-x);    &#125;    public:    // 构造函数：从数组构建    FenwickTree(vector&lt;int&gt;&amp; nums) &#123;        n = nums.size();        tree.resize(n + 1, 0);        for (int i = 0; i &lt; n; i++) &#123;            update(i, nums[i]);        &#125;    &#125;        // 单点更新：在位置index增加value    void update(int index, int value) &#123;        int i = index + 1;  // 转为1-based索引        while (i &lt;= n) &#123;            tree[i] += value;            i += lowbit(i);        &#125;    &#125;        // 查询前缀和：[0, index]的和    int query(int index) &#123;        int sum = 0;        int i = index + 1;  // 转为1-based索引        while (i &gt; 0) &#123;            sum += tree[i];            i -= lowbit(i);        &#125;        return sum;    &#125;        // 查询区间和：[l, r]的和    int queryRange(int l, int r) &#123;        if (l == 0) return query(r);        return query(r) - query(l - 1);    &#125;        // 打印树结构（用于调试）    void printTree() &#123;        cout &lt;&lt; &quot;序列树结构:&quot; &lt;&lt; endl;        for (int i = 1; i &lt;= n; i++) &#123;            cout &lt;&lt; &quot;tree[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; tree[i]                  &lt;&lt; &quot; (覆盖区间: [&quot; &lt;&lt; i - lowbit(i) + 1 &lt;&lt; &quot;, &quot; &lt;&lt; i &lt;&lt; &quot;])&quot; &lt;&lt; endl;        &#125;    &#125;&#125;;</code></pre><h3 id="6-2-运行示例"><a href="#6-2-运行示例" class="headerlink" title="6.2 运行示例"></a>6.2 运行示例</h3><pre><code class="c++">int main() &#123;    vector&lt;int&gt; arr = &#123;1, 3, 5, 7, 9, 11&#125;;    FenwickTree ft(arr);        ft.printTree();        cout &lt;&lt; &quot;\n前缀和查询:&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;前缀和[0,2]: &quot; &lt;&lt; ft.query(2) &lt;&lt; &quot; (应为: 1+3+5=9)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;前缀和[0,4]: &quot; &lt;&lt; ft.query(4) &lt;&lt; &quot; (应为: 1+3+5+7+9=25)&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;\n区间和查询:&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;区间[2,4]: &quot; &lt;&lt; ft.queryRange(2, 4) &lt;&lt; &quot; (应为: 5+7+9=21)&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;\n更新测试:&quot; &lt;&lt; endl;    ft.update(3, 10);  // arr[3]从7增加到17    cout &lt;&lt; &quot;更新后区间[2,4]: &quot; &lt;&lt; ft.queryRange(2, 4) &lt;&lt; &quot; (应为: 5+17+9=31)&quot; &lt;&lt; endl;        return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;QAQ&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树与哈夫曼编码</title>
    <link href="http://example.com/2025/10/30/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <id>http://example.com/2025/10/30/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</id>
    <published>2025-10-30T14:54:11.000Z</published>
    <updated>2025-10-30T15:34:41.260Z</updated>
    
    <content type="html"><![CDATA[<p>QAQ</p><span id="more"></span><h1 id="哈夫曼树与哈夫曼编码详解"><a href="#哈夫曼树与哈夫曼编码详解" class="headerlink" title="哈夫曼树与哈夫曼编码详解"></a>哈夫曼树与哈夫曼编码详解</h1><h2 id="一、哈夫曼树构建原理"><a href="#一、哈夫曼树构建原理" class="headerlink" title="一、哈夫曼树构建原理"></a>一、哈夫曼树构建原理</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p><strong>哈夫曼树（Huffman Tree）</strong>：是一种带权路径长度最短的二叉树，也称为最优二叉树。</p><p><strong>关键术语：</strong></p><ul><li><strong>权值（Weight）</strong>：每个字符的出现频率或概率</li><li><strong>路径长度</strong>：从根节点到该节点的边数</li><li><strong>节点的带权路径长度</strong>：权值 × 路径长度</li><li><strong>树的带权路径长度（WPL）</strong>：所有叶子节点的带权路径长度之和</li></ul><h3 id="1-2-构建算法步骤"><a href="#1-2-构建算法步骤" class="headerlink" title="1.2 构建算法步骤"></a>1.2 构建算法步骤</h3><h4 id="步骤1：初始化"><a href="#步骤1：初始化" class="headerlink" title="步骤1：初始化"></a>步骤1：初始化</h4><p>将每个字符看作一个独立的二叉树，权值为该字符的频率，组成森林F。</p><p><strong>示例</strong>：假设有字符集 {A, B, C, D}，频率分别为 {5, 3, 2, 1}</p><p>初始森林：</p><pre><code>A(5)  B(3)  C(2)  D(1)</code></pre><h4 id="步骤2：选择最小权值树"><a href="#步骤2：选择最小权值树" class="headerlink" title="步骤2：选择最小权值树"></a>步骤2：选择最小权值树</h4><p>从森林F中选择<strong>权值最小的两棵树</strong>（如果有多棵树权值相同，任意选择）。</p><p>第一次选择：C(2) 和 D(1) 最小</p><h4 id="步骤3：合并树"><a href="#步骤3：合并树" class="headerlink" title="步骤3：合并树"></a>步骤3：合并树</h4><p>将选中的两棵树合并，新树的根节点权值为两棵树权值之和，原来的两棵树作为新树的左右子树。</p><p>合并C和D：</p><pre><code>新根节点(3)     /   \   C(2)  D(1)</code></pre><p>更新后的森林：</p><pre><code>A(5)  B(3)  新树(3)</code></pre><h4 id="步骤4：重复过程"><a href="#步骤4：重复过程" class="headerlink" title="步骤4：重复过程"></a>步骤4：重复过程</h4><p>重复步骤2-3，直到森林中只剩一棵树。</p><p><strong>第二次选择</strong>：B(3) 和新树(3) 最小（权值相同，任意选择）</p><pre><code>  新根节点(6)       /    \     B(3)   新树(3)              /   \            C(2)  D(1)</code></pre><p>更新后的森林：</p><pre><code>A(5)  新树(6)</code></pre><p><strong>第三次选择</strong>：A(5) 和新树(6) 合并</p><pre><code>    根节点(11)        /    \     A(5)    新树(6)              /   \            B(3)   子树(3)                    /   \                  C(2)  D(1)</code></pre><h3 id="1-3-构建过程可视化"><a href="#1-3-构建过程可视化" class="headerlink" title="1.3 构建过程可视化"></a>1.3 构建过程可视化</h3><pre><code>初始: A(5)  B(3)  C(2)  D(1)第1次合并:    C(2) + D(1) = 新树1(3)   森林: A(5)  B(3)  新树1(3)第2次合并:   B(3) + 新树1(3) = 新树2(6)   森林: A(5)  新树2(6)第3次合并:   A(5) + 新树2(6) = 根节点(11)   完成构建</code></pre><p>最终哈夫曼树：</p><pre><code>      11     /  \    5     6   A(5)  / \       3     3      B(3)  / \          2     1         C(2) D(1)</code></pre><h2 id="二、哈夫曼编码原理"><a href="#二、哈夫曼编码原理" class="headerlink" title="二、哈夫曼编码原理"></a>二、哈夫曼编码原理</h2><h3 id="2-1-编码规则"><a href="#2-1-编码规则" class="headerlink" title="2.1 编码规则"></a>2.1 编码规则</h3><p><strong>前缀编码特性</strong>：任何一个字符的编码都不是另一个字符编码的前缀，保证了解码的唯一性。</p><p><strong>编码规则：</strong></p><ol><li>从根节点开始，向左子树走编码为’0’，向右子树走编码为’1’</li><li>到达叶子节点时，路径上的0和1序列就是该字符的编码</li></ol><h3 id="2-2-编码过程"><a href="#2-2-编码过程" class="headerlink" title="2.2 编码过程"></a>2.2 编码过程</h3><p>基于上面构建的哈夫曼树：</p><pre><code>       11     0/  \1    5     6   A    0/ \1       3     3      B    0/ \1          2     1         C     D</code></pre><p><strong>编码生成：</strong></p><ul><li><strong>A</strong>：从根向左 → <code>0</code></li><li><strong>B</strong>：从根向右(1)，再向左(0) → <code>10</code></li><li><strong>C</strong>：从根向右(1)，再向右(1)，再向左(0) → <code>110</code></li><li><strong>D</strong>：从根向右(1)，再向右(1)，再向右(1) → <code>111</code></li></ul><p>编码表：</p><pre><code>A: 0B: 10  C: 110D: 111</code></pre><h3 id="2-3-编码验证"><a href="#2-3-编码验证" class="headerlink" title="2.3 编码验证"></a>2.3 编码验证</h3><p><strong>前缀编码验证：</strong></p><ul><li>A的编码<code>0</code>不是B<code>10</code>、C<code>110</code>、D<code>111</code>的前缀</li><li>B的编码<code>10</code>不是C<code>110</code>、D<code>111</code>的前缀</li><li>C的编码<code>110</code>不是D<code>111</code>的前缀</li></ul><p><strong>满足前缀编码条件，可以无歧义解码。</strong></p><h3 id="2-4-编码示例"><a href="#2-4-编码示例" class="headerlink" title="2.4 编码示例"></a>2.4 编码示例</h3><p>文本：<code>&quot;ABACABAD&quot;</code></p><p>编码过程：</p><pre><code>A: 0B: 10A: 0  C: 110A: 0B: 10A: 0D: 111</code></pre><p>编码结果：<code>0 10 0 110 0 10 0 111</code>→ <code>01001100100111</code></p><h3 id="2-5-解码过程"><a href="#2-5-解码过程" class="headerlink" title="2.5 解码过程"></a>2.5 解码过程</h3><p>编码流：<code>01001100100111</code></p><p>解码：</p><ol><li>从根开始，读入<code>0</code>→ 到达A，输出A，回到根</li><li>读入<code>1</code>→ 向右，读入<code>0</code>→ 到达B，输出B，回到根</li><li>读入<code>0</code>→ 到达A，输出A，回到根</li><li>读入<code>1</code>→ 向右，读入<code>1</code>→ 向右，读入<code>0</code>→ 到达C，输出C，回到根</li><li>继续解码…</li></ol><p>最终得到：<code>ABACABAD</code></p><h2 id="三、数学原理分析"><a href="#三、数学原理分析" class="headerlink" title="三、数学原理分析"></a>三、数学原理分析</h2><h3 id="3-1-最优性证明"><a href="#3-1-最优性证明" class="headerlink" title="3.1 最优性证明"></a>3.1 最优性证明</h3><p><strong>贪心选择性质</strong>：每次选择频率最小的两个节点合并，可以保证全局最优。</p><p><strong>数学证明思路：</strong></p><ol><li>频率最小的两个字符在最优编码中深度最大</li><li>这两个字符应该是兄弟节点</li><li>将问题规模缩小，数学归纳法证明</li></ol><h3 id="3-2-压缩效率计算"><a href="#3-2-压缩效率计算" class="headerlink" title="3.2 压缩效率计算"></a>3.2 压缩效率计算</h3><p><strong>原始编码</strong>（定长编码）：</p><ul><li>4个字符需要2位：A:00, B:01, C:10, D:11</li><li>文本”ABACABAD”长度：8字符 × 2位 &#x3D; 16位</li></ul><p><strong>哈夫曼编码</strong>：</p><ul><li>A(频率5): 1位 × 5次 &#x3D; 5位</li><li>B(频率3): 2位 × 3次 &#x3D; 6位</li><li>C(频率2): 3位 × 2次 &#x3D; 6位</li><li>D(频率1): 3位 × 1次 &#x3D; 3位</li><li>总位数：5 + 6 + 6 + 3 &#x3D; 20位</li></ul><p><strong>压缩率</strong>：(16 - 20)&#x2F;16 × 100% &#x3D; -25%（实际是膨胀，因为示例数据量小）</p><p><strong>注意</strong>：对于实际的大文本，高频字符用短编码，总体效果是压缩。</p><h3 id="3-3-复杂度分析"><a href="#3-3-复杂度分析" class="headerlink" title="3.3 复杂度分析"></a>3.3 复杂度分析</h3><p><strong>时间复杂度</strong>：O(n log n)</p><ul><li>使用最小堆选择最小权值节点</li></ul><p><strong>空间复杂度</strong>：O(n)</p><ul><li>存储哈夫曼树节点和编码表</li></ul><h2 id="四、核心特点总结"><a href="#四、核心特点总结" class="headerlink" title="四、核心特点总结"></a>四、核心特点总结</h2><h3 id="4-1-哈夫曼树特点"><a href="#4-1-哈夫曼树特点" class="headerlink" title="4.1 哈夫曼树特点"></a>4.1 哈夫曼树特点</h3><ol><li><strong>带权路径最短</strong>：WPL最小</li><li><strong>没有度为1的节点</strong>：严格的二叉树</li><li><strong>频率高的字符靠近根节点</strong></li><li><strong>频率低的字符在深层</strong></li></ol><h3 id="4-2-哈夫曼编码特点"><a href="#4-2-哈夫曼编码特点" class="headerlink" title="4.2 哈夫曼编码特点"></a>4.2 哈夫曼编码特点</h3><ol><li><strong>前缀编码</strong>：无歧义解码</li><li><strong>最优压缩</strong>：对于给定频率分布是最优的</li><li><strong>变长编码</strong>：高频字符用短编码，低频字符用长编码</li><li><strong>需要编码表</strong>：解码时需要哈夫曼树或编码表</li></ol><h2 id="五、哈夫曼树构建示例（cpp）"><a href="#五、哈夫曼树构建示例（cpp）" class="headerlink" title="五、哈夫曼树构建示例（cpp）"></a>五、哈夫曼树构建示例（cpp）</h2><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;// 哈夫曼树节点结构struct HuffmanNode &#123;    char data;           // 字符    int frequency;       // 频率    HuffmanNode *left;   // 左子树    HuffmanNode *right;  // 右子树        // 构造函数    HuffmanNode(char data, int frequency) : data(data), frequency(frequency),                                            left(nullptr), right(nullptr) &#123;&#125;&#125;;// 比较器，用于优先队列（最小堆）struct CompareNodes &#123;    bool operator()(HuffmanNode* a, HuffmanNode* b) &#123;        return a-&gt;frequency &gt; b-&gt;frequency; // 频率小的节点优先级高    &#125;&#125;;// 构建哈夫曼树HuffmanNode* buildHuffmanTree(const unordered_map&lt;char, int&gt;&amp; frequencies) &#123;    // 创建优先队列（最小堆）    priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, CompareNodes&gt; minHeap;        // 将所有字符节点加入堆    for (const auto&amp; pair : frequencies) &#123;        minHeap.push(new HuffmanNode(pair.first, pair.second));    &#125;        // 构建哈夫曼树    while (minHeap.size() &gt; 1) &#123;        // 取出频率最小的两个节点        HuffmanNode* left = minHeap.top();        minHeap.pop();                HuffmanNode* right = minHeap.top();        minHeap.pop();                // 创建新的内部节点，频率为两个节点频率之和        HuffmanNode* internalNode = new HuffmanNode(&#39;$&#39;, left-&gt;frequency + right-&gt;frequency);        internalNode-&gt;left = left;        internalNode-&gt;right = right;                // 将新节点加入堆        minHeap.push(internalNode);    &#125;        // 剩下的节点就是根节点    return minHeap.top();&#125;// 生成哈夫曼编码void generateHuffmanCodes(HuffmanNode* root, string currentCode,                          unordered_map&lt;char, string&gt;&amp; huffmanCodes) &#123;    if (root == nullptr) &#123;        return;    &#125;        // 如果是叶子节点，保存其编码    if (root-&gt;data != &#39;$&#39;) &#123;        huffmanCodes[root-&gt;data] = currentCode;        return;    &#125;        // 递归遍历左子树和右子树    generateHuffmanCodes(root-&gt;left, currentCode + &quot;0&quot;, huffmanCodes);    generateHuffmanCodes(root-&gt;right, currentCode + &quot;1&quot;, huffmanCodes);&#125;// 编码字符串string encodeString(const string&amp; text, const unordered_map&lt;char, string&gt;&amp; huffmanCodes) &#123;    string encodedString;    for (char c : text) &#123;        encodedString += huffmanCodes.at(c);    &#125;    return encodedString;&#125;// 解码哈夫曼编码string decodeString(const string&amp; encodedString, HuffmanNode* root) &#123;    string decodedString;    HuffmanNode* current = root;        for (char bit : encodedString) &#123;        if (bit == &#39;0&#39;) &#123;            current = current-&gt;left;        &#125; else &#123;            current = current-&gt;right;        &#125;                // 如果到达叶子节点        if (current-&gt;left == nullptr &amp;&amp; current-&gt;right == nullptr) &#123;            decodedString += current-&gt;data;            current = root; // 回到根节点，开始下一个字符的解码        &#125;    &#125;        return decodedString;&#125;// 计算字符频率unordered_map&lt;char, int&gt; calculateFrequencies(const string&amp; text) &#123;    unordered_map&lt;char, int&gt; frequencies;    for (char c : text) &#123;        frequencies[c]++;    &#125;    return frequencies;&#125;// 释放哈夫曼树内存void deleteHuffmanTree(HuffmanNode* root) &#123;    if (root == nullptr) return;    deleteHuffmanTree(root-&gt;left);    deleteHuffmanTree(root-&gt;right);    delete root;&#125;int main() &#123;    string text = &quot;this is an example for huffman encoding&quot;;        // 计算字符频率    unordered_map&lt;char, int&gt; frequencies = calculateFrequencies(text);        // 构建哈夫曼树    HuffmanNode* root = buildHuffmanTree(frequencies);        // 生成哈夫曼编码    unordered_map&lt;char, string&gt; huffmanCodes;    generateHuffmanCodes(root, &quot;&quot;, huffmanCodes);        // 输出哈夫曼编码    cout &lt;&lt; &quot;哈夫曼编码：&quot; &lt;&lt; endl;    for (const auto&amp; pair : huffmanCodes) &#123;        cout &lt;&lt; pair.first &lt;&lt; &quot; : &quot; &lt;&lt; pair.second &lt;&lt; endl;    &#125;        // 编码字符串    string encodedString = encodeString(text, huffmanCodes);    cout &lt;&lt; &quot;\n编码后的字符串：&quot; &lt;&lt; encodedString &lt;&lt; endl;        // 解码字符串    string decodedString = decodeString(encodedString, root);    cout &lt;&lt; &quot;\n解码后的字符串：&quot; &lt;&lt; decodedString &lt;&lt; endl;        // 计算压缩率    int originalSize = text.size() * 8; // 假设每个字符占8位    int compressedSize = encodedString.size();    double compressionRatio = (1.0 - (double)compressedSize / originalSize) * 100;    cout &lt;&lt; &quot;\n原始大小：&quot; &lt;&lt; originalSize &lt;&lt; &quot; 位&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;压缩后大小：&quot; &lt;&lt; compressedSize &lt;&lt; &quot; 位&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;压缩率：&quot; &lt;&lt; compressionRatio &lt;&lt; &quot;%&quot; &lt;&lt; endl;        // 释放内存    deleteHuffmanTree(root);        return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;QAQ&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>html简介与基本框架</title>
    <link href="http://example.com/2025/10/29/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2025/10/29/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</id>
    <published>2025-10-29T12:07:12.000Z</published>
    <updated>2025-10-29T12:40:45.048Z</updated>
    
    <content type="html"><![CDATA[<p> HTML（HyperText Markup Language，超文本标记语言） </p><span id="more"></span><h2 id="一、HTML-简介"><a href="#一、HTML-简介" class="headerlink" title="一、HTML 简介"></a><strong>一、HTML 简介</strong></h2><p>HTML（HyperText Markup Language，超文本标记语言）是用于创建网页的标准标记语言。它通过一系列<strong>标签（tags）</strong> 描述网页的结构和内容（如文本、图片、链接、表格等），浏览器会解析这些标签并将其渲染为可视化的网页。</p><ul><li>核心特点：<ul><li>不是编程语言，而是标记语言（通过标签定义内容的含义和结构）。</li><li>标签通常成对出现（如 &#96;&#96;），由开始标签、内容和结束标签组成。</li><li>不区分大小写，但推荐使用小写（符合规范）。</li></ul></li></ul><h2 id="二、HTML-基础框架"><a href="#二、HTML-基础框架" class="headerlink" title="二、HTML 基础框架"></a><strong>二、HTML 基础框架</strong></h2><p>一个完整的 HTML 文档有固定的基本结构，以下是最基础的框架：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;网页标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 这里是网页的可见内容 --&gt;    &lt;h1&gt;这是一级标题&lt;/h1&gt;    &lt;p&gt;这是一段文本。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="三、框架各部分说明"><a href="#三、框架各部分说明" class="headerlink" title="三、框架各部分说明"></a><strong>三、框架各部分说明</strong></h2><ol><li><strong><code>&lt;!DOCTYPE html&gt;</code></strong><ul><li>声明文档类型，告诉浏览器这是一个 HTML5 文档（必须放在文档最开头）。</li><li>不属于 HTML 标签，仅作为声明。</li></ul></li><li><strong><code>&lt;html&gt;</code>标签</strong><ul><li>整个 HTML 文档的根标签，所有内容都包裹在其中。</li><li><code>lang=&quot;zh-CN&quot;</code> 属性：指定文档主要语言为中文（有助于搜索引擎和辅助工具识别）。</li></ul></li><li><strong><code>&lt;head&gt;</code> 标签</strong><ul><li>包含文档的<strong>元数据（metadata）</strong>，即不直接显示在页面上的信息（如标题、编码方式、样式等）。</li><li>常见子标签：<ul><li><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：指定文档编码为 UTF-8（支持中文等多语言）。</li><li><code>&lt;meta name=&quot;viewport&quot; ...&gt;</code>：用于响应式设计，确保移动端页面正确缩放。</li><li><code>&lt;title&gt;</code>：定义网页标题（显示在浏览器标签页上，是搜索引擎优化的重要元素）。</li></ul></li></ul></li><li><strong><code>&lt;body&gt;</code> 标签</strong><ul><li>包含网页的<strong>可见内容</strong>，如文本、图片、链接、按钮等，浏览器会将这里的内容渲染到页面上。</li></ul></li></ol><h2 id="四、入门示例"><a href="#四、入门示例" class="headerlink" title="四、入门示例"></a><strong>四、入门示例</strong></h2><p>以下是一个简单的完整 HTML 页面示例，可直接保存为 <code>.html</code> 文件（如 <code>index.html</code>），用浏览器打开即可查看效果：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;我的第一个网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;欢迎来到我的网页&lt;/h1&gt;    &lt;p&gt;这是我用 HTML 写的第一个页面。&lt;/p&gt;    &lt;a href=&quot;https://www.example.com&quot;&gt;点击访问示例网站&lt;/a&gt;    &lt;img src=&quot;https://picsum.photos/200/100&quot; alt=&quot;示例图片&quot;&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="五、子标签"><a href="#五、子标签" class="headerlink" title="五、&lt;body&gt;子标签"></a>五、<code>&lt;body&gt;</code>子标签</h2><h3 id="文本与标题标签"><a href="#文本与标题标签" class="headerlink" title="文本与标题标签"></a>文本与标题标签</h3><p>用于组织页面文本内容，明确层级关系。</p><ol><li><p><strong>标题标签</strong>（ <code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>）表示不同级别的标题，<code>&lt;h1&gt;</code>级别最高 （通常一个页面只有一个）， <code>&lt;h6&gt;</code>最低。</p><p>属性：<code>align</code>（有left | center | right 三个值）。</p><pre><code class="html">&lt;h1&gt;一级标题（页面主标题）&lt;/h1&gt;&lt;h2&gt;二级标题（章节标题）&lt;/h2&gt;&lt;h3&gt;三级标题（小节标题）&lt;/h3&gt;&lt;!-- 以此类推到 h6 --&gt;&lt;h6 align=&quot;left&quot;&gt;六级标题 &lt;/h6&gt;</code></pre></li><li><p><strong>段落标签</strong>（<code>&lt;p&gt;</code>）定义一段文本，浏览器会自动在段落前后添加换行和间距。</p><pre><code class="html">&lt;p&gt;这是一段普通文本，用于描述内容。&lt;/p&gt;&lt;p&gt;段落标签会自动分隔内容，让页面更易读。&lt;/p&gt;</code></pre></li><li><p><strong>换行标签</strong>（<code>&lt;br&gt;</code>）强制换行（单标签，无需闭合），常用于段落内的换行。</p><pre><code class="html">&lt;p&gt;第一行文本&lt;br&gt;第二行文本（通过 br 标签换行）&lt;/p&gt;</code></pre></li><li><p><strong>文本格式化标签</strong></p><p>用于强调或修饰文本：</p><pre><code class="html">&lt;strong&gt;加粗文本&lt;/strong&gt;  &lt;!-- 语义上的强调，通常显示为粗体 --&gt;&lt;em&gt;斜体文本&lt;/em&gt;          &lt;!-- 语义上的强调，通常显示为斜体 --&gt;&lt;del&gt;删除线文本&lt;/del&gt;      &lt;!-- 表示已删除的内容 --&gt;&lt;ins&gt;下划线文本&lt;/ins&gt;      &lt;!-- 表示新增的内容 --&gt;</code></pre></li></ol><h3 id="链接标签（）"><a href="#链接标签（）" class="headerlink" title="链接标签（&lt;a&gt;）"></a>链接标签（<code>&lt;a&gt;</code>）</h3><p>定义超链接，用于跳转至其他页面、文件或同一页面的指定位置。</p><p>核心属性：<code>href</code>（目标地址）<code>target</code>（打开方式，<code>_blank</code>表示新窗口）。</p><pre><code class="html">&lt;!-- 跳转到外部网站 --&gt;&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度一下&lt;/a&gt;&lt;!-- 跳转到本地页面（同一文件夹下的 page.html） --&gt;&lt;a href=&quot;page.html&quot;&gt;访问内部页面&lt;/a&gt;&lt;!-- 跳转到页面内的指定位置（需配合 id 属性） --&gt;&lt;a href=&quot;#section1&quot;&gt;跳至第一部分&lt;/a&gt;&lt;h2 id=&quot;section1&quot;&gt;第一部分内容&lt;/h2&gt;&lt;!-- 邮件链接（点击打开邮件客户端） --&gt;&lt;a href=&quot;mailto:example@mail.com&quot;&gt;发送邮件&lt;/a&gt;</code></pre><h3 id="图像标签（）"><a href="#图像标签（）" class="headerlink" title="图像标签（&lt;img&gt;）"></a>图像标签（<code>&lt;img&gt;</code>）</h3><p>插入图片（单标签），核心属性：</p><ul><li><code>src</code>：图片路径（本地路径或网络 URL）。</li><li><code>alt</code>：图片加载失败时的替代文本（必填，提升可访问性）。</li><li><code>width</code>&#x2F;<code>height</code>：图片宽度 &#x2F; 高度（单位：像素或百分比）。</li></ul><pre><code class="html">&lt;!-- 插入网络图片 --&gt;&lt;img src=&quot;https://picsum.photos/400/200&quot; alt=&quot;示例风景图&quot; width=&quot;400&quot;&gt;&lt;!-- 插入本地图片（假设图片在 images 文件夹下） --&gt;&lt;img src=&quot;images/photo.jpg&quot; alt=&quot;本地照片&quot; height=&quot;200&quot;&gt;</code></pre><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p>用于展示有序或无序的列表项。</p><ol><li><p><strong>无序列表</strong>（<code>&lt;ul&gt;</code> + <code>&lt;li&gt;</code>）列表项前默认显示圆点（样式可通过 CSS 修改）。</p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;苹果&lt;/li&gt;  &lt;li&gt;香蕉&lt;/li&gt;  &lt;li&gt;橙子&lt;/li&gt;&lt;/ul&gt;</code></pre></li><li><p><strong>有序列表</strong>（<code>&lt;ol&gt;</code> + <code>&lt;li&gt;</code>）列表项前显示数字（默认）、字母等序号。</p><pre><code class="html">&lt;ol&gt;  &lt;li&gt;第一步：打开浏览器&lt;/li&gt;  &lt;li&gt;第二步：输入网址&lt;/li&gt;  &lt;li&gt;第三步：按下回车&lt;/li&gt;&lt;/ol&gt;</code></pre></li><li><p><strong>定义列表</strong>（<code>&lt;dl&gt;</code> + <code>&lt;dt&gt;</code> + <code>&lt;dd&gt;</code>）用于展示 “术语 - 解释” 类内容。</p><pre><code class="html">&lt;dl&gt;  &lt;dt&gt;HTML&lt;/dt&gt;  &lt;dd&gt;超文本标记语言，用于构建网页结构。&lt;/dd&gt;  &lt;dt&gt;CSS&lt;/dt&gt;  &lt;dd&gt;层叠样式表，用于美化网页。&lt;/dd&gt;&lt;/dl&gt;</code></pre></li></ol><h3 id="容器标签"><a href="#容器标签" class="headerlink" title="容器标签"></a>容器标签</h3><p>用于布局和分组内容，无默认样式，需配合 CSS 使用。</p><ol><li><p><code>&lt;div&gt;</code>：块级容器（独占一行），常用于大区块布局（如头部、主体、底部）。</p></li><li><p><code>&lt;span&gt;</code>：行内容器（不独占一行），常用于包裹文本中的部分内容（如单独修饰某段文字）。</p><pre><code class="html">&lt;p&gt;我喜欢 &lt;span style=&quot;color: red;&quot;&gt;红色&lt;/span&gt; 和 &lt;span style=&quot;color: blue;&quot;&gt;蓝色&lt;/span&gt;。&lt;/p&gt;</code></pre></li></ol><h3 id="表格标签（）"><a href="#表格标签（）" class="headerlink" title="表格标签（&lt;table&gt;）"></a>表格标签（<code>&lt;table&gt;</code>）</h3><p>用于展示结构化数据（如成绩单、价格表）。</p><p>核心标签：<code>&lt;table&gt;</code>（表格）、<code>&lt;tr&gt;</code>（行）、<code>&lt;td&gt;</code>（单元格）、<code>&lt;th&gt;</code>（表头单元格，默认加粗居中）。</p><pre><code class="html">&lt;table border=&quot;1&quot;&gt;  &lt;!-- border 属性添加边框（仅示例用，实际推荐用 CSS） --&gt;  &lt;tr&gt;    &lt;th&gt;姓名&lt;/th&gt;    &lt;th&gt;年龄&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;张三&lt;/td&gt;    &lt;td&gt;20&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;李四&lt;/td&gt;    &lt;td&gt;22&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;</code></pre><h3 id="表单标签（）"><a href="#表单标签（）" class="headerlink" title="表单标签（&lt;form&gt;）"></a>表单标签（<code>&lt;form&gt;</code>）</h3><p>用于收集用户输入（如登录、注册、搜索），配合输入类标签使用。</p><p>核心属性：<code>action</code>（提交数据的地址）、<code>method</code>（提交方式、<code>get</code>或<code>post</code>）</p><p>常用输入标签：</p><ul><li><code>&lt;input&gt;</code>：单行文本、密码、复选框等（通过 <code>type</code> 属性控制类型）。</li><li><code>&lt;textarea&gt;</code>：多行文本输入。</li><li><code>&lt;select&gt;</code> + <code>&lt;option&gt;</code>：下拉选择框。</li><li><code>&lt;button&gt;</code>：提交或重置按钮。</li></ul><pre><code class="html">&lt;form action=&quot;/submit&quot; method=&quot;post&quot;&gt;  &lt;p&gt;    &lt;label for=&quot;name&quot;&gt;姓名：&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;username&quot;&gt;  &lt;!-- name 用于后端接收数据 --&gt;  &lt;/p&gt;  &lt;p&gt;    &lt;label for=&quot;pwd&quot;&gt;密码：&lt;/label&gt;    &lt;input type=&quot;password&quot; id=&quot;pwd&quot; name=&quot;password&quot;&gt;  &lt;/p&gt;  &lt;p&gt;    &lt;label&gt;性别：&lt;/label&gt;    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女  &lt;/p&gt;  &lt;p&gt;    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;    &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;  &lt;/p&gt;&lt;/form&gt;</code></pre><p>这些标签是构建网页内容的基础，实际开发中会结合 CSS（美化样式）和 JavaScript（添加交互），让页面更丰富。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; HTML（HyperText Markup Language，超文本标记语言） &lt;/p&gt;</summary>
    
    
    
    
    <category term="web前端" scheme="http://example.com/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>鼹鼠报数</title>
    <link href="http://example.com/2025/10/25/%E9%BC%B9%E9%BC%A0%E6%8A%A5%E6%95%B0/"/>
    <id>http://example.com/2025/10/25/%E9%BC%B9%E9%BC%A0%E6%8A%A5%E6%95%B0/</id>
    <published>2025-10-25T11:54:38.000Z</published>
    <updated>2025-10-25T12:04:47.894Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树的应用示例。</p><span id="more"></span><h2 id="鼹鼠报数"><a href="#鼹鼠报数" class="headerlink" title="鼹鼠报数"></a>鼹鼠报数</h2><h2 id="★实验任务"><a href="#★实验任务" class="headerlink" title="★实验任务"></a>★实验任务</h2><p>Winder 养了一群会报数的鼹鼠，而且Winder喜欢用数字给他的鼹鼠们编号，如“311”、“1048”等。当然，为了不混淆，鼹鼠们的编号都是不同的。为了锻炼鼹鼠们的身体健康，Winder决定让鼹鼠们进行掘土训练，顺便提高鼹鼠们的挖掘能力。<br>鼹鼠们排成一列，由第一个开始向下挖洞，并待在洞中。第二只与第一只相比，若编号值大的鼹鼠，则向右下方挖洞，否则向左下方。接下来的鼹鼠们以此类推，若比洞中所在鼹鼠编号值大，则向右下方走，否则向左下方。<br>训练结束后，Winder会让他的鼹鼠们报数（既报出各自的编号）。通过报数的序列Winder想知道经过训练之后，鼹鼠们的位置是怎样的。<br>报数规则为：如果A鼹鼠的下方分别存在ALeft鼹鼠和ARight鼹鼠，则ALeft鼹鼠在ARight鼹鼠之前报数，ARight鼹鼠在A鼹鼠之前报数。<br>位置表达式规则为：“根节点&lt;左子树表达式&gt;&lt;右子树表达式&gt;”,如左子树不存在,则只输出“根节点&lt;右子树表达式&gt;”，右子树同理。</p><p><img src="/../images/%E9%BC%B9%E9%BC%A0%E6%8A%A5%E6%95%B0/1761393457224.png" alt="1761393457224"></p><p>例如上图，报数顺序为2，4，7，5，3可以表示为 3&lt;2&gt;&lt;5&lt;4&gt;&lt;7&gt;&gt;</p><h2 id="★数据输入"><a href="#★数据输入" class="headerlink" title="★数据输入"></a>★数据输入</h2><p>第一行为N（2&lt;N&lt;&#x3D;1000），表示有N只鼹鼠。<br>第二行为N个整数bi（0&lt;bi&lt;10000），表示报数顺序。</p><h2 id="★数据输出"><a href="#★数据输出" class="headerlink" title="★数据输出"></a>★数据输出</h2><p>输出鼹鼠们的位置表达式。</p><table><thead><tr><th>输入示例</th></tr></thead><tbody><tr><td>5</td></tr><tr><td>2 4 7 5 3</td></tr></tbody></table><table><thead><tr><th>输出示例</th></tr></thead><tbody><tr><td>3&lt;2&gt;&lt;5&lt;4&gt;&lt;7&gt;&gt;</td></tr></tbody></table><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class TreeNode &#123;public:    int id;    TreeNode* left;    TreeNode* right;    TreeNode(int id) : id(id), left(nullptr), right(nullptr) &#123;&#125;&#125;;TreeNode* insertBST(TreeNode* root, int id) &#123;    if (root == nullptr) return new TreeNode(id);    if (id &lt; root-&gt;id) &#123;        root-&gt;left = insertBST(root-&gt;left, id);    &#125;    else if (id &gt; root-&gt;id)&#123;        root-&gt;right = insertBST(root-&gt;right, id);    &#125;    return root;&#125;void preOrder(TreeNode* root) &#123;    if (root == nullptr) return;    cout &lt;&lt; root-&gt;id;    if (root-&gt;left) &#123;        cout &lt;&lt; &#39;&lt;&#39;;        preOrder(root-&gt;left);        cout &lt;&lt; &#39;&gt;&#39;;    &#125;    if (root-&gt;right) &#123;        cout &lt;&lt; &#39;&lt;&#39;;        preOrder(root-&gt;right);        cout &lt;&lt; &#39;&gt;&#39;;            &#125;        return;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    TreeNode* T = nullptr;    vector&lt;int&gt; arr;    for (int i = 0; i &lt; n;i ++) &#123;        int id;        cin &gt;&gt; id;        arr.push_back(id);    &#125;    for (int i = 0; i &lt; n; i++) &#123;        T = insertBST(T, arr[n - 1 - i]);    &#125;    preOrder(T);    return 0;&#125;</code></pre><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p><strong>解题需要先清楚</strong>： 将 BST 的后序遍历序列逆序后，按 BST 插入规则重建的树，与原 BST 结构相同。</p><p>题目给出的是BST的后序遍历序列，我们可以将其逆序，再依次插入BST，得到原BST，最后再前序遍历BST就可以得到结果。 </p><h3 id="1-数据结构与核心操作"><a href="#1-数据结构与核心操作" class="headerlink" title="1. 数据结构与核心操作"></a>1. 数据结构与核心操作</h3><ul><li><strong>TreeNode 类</strong>：定义二叉树节点，包含节点值<code>id</code>和左右子树指针<code>left</code>&#x2F;<code>right</code>。</li><li><strong>insertBST 函数</strong>：按 BST 规则插入节点（左子树节点值小于根，右子树节点值大于根），保证树的有序性。</li></ul><h3 id="2-核心逻辑"><a href="#2-核心逻辑" class="headerlink" title="2. 核心逻辑"></a>2. 核心逻辑</h3><h4 id="逆序插入构建-BST"><a href="#逆序插入构建-BST" class="headerlink" title="逆序插入构建 BST"></a>逆序插入构建 BST</h4><ul><li><p>输入一个整数序列<code>arr</code>（长度为<code>n</code>）。</p></li><li><p>从序列的</p><p>最后一个元素开始，依次向前遍历（即按<code>arr[n-1] → arr[n-2] → ... → arr[0]</code>的顺序），将每个元素插入 BST。</p><ul><li>目的：以逆序序列的第一个元素（原序列最后一个元素）为根，逐步构建 BST。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉搜索树的应用示例。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>文件管理器</title>
    <link href="http://example.com/2025/10/25/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://example.com/2025/10/25/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8/</id>
    <published>2025-10-25T11:08:26.000Z</published>
    <updated>2025-10-25T11:17:38.326Z</updated>
    
    <content type="html"><![CDATA[<p> 二叉搜索树的应用示例。</p><span id="more"></span><h1 id="文件管理器"><a href="#文件管理器" class="headerlink" title="文件管理器"></a>文件管理器</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>操作系统具有对计算机硬件资源管理和调度的功能。文件是对占用了硬盘一定空间的对象的描述和抽象。考虑一般的文件具有文件名、大小和创建时间。文件管理在任何操作系统中都是必不可少的。文件管理器是用户用来观察和操作文件的一个软件。考虑一个简易的文件管理器，用户可以通过这个简易的文件管理器对某个目录下文件最大&#x2F;小、文件名(字符串)字典序最大&#x2F;最小的一些文件，即按XX排序功能，此外文件管理器具有删除和添加文件的功能。输入保证目录只有一级，操作随机。</p><h2 id="输入及输出格式"><a href="#输入及输出格式" class="headerlink" title="输入及输出格式"></a>输入及输出格式</h2><p>第1行输入一个Q(1&lt;&#x3D;Q&lt;&#x3D;100000)，表示操作的次数。</p><p>第2-Q+1行输入一行操作序列</p><p>操作序列的格式为 op args</p><p>当op&#x3D;1,即第一种操作时，args的格式为 folder name size 表示将要在某个folder目录(1&lt;&#x3D;folder&lt;&#x3D;5的整数)下添加文件名为name(1&lt;&#x3D;name&lt;&#x3D;100000的整数)的文件，文件大小为size(1&lt;&#x3D;size&lt;&#x3D;100000的整数)，如果文件名重复，就先删除原来的文件再进行1操作；</p><p>当op&#x3D;2,即第二种操作时，args的格式为 folder name表示将要在某个folder目录(1&lt;&#x3D;folder&lt;&#x3D;5的整数)下删除文件名为name(1&lt;&#x3D;name&lt;&#x3D;100000的整数)的文件，如果文件名不存在，操作不执行；</p><p>当op&#x3D;3,即第三种操作时，args的格式为 folder k 表示输出某个目录下文件大小最大至第k大的文件名，如果大小相同按文件名数字从小到大输出，如果不满k个文件只需要输出已有的文件名，如果文件夹为空或不存在则输出一个空行；</p><p>当op&#x3D;4,即第四种操作时，args的格式为 folder k 表示输出某个目录下文件名数字大小最小至第k小的文件名，如果不满k个文件只需要输出已有的文件名，如果文件夹为空或不存在则输出一个空行；</p><p>保证1&lt;&#x3D; k &lt;&#x3D;10</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>输出文件名以空格隔开，不输出多余的换行和空格</p><table><thead><tr><th><strong>输入示例</strong></th></tr></thead><tbody><tr><td>10</td></tr><tr><td>2 3 74071</td></tr><tr><td>3 1 2</td></tr><tr><td>3 2 8</td></tr><tr><td>2 3 71337</td></tr><tr><td>3 3 7</td></tr><tr><td>3 2 7</td></tr><tr><td>4 2 10</td></tr><tr><td>4 3 6</td></tr><tr><td>4 3 4</td></tr><tr><td>3 1 4</td></tr></tbody></table><table><thead><tr><th><strong>输出示例</strong></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>上方输出为8个空行</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class TreeNode &#123;public:    int size;    int name;    TreeNode* left;    TreeNode* right;    TreeNode(int size,int name) : size(size),name(name), left(nullptr), right(nullptr)&#123;&#125;&#125;;TreeNode* deleteNodebySize(TreeNode* root, int size);TreeNode* deleteNodebyName(TreeNode* root, int name);TreeNode* insertBSTbySize(TreeNode* root, int size,int name) &#123;    if (root == nullptr) &#123;        return new TreeNode(size,name);    &#125;    if (size &lt; root-&gt;size) &#123;        root-&gt;left = insertBSTbySize(root-&gt;left, size, name);    &#125;    else if (size &gt; root-&gt;size) &#123;        root-&gt;right = insertBSTbySize(root-&gt;right, size, name);    &#125;    return root;&#125;TreeNode* insertBSTbyName(TreeNode* root, int size, int name,TreeNode* root_Size) &#123;    if (root == nullptr) &#123;        return new TreeNode(size, name);    &#125;    if (name &lt; root-&gt;name) &#123;        root-&gt;left = insertBSTbyName(root-&gt;left, size, name, root_Size);    &#125;    else if (name &gt; root-&gt;name) &#123;        root-&gt;right = insertBSTbyName(root-&gt;right, size, name, root_Size);    &#125;    else &#123;        root_Size = deleteNodebySize(root_Size,root-&gt;size);        root_Size = insertBSTbySize(root_Size, size, name);        root = deleteNodebyName(root, name);        root = insertBSTbyName(root, size, name, root_Size);    &#125;    return root;&#125;TreeNode* findMin(TreeNode* root) &#123;    while (root-&gt;left != nullptr) &#123;        root = root-&gt;left;    &#125;    return root;&#125;TreeNode* deleteNodebyName(TreeNode* root, int name) &#123;    if (root == nullptr) return nullptr;    if (name &lt; root-&gt;name) &#123;        root-&gt;left = deleteNodebyName(root-&gt;left, name);    &#125;    else if (name &gt; root-&gt;name) &#123;        root-&gt;right = deleteNodebyName(root-&gt;right, name);    &#125;    else &#123;        if (root-&gt;left == nullptr) &#123;            TreeNode* temp = root-&gt;right;            delete root;            return temp;        &#125;        else if (root-&gt;right == nullptr) &#123;            TreeNode* temp = root-&gt;left;            delete root;            return temp;        &#125;        else &#123;            TreeNode* temp = findMin(root-&gt;right);            root-&gt;name = temp-&gt;name;            root-&gt;right = deleteNodebyName(root-&gt;right, temp-&gt;name);        &#125;    &#125;    return root;&#125;TreeNode* deleteNodebySize(TreeNode* root, int size) &#123;    if (root == nullptr) return nullptr;    if (size &lt; root-&gt;size) &#123;        root-&gt;left = deleteNodebySize(root-&gt;left, size);    &#125;    else if (size &gt; root-&gt;size) &#123;        root-&gt;right = deleteNodebySize(root-&gt;right, size);    &#125;    else &#123;        if (root-&gt;left == nullptr) &#123;            TreeNode* temp = root-&gt;right;            delete root;            return temp;        &#125;        else if (root-&gt;right == nullptr) &#123;            TreeNode* temp = root-&gt;left;            delete root;            return temp;        &#125;        else &#123;            TreeNode* temp = findMin(root-&gt;right);            root-&gt;size = temp-&gt;size;            root-&gt;right = deleteNodebySize(root-&gt;right, temp-&gt;size);        &#125;    &#125;    return root;&#125;TreeNode* searchBSTbyName(TreeNode* root, int name) &#123;    if (root == nullptr) &#123;        return root;    &#125;    if (name &lt; root-&gt;name) &#123;        return searchBSTbyName(root-&gt;left, name);    &#125;    else if (name &gt; root-&gt;name) &#123;        return searchBSTbyName(root-&gt;right, name);    &#125;    else &#123;        return root;    &#125;&#125;void inOrder(TreeNode* root,vector&lt;int&gt;&amp; arr) &#123;    if (root == nullptr) return;    inOrder(root-&gt;left,arr);       arr.push_back(root-&gt;name);    inOrder(root-&gt;right,arr);&#125;int main()&#123;    int n;    vector&lt;TreeNode*&gt; T_Name(6);    vector&lt;TreeNode*&gt; T_Size(6);    cin &gt;&gt; n;    while (n--) &#123;        int op;        cin &gt;&gt; op;        if (op == 1) &#123;            int folder, name, size;            cin &gt;&gt; folder &gt;&gt; name &gt;&gt; size;            T_Name[folder] = insertBSTbyName(T_Name[folder], size, name, T_Size[folder]);            T_Size[folder] = insertBSTbySize(T_Size[folder], size, name);        &#125;        else if (op == 2) &#123;            int name,folder;            cin &gt;&gt; folder &gt;&gt;  name;            TreeNode* temp = searchBSTbyName(T_Name[folder], name);            if (temp != nullptr) &#123;                int size = temp-&gt;size;                T_Name[folder] = deleteNodebyName(T_Name[folder], name);                T_Size[folder] = deleteNodebySize(T_Size[folder], size);            &#125;        &#125;        else if (op == 3) &#123;            int k,folder;            cin &gt;&gt; folder &gt;&gt; k;            vector&lt;int&gt; arr;            inOrder(T_Name[folder], arr);            int i = arr.size() - 1;            int count = arr.size() - k;            while (i &gt;= count &amp;&amp; i &gt;= 0) &#123;                cout &lt;&lt; arr[i] &lt;&lt; &#39; &#39;;                i--;            &#125;            cout &lt;&lt; endl;        &#125;        else if (op == 4) &#123;            int k, folder;            cin &gt;&gt; folder &gt;&gt; k;            vector&lt;int&gt; arr;            inOrder(T_Size[folder], arr);            int i = 0;            while (i &lt; k &amp;&amp; i &lt; arr.size()) &#123;                cout &lt;&lt; arr[i] &lt;&lt; &#39; &#39;;                i++;            &#125;        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>由于本题的操作次数和搜索量非常大，一般的线性数据存储和搜索时间会爆，因此采用二叉搜索树。</p><h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a><strong>数据结构设计</strong></h3><ol><li><strong>TreeNode 类</strong>：每个节点点存储两个关键信息<ul><li><code>size</code>：元素大小（用于按大小排序的 BST）</li><li><code>name</code>：元素名称（用于按名称排序的 BST）</li><li>左右指针（<code>left</code>&#x2F;<code>right</code>）维护 BST 结构</li></ul></li><li><strong>双 BST 设计</strong>：<ul><li><code>T_Name[folder]</code>：按 <code>name</code> 升序的 BST（同一文件夹下的元素按名称组织）</li><li><code>T_Size[folder]</code>：按 <code>size</code> 升序的 BST（同一文件夹下的元素按大小组织）</li><li>两个 BST 存储相同的元素集合，只是排序依据不同，通过操作同步保证数据一致性</li></ul></li></ol><h3 id="核心操作实现"><a href="#核心操作实现" class="headerlink" title="核心操作实现"></a><strong>核心操作实现</strong></h3><h4 id="1-插入元素（op-1）"><a href="#1-插入元素（op-1）" class="headerlink" title="1. 插入元素（op == 1）"></a>1. 插入元素（<code>op == 1</code>）</h4><ul><li><strong>输入</strong>：文件夹编号 <code>folder</code>、元素名称 <code>name</code>、元素大小 <code>size</code></li><li><strong>操作</strong>：<ul><li>调用 <code>insertBSTbyName</code> 向 <code>T_Name[folder]</code> 插入元素（按名称排序）</li><li>调用 <code>insertBSTbySize</code> 向 <code>T_Size[folder]</code> 插入元素（按大小排序）</li><li>若插入的 <code>name</code> 已存在，则先删除原元素（同步更新两个 BST），再插入新元素</li></ul></li></ul><h4 id="2-删除元素（op-2）"><a href="#2-删除元素（op-2）" class="headerlink" title="2. 删除元素（op == 2）"></a>2. 删除元素（<code>op == 2</code>）</h4><ul><li><strong>输入</strong>：文件夹编号 <code>folder</code>、元素名称 <code>name</code></li><li><strong>操作</strong>：<ul><li>通过 <code>searchBSTbyName</code> 在 <code>T_Name[folder]</code> 中查找该名称对应的节点</li><li>若找到，获取其<code>size</code>，同步执行：<ul><li>在 <code>T_Name[folder]</code> 中按 <code>name</code> 删除节点（<code>deleteNodebyName</code>）</li><li>在 <code>T_Size[folder]</code> 中按 <code>size</code> 删除节点（<code>deleteNodebySize</code>）</li></ul></li></ul></li></ul><h4 id="3-查询名称最大的-k-个元素（op-3）"><a href="#3-查询名称最大的-k-个元素（op-3）" class="headerlink" title="3. 查询名称最大的 k 个元素（op == 3）"></a>3. 查询名称最大的 k 个元素（<code>op == 3</code>）</h4><ul><li><strong>输入</strong>：文件夹编号 <code>folder</code>、数量 <code>k</code></li><li><strong>操作</strong>：<ul><li>对 <code>T_Name[folder]</code> 执行中序遍历（中序遍历 BST 可得到升序序列）</li><li>取遍历结果的最后 <code>k</code> 个元素（即名称最大的 k 个），逆序输出</li></ul></li></ul><h4 id="4-查询大小最小的-k-个元素（op-4）"><a href="#4-查询大小最小的-k-个元素（op-4）" class="headerlink" title="4. 查询大小最小的 k 个元素（op == 4）"></a>4. 查询大小最小的 k 个元素（<code>op == 4</code>）</h4><ul><li><strong>输入</strong>：文件夹编号 <code>folder</code>、数量 <code>k</code></li><li><strong>操作</strong>：<ul><li>对 <code>T_Size[folder]</code> 执行中序遍历（得到按大小升序的序列）</li><li>取遍历结果的前 <code>k</code> 个元素（即大小最小的 k 个）输出</li></ul></li></ul><h3 id="BST-辅助函数"><a href="#BST-辅助函数" class="headerlink" title="BST 辅助函数"></a><strong>BST 辅助函数</strong></h3><ul><li><strong>插入</strong>：<code>insertBSTbyName</code> 和 <code>insertBSTbySize</code> 分别按 <code>name</code> 和 <code>size</code> 递归插入节点，维持 BST 性质</li><li><strong>删除</strong>：<code>deleteNodebyName</code> 和 <code>deleteNodebySize</code> 处理三种节点情况（叶子、单孩子、双孩子），双孩子节点用右子树最小节点替换</li><li><strong>查找</strong>：<code>searchBSTbyName</code> 按名称递归查找节点</li><li><strong>中序遍历</strong>：<code>inOrder</code> 递归遍历 BST，收集节点信息（用于查询操作）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; 二叉搜索树的应用示例。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树与AVL树</title>
    <link href="http://example.com/2025/10/23/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/"/>
    <id>http://example.com/2025/10/23/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/</id>
    <published>2025-10-23T15:13:34.000Z</published>
    <updated>2025-10-24T14:09:29.606Z</updated>
    
    <content type="html"><![CDATA[<p>​              </p><span id="more"></span><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="一、二叉搜索树的定义与特性"><a href="#一、二叉搜索树的定义与特性" class="headerlink" title="一、二叉搜索树的定义与特性"></a>一、二叉搜索树的定义与特性</h3><ol><li><p><strong>结构定义</strong></p><p>二叉搜索树是由节点组成的二叉树，每个节点包含：</p><ul><li>一个值（关键字）；</li><li>左子节点指针（指向左子树）；</li><li>右子节点指针（指向右子树）。</li></ul></li><li><p><strong>核心特性</strong></p><p>对任意节点 ：</p><ul><li>左子树中所有节点的值 &lt; <code>node</code> 的值；</li><li>右子树中所有节点的值 &gt; <code>node</code> 的值；</li><li>左、右子树本身也必须是二叉搜索树（递归定义）；</li><li>（可选）通常不允许重复值（若允许，需额外定义规则，如重复值放在右子树）。</li></ul></li></ol><h3 id="二、二叉搜索树的基本操作"><a href="#二、二叉搜索树的基本操作" class="headerlink" title="二、二叉搜索树的基本操作"></a>二、二叉搜索树的基本操作</h3><h4 id="1-查找操作"><a href="#1-查找操作" class="headerlink" title="1. 查找操作"></a>1. 查找操作</h4><p><strong>思路</strong>：利用 BST 的特性，通过与当前节点值比较，逐步缩小查找范围：</p><ul><li>若目标值 &#x3D;&#x3D; 当前节点值：找到目标，返回节点；</li><li>若目标值 &lt; 当前节点值：递归查找左子树；</li><li>若目标值 &gt; 当前节点值：递归查找右子树；</li><li>若遍历到空节点：目标不存在。</li></ul><p><strong>示例代码（C++）</strong>：</p><pre><code class="cpp">struct TreeNode &#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;// 查找值为target的节点TreeNode* searchBST(TreeNode* root, int target) &#123;    if (root == nullptr || root-&gt;val == target) &#123;        return root; // 空树或找到目标    &#125;    if (target &lt; root-&gt;val) &#123;        return searchBST(root-&gt;left, target); // 查左子树    &#125; else &#123;        return searchBST(root-&gt;right, target); // 查右子树    &#125;&#125;</code></pre><p><strong>时间复杂度</strong>：O (h)，其中 <code>h</code> 是树的高度。理想情况下（平衡树）h&#x3D;log n，最坏情况（斜树）h&#x3D;n。</p><h4 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2. 插入操作"></a>2. 插入操作</h4><p><strong>思路</strong>：类似查找，先找到插入位置（空节点），再创建新节点并连接到父节点的左 &#x2F; 右指针：</p><ul><li>若树为空：新节点作为根节点；</li><li>若插入值 &lt; 当前节点值：递归插入到左子树；</li><li>若插入值 &gt; 当前节点值：递归插入到右子树；</li><li>（重复值处理）通常直接返回（不插入）。</li></ul><p><strong>示例代码（C++）</strong>：</p><pre><code class="cpp">// 插入值为val的节点，返回新树的根TreeNode* insertIntoBST(TreeNode* root, int val) &#123;    if (root == nullptr) &#123;        return new TreeNode(val); // 找到插入位置    &#125;    if (val &lt; root-&gt;val) &#123;        root-&gt;left = insertIntoBST(root-&gt;left, val); // 插入左子树    &#125; else if (val &gt; root-&gt;val) &#123;        root-&gt;right = insertIntoBST(root-&gt;right, val); // 插入右子树    &#125;    return root; // 不处理重复值&#125;</code></pre><p><strong>时间复杂度</strong>：O (h)，同查找操作。</p><h4 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="3. 删除操作"></a>3. 删除操作</h4><p>删除操作较复杂，需根据目标节点的子树情况分三种情形处理，确保删除后仍满足 BST 特性：</p><table><thead><tr><th>情形</th><th>处理方式</th></tr></thead><tbody><tr><td>目标节点无左、右子树（叶子节点）</td><td>直接删除，父节点指针置空</td></tr><tr><td>目标节点只有左子树或只有右子树</td><td>用子树的根节点替换目标节点</td></tr><tr><td>目标节点有左、右子树</td><td>找到右子树中最小的节点（或左子树中最大的节点），用其值替换目标节点值，再删除该最小 &#x2F; 最大节点</td></tr></tbody></table><p><strong>示例代码（C++）</strong>：</p><pre><code class="cpp">// 找到以root为根的树中最小值的节点TreeNode* findMin(TreeNode* root) &#123;    while (root-&gt;left != nullptr) &#123;        root = root-&gt;left;    &#125;    return root;&#125;// 删除值为val的节点，返回新树的根TreeNode* deleteNode(TreeNode* root, int val) &#123;    if (root == nullptr) return nullptr; // 树为空，无需删除    // 1. 查找目标节点    if (val &lt; root-&gt;val) &#123;        root-&gt;left = deleteNode(root-&gt;left, val); // 左子树删除    &#125; else if (val &gt; root-&gt;val) &#123;        root-&gt;right = deleteNode(root-&gt;right, val); // 右子树删除    &#125; else &#123;        // 2. 找到目标节点，处理删除        if (root-&gt;left == nullptr) &#123; // 只有右子树或无子树            TreeNode* temp = root-&gt;right;            delete root;            return temp;        &#125; else if (root-&gt;right == nullptr) &#123; // 只有左子树            TreeNode* temp = root-&gt;left;            delete root;            return temp;        &#125; else &#123; // 左右子树都存在            // 找右子树最小节点（或左子树最大节点）            TreeNode* temp = findMin(root-&gt;right);            root-&gt;val = temp-&gt;val; // 替换值            // 删除右子树中最小节点            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val);        &#125;    &#125;    return root;&#125;</code></pre><p><strong>时间复杂度</strong>：O (h)，同查找操作。</p><h3 id="三、二叉搜索树的遍历"><a href="#三、二叉搜索树的遍历" class="headerlink" title="三、二叉搜索树的遍历"></a>三、二叉搜索树的遍历</h3><p>BST 的中序遍历（左→根→右）具有特殊意义：<strong>遍历结果是严格递增的有序序列</strong>。这是 BST 的重要特性，可用于验证树是否为 BST。</p><p><strong>中序遍历示例代码（C++）</strong>：</p><pre><code class="cpp">void inorderTraversal(TreeNode* root) &#123;    if (root == nullptr) return;    inorderTraversal(root-&gt;left);   // 遍历左子树    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;       // 访问根节点    inorderTraversal(root-&gt;right);  // 遍历右子树&#125;</code></pre><p>例如，对如下 BST：</p><pre><code class="plaintext">    4   / \  2   6 / \ / \1  3 5  7</code></pre><p>中序遍历结果为：<code>1 2 3 4 5 6 7</code>（严格递增）。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><h3 id="一、AVL-树的核心定义"><a href="#一、AVL-树的核心定义" class="headerlink" title="一、AVL 树的核心定义"></a>一、AVL 树的核心定义</h3><ol><li><strong>二叉搜索树特性</strong>：对于任意节点，左子树所有节点值 &lt;该节点值，右子树所有节点值&gt; 该节点值（与 BST 一致）。</li><li><strong>平衡约束</strong>：任意节点的<strong>左右子树高度差（平衡因子）的绝对值 ≤ 1</strong>。<ul><li>平衡因子 &#x3D; 左子树高度 - 右子树高度。</li><li>若平衡因子为 2 或 - 2，则称该节点<strong>失衡</strong>，需要通过旋转调整恢复平衡。</li></ul></li></ol><h3 id="二、AVL-树的节点结构"><a href="#二、AVL-树的节点结构" class="headerlink" title="二、AVL 树的节点结构"></a>二、AVL 树的节点结构</h3><p>AVL 树的节点在 BST 节点基础上增加了<strong>高度（height）</strong> 字段，用于快速计算平衡因子：</p><pre><code class="cpp">struct AVLNode &#123;    int val;           // 节点值    AVLNode* left;     // 左子节点    AVLNode* right;    // 右子节点    int height;        // 以该节点为根的子树高度（空节点高度为0）    AVLNode(int x) : val(x), left(nullptr), right(nullptr), height(1) &#123;&#125;&#125;;</code></pre><ul><li>新节点的初始高度为 1（自身作为叶子节点）。</li><li>非叶子节点的高度 &#x3D; max (左子树高度，右子树高度) + 1。</li></ul><h3 id="三、AVL-树的核心操作"><a href="#三、AVL-树的核心操作" class="headerlink" title="三、AVL 树的核心操作"></a>三、AVL 树的核心操作</h3><h4 id="1-辅助函数"><a href="#1-辅助函数" class="headerlink" title="1. 辅助函数"></a>1. 辅助函数</h4><p>为实现平衡维护，需要以下辅助函数：</p><ul><li><p><strong>获取节点高度</strong>：处理空节点的边界情况。</p><pre><code class="cpp">int getHeight(AVLNode* node) &#123;    return (node == nullptr) ? 0 : node-&gt;height;&#125;</code></pre></li><li><p><strong>计算平衡因子</strong>：判断节点是否失衡。</p><pre><code class="cpp">int getBalance(AVLNode* node) &#123;    return (node == nullptr) ? 0 : getHeight(node-&gt;left) - getHeight(node-&gt;right);&#125;</code></pre></li><li><p><strong>更新节点高度</strong>：插入或旋转后需更新节点高度。</p><pre><code class="cpp">void updateHeight(AVLNode* node) &#123;    if (node != nullptr) &#123;        node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));    &#125;&#125;</code></pre></li></ul><h4 id="2-旋转操作（核心）"><a href="#2-旋转操作（核心）" class="headerlink" title="2. 旋转操作（核心）"></a>2. 旋转操作（核心）</h4><p>当节点失衡（平衡因子为 ±2）时，需通过<strong>旋转</strong>调整树结构以恢复平衡。旋转的目标是：</p><ul><li>降低失衡节点的子树高度。</li><li>维持二叉搜索树的特性（左小右大）。</li></ul><p>根据失衡节点的左 &#x2F; 右子树的平衡状态，分为 4 种旋转场景：</p><h5 id="（1）LL-旋转（左左失衡）"><a href="#（1）LL-旋转（左左失衡）" class="headerlink" title="（1）LL 旋转（左左失衡）"></a>（1）LL 旋转（左左失衡）</h5><ul><li><p><strong>触发条件</strong>：失衡节点的平衡因子为 2，且其左子节点的平衡因子 ≥ 0（左子树的左子树更高）。</p></li><li><p><strong>操作</strong>：将失衡节点的左子节点提升为新根，失衡节点作为其右子节点，原左子节点的右子树转为失衡节点的左子树。</p><p><img src="/../images/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/1761233948568.png" alt="1761233948568"></p><pre><code class="cpp">AVLNode* llRotate(AVLNode* y) &#123;    AVLNode* x = y-&gt;left;       // x是y的左子节点    AVLNode* T2 = x-&gt;right;     // T2是x的右子树    x-&gt;right = y;               // y成为x的右子节点    y-&gt;left = T2;               // T2成为y的左子树    // 更新高度（先更新y，再更新x，因x是y的父节点）    updateHeight(y);    updateHeight(x);    return x; // x成为新的根节点&#125;</code></pre></li></ul><h5 id="（2）RR-旋转（右右失衡）"><a href="#（2）RR-旋转（右右失衡）" class="headerlink" title="（2）RR 旋转（右右失衡）"></a>（2）RR 旋转（右右失衡）</h5><ul><li><p><strong>触发条件</strong>：失衡节点的平衡因子为 - 2，且其右子节点的平衡因子 ≤ 0（右子树的右子树更高）。</p></li><li><p><strong>操作</strong>：将失衡节点的右子节点提升为新根，失衡节点作为其左子节点，原右子节点的左子树转为失衡节点的右子树。</p><p><img src="/../images/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/1761234031632.png" alt="1761234031632"></p></li></ul><pre><code class="c++">AVLNode* rrRotate(AVLNode* y) &#123;    AVLNode* x = y-&gt;right;      // x是y的右子节点    AVLNode* T2 = x-&gt;left;      // T2是x的左子树    x-&gt;left = y;                // y成为x的左子节点    y-&gt;right = T2;              // T2成为y的右子树    // 更新高度    updateHeight(y);    updateHeight(x);    return x; // x成为新的根节点&#125;</code></pre><h5 id="（3）LR-旋转（左右失衡）"><a href="#（3）LR-旋转（左右失衡）" class="headerlink" title="（3）LR 旋转（左右失衡）"></a>（3）LR 旋转（左右失衡）</h5><ul><li><p><strong>触发条件</strong>：失衡节点的平衡因子为 2，且其左子节点的平衡因子 &lt; 0（左子树的右子树更高）。</p></li><li><p><strong>操作</strong>：先对左子节点执行 RR 旋转（转为 LL 型），再对失衡节点执行 LL 旋转。</p><p><img src="/../images/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/1761234065591.png" alt="1761234065591"></p><pre><code class="cpp">AVLNode* lrRotate(AVLNode* y) &#123;    y-&gt;left = rrRotate(y-&gt;left); // 先将左子树转为LL型    return llRotate(y);          // 再做LL旋转&#125;</code></pre></li></ul><h5 id="（4）RL-旋转（右左失衡）"><a href="#（4）RL-旋转（右左失衡）" class="headerlink" title="（4）RL 旋转（右左失衡）"></a>（4）RL 旋转（右左失衡）</h5><ul><li><p><strong>触发条件</strong>：失衡节点的平衡因子为 - 2，且其右子节点的平衡因子 &gt; 0（右子树的左子树更高）。</p></li><li><p><strong>操作</strong>：先对右子节点执行 LL 旋转（转为 RR 型），再对失衡节点执行 RR 旋转。</p><p><img src="/../images/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/1761234298746.png" alt="1761234298746"></p></li></ul><pre><code class="c++">AVLNode* rlRotate(AVLNode* y) &#123;    y-&gt;right = llRotate(y-&gt;right); // 先将右子树转为RR型    return rrRotate(y);            // 再做RR旋转&#125;</code></pre><h4 id="3-插入操作"><a href="#3-插入操作" class="headerlink" title="3. 插入操作"></a>3. 插入操作</h4><p>AVL 树的插入流程：</p><ol><li><strong>按 BST 规则插入</strong>：递归找到插入位置，创建新节点。</li><li><strong>更新高度</strong>：从插入节点向上回溯，更新所有祖先节点的高度。</li><li><strong>检查平衡</strong>：计算每个祖先节点的平衡因子，若失衡则执行对应旋转。</li><li><strong>返回新根</strong>：旋转后可能改变子树的根，需将新根返回给父节点。</li></ol><pre><code class="cpp">AVLNode* insert(AVLNode* root, int val) &#123;    // 1. 按BST规则插入新节点    if (root == nullptr) &#123;        return new AVLNode(val); // 空树，直接创建节点    &#125;    if (val &lt; root-&gt;val) &#123;        root-&gt;left = insert(root-&gt;left, val); // 插入左子树    &#125; else if (val &gt; root-&gt;val) &#123;        root-&gt;right = insert(root-&gt;right, val); // 插入右子树    &#125; else &#123;        return root; // 不允许重复值    &#125;    // 2. 更新当前节点高度    updateHeight(root);    // 3. 计算平衡因子，检查是否失衡    int balance = getBalance(root);    // 4. 失衡处理（四种情况）    if (balance &gt; 1) &#123; // 左子树过高        if (val &lt; root-&gt;left-&gt;val) &#123;            return llRotate(root); // LL型        &#125; else &#123;            return lrRotate(root); // LR型        &#125;    &#125;    if (balance &lt; -1) &#123; // 右子树过高        if (val &gt; root-&gt;right-&gt;val) &#123;            return rrRotate(root); // RR型        &#125; else &#123;            return rlRotate(root); // RL型        &#125;    &#125;    // 未失衡，返回原节点    return root;&#125;</code></pre><h4 id="4-删除操作"><a href="#4-删除操作" class="headerlink" title="4. 删除操作"></a>4. 删除操作</h4><p>删除操作与插入类似，但更复杂：</p><ol><li><strong>按 BST 规则删除</strong>：分三种情况（叶子节点、单孩子节点、双孩子节点）删除目标节点。</li><li><strong>更新高度</strong>：从删除位置向上回溯，更新祖先节点高度。</li><li><strong>检查平衡</strong>：若节点失衡，执行对应旋转（旋转逻辑与插入相同）。</li></ol><pre><code class="cpp">// 查找以root为根的树中的最小值节点（用于双孩子节点删除）AVLNode* findMin(AVLNode* root) &#123;    while (root-&gt;left != nullptr) root = root-&gt;left;    return root;&#125;AVLNode* deleteNode(AVLNode* root, int val) &#123;    // 1. 按BST规则删除节点    if (root == nullptr) return nullptr; // 树为空    if (val &lt; root-&gt;val) &#123;        root-&gt;left = deleteNode(root-&gt;left, val); // 左子树删除    &#125; else if (val &gt; root-&gt;val) &#123;        root-&gt;right = deleteNode(root-&gt;right, val); // 右子树删除    &#125; else &#123; // 找到目标节点        // 情况1：叶子节点或只有一个孩子        if (root-&gt;left == nullptr) &#123;            AVLNode* temp = root-&gt;right;            delete root;            return temp;        &#125; else if (root-&gt;right == nullptr) &#123;            AVLNode* temp = root-&gt;left;            delete root;            return temp;        &#125;        // 情况2：有两个孩子，用右子树最小值替换        AVLNode* temp = findMin(root-&gt;right);        root-&gt;val = temp-&gt;val;        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val); // 删除右子树最小值    &#125;    // 若树为空，直接返回    if (root == nullptr) return nullptr;    // 2. 更新当前节点高度    updateHeight(root);    // 3. 计算平衡因子，处理失衡    int balance = getBalance(root);    // 左子树失衡    if (balance &gt; 1) &#123;        if (getBalance(root-&gt;left) &gt;= 0) &#123;            return llRotate(root); // LL型        &#125; else &#123;            return lrRotate(root); // LR型        &#125;    &#125;    // 右子树失衡    if (balance &lt; -1) &#123;        if (getBalance(root-&gt;right) &lt;= 0) &#123;            return rrRotate(root); // RR型        &#125; else &#123;            return rlRotate(root); // RL型        &#125;    &#125;    return root;&#125;</code></pre><h3 id="四、AVL-树的性能分析"><a href="#四、AVL-树的性能分析" class="headerlink" title="四、AVL 树的性能分析"></a>四、AVL 树的性能分析</h3><ul><li><strong>时间复杂度</strong>：插入、删除、查找均为**O(log n)**，因平衡约束保证树高为 O (log n)（n 为节点数）。</li><li><strong>空间复杂度</strong>：O (n)，需存储 n 个节点及高度信息。</li><li><strong>优势</strong>：严格平衡，查询效率稳定。</li><li><strong>劣势</strong>：旋转操作频繁（尤其是插入和删除时），维护成本较高，适用于查询密集、插入删除较少的场景。</li></ul><h3 id="五、AVL树构建C-示例"><a href="#五、AVL树构建C-示例" class="headerlink" title="五、AVL树构建C++示例"></a>五、AVL树构建C++示例</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;algorithm&gt; // 用于max函数using namespace std;// AVL树节点结构struct AVLNode &#123;    int data;    AVLNode* left;    AVLNode* right;    int height; // 节点高度    // 构造函数    AVLNode(int val) : data(val), left(nullptr), right(nullptr), height(1) &#123;&#125;&#125;;// 获取节点高度（空节点高度为0）int getHeight(AVLNode* node) &#123;    return (node == nullptr) ? 0 : node-&gt;height;&#125;// 计算平衡因子（左子树高度 - 右子树高度）int getBalance(AVLNode* node) &#123;    return (node == nullptr) ? 0 : getHeight(node-&gt;left) - getHeight(node-&gt;right);&#125;// LL旋转（左左旋转）AVLNode* llRotate(AVLNode* y) &#123;    AVLNode* x = y-&gt;left;    AVLNode* T2 = x-&gt;right;    // 执行旋转    x-&gt;right = y;    y-&gt;left = T2;    // 更新高度    y-&gt;height = 1 + max(getHeight(y-&gt;left), getHeight(y-&gt;right));    x-&gt;height = 1 + max(getHeight(x-&gt;left), getHeight(x-&gt;right));    // 返回新的根节点    return x;&#125;// RR旋转（右右旋转）AVLNode* rrRotate(AVLNode* y) &#123;    AVLNode* x = y-&gt;right;    AVLNode* T2 = x-&gt;left;    // 执行旋转    x-&gt;left = y;    y-&gt;right = T2;    // 更新高度    y-&gt;height = 1 + max(getHeight(y-&gt;left), getHeight(y-&gt;right));    x-&gt;height = 1 + max(getHeight(x-&gt;left), getHeight(x-&gt;right));    // 返回新的根节点    return x;&#125;// LR旋转（左右旋转）：先对左子树做RR旋转，再做LL旋转AVLNode* lrRotate(AVLNode* y) &#123;    y-&gt;left = rrRotate(y-&gt;left); // 先将左子树转为LL型    return llRotate(y);          // 再做LL旋转&#125;// RL旋转（右左旋转）：先对右子树做LL旋转，再做RR旋转AVLNode* rlRotate(AVLNode* y) &#123;    y-&gt;right = llRotate(y-&gt;right); // 先将右子树转为RR型    return rrRotate(y);            // 再做RR旋转&#125;// 插入节点并维持AVL平衡AVLNode* insert(AVLNode* node, int val) &#123;    // 1. 执行普通二叉搜索树插入    if (node == nullptr) &#123;        return new AVLNode(val); // 插入新节点    &#125;    if (val &lt; node-&gt;data) &#123;        node-&gt;left = insert(node-&gt;left, val); // 插入左子树    &#125; else if (val &gt; node-&gt;data) &#123;        node-&gt;right = insert(node-&gt;right, val); // 插入右子树    &#125; else &#123;        // AVL树不允许重复值（题目说明输入值不同）        return node;    &#125;    // 2. 更新当前节点高度    node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));    // 3. 计算平衡因子，检查是否失衡    int balance = getBalance(node);    // 4. 失衡处理（四种情况）    // LL型：左子树的左子树插入导致失衡    if (balance &gt; 1 &amp;&amp; val &lt; node-&gt;left-&gt;data) &#123;        return llRotate(node);    &#125;    // RR型：右子树的右子树插入导致失衡    if (balance &lt; -1 &amp;&amp; val &gt; node-&gt;right-&gt;data) &#123;        return rrRotate(node);    &#125;    // LR型：左子树的右子树插入导致失衡    if (balance &gt; 1 &amp;&amp; val &gt; node-&gt;left-&gt;data) &#123;        return lrRotate(node);    &#125;    // RL型：右子树的左子树插入导致失衡    if (balance &lt; -1 &amp;&amp; val &lt; node-&gt;right-&gt;data) &#123;        return rlRotate(node);    &#125;    // 未失衡，返回原节点    return node;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    AVLNode* root = nullptr;    for (int i = 0; i &lt; n; ++i) &#123;        int val;        cin &gt;&gt; val;        root = insert(root, val);    &#125;    cout &lt;&lt; root-&gt;data &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;​              &lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://example.com/2025/10/21/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2025/10/21/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2025-10-21T11:08:21.000Z</published>
    <updated>2025-10-25T12:06:49.909Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的概念及性质</p><span id="more"></span><h3 id="一、二叉树的核心概念"><a href="#一、二叉树的核心概念" class="headerlink" title="一、二叉树的核心概念"></a><strong>一、二叉树的核心概念</strong></h3><p>二叉树是每个节点最多有两个子节点（左子节点、右子节点）的树形结构，具有以下特点：</p><ul><li><strong>根节点</strong>：无父节点的唯一节点。</li><li><strong>叶子节点</strong>：无左 &#x2F; 右子节点的节点。</li><li><strong>子树</strong>：以任意节点为根的二叉树（左子树、右子树）。</li><li><strong>深度</strong>：根节点到某节点的路径长度（根节点深度为 1）。</li><li><strong>高度</strong>：某节点到最深叶子节点的路径长度（叶子节点高度为 1）。</li></ul><h4 id="性质-1：节点数量与层数的关系"><a href="#性质-1：节点数量与层数的关系" class="headerlink" title="性质 1：节点数量与层数的关系"></a><strong>性质 1：节点数量与层数的关系</strong></h4><ul><li><p>第 <code>i</code> 层最多有 <code>2^(i-1)</code> 个节点<code>（i ≥ 1）</code>。</p><p>例如：第 1 层（根节点）最多 1 个<code>（2^0）</code>，第 2 层最多 2 个<code>（2^1）</code>，第 3 层最多 4 个<code>（2^2）</code>，以此类推。</p></li></ul><h4 id="性质-2：深度与总节点数的关系"><a href="#性质-2：深度与总节点数的关系" class="headerlink" title="性质 2：深度与总节点数的关系"></a><strong>性质 2：深度与总节点数的关系</strong></h4><ul><li><p>深度为 <code>k</code> 的二叉树最多有 <code>2^k - 1</code> 个节点<code>（k ≥ 1）</code>。</p><p>此时二叉树为满二叉树（每一层节点数都达到最大值）。</p><p>例如：深度为 3 的满二叉树最多有<code>2^3 - 1 = 7</code>个节点。</p></li></ul><h4 id="性质-3：叶子节点与度为-2-的节点的关系"><a href="#性质-3：叶子节点与度为-2-的节点的关系" class="headerlink" title="性质 3：叶子节点与度为 2 的节点的关系"></a><strong>性质 3：叶子节点与度为 2 的节点的关系</strong></h4><ul><li><p>对任意非空二叉树，若叶子节点数为 <code>n₀</code>，度为 2 的节点数为 <code>n₂</code>，则 <code>n₀ = n₂ + 1</code>。</p><p>（度：节点的子节点数，二叉树中节点的度只能是 0、1、2）</p><p>推导：总节点数<code>n = n₀ + n₁ + n₂</code>（<code>n₁</code>为度为 1 的节点数），</p><p>总边数 <code>n-1 = n₁ + 2n₂</code>（每个节点除根外都有一条父节点边），</p><p>联立得<code>n₀ = n₂ + 1</code>。</p></li></ul><h4 id="性质-4：完全二叉树的节点编号特性"><a href="#性质-4：完全二叉树的节点编号特性" class="headerlink" title="性质 4：完全二叉树的节点编号特性"></a><strong>性质 4：完全二叉树的节点编号特性</strong></h4><p>完全二叉树（除最后一层外均满，最后一层节点从左到右连续）中，若节点按层序编号（根为 1，左→右、上→下），则对任意节点 <code>i</code>（<code>i ≥ 1</code>）：</p><ul><li>左子节点编号为 <code>2i</code>（若存在）；</li><li>右子节点编号为 <code>2i + 1</code>（若存在）；</li><li>父节点编号为 <code>⌊i/2⌋</code>（若 <code>i &gt; 1</code>）。</li></ul><h4 id="性质-5：完全二叉树的深度计算"><a href="#性质-5：完全二叉树的深度计算" class="headerlink" title="性质 5：完全二叉树的深度计算"></a><strong>性质 5：完全二叉树的深度计算</strong></h4><ul><li><p>具有 <code>n</code> 个节点的完全二叉树，深度为 <code>⌊log₂n⌋ + 1</code>（<code>⌊x⌋</code>表示向下取整）。</p><p>例如：<code>n=6</code>时，<code>log₂6 ≈ 2.58</code>，深度为<code>2 + 1 = 3</code>。</p></li></ul><h4 id="性质-6：完全二叉树的叶子节点分布"><a href="#性质-6：完全二叉树的叶子节点分布" class="headerlink" title="性质 6：完全二叉树的叶子节点分布"></a><strong>性质 6：完全二叉树的叶子节点分布</strong></h4><ul><li>若完全二叉树有<code>n</code>个节点，则：<ul><li>当 <code>n</code> 为奇数时，无度为 1 的节点（<code>n₁ = 0</code>）；</li><li>当 <code>n</code> 为偶数时，有且仅有 1 个度为 1 的节点（<code>n₁ = 1</code>）。</li></ul></li></ul><h3 id="二、节点定义与基础结构"><a href="#二、节点定义与基础结构" class="headerlink" title="二、节点定义与基础结构"></a><strong>二、节点定义与基础结构</strong></h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;  // 层序遍历用#include &lt;stack&gt;  // 迭代遍历用using namespace std;// 二叉树节点结构struct TreeNode &#123;    int val;         // 节点值    TreeNode* left;  // 左子节点指针    TreeNode* right; // 右子节点指针    // 构造函数    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;</code></pre><h3 id="三、遍历算法（核心操作）"><a href="#三、遍历算法（核心操作）" class="headerlink" title="三、遍历算法（核心操作）"></a><strong>三、遍历算法（核心操作）</strong></h3><p>遍历是按规则访问所有节点，分为<strong>深度优先（DFS）</strong> 和<strong>广度优先（BFS）</strong> 两类。</p><h4 id="1-深度优先遍历（DFS）"><a href="#1-深度优先遍历（DFS）" class="headerlink" title="1. 深度优先遍历（DFS）"></a><strong>1. 深度优先遍历（DFS）</strong></h4><p>包括前序、中序、后序遍历，核心是递归或用栈模拟递归。</p><h5 id="（1）前序遍历（根-→-左-→-右）"><a href="#（1）前序遍历（根-→-左-→-右）" class="headerlink" title="（1）前序遍历（根 → 左 → 右）"></a><strong>（1）前序遍历（根 → 左 → 右）</strong></h5><pre><code class="cpp">// 递归实现void preorderRecursive(TreeNode* root) &#123;    if (root == nullptr) return;    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;       // 访问根    preorderRecursive(root-&gt;left);  // 遍历左子树    preorderRecursive(root-&gt;right); // 遍历右子树&#125;// 迭代实现（用栈）void preorderIterative(TreeNode* root) &#123;    if (root == nullptr) return;    stack&lt;TreeNode*&gt; st;    st.push(root);    while (!st.empty()) &#123;        TreeNode* cur = st.top();        st.pop();        cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;;   // 访问根        // 右子树先入栈（栈是后进先出，保证左子树先访问）        if (cur-&gt;right != nullptr) st.push(cur-&gt;right);        if (cur-&gt;left != nullptr) st.push(cur-&gt;left);    &#125;&#125;</code></pre><h5 id="（2）中序遍历（左-→-根-→-右）"><a href="#（2）中序遍历（左-→-根-→-右）" class="headerlink" title="（2）中序遍历（左 → 根 → 右）"></a><strong>（2）中序遍历（左 → 根 → 右）</strong></h5><p>对二叉搜索树（BST）遍历可得到升序序列。</p><pre><code class="cpp">// 递归实现void inorderRecursive(TreeNode* root) &#123;    if (root == nullptr) return;    inorderRecursive(root-&gt;left);   // 遍历左子树    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;       // 访问根    inorderRecursive(root-&gt;right);  // 遍历右子树&#125;// 迭代实现（用栈）void inorderIterative(TreeNode* root) &#123;    if (root == nullptr) return;    stack&lt;TreeNode*&gt; st;    TreeNode* cur = root;    while (cur != nullptr || !st.empty()) &#123;        // 左子树全部入栈        while (cur != nullptr) &#123;            st.push(cur);            cur = cur-&gt;left;        &#125;        // 访问节点，转向右子树        cur = st.top();        st.pop();        cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;;        cur = cur-&gt;right;    &#125;&#125;</code></pre><h5 id="（3）后序遍历（左-→-右-→-根）"><a href="#（3）后序遍历（左-→-右-→-根）" class="headerlink" title="（3）后序遍历（左 → 右 → 根）"></a><strong>（3）后序遍历（左 → 右 → 根）</strong></h5><p>常用于删除节点或计算表达式树。</p><pre><code class="cpp">// 递归实现void postorderRecursive(TreeNode* root) &#123;    if (root == nullptr) return;    postorderRecursive(root-&gt;left);  // 遍历左子树    postorderRecursive(root-&gt;right); // 遍历右子树    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;        // 访问根&#125;// 迭代实现（双栈法）void postorderIterative(TreeNode* root) &#123;    if (root == nullptr) return;    stack&lt;TreeNode*&gt; st1, st2;    st1.push(root);    // 栈1弹出顺序：根→右→左，压入栈2后弹出顺序为左→右→根    while (!st1.empty()) &#123;        TreeNode* cur = st1.top();        st1.pop();        st2.push(cur);        if (cur-&gt;left != nullptr) st1.push(cur-&gt;left);        if (cur-&gt;right != nullptr) st1.push(cur-&gt;right);    &#125;    // 输出栈2    while (!st2.empty()) &#123;        cout &lt;&lt; st2.top()-&gt;val &lt;&lt; &quot; &quot;;        st2.pop();    &#125;&#125;</code></pre><h4 id="2-广度优先遍历（BFS）：层序遍历"><a href="#2-广度优先遍历（BFS）：层序遍历" class="headerlink" title="2. 广度优先遍历（BFS）：层序遍历"></a><strong>2. 广度优先遍历（BFS）：层序遍历</strong></h4><p>按层次访问节点，用队列实现。</p><pre><code class="cpp">void levelorder(TreeNode* root) &#123;    if (root == nullptr) return;    queue&lt;TreeNode*&gt; q;    q.push(root); // 根节点入队    while (!q.empty()) &#123;        int size = q.size(); // 当前层节点数        // 遍历当前层所有节点        for (int i = 0; i &lt; size; ++i) &#123;            TreeNode* cur = q.front();            q.pop();            cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;;            // 子节点入队（下一层）            if (cur-&gt;left != nullptr) q.push(cur-&gt;left);            if (cur-&gt;right != nullptr) q.push(cur-&gt;right);        &#125;    &#125;&#125;</code></pre><h3 id="四、常用操作"><a href="#四、常用操作" class="headerlink" title="四、常用操作"></a><strong>四、常用操作</strong></h3><pre><code class="cpp">// 计算二叉树高度（递归）int getHeight(TreeNode* root) &#123;    if (root == nullptr) return 0; // 空树高度为0    return max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;&#125;// 计算节点总数（递归）int getNodeCount(TreeNode* root) &#123;    if (root == nullptr) return 0;    return 1 + getNodeCount(root-&gt;left) + getNodeCount(root-&gt;right);&#125;// 销毁二叉树（后序遍历释放节点，避免内存泄漏）void destroyTree(TreeNode*&amp; root) &#123; // 传引用，确保root置空    if (root == nullptr) return;    destroyTree(root-&gt;left);    destroyTree(root-&gt;right);    delete root;    root = nullptr;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉树的概念及性质&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://example.com/2025/10/12/%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2025/10/12/%E6%8E%92%E5%BA%8F/</id>
    <published>2025-10-12T06:08:17.000Z</published>
    <updated>2025-10-12T08:34:32.347Z</updated>
    
    <content type="html"><![CDATA[<p>简单排序（冒泡、插入、比较），快速排序，归并排序。</p><span id="more"></span><h1 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h1><h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><pre><code class="c++">void bubbleSort(vector&lt;int&gt;&amp; arr, int l, int r) &#123;    for (int i = l; i &lt; r; i++) &#123;        bool swapped = false;        for (int j = l; j &lt; r - (i - l); j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr[j], arr[j + 1]);                swapped = true;            &#125;        &#125;        if (!swapped) &#123;            break;        &#125;    &#125;&#125;int main ()&#123;    bubbleSort(arr, 0, n - 1);    return 0;&#125;</code></pre><p><strong>核心思想</strong>：通过相邻元素的两两比较，每轮将最大的元素 “冒泡” 到当前未排序部分的末尾。优化点在于若某轮未发生交换，说明数组已有序，可提前终止。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><pre><code class="c++">void insertionSort(vector&lt;int&gt;&amp; arr,int l,int r) &#123;    for (int i = l + 1;i &lt;= r;i ++)&#123;        int key = arr[i];        int j = i - 1;        while (j &gt;= l &amp;&amp; arr[j] &gt; key)&#123;            arr[j + 1] = arr[j];            j--;        &#125;        arr[j + 1] = key;    &#125;&#125;int main ()&#123;    insertionSort(arr, 0, n - 1);    return 0;&#125;</code></pre><p><strong>核心思想</strong>：将数组分为 “已排序”（初始为 ）和 “未排序” 两部分，依次将未排序元素插入到已排序部分的合适位置（通过移动元素腾出位置）。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><pre><code class="c++">void selectionSort(vector&lt;int&gt;&amp; arr, int l, int r) &#123;    for (int i = l; i &lt; r; i++) &#123;        int minIndex = i;        for (int j = i + 1; j &lt;= r; j++) &#123;            if (arr[j] &lt; arr[minIndex]) &#123;                minIndex = j;            &#125;        &#125;        swap(arr[i], arr[minIndex]);    &#125;&#125;int main ()&#123;    selectionSort(arr, 0, n - 1);    return 0;&#125;</code></pre><p><strong>核心思想</strong>：每轮从当前未排序部分中找到最小元素，与未排序部分的首位交换，逐步扩大已排序部分。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><pre><code class="c++">void quickSort(vector&lt;int&gt;&amp; arr, int l,int r)&#123;    if (l &gt;= r) return;    int privotIndex = partition(arr, l, r);    quickSort(arr, l, privotIndex - 1);    quickSort(arr, privotIndex + 1, r);&#125;int partition(vector&lt;int&gt;&amp; arr, int l, int r) &#123;    int privot = arr[r];    int i = l - 1;    for (int j = l; j &lt; r; j++) &#123;        if (arr[j] &lt;= privot) &#123;            i++;            swap(arr[i], arr[j]);        &#125;    &#125;    swap(arr[i + 1], arr[r]);    return i + 1;&#125;int main ()&#123;    quickSort(arr, 0, n - 1);    return 0;&#125;</code></pre><p><strong>核心思想</strong>：基于分治，选择基准值（此处为 ），通过分区操作将数组分为 “小于等于基准” 和 “大于基准” 两部分，递归排序子数组。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><pre><code class="c++">void mergeSort(vector&lt;int&gt;&amp; arr,int l, int r) &#123;    if (l &gt;= r) return;    int m = (l + r) / 2;    mergeSort(arr ,l, m);    mergeSort(arr ,m + 1, r);    merge(arr,l, m, r);&#125;void merge(vector&lt;int&gt;&amp; arr,int l, int m, int r) &#123;    int n1 = m - l + 1;    int n2 = r - m;    vector&lt;int&gt;L(n1);    vector&lt;int&gt;R(n2);    for (int i = 0; i &lt; n1; i++) L[i] = arr[l + i];    for (int i = 0; i &lt; n2; i++) R[i] = arr[m + 1 + i];    int i = 0, j = 0, k = l;    while (i &lt; n1 &amp;&amp; j &lt; n2) &#123;        if (L[i] &lt; R[j]) &#123;            arr[k++] = L[i++];        &#125;        else &#123;            arr[k++] = R[j++];        &#125;    &#125;    while (i &lt; n1) arr[k++] = L[i++];    while (j &lt; n2) arr[k++] = R[j++];&#125;int main ()&#123;    mergeSort(arr, 0, n - 1);    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单排序（冒泡、插入、比较），快速排序，归并排序。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>队列4.2 Rescue the princess</title>
    <link href="http://example.com/2025/10/08/princess/"/>
    <id>http://example.com/2025/10/08/princess/</id>
    <published>2025-10-08T06:00:01.000Z</published>
    <updated>2025-10-08T06:44:36.943Z</updated>
    
    <content type="html"><![CDATA[<p>广度优先搜索</p><span id="more"></span><h3 id="数据结构与算法实验题-4-2-Rescue-the-princess"><a href="#数据结构与算法实验题-4-2-Rescue-the-princess" class="headerlink" title="数据结构与算法实验题 4.2 Rescue the princess"></a>数据结构与算法实验题 4.2 Rescue the princess</h3><p>★实验任务</p><p>有一天，公主被一个魔王抓走关在一个城堡里面，城堡可以用 N<em>M 的矩阵来描述，1&lt;N,M&lt;&#x3D;200。监狱由 N</em>M 个方格组成，每个方格中可能为墙壁，空地，怪物，公主或者是勇士。</p><p>现在勇士想去营救公主。他的任务是找到公主。约定，“找到公主”的意思是到达公主被关的位置。如果勇士想到达某个方格，但方格中有怪物，那么必须杀死怪物，才能到达这个方格。假设勇士只能向上，下，左，右四个方向移动一步。移动一步的需要花费 1 个单位的时间，杀死怪物也需要一个单位的时间。</p><p>试着计算勇士找到公主需要多长时间。只能上，下，左，右移动，而且墙壁不能通过。</p><p>★数据输入</p><p>输入第一行包含 2 个整数 N，M，接下来 N 行，每行 M 个字符：“.”代表空地，“a”表示公主，“r”表示勇士，“#”代表墙壁，“x”表示怪物。（测试数据中“a”和“r”只有一个）。</p><p>★数据输出</p><p>输出一个整数，表示找到公主所需要最短的时间。如果无法找到公主，输出-1。</p><table><thead><tr><th>输入示例</th></tr></thead><tbody><tr><td>7 8</td></tr><tr><td>#.#####.</td></tr><tr><td>#.a#..r.</td></tr><tr><td>#..#x…</td></tr><tr><td>..#..#.#</td></tr><tr><td>#…##..</td></tr><tr><td>.#……</td></tr><tr><td>……..</td></tr></tbody></table><table><thead><tr><th>输出示例</th></tr></thead><tbody><tr><td>13</td></tr></tbody></table><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><pre><code class="c++">#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int n, m;int ans = 1996;queue&lt;pair&lt;int, int&gt;&gt; p;int nx[4] = &#123; 0,1,0,-1 &#125;;int ny[4] = &#123; 1,0,-1,0 &#125;;void search(char** map,pair&lt;int, int&gt; loc,char count) &#123;    int x = loc.first;    int y = loc.second;    for (int i = 0; i &lt; 4; i++) &#123;        int dx = x + nx[i];        int dy = y + ny[i];        if (map[dx][dy] == &#39;.&#39;) &#123;            map[dx][dy] = count + 1;            p.push(pair&lt;int,int&gt;(dx, dy));        &#125;        else if (map[dx][dy] == &#39;x&#39;) &#123;            map[dx][dy] = count + 2;            p.push(pair&lt;int,int&gt;(dx, dy));        &#125;        else if (map[dx][dy] == &#39;a&#39;) &#123;            int temp = (int)(count + 1 - &#39;0&#39;);            if (temp &lt; ans) &#123;                ans = temp;            &#125;            p.pop();            return;        &#125;    &#125;    p.pop();    while (!p.empty()) &#123;        search(map, p.front(), map[p.front().first][p.front().second]);    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    int x, y;    char** map = new char* [n + 2];    for (int i = 0; i &lt;= n + 1; i++) &#123;        map[i] = new char[m + 2];    &#125;    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= m; j++) &#123;            cin &gt;&gt; map[i][j];            if (map[i][j] == &#39;r&#39;) &#123;                x = i;                y = j;            &#125;        &#125;    &#125;    for (int i = 0; i &lt; m + 2; i++) &#123;        map[0][i] = &#39;#&#39;;        map[n + 1][i] = &#39;#&#39;;    &#125;    for (int i = 0; i &lt; n + 2; i++) &#123;        map[i][0] = &#39;#&#39;;        map[i][m + 1] = &#39;#&#39;;    &#125;    pair &lt;int, int&gt;temp = &#123;x,y&#125;;    p.push(temp);    search(map, temp, &#39;0&#39;);    if (ans != 1996) &#123;        cout &lt;&lt; ans;    &#125;    else&#123;        cout &lt;&lt; -1;    &#125;    return 0;&#125;</code></pre><p>自己凭感觉写的，虽然用了队列，但是更接近深度优先搜索。</p><p><strong>核心思路：</strong>尝试通过 “队列辅助的递归搜索” 从起点<code>&#39;r&#39;</code>找到终点<code>&#39;a&#39;</code>，并计算路径长度，本质上是想实现 “最短路径搜索”，但因逻辑设计问题实际偏向深度优先搜索（DFS）。具体可拆解为以下几点：</p><ol><li><strong>初始设定</strong><ul><li>用二维数组<code>map</code>存储迷宫，<code>&#39;r&#39;</code>是起点，<code>&#39;a&#39;</code>是终点，<code>&#39;.&#39;</code>和<code>&#39;x&#39;</code>是可通行区域（可能<code>&#39;x&#39;</code>被视为特殊可走节点），<code>&#39;#&#39;</code>是边界（不可通行）。</li><li>用队列<code>p</code>存储待探索的坐标，初始将起点<code>&#39;r&#39;</code>的坐标入队。</li></ul></li><li><strong>搜索逻辑</strong><ul><li>定义<code>search</code>函数，参数为当前地图、当前坐标<code>loc</code>、当前路径长度<code>count</code>（用字符表示，如<code>&#39;0&#39;</code>代表 0 步）。</li><li>对当前坐标的 4 个方向（上下左右）进行探索：<ul><li>若遇到<code>&#39;.&#39;</code>（普通可走），标记为<code>count + 1</code>（更新路径长度），并将该坐标入队。</li><li>若遇到<code>&#39;x&#39;</code>（特殊可走），标记为<code>count + 2</code>（可能想区分路径类型），并将该坐标入队。</li><li>若遇到<code>&#39;a&#39;</code>（终点），计算当前路径长度并更新最短路径<code>ans</code>，然后退出。</li></ul></li></ul></li><li><strong>队列与递归的结合</strong><ul><li>每次处理完当前节点后，弹出队列头部元素，再通过递归依次处理队列中剩余的节点，试图遍历所有可能的路径。</li></ul></li></ol><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><pre><code class="c++">#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int n, m;int ans = 1996;queue&lt;pair&lt;int, int&gt;&gt; p;int nx[4] = &#123; 0,1,0,-1 &#125;;int ny[4] = &#123; 1,0,-1,0 &#125;;void search(char** map,pair&lt;int, int&gt; loc,char count) &#123;    while (!p.empty()) &#123;        int x = p.front().first;        int y = p.front().second;        for (int i = 0; i &lt; 4; i++) &#123;            int dx = x + nx[i];            int dy = y + ny[i];            if (map[dx][dy] == &#39;.&#39;) &#123;                map[dx][dy] = map[x][y] + 1;                p.push(pair&lt;int, int&gt;(dx, dy));            &#125;            else if (map[dx][dy] == &#39;x&#39;) &#123;                map[dx][dy] = map[x][y] + 2;                p.push(pair&lt;int, int&gt;(dx, dy));            &#125;            else if (map[dx][dy] == &#39;a&#39;) &#123;                int temp = (int)(map[x][y] + 1 - &#39;0&#39;);                if (temp &lt; ans) &#123;                    ans = temp;                &#125;            &#125;            else if (map[dx][dy] != &#39;#&#39;) &#123;                if (map[x][y] + 1 &lt; map[dx][dy]) &#123;                    map[dx][dy] = map[x][y] + 1;                &#125;            &#125;        &#125;        p.pop();    &#125;   &#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    int x, y;    char** map = new char* [n + 2];    for (int i = 0; i &lt;= n + 1; i++) &#123;        map[i] = new char[m + 2];    &#125;    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= m; j++) &#123;            cin &gt;&gt; map[i][j];            if (map[i][j] == &#39;r&#39;) &#123;                map[i][j] = &#39;0&#39;;                x = i;                y = j;            &#125;        &#125;    &#125;    for (int i = 0; i &lt; m + 2; i++) &#123;        map[0][i] = &#39;#&#39;;        map[n + 1][i] = &#39;#&#39;;    &#125;    for (int i = 0; i &lt; n + 2; i++) &#123;        map[i][0] = &#39;#&#39;;        map[i][m + 1] = &#39;#&#39;;    &#125;    pair &lt;int, int&gt;temp = &#123;x,y&#125;;    p.push(temp);    search(map, temp, &#39;0&#39;);    if (ans != 1996) &#123;        cout &lt;&lt; ans;    &#125;    else&#123;        cout &lt;&lt; -1;    &#125;    return 0;&#125;</code></pre><p>这个代码的核心思路是 <strong>用队列实现 BFS 框架，从起点<code>&#39;r&#39;</code>出发探索迷宫，寻找终点<code>&#39;a&#39;</code>，并尝试让节点保留更小的路径步数</strong>，具体分 4 步：</p><ol><li><p><strong>初始化与准备</strong></p><ul><li>地图外围填<code>&#39;#&#39;</code>当边界，避免越界；起点<code>&#39;r&#39;</code>改成字符<code>&#39;0&#39;</code>（作为路径长度的起始基准），并把起点坐标加入队列。</li><li>用队列<code>p</code>存储待探索的节点，按 “先进先出” 顺序处理，符合 BFS “逐层扩散” 的特点。</li></ul></li><li><p><strong>BFS 核心探索</strong></p><ul><li><p>循环从队列取节点</p><pre><code>(x,y)</code></pre><p>，遍历它的上下左右 4 个邻居</p><pre><code>(dx,dy)</code></pre><p>，根据邻居类型处理：</p><ul><li>若邻居是<code>&#39;.&#39;</code>（普通可走）：把邻居标记为 “当前节点步数 + 1”（字符累加，比如<code>&#39;0&#39;→&#39;1&#39;</code>），并加入队列；</li><li>若邻居是<code>&#39;x&#39;</code>（特殊可走）：把邻居标记为 “当前节点步数 + 2”（给<code>&#39;x&#39;</code>更高的路径成本），也加入队列；</li><li>若邻居是<code>&#39;a&#39;</code>（终点）：计算当前节点到终点的步数，更新全局最小步数<code>ans</code>。</li></ul></li></ul></li><li><p><strong>新增的 “小步数更新” 逻辑</strong></p><ul><li><p>当邻居既不是<code>&#39;.&#39;</code>,<code>&#39;x&#39;</code>,<code>&#39;a&#39;</code>,<code>&#39;#&#39;</code></p><p>（即已被标记为数字的节点）时，判断 “当前节点的步数 + 1” 是否比邻居现有步数小：</p><ul><li>若是，就把邻居的步数更新为更小的值（试图修正之前可能因<code>&#39;x&#39;</code>导致的大步数）。</li></ul></li></ul></li><li><p><strong>结果判断</strong></p><ul><li>探索结束后，若<code>ans</code>被更新（不是初始的 1996），输出最小步数；否则输出<code>-1</code>（没找到终点）。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;广度优先搜索&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈value</title>
    <link href="http://example.com/2025/09/29/%E6%A0%88value/"/>
    <id>http://example.com/2025/09/29/%E6%A0%88value/</id>
    <published>2025-09-29T10:43:48.000Z</published>
    <updated>2025-09-29T10:48:48.534Z</updated>
    
    <content type="html"><![CDATA[<p>单调栈的应用</p><span id="more"></span><h2 id="算法与数据结构实验题-3-8-价值"><a href="#算法与数据结构实验题-3-8-价值" class="headerlink" title="算法与数据结构实验题 3.8 价值"></a>算法与数据结构实验题 3.8 价值</h2><p>★实验任务</p><p>K 神最近喜欢上了刷题，一天不刷浑身难受。最近他研究发现，自己的人生价值在于他某段时间内的刷题总数乘上这几天刷题数的最小值，现在 K 神很寂寞（无敌是多么寂寞），想知道他人生价值最高的时候究竟有多高（krz）</p><p>★数据输入</p><p>第一行为总天数 N(1&lt;&#x3D;N&lt;&#x3D;100000)</p><p>接下来一行 N 个整数 ai（1&lt;&#x3D;ai&lt;&#x3D;100000），表示 K 神第 i 天的刷题数。</p><p>★数据输出</p><p>输出 K 神在连续一段时间内可能的最高价值 W。</p><table><thead><tr><th>输入示例</th></tr></thead><tbody><tr><td>6</td></tr><tr><td>3 1 6 4 5 2</td></tr></tbody></table><table><thead><tr><th>输出示例</th></tr></thead><tbody><tr><td>60</td></tr></tbody></table><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h3><ol><li><strong>核心观察</strong>：对于数组中的每个元素 <code>a[i]</code>，考虑以 <code>a[i]</code> 为最小值的所有连续子数组。在这些子数组中，找到总和最大的子数组，其价值（总和 × <code>a[i]</code>）可能是最大值。</li><li><strong>单调栈应用</strong>：使用单调栈可以高效地找到每个元素 <code>a[i]</code> 左侧第一个小于它的元素（左边界）和右侧第一个小于或等于它的元素（右边界）。这样就确定了以 <code>a[i]</code> 为最小值的最大子数组范围 <code>[left+1, right-1]</code>。</li><li><strong>前缀和优化</strong>：通过前缀和数组可以快速计算任意子数组的总和，避免重复求和，提高效率。</li></ol><pre><code class="c++">#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;stack&lt;int&gt; st;int n;int main()&#123;    cin &gt;&gt; n;    int* a = new int[n + 1];    int* value = new int[n + 1];    int* sum = new int[n + 1];    int* left = new int[n + 1];    int* right = new int[n + 1];    sum[0] = 0;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; a[i];        sum[i] = sum[i - 1] + a[i];    &#125;    for (int i = 1; i &lt;= n; i++) &#123;        while (!st.empty() &amp;&amp; a[st.top()] &gt;= a[i]) &#123;            st.pop();        &#125;        left[i] = st.empty() ? 0 : st.top();        st.push(i);    &#125;    while (!st.empty()) st.pop();    for (int i = n; i &gt;= 1; i--) &#123;        while (!st.empty() &amp;&amp; a[st.top()] &gt;= a[i]) &#123;            st.pop();        &#125;        right[i] = st.empty() ? n + 1 : st.top();        st.push(i);    &#125;    int ans = -1;    for (int i = 1; i &lt;= n; i++) &#123;        value[i] = (sum[right[i] - 1] - sum[left[i]]) * a[i];        if (value[i] &gt; ans) &#123;            ans = value[i];        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;</code></pre><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a><strong>详细解释</strong></h3><ol><li><strong>输入与前缀和</strong>：<ul><li>读取输入的天数 <code>n</code> 和每天的刷题数 <code>a</code>。</li><li>计算前缀和数组 <code>sum</code>，其中 <code>sum[i]</code> 表示前 <code>i</code> 天的刷题总数，便于快速计算任意子数组的总和。</li></ul></li><li><strong>左边界计算</strong>：<ul><li>使用单调栈找到每个元素 <code>a[i]</code> 左侧第一个小于它的元素的索引 <code>left[i]</code>。若不存在，则 <code>left[i]</code> 为 0。</li><li>单调栈保证栈内元素递增，每次弹出栈顶大于等于 <code>a[i]</code> 的元素，剩余栈顶即为左边界。</li></ul></li><li><strong>右边界计算</strong>：<ul><li>类似地，使用单调栈找到每个元素 <code>a[i]</code> 右侧第一个小于或等于它的元素的索引 <code>right[i]</code>。若不存在，则 <code>right[i]</code> 为 <code>n+1</code>。</li><li>单调栈保证栈内元素递增，每次弹出栈顶大于 <code>a[i]</code> 的元素，剩余栈顶即为右边界。</li></ul></li><li><strong>最大价值计算</strong>：<ul><li>对于每个元素 <code>a[i]</code>，以它为最小值的最大子数组范围是 <code>[left[i], right[i]-1]</code>。</li><li>计算该子数组的总和（利用前缀和），并计算价值（总和 × <code>a[i]</code>），更新最大值。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;单调栈的应用&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>内存泄漏</title>
    <link href="http://example.com/2025/09/27/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://example.com/2025/09/27/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2025-09-27T11:51:22.000Z</published>
    <updated>2025-09-27T11:58:39.774Z</updated>
    
    <content type="html"><![CDATA[<p> 在 Android 开发中，内存泄露是一个常见且棘手的问题，它指的是程序中不再使用的对象无法被垃圾回收器回收，导致内存占用持续增加，最终可能引发应用崩溃（OOM：OutOfMemoryError）。</p><span id="more"></span><p>内存泄漏（Memory Leak）是指在程序运行过程中，<strong>不再需要使用的内存空间无法被系统回收</strong>，导致这部分内存被永久占用，最终可能引发内存耗尽（OOM，OutOfMemoryError）的现象。</p><p>从技术角度更精确地说：当一个对象<strong>已经失去了所有使用价值</strong>（即程序中没有任何活跃的引用指向它），但由于某种原因，<strong>垃圾回收器（Garbage Collector，GC）无法识别这种状态</strong>，导致该对象仍然被保留在内存中，就形成了内存泄漏。</p><h3 id="内存泄漏的核心特征："><a href="#内存泄漏的核心特征：" class="headerlink" title="内存泄漏的核心特征："></a>内存泄漏的核心特征：</h3><ol><li><strong>无用性</strong>：泄漏的对象已经不再被程序的任何部分使用（没有实际业务意义）。</li><li><strong>不可回收性</strong>：由于引用链未断裂等原因，垃圾回收器无法将其判定为 “可回收对象”，导致内存无法释放。</li><li><strong>累积性</strong>：单个内存泄漏可能影响微小，但长期运行或高频触发下，泄漏的内存会持续累积，最终耗尽可用内存。</li></ol><h3 id="与相关概念的区别："><a href="#与相关概念的区别：" class="headerlink" title="与相关概念的区别："></a>与相关概念的区别：</h3><ul><li><strong>内存溢出（OOM）</strong>：内存泄漏是原因之一，OOM 是结果（内存耗尽时抛出的错误）。</li><li><strong>内存占用高</strong>：合理的内存占用是程序正常运行所需，而内存泄漏是 “无效占用”。</li></ul><h3 id="为什么会发生内存泄漏？"><a href="#为什么会发生内存泄漏？" class="headerlink" title="为什么会发生内存泄漏？"></a>为什么会发生内存泄漏？</h3><p>现代编程语言（如 Java、Kotlin）都有自动垃圾回收机制，但仍可能因<strong>错误的引用管理</strong>导致内存泄漏。例如：</p><ul><li>长生命周期对象（如单例）持有短生命周期对象（如 Activity）的强引用。</li><li>未及时移除的监听器、回调或事件订阅。</li><li>缓存中的对象未设置过期策略，导致无用对象长期驻留。</li></ul><p>这些场景会形成 “无效引用链”，让垃圾回收器误认为对象仍在使用，从而无法回收。</p><h3 id="常见的内存泄露场景"><a href="#常见的内存泄露场景" class="headerlink" title="常见的内存泄露场景"></a>常见的内存泄露场景</h3><ol><li><p><strong>静态 Activity&#x2F;Context 引用</strong></p><p>Activity 或 Context 包含大量资源（如视图、Bitmap 等），若被静态变量引用，会导致 Activity 无法被回收，即使页面已关闭。</p><pre><code class="java">// 错误示例public class MyActivity extends AppCompatActivity &#123;    private static Context sContext; // 静态引用        @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        sContext = this; // 持有Activity引用    &#125;&#125;</code></pre></li><li><p><strong>长生命周期对象持有短生命周期对象</strong></p><p>例如，单例模式（全局生命周期）持有 Activity（页面生命周期）的引用，会导致 Activity 无法释放。</p><pre><code class="java">// 错误示例public class Singleton &#123;    private static Singleton sInstance;    private Context mContext;        private Singleton(Context context) &#123;        mContext = context; // 若传入Activity，会导致泄露    &#125;        public static Singleton getInstance(Context context) &#123;        if (sInstance == null) &#123;            sInstance = new Singleton(context);        &#125;        return sInstance;    &#125;&#125;</code></pre></li><li><p><strong>未取消的监听器 &#x2F; 回调</strong></p><p>如注册了系统服务监听器（如传感器、广播）、EventBus 事件等，未在适当时候取消注册，会导致监听器持有 Activity 引用。</p></li><li><p><strong>Handler 内存泄露</strong></p><p>Handler 若为非静态内部类，会隐式持有外部类（如 Activity）的引用。若 Handler 发送的消息在消息队列中未处理完，Activity 会被一直持有。</p><pre><code class="java">// 错误示例public class MyActivity extends AppCompatActivity &#123;    private Handler mHandler = new Handler() &#123; // 非静态内部类        @Override        public void handleMessage(Message msg) &#123;            // 处理消息        &#125;    &#125;;        @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        mHandler.postDelayed(new Runnable() &#123;            @Override            public void run() &#123; /* 延迟任务 */ &#125;        &#125;, 10000); // 若10秒内关闭页面，Activity会被泄露    &#125;&#125;</code></pre></li><li><p><strong>资源未关闭</strong></p><p>如文件流（FileInputStream）、数据库连接（SQLiteDatabase）、网络连接等未关闭，会导致资源无法释放。</p></li><li><p><strong>WebView 泄露</strong></p><p>WebView 本身容易内存泄露，若不妥善处理（如在单独进程中使用，或销毁时移除并置空），可能导致整个 Activity 无法回收。</p></li></ol><h3 id="Android-Studio-检测内存泄露的工具"><a href="#Android-Studio-检测内存泄露的工具" class="headerlink" title="Android Studio 检测内存泄露的工具"></a>Android Studio 检测内存泄露的工具</h3><ol><li><strong>Profiler（内存分析器）</strong><ul><li>路径：<code>View &gt; Tool Windows &gt; Profiler</code></li><li>功能：实时监控应用内存使用情况，手动触发 GC（垃圾回收），记录内存快照（Heap Dump）。</li><li>操作：在内存波动异常时，点击 “Dump Java Heap” 生成快照，分析对象引用链，定位泄露根源。</li></ul></li><li><strong>LeakCanary（第三方库，推荐集成）</strong><ul><li>由 Square 开发的内存泄露检测库，可自动检测 Activity&#x2F;Fragment 的泄露并生成详细报告。</li><li>集成后，应用运行时若发生泄露，会在通知栏提示，并展示引用链（如 “Activity 被 Singleton 持有”）。</li></ul></li><li><strong>Lint 静态检查</strong><ul><li>Android Studio 内置的代码检查工具，可识别潜在的内存泄露风险（如静态 Context 引用）。</li><li>路径：<code>Analyze &gt; Inspect Code</code>，在结果中查看 “Memory issues” 相关警告。</li></ul></li></ol><h3 id="避免内存泄露的最佳实践"><a href="#避免内存泄露的最佳实践" class="headerlink" title="避免内存泄露的最佳实践"></a>避免内存泄露的最佳实践</h3><ol><li><p><strong>减少静态引用</strong></p><ul><li>避免静态变量持有 Activity&#x2F;Context，若需使用 Context，优先用 <code>getApplicationContext()</code>（生命周期与应用一致）。</li></ul></li><li><p><strong>使用弱引用（WeakReference）</strong></p><p>对短生命周期对象（如 Activity）使用弱引用，避免强引用导致无法回收：</p><pre><code class="java">// 正确示例：Handler + 弱引用private static class MyHandler extends Handler &#123;    private final WeakReference&lt;MyActivity&gt; mActivityRef;        public MyHandler(MyActivity activity) &#123;        mActivityRef = new WeakReference&lt;&gt;(activity);    &#125;        @Override    public void handleMessage(Message msg) &#123;        MyActivity activity = mActivityRef.get();        if (activity != null) &#123;            // 处理消息（需判断Activity是否已回收）        &#125;    &#125;&#125;</code></pre></li><li><p><strong>及时取消注册 &#x2F; 释放资源</strong></p><ul><li><p>在<code>onDestroy()</code>中取消监听器、EventBus 注册、Handler 消息等：</p><pre><code class="java">@Overrideprotected void onDestroy() &#123;    super.onDestroy();    mHandler.removeCallbacksAndMessages(null); // 移除所有消息    EventBus.getDefault().unregister(this); // 取消EventBus注册&#125;</code></pre></li><li><p>关闭文件流、数据库连接等资源（可使用 try-with-resources 自动关闭）。</p></li></ul></li><li><p><strong>单例模式优化</strong></p><p>单例若需 Context，应传入 Application Context：</p><pre><code class="java">public static Singleton getInstance(Context context) &#123;    if (sInstance == null) &#123;        sInstance = new Singleton(context.getApplicationContext()); // 用Application Context    &#125;    return sInstance;&#125;</code></pre></li><li><p><strong>WebView 处理</strong></p><ul><li><p>尽量在单独进程中使用 WebView（在 Manifest 中配置 <code>android:process</code>）。</p></li><li><p>销毁时移除父布局并置空：</p><pre><code class="java">@Overrideprotected void onDestroy() &#123;    if (mWebView != null) &#123;        mWebView.removeAllViews();        mWebView.destroy();        mWebView = null;    &#125;    super.onDestroy();&#125;</code></pre></li></ul></li></ol><h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2><h3 id="传入Application与Activity的区别"><a href="#传入Application与Activity的区别" class="headerlink" title="传入Application与Activity的区别"></a>传入Application与Activity的区别</h3><h4 id="一、本质区别：生命周期与作用范围"><a href="#一、本质区别：生命周期与作用范围" class="headerlink" title="一、本质区别：生命周期与作用范围"></a>一、本质区别：生命周期与作用范围</h4><ol><li><strong>Application</strong><ul><li><strong>生命周期</strong>：与应用进程一致，从应用启动到进程被杀死（如系统回收资源时），全局唯一且贯穿整个应用生命周期。</li><li><strong>作用范围</strong>：代表整个应用，是全局上下文，不与任何特定页面绑定。</li><li><strong>特性</strong>：内存占用稳定，不会因页面切换而销毁。</li></ul></li><li><strong>Activity</strong><ul><li><strong>生命周期</strong>：与页面绑定，随用户操作（如打开、关闭、旋转屏幕）经历 <code>onCreate()</code> 到 <code>onDestroy()</code> 的完整周期，可能被频繁创建和销毁。</li><li><strong>作用范围</strong>：代表单个页面，包含页面相关的视图、资源和状态。</li><li><strong>特性</strong>：持有大量页面相关资源（如布局、控件、图片等），内存占用较大。</li></ul></li></ol><h4 id="二、传入作为-Context-时的核心差异"><a href="#二、传入作为-Context-时的核心差异" class="headerlink" title="二、传入作为 Context 时的核心差异"></a>二、传入作为 Context 时的核心差异</h4><p>当需要传递 <code>Context</code> 时（如初始化工具类、单例、系统服务调用等），选择 <code>Application</code> 还是 <code>Activity</code> 会直接影响内存管理：</p><table><thead><tr><th>场景</th><th>传入 Application Context</th><th>传入 Activity Context</th></tr></thead><tbody><tr><td><strong>生命周期匹配</strong></td><td>适合长生命周期对象（如单例、全局工具类），生命周期一致。</td><td>仅适合与 Activity 生命周期绑定的场景（如弹出对话框、加载布局）。</td></tr><tr><td><strong>内存泄漏风险</strong></td><td>无风险，因为其生命周期与应用一致，不会因页面销毁而导致泄露。</td><td>高风险！若被长生命周期对象（如单例）持有，会导致 Activity 无法回收，引发内存泄漏。</td></tr><tr><td><strong>功能限制</strong></td><td>无法用于与页面相关的操作（如启动 Dialog、创建菜单），因缺少页面窗口信息。</td><td>可用于所有需要 Context 的场景，包括页面相关操作（如 <code>startActivity()</code>、<code>setContentView()</code>）。</td></tr></tbody></table><h4 id="三、典型使用场景对比"><a href="#三、典型使用场景对比" class="headerlink" title="三、典型使用场景对比"></a>三、典型使用场景对比</h4><ol><li><p><strong>单例模式中使用 Context</strong></p><ul><li><p>错误示例：传入 Activity 导致内存泄漏</p><pre><code class="java">// 单例（长生命周期）持有 Activity（短生命周期）引用 → 内存泄漏public class DataManager &#123;    private static DataManager sInstance;    private Context mContext;        private DataManager(Context context) &#123;        mContext = context; // 若传入 Activity，会导致 Activity 无法回收    &#125;        public static DataManager getInstance(Context context) &#123;        if (sInstance == null) &#123;            sInstance = new DataManager(context);         &#125;        return sInstance;    &#125;&#125;</code></pre></li><li><p>正确示例：传入 Application Context</p><pre><code class="java">public static DataManager getInstance(Context context) &#123;    if (sInstance == null) &#123;        // 传入 Application Context，避免持有 Activity 引用        sInstance = new DataManager(context.getApplicationContext());     &#125;    return sInstance;&#125;</code></pre></li></ul></li><li><p><strong>显示对话框（必须用 Activity Context）</strong></p><p>对话框需要依附于某个页面的窗口，必须使用 Activity Context：</p><pre><code class="java">// 正确：使用 Activity 作为 Context 显示对话框new AlertDialog.Builder(this) // this 指向当前 Activity    .setMessage(&quot;提示&quot;)    .show();// 错误：使用 Application Context 会崩溃（无窗口依附）new AlertDialog.Builder(getApplicationContext())     .setMessage(&quot;提示&quot;)    .show(); // 崩溃：android.view.WindowManager$BadTokenException</code></pre></li></ol><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><ul><li><strong>优先原则</strong>：若场景允许（如全局工具类、单例），尽量使用 <code>Application Context</code>，避免内存泄漏。</li><li><strong>限制场景</strong>：涉及页面交互（如对话框、启动新 Activity、加载布局）时，必须使用 <code>Activity Context</code>，但需注意避免被长生命周期对象持有。</li><li><strong>核心区别</strong>：<code>Application</code> 是全局上下文，生命周期与应用一致；<code>Activity</code> 是页面上下文，生命周期与页面绑定，滥用会导致内存泄漏。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; 在 Android 开发中，内存泄露是一个常见且棘手的问题，它指的是程序中不再使用的对象无法被垃圾回收器回收，导致内存占用持续增加，最终可能引发应用崩溃（OOM：OutOfMemoryError）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ViewModel+LiveData+DataBinding</title>
    <link href="http://example.com/2025/09/24/ViewModel-LiveData-DataBinding/"/>
    <id>http://example.com/2025/09/24/ViewModel-LiveData-DataBinding/</id>
    <published>2025-09-24T08:41:40.000Z</published>
    <updated>2025-09-24T09:25:19.930Z</updated>
    
    <content type="html"><![CDATA[<p> ViewModel + LiveData + DataBinding 是 Android 官方推荐的 MVVM 架构核心组合，三者协同实现了<strong>数据驱动 UI</strong>、<strong>生命周期安全</strong>和<strong>双向绑定</strong>，彻底解决了传统 MVC 架构的内存泄漏和代码耦合问题。 </p><span id="more"></span><h4 id="一、核心组件解析"><a href="#一、核心组件解析" class="headerlink" title="一、核心组件解析"></a>一、核心组件解析</h4><h5 id="1-ViewModel"><a href="#1-ViewModel" class="headerlink" title="1. ViewModel"></a>1. ViewModel</h5><ul><li><strong>作用</strong>：存储与 UI 相关的数据，生命周期独立于 Activity&#x2F;Fragment，屏幕旋转等配置变化时不会重建，避免数据丢失。</li><li>核心特性：<ul><li>不持有 View 引用（Activity&#x2F;Fragment），通过 LiveData 通知 UI 更新</li><li>可通过 <code>AndroidViewModel</code> 子类获取 Application 上下文（需谨慎使用）</li><li>自带 <code>viewModelScope</code> 协程作用域，自动在销毁时取消任务</li></ul></li></ul><pre><code class="kotlin">// 基础 ViewModelclass MainViewModel : ViewModel() &#123;    private val _userName = MutableLiveData&lt;String&gt;(&quot;默认名称&quot;)    val userName: LiveData&lt;String&gt; = _userName // 对外暴露只读LiveData    fun updateName(newName: String) &#123;        _userName.value = newName // 主线程更新        // 子线程用 _userName.postValue(newName)    &#125;&#125;// 需上下文的 AndroidViewModel（继承自 ViewModel）class MyAndroidViewModel(application: Application) : AndroidViewModel(application) &#123;    fun getAppVersion(): String &#123;        return getApplication&lt;Application&gt;().packageManager            .getPackageInfo(getApplication&lt;Application&gt;().packageName, 0).versionName    &#125;&#125;</code></pre><h5 id="2-LiveData"><a href="#2-LiveData" class="headerlink" title="2. LiveData"></a>2. LiveData</h5><ul><li><strong>作用</strong>：可观察的数据持有者，感知 Activity&#x2F;Fragment 生命周期，仅在活跃状态（STARTED&#x2F;RESUMED）通知更新，避免内存泄漏。</li><li>核心子类：<ul><li><code>MutableLiveData</code>：可修改数据（内部使用），提供 <code>setValue()</code>（主线程）和 <code>postValue()</code>（子线程）</li><li><code>Transformations</code>：数据转换工具类，如 <code>map</code>（转换数据格式）、<code>switchMap</code>（根据数据切换观察目标）</li></ul></li></ul><pre><code class="kotlin">// 一般定义方式private val _data = MutableLiveData&lt;String&gt;() // 内部可变val data: LiveData&lt;String&gt; = _data // 外部只读// 数据转换示例class UserViewModel : ViewModel() &#123;    private val _userId = MutableLiveData&lt;String&gt;(&quot;1001&quot;)    val userInfo: LiveData&lt;String&gt; = Transformations.map(_userId) &#123; id -&gt;        &quot;用户ID: $id，名称: 张三&quot; // 将userId转换为用户信息字符串    &#125;    fun changeUserId(newId: String) &#123;        _userId.value = newId // 触发userInfo自动更新    &#125;&#125;</code></pre><h5 id="3-DataBinding"><a href="#3-DataBinding" class="headerlink" title="3. DataBinding"></a>3. DataBinding</h5><ul><li><strong>作用</strong>：将布局文件与数据直接绑定，省去 <code>findViewById</code> 和手动更新 UI 的代码，支持双向绑定。</li><li>核心特性：<ul><li>布局文件以 <code>&lt;layout&gt;</code> 为根标签，可声明变量和表达式</li><li>支持 <code>@&#123;variable&#125;</code> 单向绑定和 <code>@=&#123;variable&#125;</code> 双向绑定</li><li>自动关联 LiveData，数据变化时 UI 自动刷新</li></ul></li></ul><pre><code class="xml">&lt;!-- activity_main.xml --&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;        &lt;variable name=&quot;viewModel&quot; type=&quot;com.example.MyViewModel&quot; /&gt;    &lt;/data&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;!-- 单向绑定：UI展示ViewModel数据 --&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@&#123;viewModel.userName&#125;&quot; /&gt;        &lt;!-- 双向绑定：UI输入同步到ViewModel --&gt;        &lt;EditText            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@=&#123;viewModel.inputText&#125;&quot; /&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;</code></pre><h4 id="二、Activity-中使用流程"><a href="#二、Activity-中使用流程" class="headerlink" title="二、Activity 中使用流程"></a>二、Activity 中使用流程</h4><ol><li><p>开启 DataBinding</p><p>在<code>build.gradle.kts</code>中启用：</p></li></ol><pre><code class="kotlin">android &#123;    buildFeatures &#123;        dataBinding = true    &#125;&#125;</code></pre><ol><li><strong>初始化绑定与 ViewModel</strong></li></ol><pre><code class="kotlin">class MainActivity : AppCompatActivity() &#123;    private lateinit var binding: ActivityMainBinding    private val viewModel: MainViewModel by viewModels() // 委托初始化    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)                // 初始化DataBinding        binding = DataBindingUtil.setContentView(this, R.layout.activity_main)        // 绑定ViewModel到布局        binding.viewModel = viewModel        // 关键：让DataBinding感知生命周期，自动处理LiveData        binding.lifecycleOwner = this    &#125;&#125;</code></pre><h4 id="三、Fragment-中使用流程"><a href="#三、Fragment-中使用流程" class="headerlink" title="三、Fragment 中使用流程"></a>三、Fragment 中使用流程</h4><p>Fragment 中获取 ViewModel 需注意<strong>共享范围</strong>：默认是 Fragment 自身，如需与宿主 Activity 共享，需指定 <code>ViewModelStoreOwner</code> 为 Activity。</p><pre><code class="kotlin">class MyFragment : Fragment() &#123;    private lateinit var binding: FragmentMyBinding    // 方案1：Fragment独立ViewModel    private val fragmentViewModel: MyFragmentViewModel by viewModels()        // 方案2：与Activity共享ViewModel    private val sharedViewModel: SharedViewModel by activityViewModels()    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View &#123;        // 初始化Fragment布局绑定        binding = DataBindingUtil.inflate(inflater, R.layout.fragment_my, container, false)        // 绑定ViewModel        binding.fragmentVm = fragmentViewModel        binding.sharedVm = sharedViewModel        // 绑定生命周期所有者（Fragment自身）        binding.lifecycleOwner = viewLifecycleOwner        return binding.root    &#125;&#125;</code></pre><h4 id="四、双向绑定进阶（以登录为例）"><a href="#四、双向绑定进阶（以登录为例）" class="headerlink" title="四、双向绑定进阶（以登录为例）"></a>四、双向绑定进阶（以登录为例）</h4><ol><li><strong>ViewModel 定义可观察数据</strong></li></ol><pre><code class="kotlin">class LoginViewModel : ViewModel() &#123;    val username = MutableLiveData&lt;String&gt;(&quot;&quot;)    val password = MutableLiveData&lt;String&gt;(&quot;&quot;)    // 登录按钮状态（根据输入是否为空决定）    val loginEnabled: LiveData&lt;Boolean&gt; = Transformations.map(username) &#123;        it.isNotEmpty() &amp;&amp; password.value?.isNotEmpty() == true    &#125;    fun login() &#123;        // 处理登录逻辑    &#125;&#125;</code></pre><ol><li><strong>布局中双向绑定与事件绑定</strong></li></ol><pre><code class="xml">&lt;layout&gt;    &lt;data&gt;        &lt;variable name=&quot;vm&quot; type=&quot;com.example.LoginViewModel&quot; /&gt;    &lt;/data&gt;    &lt;EditText        android:hint=&quot;用户名&quot;        android:text=&quot;@=&#123;vm.username&#125;&quot; /&gt; &lt;!-- 双向绑定 --&gt;    &lt;EditText        android:hint=&quot;密码&quot;        android:inputType=&quot;textPassword&quot;        android:text=&quot;@=&#123;vm.password&#125;&quot; /&gt; &lt;!-- 双向绑定 --&gt;    &lt;Button        android:text=&quot;登录&quot;        android:enabled=&quot;@&#123;vm.loginEnabled&#125;&quot; &lt;!-- 按钮状态随数据变化 --&gt;        android:onClick=&quot;@&#123;() -&gt; vm.login()&#125;&quot; /&gt; &lt;!-- 点击事件绑定 --&gt;&lt;/layout&gt;</code></pre><h4 id="五、最佳实践"><a href="#五、最佳实践" class="headerlink" title="五、最佳实践"></a>五、最佳实践</h4><ol><li><p><strong>数据单向流动原则</strong>：</p><ul><li>UI 事件（点击、输入）→ ViewModel 处理 → 更新 LiveData → UI 自动刷新</li><li>禁止 ViewModel 直接操作 UI 组件</li></ul></li><li><p><strong>ViewModel 与 Repository 分层</strong>：</p><pre><code class="kotlin">class UserViewModel(private val repo: UserRepository) : ViewModel() &#123;    fun loadUser() &#123;        viewModelScope.launch &#123;            val user = repo.fetchUser() // 数据层操作（网络/数据库）            _user.value = user        &#125;    &#125;&#125;</code></pre></li><li><p><strong>避免过度使用双向绑定</strong>：仅在用户输入场景（如表单）使用，其他场景优先单向绑定，减少数据流向复杂性。</p></li><li><p><strong>Fragment 与 Activity 通信</strong>：通过共享 ViewModel 实现，避免使用接口回调。</p></li></ol><h4 id="六、UI组件监听的实现"><a href="#六、UI组件监听的实现" class="headerlink" title="六、UI组件监听的实现"></a>六、UI组件监听的实现</h4><p>组件监听（如点击、文本变化）应在 View 层（Activity&#x2F;Fragment）处理，然后通过调用 ViewModel 的方法将事件 “转发” 给 ViewModel，由 ViewModel 处理业务逻辑并更新 LiveData，最终通过 DataBinding 自动反映到 UI 上。</p><h5 id="示例：EditText-文本变化监听"><a href="#示例：EditText-文本变化监听" class="headerlink" title="示例：EditText 文本变化监听"></a>示例：EditText 文本变化监听</h5><pre><code class="kotlin">// ViewModel（只处理数据逻辑，不涉及任何View）class SearchViewModel : ViewModel() &#123;    private val _searchText = MutableLiveData&lt;String&gt;(&quot;&quot;)    val searchText: LiveData&lt;String&gt; = _searchText    // 处理文本变化的业务逻辑（如过滤、搜索）    fun onTextChanged(newText: String) &#123;        _searchText.value = newText        // 其他逻辑：如防抖搜索、过滤条件判断等    &#125;&#125;// Activity（View层，负责组件监听并转发事件）class SearchActivity : AppCompatActivity() &#123;    private val viewModel: SearchViewModel by viewModels()    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        val binding = ActivitySearchBinding.inflate(layoutInflater)        setContentView(binding.root)        binding.lifecycleOwner = this        binding.vm = viewModel        // 组件监听在View层实现，调用ViewModel方法转发事件        binding.searchEt.addTextChangedListener(object : TextWatcher &#123;            override fun afterTextChanged(s: Editable?) &#123;                // 将文本变化事件转发给ViewModel                viewModel.onTextChanged(s?.toString() ?: &quot;&quot;)            &#125;            // 其他方法省略...        &#125;)    &#125;&#125;</code></pre><h4 id="七、ViewModel委托初始化"><a href="#七、ViewModel委托初始化" class="headerlink" title="七、ViewModel委托初始化"></a>七、ViewModel委托初始化</h4><h5 id="核心委托方式：viewModels-与-activityViewModels"><a href="#核心委托方式：viewModels-与-activityViewModels" class="headerlink" title="核心委托方式：viewModels() 与 activityViewModels()"></a>核心委托方式：<code>viewModels()</code> 与 <code>activityViewModels()</code></h5><p>AndroidX 提供了 <strong><code>androidx.activity.viewModels</code></strong> 和 <strong><code>androidx.fragment.app.viewModels</code></strong> 扩展函数，通过委托自动处理 <code>AndroidViewModel</code> 的初始化，无需手动创建 <code>ViewModelProvider.Factory</code>。</p><p>确保 <code>build.gradle.kts</code> 中包含 ViewModel 扩展库（通常已默认包含）：</p><pre><code class="kotlin">dependencies &#123;    implementation(&quot;androidx.activity:activity-ktx:1.8.0&quot;) // 提供Activity的viewModels()    implementation(&quot;androidx.fragment:fragment-ktx:1.6.2&quot;) // 提供Fragment的viewModels()&#125;</code></pre><pre><code class="kotlin"> private val viewModel: MyAndroidViewModel by viewModels()</code></pre><h4 id="八、MutableLiveData：-setValue-（主线程）和-postValue-（子线程）"><a href="#八、MutableLiveData：-setValue-（主线程）和-postValue-（子线程）" class="headerlink" title="八、MutableLiveData： setValue()（主线程）和 postValue()（子线程）"></a>八、<code>MutableLiveData</code>： <code>setValue()</code>（主线程）和 <code>postValue()</code>（子线程）</h4><h5 id="1-调用线程限制"><a href="#1-调用线程限制" class="headerlink" title="1. 调用线程限制"></a>1. 调用线程限制</h5><ul><li>**<code>setValue</code>**：要求必须在主线程（UI 线程）中调用。因为<code>LiveData</code>主要用于和 UI 交互，在主线程更新数据可以保证 UI 的及时更新以及线程安全，避免多线程并发访问导致的 UI 错乱等问题。如果在子线程中调用<code>setValue</code>，会抛出<code>IllegalStateException</code>异常。例如：</li></ul><pre><code class="kotlin">import androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelclass MyViewModel : ViewModel() &#123;    private val _data = MutableLiveData&lt;String&gt;(&quot;初始值&quot;)    val data: MutableLiveData&lt;String&gt; = _data    fun updateDataOnMainThread() &#123;        // 正确，在主线程调用setValue        _data.setValue(&quot;更新后的值&quot;)     &#125;&#125;</code></pre><ul><li>**<code>postValue</code>**：没有线程限制，可以在子线程中调用。它内部会通过<code>Handler</code>机制将数据更新操作切换到主线程执行，从而实现子线程更新<code>LiveData</code>数据。这在进行异步操作（如网络请求、数据库操作）后更新数据时非常有用。示例如下：</li></ul><pre><code class="kotlin">import androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingclass AnotherViewModel : ViewModel() &#123;    private val _result = MutableLiveData&lt;String&gt;()    val result: MutableLiveData&lt;String&gt; = _result    fun fetchData() &#123;        runBlocking &#123;            launch(Dispatchers.IO) &#123;                val data = &quot;从子线程获取的数据&quot;                // 在子线程中使用postValue更新LiveData                _result.postValue(data)             &#125;        &#125;    &#125;&#125;</code></pre><h5 id="2-更新时机与方式"><a href="#2-更新时机与方式" class="headerlink" title="2. 更新时机与方式"></a>2. 更新时机与方式</h5><ul><li>**<code>setValue</code>**：会立即更新<code>LiveData</code>所持有的值，并通知所有处于活跃状态（<code>STARTED</code> 或 <code>RESUMED</code> 状态）的观察者，让它们可以及时更新 UI 或执行相应逻辑。</li><li>**<code>postValue</code>**：不会立即更新数据，而是将更新操作发送到主线程的消息队列中。当主线程空闲时，才会从消息队列中取出该操作并执行，进而更新<code>LiveData</code>的值并通知观察者。如果在短时间内多次调用<code>postValue</code>，<code>LiveData</code>只会保留最后一次设置的值，并在合适的时候进行更新。比如：</li></ul><pre><code class="kotlin">class TestViewModel : ViewModel() &#123;    private val _number = MutableLiveData&lt;Int&gt;()    val number: MutableLiveData&lt;Int&gt; = _number    fun multiplePostValue() &#123;        // 短时间内多次调用postValue        for (i in 1..3) &#123;            _number.postValue(i)        &#125;        // 最终LiveData的值是3    &#125;&#125;</code></pre><h5 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h5><ul><li>**<code>setValue</code>**：适用于在主线程中，当数据的更新是由主线程中的操作（如按钮点击事件）触发，并且希望数据能立即更新并通知观察者的场景。</li><li>**<code>postValue</code>**：适用于在异步任务（如网络请求、读取文件等）完成后，需要更新<code>LiveData</code>数据并通知 UI 的场景，因为异步任务通常在子线程中执行。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; ViewModel + LiveData + DataBinding 是 Android 官方推荐的 MVVM 架构核心组合，三者协同实现了&lt;strong&gt;数据驱动 UI&lt;/strong&gt;、&lt;strong&gt;生命周期安全&lt;/strong&gt;和&lt;strong&gt;双向绑定&lt;/strong&gt;，彻底解决了传统 MVC 架构的内存泄漏和代码耦合问题。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack全家桶介绍</title>
    <link href="http://example.com/2025/09/23/Jetpack%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2025/09/23/Jetpack%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-09-23T11:48:41.000Z</published>
    <updated>2025-09-23T14:56:30.744Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack全家桶简单介绍</p><span id="more"></span><p>Android Jetpack 是一套库、工具和指南的集合，可帮助开发者更轻松地编写优质应用。它主要包括以下几类组件：</p><ul><li>架构组件（Architecture）<ul><li><strong>DataBinding</strong>：以声明方式将可观察数据绑定到界面元素，通常和 ViewModel 配合使用。</li><li><strong>Lifecycle</strong>：用于管理 Activity 和 Fragment 的生命周期，可帮助开发者生成更易于维护的轻量级代码。</li><li><strong>LiveData</strong>：在底层数据库更改时通知视图，是一个具有生命周期感知的可观察数据持有者。</li><li><strong>Navigation</strong>：处理应用内导航。</li><li><strong>Paging</strong>：帮助开发者一次加载和显示小块数据，按需加载部分数据可减少网络带宽和系统资源的使用。</li><li><strong>Room</strong>：在 SQLite 的基础上提供了一个抽象层，允许更友好、流畅地访问 SQLite 数据库。</li><li><strong>ViewModel</strong>：以生命周期感知的方式管理界面相关的数据，通常和 DataBinding 配合使用，为实现 MVVM 架构提供支持。</li><li><strong>WorkManager</strong>：管理 Android 的后台作业，即使应用程序退出或设备重新启动也可以运行可延迟的异步任务。</li></ul></li><li>基础组件（Foundation）<ul><li><strong>Android KTX</strong>：优化了供 Kotlin 使用的 Jetpack 和 Android 平台 API，帮助开发者以更简洁、更惯用的方式使用 Kotlin 进行 Android 开发。</li><li><strong>AppCompat</strong>：帮助较低版本的 Android 系统进行兼容。</li><li><strong>Auto</strong>：开发 Android Auto 应用的组件，提供了适用于所有车辆的标准化界面和用户交互。</li><li><strong>检测</strong>：从 Android Studio 中快速检测基于 Kotlin 或 Java 的代码。</li><li><strong>多 Dex 处理</strong>：为具有多个 Dex 文件的应用提供支持。</li><li><strong>安全</strong>：安全的读写加密文件和共享偏好设置。</li><li><strong>测试</strong>：用于单元和运行时界面测试的 Android 测试框架。</li><li><strong>TV</strong>：构建可让用户在大屏幕上体验沉浸式内容的应用。</li><li><strong>Wear OS</strong>：开发 Wear 应用的组件。</li></ul></li><li>行为组件（Behavior）<ul><li><strong>CameraX</strong>：帮助简化相机应用的开发工作，提供一致且易于使用的界面，适用于大多数 Android 设备，并可向后兼容至 Android 5.0（API 21）。</li><li><strong>DownloadManager</strong>：处理长时间运行的 HTTP 下载的系统服务。</li><li><strong>媒体和播放</strong>：用于媒体播放和路由（包括 Google Cast）的向后兼容 API。</li><li><strong>通知</strong>：提供向后兼容的通知 API，支持 Wear 和 Auto。</li><li><strong>权限</strong>：用于检查和请求应用权限的兼容性 API。</li><li><strong>设置</strong>：创建交互式设置，建议使用 AndroidX Preference Library 库将用户可配置设置集成到应用中。</li><li><strong>分享操作</strong>：可以更轻松地实现友好的用户分享操作。</li><li><strong>切片</strong>：切片是一种 UI 模板，创建可在应用外部显示应用数据的灵活界面元素。</li></ul></li><li>界面组件（UI）<ul><li><strong>Animation and Transition</strong>：该框架包含用于常见效果的内置动画，并允许开发者创建自定义动画和生命周期回调。</li><li><strong>Emoji Compatibility</strong>：即便用户没有更新 Android 系统也可以获取最新的表情符号。</li><li><strong>Fragment</strong>：组件化界面的基本单位。</li><li><strong>布局</strong>：用 XML 中声明 UI 元素或者在代码中实例化 UI 元素。</li><li><strong>调色板</strong>：从调色板中提取出有用的信息。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jetpack全家桶简单介绍&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>流式输出显示文本</title>
    <link href="http://example.com/2025/09/23/%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA%E6%98%BE%E7%A4%BA%E6%96%87%E6%9C%AC/"/>
    <id>http://example.com/2025/09/23/%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA%E6%98%BE%E7%A4%BA%E6%96%87%E6%9C%AC/</id>
    <published>2025-09-23T11:19:39.000Z</published>
    <updated>2025-09-23T11:45:06.359Z</updated>
    
    <content type="html"><![CDATA[<p>仿AI对话流式输出文本（handler + Runnable，ValueAnimator及Coroutine）。</p><span id="more"></span><pre><code class="kotlin">import androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.os.Handlerimport android.os.Looperimport android.widget.TextViewclass MainActivity : AppCompatActivity() &#123;    private lateinit var textView: TextView    private val targetText = &quot;Hello World&quot;    private var index = 0    private val handler = Handler(Looper.getMainLooper())        // 定义Runnable实现字符逐个输出    private val typingRunnable = object : Runnable &#123;        override fun run() &#123;            if (index &lt; targetText.length) &#123;                // 拼接当前字符                textView.text = targetText.substring(0, index + 1)                index++                // 延迟200毫秒执行下一次                handler.postDelayed(this, 200)            &#125;        &#125;    &#125;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)                textView = findViewById(R.id.textView)                // 开始逐个输出文字        handler.post(typingRunnable)    &#125;    override fun onDestroy() &#123;        super.onDestroy()        // 移除回调，防止内存泄漏        handler.removeCallbacks(typingRunnable)    &#125;&#125;</code></pre><h2 id="方案一：用-handler-Runnable实现"><a href="#方案一：用-handler-Runnable实现" class="headerlink" title="方案一：用 handler + Runnable实现"></a>方案一：用 <code>handler + Runnable</code>实现</h2><p>核心思路：是利用 <strong><code>Handler</code> 的延迟消息机制</strong> 控制字符的逐个追加，本质是 “定时更新 UI + 字符索引递增” 的组合逻辑。下面从 “核心原理→关键组件→执行流程” 三个层面拆解思路：</p><h4 id="核心原理：用-“延迟任务”-模拟-“打字节奏”"><a href="#核心原理：用-“延迟任务”-模拟-“打字节奏”" class="headerlink" title="核心原理：用 “延迟任务” 模拟 “打字节奏”"></a>核心原理：用 “延迟任务” 模拟 “打字节奏”</h4><p>Android 中 UI 更新必须在 <strong>主线程（UI 线程）</strong> 执行，而 “逐个输出文字” 需要 “每隔一段时间（如 200ms）更新一次文本”—— 这个 “定时 + 主线程更新” 的需求，正好可以用 <code>Handler</code> 实现：</p><ul><li><code>Handler</code> 能绑定主线程的消息队列（通过 <code>Looper.getMainLooper()</code>），确保其处理的任务在主线程执行；</li><li><code>handler.postDelayed(Runnable, 延迟时间)</code> 可以让任务延迟指定时间后执行，从而模拟 “打一个字停一下” 的节奏。</li></ul><h4 id="关键组件：4-个核心变量的作用"><a href="#关键组件：4-个核心变量的作用" class="headerlink" title="关键组件：4 个核心变量的作用"></a>关键组件：4 个核心变量的作用</h4><p>代码中定义的 4 个变量，分别对应 “目标内容、当前进度、UI 载体、定时控制器”，是实现逻辑的基础：</p><table><thead><tr><th>变量名</th><th>类型</th><th>核心作用</th></tr></thead><tbody><tr><td><code>textView</code></td><td><code>TextView</code></td><td>最终显示文字的 UI 载体，所有字符追加操作都围绕它进行</td></tr><tr><td><code>targetText</code></td><td><code>String</code></td><td>要输出的完整目标文本（如 “Hello World”），是字符追加的 “数据源”</td></tr><tr><td><code>index</code></td><td><code>Int</code></td><td>字符索引，记录 “当前该输出到第几个字符”（从 0 开始，每次输出后 + 1）</td></tr><tr><td><code>handler</code></td><td><code>Handler</code></td><td>定时控制器，负责发送 “延迟执行的字符追加任务”，确保 UI 更新在主线程</td></tr><tr><td><code>typingRunnable</code></td><td><code>Runnable</code></td><td>字符追加的 “任务体”，封装了 “判断是否还有字符要输出→追加字符→延迟下一次” 的逻辑</td></tr></tbody></table><h4 id="完整执行流程：从启动到结束的-5-步"><a href="#完整执行流程：从启动到结束的-5-步" class="headerlink" title="完整执行流程：从启动到结束的 5 步"></a>完整执行流程：从启动到结束的 5 步</h4><p>整个 “逐个输出” 的过程，本质是 <code>typingRunnable</code> 被反复执行的循环，直到所有字符输出完成，具体流程如下：</p><h5 id="1-初始化：绑定-UI-与变量"><a href="#1-初始化：绑定-UI-与变量" class="headerlink" title="1. 初始化：绑定 UI 与变量"></a>1. 初始化：绑定 UI 与变量</h5><p>在 <code>onCreate</code> 中完成基础准备：</p><ul><li>通过 <code>findViewById(R.id.textView)</code> 找到显示文字的 <code>TextView</code>，赋值给 <code>textView</code>；</li><li>初始化 <code>handler</code> 并绑定主线程的 <code>Looper</code>（确保后续任务在主线程执行）。</li></ul><h5 id="2-启动任务：触发第一次字符输出"><a href="#2-启动任务：触发第一次字符输出" class="headerlink" title="2. 启动任务：触发第一次字符输出"></a>2. 启动任务：触发第一次字符输出</h5><p>调用 <code>handler.post(typingRunnable)</code>，将 “字符追加任务” 立即发送到主线程的消息队列，启动整个流程。</p><h5 id="3-执行任务：追加一个字符-判断是否继续"><a href="#3-执行任务：追加一个字符-判断是否继续" class="headerlink" title="3. 执行任务：追加一个字符 + 判断是否继续"></a>3. 执行任务：追加一个字符 + 判断是否继续</h5><p><code>typingRunnable</code> 的 <code>run()</code> 方法是核心逻辑，每次执行会做 3 件事：</p><ul><li><strong>判断是否还有字符</strong>：检查 <code>index</code>（当前索引）是否小于 <code>targetText.length</code>（总字符数），如果小于说明还有字符没输出；</li><li><strong>追加当前字符</strong>：通过 <code>targetText.substring(0, index + 1)</code> 截取 “从开头到当前索引 + 1” 的子串（比如 <code>index=0</code> 时截取 “J”，<code>index=1</code> 时截取 “He”），然后赋值给 <code>textView.text</code>，实现 “追加一个字符” 的效果；</li><li><strong>递增索引 + 延迟下一次</strong>：<code>index++</code> 更新索引（准备下一个字符），再调用 <code>handler.postDelayed(this, 200)</code>，让 <code>typingRunnable</code> 自身延迟 200ms 后再次执行 —— 这样就形成了 “输出一个字符→等 200ms→输出下一个字符” 的循环。</li></ul><h5 id="4-结束循环：所有字符输出完成"><a href="#4-结束循环：所有字符输出完成" class="headerlink" title="4. 结束循环：所有字符输出完成"></a>4. 结束循环：所有字符输出完成</h5><p>当 <code>index</code> 递增到等于 <code>targetText.length</code> 时（比如 “Hello World” 总长度是 11，<code>index=11</code> 时），<code>if (index &lt; targetText.length)</code> 条件不成立，循环终止，整个 “逐个输出” 流程结束。</p><h5 id="5-内存清理：防止泄漏"><a href="#5-内存清理：防止泄漏" class="headerlink" title="5. 内存清理：防止泄漏"></a>5. 内存清理：防止泄漏</h5><p>在 <code>onDestroy</code> 中调用 <code>handler.removeCallbacks(typingRunnable)</code>，移除所有未执行的 <code>typingRunnable</code> 任务 —— 因为如果 Activity 销毁时，<code>handler</code> 还持有 <code>typingRunnable</code> 的引用，会导致 Activity 无法被回收，引发内存泄漏。</p><h2 id="方案二：用-ValueAnimator（属性动画）实现"><a href="#方案二：用-ValueAnimator（属性动画）实现" class="headerlink" title="方案二：用 ValueAnimator（属性动画）实现"></a>方案二：用 ValueAnimator（属性动画）实现</h2><h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><p><code>ValueAnimator</code> 是 Android 动画框架的核心类，可生成从 “起始值” 到 “结束值” 的连续数值变化。这里利用它生成 <strong>“从 0 到目标文本长度”</strong> 的整数变化，每次数值更新时，截取对应长度的文本赋值给 <code>TextView</code>，从而模拟 “逐个输出”。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><pre><code class="kotlin">import androidx.appcompat.app.AppCompatActivityimport android.animation.ValueAnimatorimport android.os.Bundleimport android.widget.TextViewclass MainActivity : AppCompatActivity() &#123;    private lateinit var textView: TextView    private val targetText = &quot;Hello World (ValueAnimator 版)&quot;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)                textView = findViewById(R.id.textView)        startTypingWithAnimator() // 启动动画式逐个输出    &#125;    private fun startTypingWithAnimator() &#123;        // 1. 创建动画：数值从 0 变化到目标文本的长度（每个数值对应“当前要显示的字符数”）        val typingAnimator = ValueAnimator.ofInt(0, targetText.length)                // 2. 设置动画总时长：字符数 × 每个字符的显示间隔（这里 200ms/字符，总时长动态计算）        typingAnimator.duration = targetText.length * 200L                // 3. 动画更新监听：每次数值变化时，截取对应长度的文本        typingAnimator.addUpdateListener &#123; animation -&gt;            // 获取当前动画生成的数值（即“要显示的字符数”）            val currentCharCount = animation.animatedValue as Int            // 截取“从开头到 currentCharCount 长度”的文本，赋值给 TextView            textView.text = targetText.substring(0, currentCharCount)        &#125;                // 4. 启动动画        typingAnimator.start()    &#125;&#125;</code></pre><h4 id="方案特点"><a href="#方案特点" class="headerlink" title="方案特点"></a>方案特点</h4><ul><li><strong>优点</strong>：代码简洁，无需手动管理 <code>index</code> 和延迟任务；支持动画暂停、取消、重复等控制（如 <code>typingAnimator.pause()</code>&#x2F;<code>resume()</code>）；自带主线程调度，无需担心 UI 线程问题。</li><li><strong>缺点</strong>：若需更精细的节奏控制（如某些字符延迟更长），需额外处理；动画中途取消后重启需重新创建 <code>ValueAnimator</code>。</li></ul><h2 id="方案三：用-Coroutine（协程）实现"><a href="#方案三：用-Coroutine（协程）实现" class="headerlink" title="方案三：用 Coroutine（协程）实现"></a>方案三：用 Coroutine（协程）实现</h2><h4 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h4><p>Kotlin 协程的 <code>delay()</code> 函数可实现 “非阻塞延迟”，且在 <code>Dispatchers.Main</code> 调度器下可直接更新 UI。这里通过 <strong>“循环遍历每个字符 + 延迟后追加”</strong> 的逻辑，实现逐个输出，无需 <code>Handler</code>。</p><h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><pre><code class="kotlin">import androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.widget.TextViewimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.Jobimport kotlinx.coroutines.delayimport kotlinx.coroutines.launchclass MainActivity : AppCompatActivity() &#123;    private lateinit var textView: TextView    private val targetText = &quot;Hello World (Coroutine 版)&quot;    // 协程 Job：用于控制协程（如取消），防止 Activity 销毁时协程泄漏    private var typingJob: Job? = null    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)                textView = findViewById(R.id.textView)        startTypingWithCoroutine() // 启动协程式逐个输出    &#125;    private fun startTypingWithCoroutine() &#123;        // 1. 在主线程协程中执行（Dispatchers.Main 确保可直接更新 UI）        typingJob = CoroutineScope(Dispatchers.Main).launch &#123;            // 2. 清空之前的文本（避免重复输出残留）            textView.text = &quot;&quot;                        // 3. 遍历目标文本的每个字符            for (char in targetText) &#123;                // 4. 追加当前字符到 TextView                textView.append(char.toString())                // 5. 延迟 200ms（非阻塞延迟，不影响主线程）                delay(200)            &#125;        &#125;    &#125;    override fun onDestroy() &#123;        super.onDestroy()        // 6. 取消协程：防止 Activity 销毁后协程仍在执行，导致内存泄漏        typingJob?.cancel()    &#125;&#125;</code></pre><h4 id="方案特点-1"><a href="#方案特点-1" class="headerlink" title="方案特点"></a>方案特点</h4><ul><li><strong>优点</strong>：逻辑直观（直接用 <code>for</code> 循环遍历字符）；<code>delay()</code> 是非阻塞的，不会阻塞主线程；协程 <code>Job</code> 可轻松取消，内存管理更简洁（Kotlin 推荐方案）。</li><li><strong>缺点</strong>：需依赖 Kotlin 协程库（AndroidX 项目默认已集成，无需额外导包）；精细控制（如暂停 &#x2F; 继续）需结合 <code>Mutex</code> 或 <code>StateFlow</code> 额外处理。</li></ul><h2 id="三种方案对比"><a href="#三种方案对比" class="headerlink" title="三种方案对比"></a>三种方案对比</h2><table><thead><tr><th>实现方式</th><th>核心 API</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Handler + Runnable</td><td>Handler.postDelayed</td><td>兼容性好（支持所有 Android 版本）</td><td>需手动管理 index 和回调，代码稍繁琐</td><td>需兼容低版本（如 Android 5.0 以下）</td></tr><tr><td>ValueAnimator</td><td>ValueAnimator.ofInt</td><td>动画控制灵活（暂停 &#x2F; 取消 &#x2F; 重复），代码简洁</td><td>精细节奏控制较麻烦</td><td>偏向 “动画化” 的文字输出需求</td></tr><tr><td>Coroutine</td><td>CoroutineScope + delay</td><td>逻辑直观，非阻塞延迟，内存管理简单</td><td>依赖 Kotlin 协程，低版本需适配（少见）</td><td>Kotlin 项目首选，追求代码简洁性</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;仿AI对话流式输出文本（handler + Runnable，ValueAnimator及Coroutine）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>链表基础操作</title>
    <link href="http://example.com/2025/09/22/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2025/09/22/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2025-09-22T15:18:35.000Z</published>
    <updated>2025-09-23T11:18:31.059Z</updated>
    
    <content type="html"><![CDATA[<p>链表的定义及增删改查</p><span id="more"></span><h3 id="1-链表节点定义"><a href="#1-链表节点定义" class="headerlink" title="1. 链表节点定义"></a>1. 链表节点定义</h3><p>单链表节点包含数据域和指针域（指向下一个节点）：</p><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;// 节点结构体定义struct Node &#123;    int data;       // 数据域    Node* next;     // 指针域，指向下一个节点    // 构造函数，方便初始化    Node(int val) : data(val), next(nullptr) &#123;&#125;&#125;;</code></pre><h3 id="2-链表初始化"><a href="#2-链表初始化" class="headerlink" title="2. 链表初始化"></a>2. 链表初始化</h3><p>创建一个空链表（通常用头指针 &#x2F; 哨兵节点表示）：</p><pre><code class="cpp">// 方法1：使用头指针（初始为nullptr）Node* head = nullptr;// 方法2：使用哨兵节点（简化操作，不存储实际数据）Node* sentinel = new Node(0);  // 哨兵节点数据无意义</code></pre><h3 id="3-插入操作"><a href="#3-插入操作" class="headerlink" title="3. 插入操作"></a>3. 插入操作</h3><h4 id="3-1-头插法（在链表头部插入）"><a href="#3-1-头插法（在链表头部插入）" class="headerlink" title="3.1 头插法（在链表头部插入）"></a>3.1 头插法（在链表头部插入）</h4><pre><code class="cpp">// 在链表头部插入新节点void insertAtHead(Node*&amp; head, int val) &#123;    Node* newNode = new Node(val);  // 创建新节点    newNode-&gt;next = head;           // 新节点指向原头节点    head = newNode;                 // 更新头指针&#125;// 示例int main() &#123;    Node* head = nullptr;    insertAtHead(head, 3);  // 链表：3    insertAtHead(head, 2);  // 链表：2-&gt;3    insertAtHead(head, 1);  // 链表：1-&gt;2-&gt;3    return 0;&#125;</code></pre><h4 id="3-2-尾插法（在链表尾部插入）"><a href="#3-2-尾插法（在链表尾部插入）" class="headerlink" title="3.2 尾插法（在链表尾部插入）"></a>3.2 尾插法（在链表尾部插入）</h4><pre><code class="cpp">// 在链表尾部插入新节点void insertAtTail(Node*&amp; head, int val) &#123;    Node* newNode = new Node(val);    if (head == nullptr) &#123;  // 空链表直接作为头节点        head = newNode;        return;    &#125;    // 遍历到尾部    Node* curr = head;    while (curr-&gt;next != nullptr) &#123;        curr = curr-&gt;next;    &#125;    curr-&gt;next = newNode;  // 尾部节点指向新节点&#125;// 示例int main() &#123;    Node* head = nullptr;    insertAtTail(head, 1);  // 链表：1    insertAtTail(head, 2);  // 链表：1-&gt;2    insertAtTail(head, 3);  // 链表：1-&gt;2-&gt;3    return 0;&#125;</code></pre><h4 id="3-3-中间插入（在指定位置插入）"><a href="#3-3-中间插入（在指定位置插入）" class="headerlink" title="3.3 中间插入（在指定位置插入）"></a>3.3 中间插入（在指定位置插入）</h4><pre><code class="cpp">// 在第k个节点后插入新节点（k从1开始计数）void insertAtPosition(Node*&amp; head, int k, int val) &#123;    if (k &lt;= 0) return;  // 位置无效    // 若插入到头部（k=0的特殊情况）    if (k == 1 &amp;&amp; head == nullptr) &#123;        insertAtHead(head, val);        return;    &#125;    Node* curr = head;    // 遍历到第k-1个节点    for (int i = 1; i &lt; k - 1 &amp;&amp; curr != nullptr; ++i) &#123;        curr = curr-&gt;next;    &#125;    if (curr == nullptr) return;  // 位置超出链表长度    Node* newNode = new Node(val);    newNode-&gt;next = curr-&gt;next;   // 新节点指向原k位置节点    curr-&gt;next = newNode;         // 原k-1节点指向新节点&#125;// 示例int main() &#123;    Node* head = nullptr;    insertAtTail(head, 1);    insertAtTail(head, 3);    insertAtPosition(head, 2, 2);  // 在第1个节点后插入2，链表：1-&gt;2-&gt;3    return 0;&#125;</code></pre><h3 id="4-删除操作"><a href="#4-删除操作" class="headerlink" title="4. 删除操作"></a>4. 删除操作</h3><h4 id="4-1-删除头节点"><a href="#4-1-删除头节点" class="headerlink" title="4.1 删除头节点"></a>4.1 删除头节点</h4><pre><code class="cpp">void deleteHead(Node*&amp; head) &#123;    if (head == nullptr) return;  // 空链表    Node* temp = head;    // 暂存头节点    head = head-&gt;next;    // 更新头指针    delete temp;          // 释放内存&#125;// 示例int main() &#123;    Node* head = nullptr;    insertAtTail(head, 1);    insertAtTail(head, 2);    deleteHead(head);  // 链表变为：2    return 0;&#125;</code></pre><h4 id="4-2-删除尾节点"><a href="#4-2-删除尾节点" class="headerlink" title="4.2 删除尾节点"></a>4.2 删除尾节点</h4><pre><code class="cpp">void deleteTail(Node*&amp; head) &#123;    if (head == nullptr) return;  // 空链表    if (head-&gt;next == nullptr) &#123;  // 只有一个节点        delete head;        head = nullptr;        return;    &#125;    Node* curr = head;    // 遍历到倒数第二个节点    while (curr-&gt;next-&gt;next != nullptr) &#123;        curr = curr-&gt;next;    &#125;    delete curr-&gt;next;    // 释放尾节点    curr-&gt;next = nullptr; // 倒数第二个节点指向nullptr&#125;// 示例int main() &#123;    Node* head = nullptr;    insertAtTail(head, 1);    insertAtTail(head, 2);    deleteTail(head);  // 链表变为：1    return 0;&#125;</code></pre><h4 id="4-3-删除指定值的节点"><a href="#4-3-删除指定值的节点" class="headerlink" title="4.3 删除指定值的节点"></a>4.3 删除指定值的节点</h4><pre><code class="cpp">void deleteByValue(Node*&amp; head, int val) &#123;    if (head == nullptr) return;    // 若头节点是目标值    if (head-&gt;data == val) &#123;        deleteHead(head);        return;    &#125;    Node* curr = head;    // 找到目标节点的前一个节点    while (curr-&gt;next != nullptr &amp;&amp; curr-&gt;next-&gt;data != val) &#123;        curr = curr-&gt;next;    &#125;    if (curr-&gt;next == nullptr) return;  // 未找到目标值    Node* temp = curr-&gt;next;    curr-&gt;next = curr-&gt;next-&gt;next;  // 跳过目标节点    delete temp;                    // 释放内存&#125;// 示例int main() &#123;    Node* head = nullptr;    insertAtTail(head, 1);    insertAtTail(head, 2);    insertAtTail(head, 3);    deleteByValue(head, 2);  // 链表变为：1-&gt;3    return 0;&#125;</code></pre><h3 id="5-遍历操作"><a href="#5-遍历操作" class="headerlink" title="5. 遍历操作"></a>5. 遍历操作</h3><pre><code class="cpp">// 遍历并打印链表所有元素void traverse(Node* head) &#123;    Node* curr = head;    while (curr != nullptr) &#123;        cout &lt;&lt; curr-&gt;data &lt;&lt; &quot;-&gt;&quot;;        curr = curr-&gt;next;    &#125;    cout &lt;&lt; &quot;nullptr&quot; &lt;&lt; endl;&#125;// 示例int main() &#123;    Node* head = nullptr;    insertAtTail(head, 1);    insertAtTail(head, 2);    insertAtTail(head, 3);    traverse(head);  // 输出：1-&gt;2-&gt;3-&gt;nullptr    return 0;&#125;</code></pre><h3 id="6-查找操作"><a href="#6-查找操作" class="headerlink" title="6. 查找操作"></a>6. 查找操作</h3><pre><code class="cpp">// 查找值为val的节点，返回是否存在bool find(Node* head, int val) &#123;    Node* curr = head;    while (curr != nullptr) &#123;        if (curr-&gt;data == val) &#123;            return true;        &#125;        curr = curr-&gt;next;    &#125;    return false;&#125;// 示例int main() &#123;    Node* head = nullptr;    insertAtTail(head, 1);    insertAtTail(head, 2);    cout &lt;&lt; find(head, 2) &lt;&lt; endl;  // 输出：1（存在）    cout &lt;&lt; find(head, 3) &lt;&lt; endl;  // 输出：0（不存在）    return 0;&#125;</code></pre><h3 id="7-销毁链表（释放内存）"><a href="#7-销毁链表（释放内存）" class="headerlink" title="7. 销毁链表（释放内存）"></a>7. 销毁链表（释放内存）</h3><pre><code class="cpp">void destroy(Node*&amp; head) &#123;    while (head != nullptr) &#123;        Node* temp = head;        head = head-&gt;next;        delete temp;  // 逐个释放节点    &#125;&#125;// 示例int main() &#123;    Node* head = nullptr;    insertAtTail(head, 1);    insertAtTail(head, 2);    destroy(head);  // 释放所有节点，head变为nullptr    return 0;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单链表的核心操作围绕<strong>指针的修改</strong>展开，关键是要：</p><ol><li>避免空指针访问（操作前判断节点是否为<code>nullptr</code>）</li><li>正确维护指针关系（插入 &#x2F; 删除时确保链表不中断）</li><li>及时释放动态分配的内存（防止内存泄漏）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表的定义及增删改查&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哥德巴赫猜想问题</title>
    <link href="http://example.com/2025/09/13/%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/09/13/%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3%E9%97%AE%E9%A2%98/</id>
    <published>2025-09-13T07:30:53.000Z</published>
    <updated>2025-09-14T06:16:32.143Z</updated>
    
    <content type="html"><![CDATA[<p>计算给定的大偶数可以表示为多少对素数之和。</p><span id="more"></span><h1 id="哥德巴赫猜想问题"><a href="#哥德巴赫猜想问题" class="headerlink" title="哥德巴赫猜想问题"></a>哥德巴赫猜想问题</h1><h3 id="★实验任务"><a href="#★实验任务" class="headerlink" title="★实验任务"></a>★实验任务</h3><p>验证哥德巴赫猜想。计算给定的大偶数可以表示为多少对素数之和。例如，大偶数 10 可以表示为 2 对素数 3，7 和 5，5 之和。</p><h3 id="★数据输入"><a href="#★数据输入" class="headerlink" title="★数据输入"></a>★数据输入</h3><p>输入数据只有一行，一个大偶数 N（2&lt;&#x3D;N&lt;&#x3D;30000）。</p><h3 id="★数据输出"><a href="#★数据输出" class="headerlink" title="★数据输出"></a>★数据输出</h3><p>输出计算出的相应的素数分解数。</p><h2 id="一、暴力算法"><a href="#一、暴力算法" class="headerlink" title="一、暴力算法"></a>一、暴力算法</h2><ul><li>时间复杂度： <code>O (n√n) </code></li></ul><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int n;int main()&#123;    int count = 0;    cin &gt;&gt; n;    for (int i = 2; i &lt;= n/2; i++) &#123;        int flag = 0;        for (int j = 2; j &lt;= sqrt(i); j++) &#123;            if (i % j == 0) &#123;                flag = 1;                break;            &#125;        &#125;        if (!flag) &#123;            int flag2 = 0;            for (int j = 2; j &lt;= sqrt(n - i); j++) &#123;                if ((n - i) % j == 0) &#123;                    flag2 = 1;                    break;                &#125;            &#125;            if (!flag2) &#123;                count++;            &#125;        &#125;    &#125;    cout &lt;&lt; count;    return 0;&#125;</code></pre><h2 id="二、埃拉托斯特尼筛法"><a href="#二、埃拉托斯特尼筛法" class="headerlink" title="二、埃拉托斯特尼筛法"></a>二、埃拉托斯特尼筛法</h2><ul><li>预先计算出所有小于等于 N 的素数，然后直接查表判断素数</li><li>时间复杂度：<code>O (n log log n)</code>，适合多次判断素数的场景</li></ul><pre><code class="c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n;int main()&#123;    int count = 0;    cin &gt;&gt; n;    vector&lt;bool&gt; prime(n + 1,true);    prime[0] = prime[1] = false;    for (int i = 2; i*i &lt;= n; i++) &#123;        if (prime[i]) &#123;            for (int j = i * i; j &lt;= n; j += i) &#123;                prime[j] = false;            &#125;        &#125;    &#125;    for (int i = 2; i &lt;= n / 2; i++) &#123;        if (prime[i] &amp;&amp; prime[n - i]) &#123;            count++;        &#125;    &#125;    cout &lt;&lt; count;    return 0;&#125;</code></pre><h3 id="核心思路：“标记非质数，保留质数”"><a href="#核心思路：“标记非质数，保留质数”" class="headerlink" title="核心思路：“标记非质数，保留质数”"></a>核心思路：“标记非质数，保留质数”</h3><p>算法的本质是利用 “<strong>质数的倍数一定是合数</strong>” 这一数学特性，通过逐步标记合数，最终筛选出所有质数。具体可拆解为 3 个核心步骤：</p><h4 id="1-初始化：创建-“数字-状态”-标记数组"><a href="#1-初始化：创建-“数字-状态”-标记数组" class="headerlink" title="1. 初始化：创建 “数字 - 状态” 标记数组"></a>1. 初始化：创建 “数字 - 状态” 标记数组</h4><p>首先定义一个<strong>布尔类型数组</strong>（通常命名为<code>is_prime</code>），数组的<strong>索引代表待判断的数字</strong>，数组的<strong>值代表该数字是否为质数</strong>：</p><ul><li>索引范围：从 <code>0</code> 到目标范围 <code>max_num</code>（若要筛选≤100 的质数，数组长度为 101）。</li><li>初始状态：<ul><li>0 和 1 不是质数，直接标记为 <code>false</code>（非质数）；</li><li>其余数字（2~max_num）先默认标记为 <code>true</code>（暂认为质数），后续通过筛选修正。</li></ul></li></ul><h4 id="2-筛选：从最小质数开始，标记其所有倍数为合数"><a href="#2-筛选：从最小质数开始，标记其所有倍数为合数" class="headerlink" title="2. 筛选：从最小质数开始，标记其所有倍数为合数"></a>2. 筛选：从最小质数开始，标记其所有倍数为合数</h4><p>从第一个质数（2）开始，依次遍历每个已标记为 “质数” 的数字 <code>p</code>，并将 <code>p</code> 的所有<strong>大于等于 p² 的倍数</strong>标记为 <code>false</code>（合数）：</p><ul><li>为什么从 <code>p²</code> 开始？<br>因为 <code>p</code> 的小于 <code>p²</code> 的倍数（如 <code>p×2</code>、<code>p×3</code>、…、<code>p×(p-1)</code>），早已被比 <code>p</code> 更小的质数（如 2、3、…、p-1）标记过了。例如筛选 <code>p=5</code> 时，<code>5×2=10</code> 已被 <code>p=2</code> 标记，<code>5×3=15</code> 已被 <code>p=3</code> 标记，无需重复操作，从 <code>5×5=25</code> 开始标记即可，减少冗余计算。</li></ul><h4 id="3-结果：数组中仍为-“true”-的索引即为质数"><a href="#3-结果：数组中仍为-“true”-的索引即为质数" class="headerlink" title="3. 结果：数组中仍为 “true” 的索引即为质数"></a>3. 结果：数组中仍为 “true” 的索引即为质数</h4><p>遍历结束后，<code>is_prime</code> 数组中值为 <code>true</code> 的索引，就是 <code>0~max_num</code> 范围内的所有质数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算给定的大偶数可以表示为多少对素数之和。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>优雅的序列</title>
    <link href="http://example.com/2025/09/13/%E4%BC%98%E9%9B%85%E7%9A%84%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2025/09/13/%E4%BC%98%E9%9B%85%E7%9A%84%E5%BA%8F%E5%88%97/</id>
    <published>2025-09-13T07:03:48.000Z</published>
    <updated>2025-09-13T07:25:22.641Z</updated>
    
    <content type="html"><![CDATA[<p> 利用<strong>异或运算的性质</strong>设计高效的查询方案 。</p><span id="more"></span><h1 id="优雅的序列"><a href="#优雅的序列" class="headerlink" title="优雅的序列"></a>优雅的序列</h1><p>算法与数据结构实验题 1.13 优雅的序列</p><p>★实验任务</p><p>如果一个序列的元素的异或和等于 1，我们称这个序列为优雅的序列。现在给你一个01序列，和m次询问。对于每次询问，给出l,r。请你输出子序列a[l…r]的异或和。</p><p>★数据输入</p><p>输入第一行为正整数 n，m。</p><p>第二行为 n 个正整数 a[1…n]。</p><p>接下来的 m 行，每行两个数 l,r。(1&lt;&#x3D;l&lt;&#x3D;r&lt;&#x3D;n)</p><p>80%的数据 1&lt;&#x3D;n,m&lt;&#x3D;1000.</p><p>100%的数据1&lt;&#x3D;n,m&lt;&#x3D;100000.</p><h2 id="一、暴力求解法"><a href="#一、暴力求解法" class="headerlink" title="一、暴力求解法"></a>一、暴力求解法</h2><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int n, m;int num[100000 + 5];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; num[i];    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        int l, r;        int sum;        cin &gt;&gt; l &gt;&gt; r;        sum = num[l];        for (int i = l + 1; i &lt;= r; i++) &#123;            sum ^= num[i];        &#125;        cout &lt;&lt; sum &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><h2 id="二、前缀异或和"><a href="#二、前缀异或和" class="headerlink" title="二、前缀异或和"></a>二、前缀异或和</h2><p><strong>思路</strong>：</p><p>​设sum[i]为num前i项的异或和，则<code>sum[i] = num[1]^num[2]^......^num[i]</code>。</p><p>当要求区间[l,r]的异或和时，则<code>sum[r] = num[1]^num[2]^......^num[r] = num[1]^......^num[l-1]^num[l]^......^num[r]</code>。其中<code>num[l]^......^num[r]</code>为所求内容，再根据异或运算的特性两边同时异或上<code>sum[l-1]</code>，可得：<code>num[l]^......^num[r] = sum[r] ^ sum[l - 1]</code>。</p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int n, m;int num[100000 + 5];int sum[100000 + 5];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; num[i];        if (i == 1) &#123;            sum[i] = num[i];        &#125;        else &#123;            sum[i] = sum[i - 1] ^ num[i];        &#125;    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        cout &lt;&lt; (sum[r] ^ sum[l - 1]) &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt; 利用&lt;strong&gt;异或运算的性质&lt;/strong&gt;设计高效的查询方案 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最大子列和</title>
    <link href="http://example.com/2025/09/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/"/>
    <id>http://example.com/2025/09/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/</id>
    <published>2025-09-12T14:16:39.000Z</published>
    <updated>2025-09-12T14:55:20.221Z</updated>
    
    <content type="html"><![CDATA[<p>最大子列和问题详解（分治法和动态规划）。</p><span id="more"></span><h1 id="最大子列和问题"><a href="#最大子列和问题" class="headerlink" title="最大子列和问题"></a>最大子列和问题</h1><p><img src="/../images/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/1757687533219.png" alt="1757687533219"></p><h2 id="一、暴力求解法"><a href="#一、暴力求解法" class="headerlink" title="一、暴力求解法"></a>一、暴力求解法</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int num[100000 + 5];int k;int main ()&#123;    int ans = 0;    cin &gt;&gt; k;    for (int i = 0;i &lt; k;i ++)&#123;        cin &gt;&gt; num[i];    &#125;    for (int i = 0;i &lt; k;i ++)&#123;        int sum = 0;        for (int j = i;j &lt; k;j ++)&#123;            sum += num[j];            if (sum &gt; ans)&#123;                ans = sum;            &#125;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;</code></pre><ul><li><strong>思路</strong>：以<code>i</code>作为每个子列的起点，枚举到以该起点的子列最大值。</li><li><strong>步骤</strong>：<ol><li>外层循环控制起始索引 <code>i</code>，初始化当前和 <code>sum = 0</code>；</li><li>内层循环控制结束索引 <code>j</code>（从 <code>i</code> 开始），<code>sum += num[j]</code>，同步更新最大和。</li></ol></li><li><strong>时间复杂度</strong>：<code>O(n²)</code>，不适合大规模数据。</li></ul><h2 id="二、分治法"><a href="#二、分治法" class="headerlink" title="二、分治法"></a>二、分治法</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int num[100000 + 5];int k;int Max(int l,int r)&#123;    int maxL = 0;    int maxR = 0;    int sumL = 0;    int sumR = 0;    if (l == r)&#123;        return num[l];    &#125;    int m = (l + r)/2;    for (int i = m;i &gt;= l; i--)&#123;        sumL += num[i];        if (sumL &gt; maxL)&#123;            maxL = sumL;        &#125;    &#125;    for (int i = m + 1;i &lt;= r;i ++)&#123;        sumR += num[i];        if (sumR &gt; maxR)&#123;            maxR = sumR;        &#125;    &#125;    int maxMid = maxL + maxR;    return max(max(Max(l,m),Max(m+1,r)),maxMid);&#125;int main() &#123;    cin &gt;&gt; k;    for (int i = 0;i &lt; k;i ++)&#123;        cin &gt;&gt; num[i];    &#125;    cout &lt;&lt; Max(0,k-1) &lt;&lt; endl;        return 0;&#125;</code></pre><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a><strong>核心思路</strong></h3><p>分治法的核心思想是<strong>将问题分解为更小的子问题</strong>，求解子问题后<strong>合并结果</strong>：</p><ol><li><strong>分解</strong>：将数组从中间分为左半部分和右半部分。</li><li><strong>求解子问题</strong>：递归求解左半部分的最大子数组和、右半部分的最大子数组和。</li><li><strong>合并</strong>：计算跨越左右两部分的最大子数组和（即包含中间元素的最大子数组），最终结果为这三者中的最大值。</li></ol><h3 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a><strong>步骤解析</strong></h3><p>以函数<code>Max(l, r)</code>为例（表示求解数组<code>num</code>中从索引<code>l</code>到<code>r</code>的最大子数组和）：</p><ol><li><strong>递归终止条件</strong>：<ul><li>当<code>l == r</code>（子数组只有一个元素），直接返回该元素的值（单个元素的最大子数组就是它本身）。</li></ul></li><li><strong>分解数组</strong>：<ul><li>计算中间索引<code>m = (l + r) / 2</code>，将数组分为<code>[l, m]</code>（左半部分）和<code>[m+1, r]</code>（右半部分）。</li></ul></li><li><strong>求解左、右子数组的最大和</strong>：<ul><li>递归计算左半部分：<code>Max(l, m)</code></li><li>递归计算右半部分：<code>Max(m+1, r)</code></li></ul></li><li><strong>计算跨越中间的最大子数组和</strong>：<ul><li><strong>左半部分延伸</strong>：从中间<code>m</code>向左遍历（<code>i = m</code>到<code>l</code>），累加元素并记录最大和<code>maxL</code>（包含<code>m</code>的左侧最大子数组）。</li><li><strong>右半部分延伸</strong>：从中间<code>m+1</code>向右遍历（<code>i = m+1</code>到<code>r</code>），累加元素并记录最大和<code>maxR</code>（包含<code>m+1</code>的右侧最大子数组）。</li><li>跨越中间的最大和为<code>maxMid = maxL + maxR</code>（左右两部分连接形成的子数组）。</li></ul></li><li><strong>合并结果</strong>：<ul><li>最终结果为左半部分最大和、右半部分最大和、跨越中间最大和中的最大值，即<code>max(max(Max(l,m), Max(m+1,r)), maxMid)</code>。</li></ul></li></ol><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a><strong>时间复杂度分析</strong></h3><ul><li><strong>分解</strong>：每次将数组分为两半，递归深度为<code>O(log n)</code>（<code>n</code>为数组长度）。</li><li><strong>合并</strong>：每次计算跨越中间的最大子数组和时，需要遍历左半部分和右半部分，总遍历次数为<code>O(n)</code>（每次递归处理的子数组长度之和为<code>n</code>）。</li><li><strong>总时间复杂度</strong>：<code>O(n log n)</code>，其中<code>n</code>是数组的长度（代码中为<code>k</code>）。</li></ul><h2 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int num[100000 + 5];int dp[100000 + 5];int k;int ans;int main() &#123;    ans = 0;    cin &gt;&gt; k;    for (int i = 0;i &lt; k;i ++)&#123;        cin &gt;&gt; num[i];    &#125;    dp[0] = num[0];    for (int i = 1;i &lt; k;i ++)&#123;        dp[i] = max(num[i],dp[i-1] + num[i]);        if (dp[i] &gt; ans)&#123;            ans = dp[i];        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;        return 0;&#125;</code></pre><h3 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a><strong>核心思路</strong></h3><p>动态规划的核心思想是<strong>通过求解子问题的最优解来推导整个问题的最优解</strong>，并利用中间结果避免重复计算。</p><p>对于最大子数组和问题，定义<code>dp[i]</code>表示：以数组第<code>i</code>个元素（<code>num[i]</code>）为结尾的最大子数组的和。</p><p>关键逻辑是：</p><ul><li>对于每个元素<code>num[i]</code>，有两种选择：<ol><li>单独作为一个子数组（此时和为<code>num[i]</code>）</li><li>加入以<code>num[i-1]</code>为结尾的最大子数组（此时和为<code>dp[i-1] + num[i]</code>）</li></ol></li><li>取两种选择中的最大值作为<code>dp[i]</code>，即<code>dp[i] = max(num[i], dp[i-1] + num[i])</code></li><li>整个数组的最大子数组和，就是所有<code>dp[i]</code>中的最大值</li></ul><h3 id="步骤解析-1"><a href="#步骤解析-1" class="headerlink" title="步骤解析"></a><strong>步骤解析</strong></h3><ol><li><p><strong>初始化</strong>：</p><ul><li><code>dp[0] = num[0]</code>：第一个元素的最大子数组就是它本身</li><li><code>ans = 0</code>：用于记录全局最大子数组和（后续会更新）</li></ul></li><li><p><strong>遍历数组计算 dp 数组</strong>：</p><ul><li><p>从第二个元素（<code>i = 1</code>）开始遍历到最后一个元素（<code>i = k-1</code>）</p></li><li><p>对每个</p><pre><code>i</code></pre><p>，计算</p><pre><code>dp[i] = max(num[i], dp[i-1] + num[i])</code></pre><p>：</p><ul><li>若<code>dp[i-1] + num[i]</code>更大，说明将<code>num[i]</code>加入前一个子数组能得到更大和</li><li>若<code>num[i]</code>更大，说明从<code>num[i]</code>开始重新计算子数组更优</li></ul></li><li><p>每次计算<code>dp[i]</code>后，更新<code>ans</code>为<code>ans</code>和<code>dp[i]</code>中的最大值</p></li></ul></li><li><p><strong>输出结果</strong>：</p><ul><li>最终<code>ans</code>即为整个数组的最大子数组和</li></ul></li></ol><h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a><strong>时间复杂度分析</strong></h3><ul><li>代码中只有一次对数组的遍历（从<code>i = 1</code>到<code>i = k-1</code>），共执行<code>k-1</code>次操作</li><li>每次操作（计算<code>dp[i]</code>和更新<code>ans</code>）都是常数时间<code>O(1)</code></li><li>因此，<strong>总时间复杂度为</strong><code>O(k)</code>（<code>k</code>为数组长度）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最大子列和问题详解（分治法和动态规划）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android信息传递详解</title>
    <link href="http://example.com/2025/09/10/Android%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/09/10/Android%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-09-10T07:12:14.000Z</published>
    <updated>2025-09-10T07:15:03.757Z</updated>
    
    <content type="html"><![CDATA[<p> 在 Android 开发中，信息传递（数据传递）是组件间通信的核心，常见场景包括 Activity 之间、Activity 与 Fragment 之间、线程之间等。 </p><span id="more"></span><h3 id="一、Activity-之间的数据传递"><a href="#一、Activity-之间的数据传递" class="headerlink" title="一、Activity 之间的数据传递"></a>一、Activity 之间的数据传递</h3><p>最常用的是通过<code>Intent</code>携带数据，配合<code>startActivity()</code>或<code>startActivityForResult()</code>（已过时，推荐<code>Activity Result API</code>）。</p><h4 id="1-基础数据传递（Intent-putExtra-）"><a href="#1-基础数据传递（Intent-putExtra-）" class="headerlink" title="1. 基础数据传递（Intent.putExtra ()）"></a>1. 基础数据传递（Intent.putExtra ()）</h4><p><strong>发送方 Activity</strong>：</p><pre><code class="java">// 发送数据到目标ActivityIntent intent = new Intent(SenderActivity.this, ReceiverActivity.class);// 传递基本类型数据intent.putExtra(&quot;key_string&quot;, &quot;Hello Receiver&quot;);intent.putExtra(&quot;key_int&quot;, 123);intent.putExtra(&quot;key_boolean&quot;, true);// 传递自定义对象（需实现Serializable或Parcelable）User user = new User(&quot;Tom&quot;, 20);intent.putExtra(&quot;key_user&quot;, user); // User需实现SerializablestartActivity(intent);</code></pre><p><strong>接收方 Activity</strong>：</p><pre><code class="java">// 在onCreate中接收数据@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_receiver);        Intent intent = getIntent();    // 获取基本类型数据    String str = intent.getStringExtra(&quot;key_string&quot;);    int num = intent.getIntExtra(&quot;key_int&quot;, 0); // 第二个参数为默认值    boolean flag = intent.getBooleanExtra(&quot;key_boolean&quot;, false);        // 获取自定义对象    User user = (User) intent.getSerializableExtra(&quot;key_user&quot;);&#125;// 自定义对象（实现Serializable）public class User implements Serializable &#123;    private String name;    private int age;        // 构造方法、getter、setter    public User(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    // ... getter和setter&#125;</code></pre><h4 id="2-回传数据（Activity-Result-API）"><a href="#2-回传数据（Activity-Result-API）" class="headerlink" title="2. 回传数据（Activity Result API）"></a>2. 回传数据（Activity Result API）</h4><p>替代已过时的<code>startActivityForResult()</code>，用于需要从目标 Activity 返回数据的场景。</p><p><strong>发送方 Activity</strong>：</p><pre><code class="java">import androidx.activity.result.ActivityResultLauncher;import androidx.activity.result.contract.ActivityResultContracts;public class SenderActivity extends AppCompatActivity &#123;    // 注册回调    private ActivityResultLauncher&lt;Intent&gt; resultLauncher = registerForActivityResult(        new ActivityResultContracts.StartActivityForResult(),        result -&gt; &#123;            // 处理返回结果            if (result.getResultCode() == RESULT_OK) &#123;                Intent data = result.getData();                if (data != null) &#123;                    String returnStr = data.getStringExtra(&quot;return_key&quot;);                    // 更新UI                &#125;            &#125;        &#125;    );    // 触发跳转并等待返回    public void sendAndWaitResult(View view) &#123;        Intent intent = new Intent(this, ReceiverActivity.class);        intent.putExtra(&quot;request_key&quot;, &quot;请处理数据&quot;);        resultLauncher.launch(intent);    &#125;&#125;</code></pre><p><strong>接收方 Activity</strong>：</p><pre><code class="java">// 处理数据并返回结果public class ReceiverActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_receiver);                // 获取请求数据        String requestData = getIntent().getStringExtra(&quot;request_key&quot;);                // 处理后返回结果        findViewById(R.id.btn_return).setOnClickListener(v -&gt; &#123;            Intent returnIntent = new Intent();            returnIntent.putExtra(&quot;return_key&quot;, &quot;处理完成：&quot; + requestData);            setResult(RESULT_OK, returnIntent);            finish(); // 关闭当前Activity        &#125;);    &#125;&#125;</code></pre><h3 id="二、Activity-与-Fragment-之间的数据传递"><a href="#二、Activity-与-Fragment-之间的数据传递" class="headerlink" title="二、Activity 与 Fragment 之间的数据传递"></a>二、Activity 与 Fragment 之间的数据传递</h3><h4 id="1-Activity-向-Fragment-传递数据"><a href="#1-Activity-向-Fragment-传递数据" class="headerlink" title="1. Activity 向 Fragment 传递数据"></a>1. Activity 向 Fragment 传递数据</h4><p>通过<code>Fragment.setArguments(Bundle)</code>传递：</p><p><strong>Activity 中</strong>：</p><pre><code class="java">// 创建Fragment并传递数据MyFragment fragment = new MyFragment();Bundle bundle = new Bundle();bundle.putString(&quot;fragment_key&quot;, &quot;来自Activity的数据&quot;);bundle.putInt(&quot;fragment_num&quot;, 456);fragment.setArguments(bundle);// 加载FragmentgetSupportFragmentManager().beginTransaction()    .replace(R.id.container, fragment)    .commit();</code></pre><p><strong>Fragment 中</strong>：</p><pre><code class="java">@Overridepublic void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    // 接收数据    if (getArguments() != null) &#123;        String str = getArguments().getString(&quot;fragment_key&quot;);        int num = getArguments().getInt(&quot;fragment_num&quot;);    &#125;&#125;</code></pre><h4 id="2-Fragment-向-Activity-传递数据"><a href="#2-Fragment-向-Activity-传递数据" class="headerlink" title="2. Fragment 向 Activity 传递数据"></a>2. Fragment 向 Activity 传递数据</h4><p>通过接口回调实现：</p><p><strong>定义回调接口（在 Fragment 中）</strong>：</p><pre><code class="java">public class MyFragment extends Fragment &#123;    // 定义回调接口    public interface OnDataPassListener &#123;        void onDataPass(String data);    &#125;        private OnDataPassListener listener;        // 绑定Activity时初始化接口    @Override    public void onAttach(@NonNull Context context) &#123;        super.onAttach(context);        if (context instanceof OnDataPassListener) &#123;            listener = (OnDataPassListener) context;        &#125; else &#123;            throw new RuntimeException(&quot;Activity需实现OnDataPassListener接口&quot;);        &#125;    &#125;        // 发送数据到Activity    private void sendDataToActivity() &#123;        String data = &quot;来自Fragment的数据&quot;;        listener.onDataPass(data); // 调用接口方法    &#125;&#125;</code></pre><p><strong>Activity 实现接口</strong>：</p><pre><code class="java">public class MainActivity extends AppCompatActivity implements MyFragment.OnDataPassListener &#123;    @Override    public void onDataPass(String data) &#123;        // 接收Fragment传递的数据        Log.d(&quot;MainActivity&quot;, &quot;收到数据：&quot; + data);    &#125;&#125;</code></pre><h3 id="三、全局数据传递（Application-单例模式）"><a href="#三、全局数据传递（Application-单例模式）" class="headerlink" title="三、全局数据传递（Application &#x2F; 单例模式）"></a>三、全局数据传递（Application &#x2F; 单例模式）</h3><p>适合需要在整个应用中共享的数据（如用户信息、配置参数）。</p><h4 id="1-自定义-Application-类"><a href="#1-自定义-Application-类" class="headerlink" title="1. 自定义 Application 类"></a>1. 自定义 Application 类</h4><pre><code class="java">public class MyApplication extends Application &#123;    private String globalData; // 全局共享数据        public static MyApplication getInstance(Context context) &#123;        return (MyApplication) context.getApplicationContext();    &#125;        // getter和setter    public String getGlobalData() &#123;        return globalData;    &#125;        public void setGlobalData(String data) &#123;        this.globalData = data;    &#125;&#125;</code></pre><p><strong>在 AndroidManifest.xml 中注册</strong>：</p><pre><code class="xml">&lt;application    android:name=&quot;.MyApplication&quot;    &lt;!-- 其他配置 --&gt;&lt;/application&gt;</code></pre><p><strong>使用方式</strong>：</p><pre><code class="java">// 保存数据MyApplication.getInstance(this).setGlobalData(&quot;全局共享内容&quot;);// 读取数据String data = MyApplication.getInstance(this).getGlobalData();</code></pre><h4 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h4><pre><code class="java">public class DataManager &#123;    // 单例实例    private static DataManager instance;    private String sharedData;        // 私有构造方法    private DataManager() &#123;&#125;        // 获取单例    public static synchronized DataManager getInstance() &#123;        if (instance == null) &#123;            instance = new DataManager();        &#125;        return instance;    &#125;        // getter和setter    public String getSharedData() &#123;        return sharedData;    &#125;        public void setSharedData(String data) &#123;        this.sharedData = data;    &#125;&#125;</code></pre><p><strong>使用方式</strong>：</p><pre><code class="java">// 保存数据DataManager.getInstance().setSharedData(&quot;单例共享数据&quot;);// 读取数据String data = DataManager.getInstance().getSharedData();</code></pre><h3 id="四、线程间的数据传递"><a href="#四、线程间的数据传递" class="headerlink" title="四、线程间的数据传递"></a>四、线程间的数据传递</h3><p>子线程向主线程传递数据（更新 UI），主要通过<code>Handler</code>实现。</p><pre><code class="java">public class MainActivity extends AppCompatActivity &#123;    private TextView textView;    // 主线程的Handler    private Handler mainHandler = new Handler(Looper.getMainLooper()) &#123;        @Override        public void handleMessage(@NonNull Message msg) &#123;            super.handleMessage(msg);            // 主线程中处理消息（更新UI）            if (msg.what == 1) &#123;                String result = (String) msg.obj;                textView.setText(result);            &#125;        &#125;    &#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        textView = findViewById(R.id.text_view);                // 启动子线程执行耗时操作        new Thread(() -&gt; &#123;            // 模拟耗时操作            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;                        // 子线程发送数据到主线程            Message message = Message.obtain();            message.what = 1; // 消息标识            message.obj = &quot;子线程处理完成的数据&quot;; // 传递的数据            mainHandler.sendMessage(message);        &#125;).start();    &#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不同场景适合的传递方式：</p><ul><li><strong>组件间临时数据</strong>：优先使用<code>Intent</code> + <code>Bundle</code></li><li><strong>Activity 与 Fragment 通信</strong>：推荐接口回调或<code>ViewModel</code>（Jetpack 组件）</li><li><strong>全局共享数据</strong>：使用自定义<code>Application</code>或单例模式</li><li><strong>线程间通信</strong>：通过<code>Handler</code>或<code>runOnUiThread()</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; 在 Android 开发中，信息传递（数据传递）是组件间通信的核心，常见场景包括 Activity 之间、Activity 与 Fragment 之间、线程之间等。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android异步任务与多线程详解</title>
    <link href="http://example.com/2025/09/10/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/09/10/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-09-10T06:42:48.000Z</published>
    <updated>2025-09-10T07:24:42.732Z</updated>
    
    <content type="html"><![CDATA[<p> 在 Android 开发中，多线程是处理耗时操作（如网络请求、文件读写、复杂计算等）的核心技术，能有效避免主线程（UI 线程）阻塞，保证应用的流畅性。 </p><span id="more"></span><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><h3 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h3><h4 id="1-同步任务（Synchronous）"><a href="#1-同步任务（Synchronous）" class="headerlink" title="1. 同步任务（Synchronous）"></a>1. 同步任务（Synchronous）</h4><ul><li><strong>执行方式</strong>：任务按顺序执行，前一个任务完成后，才会开始下一个任务。</li><li><strong>阻塞特性</strong>：当前线程会被阻塞，等待任务完成后再继续执行后续代码。</li><li><strong>形象比喻</strong>：类似打电话，必须等对方说完，你才能开始说，中间不能做其他事。</li></ul><h4 id="2-异步任务（Asynchronous）"><a href="#2-异步任务（Asynchronous）" class="headerlink" title="2. 异步任务（Asynchronous）"></a>2. 异步任务（Asynchronous）</h4><ul><li><strong>执行方式</strong>：任务启动后，不等待其完成，直接执行后续代码，任务在后台独立运行。</li><li><strong>非阻塞特性</strong>：当前线程不会被阻塞，可以继续处理其他任务。</li><li><strong>结果处理</strong>：任务完成后，通常通过回调（Callback）、事件通知等方式返回结果。</li><li><strong>形象比喻</strong>：类似发邮件，发送后不必等待对方回复，可以继续做其他事，对方回复时会收到通知。</li></ul><h3 id="二、代码示例对比"><a href="#二、代码示例对比" class="headerlink" title="二、代码示例对比"></a>二、代码示例对比</h3><h4 id="1-同步任务示例（Android-中主线程执行耗时操作的错误示范）"><a href="#1-同步任务示例（Android-中主线程执行耗时操作的错误示范）" class="headerlink" title="1. 同步任务示例（Android 中主线程执行耗时操作的错误示范）"></a>1. 同步任务示例（Android 中主线程执行耗时操作的错误示范）</h4><pre><code class="kotlin">// 主线程中执行同步任务（错误示例！会导致ANR）fun syncTask() &#123;    println(&quot;任务1开始&quot;)    // 模拟耗时操作（如网络请求）    Thread.sleep(3000) // 主线程被阻塞3秒    println(&quot;任务1完成&quot;)        println(&quot;任务2开始&quot;) // 必须等任务1完成才执行    Thread.sleep(2000)    println(&quot;任务2完成&quot;)&#125;</code></pre><p><strong>问题</strong>：主线程被阻塞，界面会冻结，超过 5 秒触发 ANR。</p><h4 id="2-异步任务示例（使用-Kotlin-协程）"><a href="#2-异步任务示例（使用-Kotlin-协程）" class="headerlink" title="2. 异步任务示例（使用 Kotlin 协程）"></a>2. 异步任务示例（使用 Kotlin 协程）</h4><pre><code class="kotlin">// 异步执行任务（推荐方式）fun asyncTask() &#123;    println(&quot;主线程继续执行其他操作&quot;)        // 启动异步任务（在IO线程执行）    lifecycleScope.launch(Dispatchers.IO) &#123;        println(&quot;异步任务1开始&quot;)        delay(3000) // 模拟耗时，不阻塞主线程        println(&quot;异步任务1完成&quot;)                // 切换到主线程更新UI        withContext(Dispatchers.Main) &#123;            textView.text = &quot;任务1完成&quot;        &#125;    &#125;        // 无需等待任务1，直接执行后续代码    println(&quot;任务2开始（主线程）&quot;)    // 主线程可以继续处理用户交互等操作&#125;</code></pre><p><strong>特点</strong>：异步任务在后台执行，主线程不阻塞，界面保持流畅。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="一、Android-线程基础"><a href="#一、Android-线程基础" class="headerlink" title="一、Android 线程基础"></a>一、Android 线程基础</h3><ol><li><strong>主线程（UI 线程）</strong><ul><li>负责处理 UI 渲染和用户交互，不能执行耗时操作（超过 5 秒会触发 ANR - Application Not Responding）。</li><li>所有 UI 操作必须在主线程执行，子线程不能直接更新 UI。</li></ul></li><li><strong>子线程（工作线程）</strong><ul><li>用于执行耗时操作，避免阻塞主线程。</li><li>不能直接操作 UI，需通过特定机制通知主线程更新 UI。</li></ul></li></ol><h3 id="二、多线程实现方式"><a href="#二、多线程实现方式" class="headerlink" title="二、多线程实现方式"></a>二、多线程实现方式</h3><h4 id="1-Thread-Handler（传统方式）"><a href="#1-Thread-Handler（传统方式）" class="headerlink" title="1. Thread + Handler（传统方式）"></a>1. Thread + Handler（传统方式）</h4><p>通过<code>Thread</code>执行耗时操作，<code>Handler</code>实现线程间通信（子线程通知主线程更新 UI）。</p><p><strong>示例代码</strong>：</p><pre><code class="kotlin">// 主线程中定义Handler（用于接收子线程消息）private val mHandler = object : Handler(Looper.getMainLooper()) &#123;    override fun handleMessage(msg: Message) &#123;        super.handleMessage(msg)        // 在主线程更新UI        when (msg.what) &#123;            1 -&gt; textView.text = &quot;耗时操作完成&quot;        &#125;    &#125;&#125;// 启动子线程执行耗时操作fun startTask() &#123;    Thread &#123;        // 模拟耗时操作（如网络请求）        Thread.sleep(3000)                // 发送消息到主线程        val msg = Message.obtain()        msg.what = 1 // 消息标识        mHandler.sendMessage(msg)    &#125;.start()&#125;</code></pre><h4 id="2-AsyncTask（已过时，了解即可）"><a href="#2-AsyncTask（已过时，了解即可）" class="headerlink" title="2. AsyncTask（已过时，了解即可）"></a>2. AsyncTask（已过时，了解即可）</h4><p>封装了<code>Thread</code>和<code>Handler</code>，简化异步操作，但在 Android 11 中已被标记为过时，推荐使用<code>Coroutine</code>或<code>Executor</code>替代。</p><p><strong>示例代码</strong>：</p><pre><code class="kotlin">// 泛型参数：Params（输入参数）、Progress（进度）、Result（结果）class MyAsyncTask : AsyncTask&lt;Void, Int, String&gt;() &#123;    // 子线程中执行耗时操作    override fun doInBackground(vararg params: Void?): String &#123;        for (i in 0..100) &#123;            Thread.sleep(50)            publishProgress(i) // 发布进度        &#125;        return &quot;任务完成&quot;    &#125;    // 主线程中更新进度（在publishProgress后调用）    override fun onProgressUpdate(vararg values: Int?) &#123;        super.onProgressUpdate(*values)        progressBar.progress = values[0] ?: 0    &#125;    // 主线程中处理结果（任务完成后调用）    override fun onPostExecute(result: String?) &#123;        super.onPostExecute(result)        textView.text = result    &#125;&#125;// 启动任务MyAsyncTask().execute()</code></pre><h4 id="3-ThreadPoolExecutor（线程池）"><a href="#3-ThreadPoolExecutor（线程池）" class="headerlink" title="3. ThreadPoolExecutor（线程池）"></a>3. ThreadPoolExecutor（线程池）</h4><p>通过线程池管理线程，避免频繁创建 &#x2F; 销毁线程的开销，提高性能。Android 推荐使用<code>Executors</code>工具类创建线程池。</p><p><strong>示例代码</strong>：</p><pre><code class="kotlin">// 创建线程池（核心线程数3，最大线程数5，空闲时间10秒）private val executor = ThreadPoolExecutor(    3, 5, 10, TimeUnit.SECONDS,    LinkedBlockingQueue(),    Executors.defaultThreadFactory(),    ThreadPoolExecutor.AbortPolicy() // 拒绝策略)// 执行任务fun executeTask() &#123;    executor.execute &#123;        // 子线程执行耗时操作        Thread.sleep(3000)                // 切换到主线程更新UI        runOnUiThread &#123;            textView.text = &quot;线程池任务完成&quot;        &#125;    &#125;&#125;// 页面销毁时关闭线程池override fun onDestroy() &#123;    super.onDestroy()    executor.shutdown()&#125;</code></pre><h4 id="4-Kotlin-Coroutine（推荐）"><a href="#4-Kotlin-Coroutine（推荐）" class="headerlink" title="4. Kotlin Coroutine（推荐）"></a>4. Kotlin Coroutine（推荐）</h4><p>Kotlin 协程是轻量级线程，语法简洁，通过<code>Dispatchers</code>指定线程类型，轻松实现线程切换。</p><p><strong>使用步骤</strong>：</p><ol><li>添加依赖（AndroidX 项目默认包含）：</li></ol><pre><code class="gradle">dependencies &#123;    implementation &#39;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4&#39;&#125;</code></pre><ol><li><strong>示例代码</strong>：</li></ol><pre><code class="kotlin">// 启动协程（ lifecycleScope 是AndroidX提供的生命周期感知协程作用域）fun startCoroutineTask() &#123;    lifecycleScope.launch &#123;        // 切换到IO线程执行耗时操作        val result = withContext(Dispatchers.IO) &#123;            // 模拟网络请求            Thread.sleep(3000)            &quot;协程任务结果&quot;        &#125;                // 自动切换回主线程更新UI        textView.text = result    &#125;&#125;</code></pre><p><strong>核心优势</strong>：</p><ul><li>语法简洁，避免回调嵌套（“回调地狱”）。</li><li>自动绑定生命周期（<code>lifecycleScope</code>），防止内存泄漏。</li><li>通过<code>Dispatchers</code>灵活切换线程（<code>Main</code>主线程、<code>IO</code>输入输出、<code>Default</code>计算密集型）。</li></ul><h3 id="三、线程通信核心机制"><a href="#三、线程通信核心机制" class="headerlink" title="三、线程通信核心机制"></a>三、线程通信核心机制</h3><ol><li><p><strong>Handler + Looper + MessageQueue</strong></p><ul><li><code>MessageQueue</code>：消息队列，存储子线程发送的消息。</li><li><code>Looper</code>：循环读取<code>MessageQueue</code>中的消息，分发给对应<code>Handler</code>。</li><li><code>Handler</code>：发送和处理消息，实现线程间通信。</li></ul></li><li><p><strong>runOnUiThread</strong><br>Activity 提供的方法，简化子线程切换到主线程更新 UI：</p><pre><code class="kotlin">Thread &#123;    // 耗时操作    runOnUiThread &#123;        textView.text = &quot;更新UI&quot;    &#125;&#125;.start()</code></pre></li><li><p><strong>View.post()</strong><br>视图提供的方法，将任务 post 到主线程执行：</p><pre><code class="kotlin">textView.post &#123;    textView.text = &quot;主线程更新&quot;&#125;</code></pre></li></ol><h3 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h3><ol><li><strong>避免内存泄漏</strong><ul><li>子线程持有 Activity 引用时，需在页面销毁时停止线程。</li><li>使用<code>lifecycleScope</code>（协程）或<code>WeakReference</code>（弱引用）管理生命周期。</li></ul></li><li><strong>UI 操作限制</strong><ul><li>所有 UI 更新必须在主线程执行，子线程直接操作会抛出异常。</li></ul></li><li><strong>线程池管理</strong><ul><li>避免创建大量线程，优先使用线程池复用线程。</li><li>不再使用时需调用<code>shutdown()</code>关闭线程池。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>简单场景：使用<code>Thread + Handler</code>或<code>View.post()</code>。</li><li>复杂异步任务：推荐<code>Kotlin Coroutine</code>（简洁、安全）。</li><li>多任务并发：使用<code>ThreadPoolExecutor</code>管理线程资源。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; 在 Android 开发中，多线程是处理耗时操作（如网络请求、文件读写、复杂计算等）的核心技术，能有效避免主线程（UI 线程）阻塞，保证应用的流畅性。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
</feed>
