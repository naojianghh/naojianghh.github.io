<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NaoJianghh</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-11-11T15:16:58.106Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>脑浆糊</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS_动画</title>
    <link href="http://example.com/2025/11/11/CSS-%E5%8A%A8%E7%94%BB/"/>
    <id>http://example.com/2025/11/11/CSS-%E5%8A%A8%E7%94%BB/</id>
    <published>2025-11-11T15:10:59.000Z</published>
    <updated>2025-11-11T15:16:58.106Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 动画是通过 CSS 属性控制元素从一种样式状态平滑过渡到另一种状态的技术，无需 JavaScript 即可实现丰富的视觉效果（如渐变、旋转、缩放、位移等）。核心分为 <strong>过渡动画（<code>transition</code>）</strong> 和 <strong>关键帧动画（<code>animation</code>）</strong> 两大类，前者适合简单的 “状态切换”，后者适合复杂的 “多阶段动画”。本文将从基础概念、用法、特性、实战场景及优化全面解析。</p><span id="more"></span><h1 id="CSS-动画详解"><a href="#CSS-动画详解" class="headerlink" title="CSS 动画详解"></a>CSS 动画详解</h1><h2 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h2><h3 id="1-动画的本质"><a href="#1-动画的本质" class="headerlink" title="1. 动画的本质"></a>1. 动画的本质</h3><p>通过 CSS 定义元素的 “初始状态” 和 “目标状态”（或多阶段状态），浏览器自动计算中间帧，实现平滑过渡。核心优势：</p><ul><li>浏览器原生支持，性能优于 JS 动画（可利用 GPU 加速）；</li><li>语法简洁，无需复杂脚本；</li><li>支持暂停、延迟、循环等控制。</li></ul><h3 id="2-关键术语"><a href="#2-关键术语" class="headerlink" title="2. 关键术语"></a>2. 关键术语</h3><ul><li><strong>状态</strong>：元素的 CSS 样式集合（如 <code>width: 100px</code>、<code>opacity: 0</code>）；</li><li><strong>过渡（Transition）</strong>：从 “初始状态” 到 “目标状态” 的一次性平滑过渡；</li><li><strong>关键帧（Keyframe）</strong>：定义动画的多个关键阶段（如开始、中间、结束），<code>animation</code> 基于关键帧实现复杂动画；</li><li><strong>时间函数（Timing Function）</strong>：控制动画的速度曲线（如匀速、先慢后快）；</li><li><strong>持续时间（Duration）</strong>：动画从开始到结束的总时间；</li><li><strong>延迟时间（Delay）</strong>：动画触发后等待多久开始执行。</li></ul><h2 id="二、过渡动画（transition）：简单状态切换"><a href="#二、过渡动画（transition）：简单状态切换" class="headerlink" title="二、过渡动画（transition）：简单状态切换"></a>二、过渡动画（transition）：简单状态切换</h2><p><code>transition</code> 是最基础的 CSS 动画，用于实现 “元素状态变化时的平滑过渡”（如 hover 效果、点击切换样式），仅需定义 “过渡属性”“持续时间” 等核心参数。</p><h3 id="1-语法（简写）"><a href="#1-语法（简写）" class="headerlink" title="1. 语法（简写）"></a>1. 语法（简写）</h3><pre><code class="css">transition: [过渡属性] [持续时间] [时间函数] [延迟时间];</code></pre><ul><li>各参数可选，顺序固定（后两个可省略，默认：<code>ease</code> 时间函数、<code>0s</code> 延迟）；</li><li>多属性过渡：用逗号分隔（如 <code>transition: width 0.3s, background 0.5s</code>）；</li><li>所有属性过渡：<code>transition: all 0.3s</code>（简单但性能略差，推荐明确指定属性）。</li></ul><h3 id="2-核心参数详解"><a href="#2-核心参数详解" class="headerlink" title="2. 核心参数详解"></a>2. 核心参数详解</h3><table><thead><tr><th>参数</th><th>说明</th><th>可选值</th></tr></thead><tbody><tr><td>过渡属性</td><td>要过渡的 CSS 属性（如 <code>width</code>、<code>opacity</code>、<code>transform</code>）</td><td>具体属性名 &#x2F; <code>all</code>（所有属性） &#x2F; <code>none</code></td></tr><tr><td>持续时间</td><td>动画完成的时间（必须指定，否则无效）</td><td>单位 <code>s</code>（秒）或 <code>ms</code>（毫秒）（如 <code>0.3s</code>）</td></tr><tr><td>时间函数</td><td>动画速度曲线</td><td><code>ease</code>（默认：先慢后快）、<code>linear</code>（匀速）、<code>ease-in-out</code>（先慢后快再慢）、<code>cubic-bezier(n,n,n,n)</code>（自定义曲线）</td></tr><tr><td>延迟时间</td><td>触发后延迟多久开始动画</td><td>单位 <code>s</code>&#x2F;<code>ms</code>（如 <code>0.2s</code>，默认 <code>0s</code>）</td></tr></tbody></table><h3 id="3-基础示例：hover-平滑缩放"><a href="#3-基础示例：hover-平滑缩放" class="headerlink" title="3. 基础示例：hover 平滑缩放"></a>3. 基础示例：hover 平滑缩放</h3><pre><code class="html">&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background: blue;    /* 过渡动画：transform 属性，持续 0.3s，匀速 */    transition: transform 0.3s linear;  &#125;  .box:hover &#123;    transform: scale(1.2); /* hover 时放大 1.2 倍 */  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><ul><li>效果：鼠标悬浮时，盒子平滑放大；离开时，平滑恢复原大小。</li></ul><h3 id="4-多属性过渡示例"><a href="#4-多属性过渡示例" class="headerlink" title="4. 多属性过渡示例"></a>4. 多属性过渡示例</h3><pre><code class="css">.box &#123;  width: 100px;  height: 100px;  background: red;  /* 同时过渡 width、background、border-radius，各属性持续时间不同 */  transition: width 0.5s ease, background 0.3s, border-radius 0.8s;&#125;.box:hover &#123;  width: 200px;  background: green;  border-radius: 50%; /* 变为圆形 */&#125;</code></pre><h3 id="5-过渡动画的触发方式"><a href="#5-过渡动画的触发方式" class="headerlink" title="5. 过渡动画的触发方式"></a>5. 过渡动画的触发方式</h3><p><code>transition</code> 需通过 “状态变化” 触发，常见触发方式：</p><ul><li>伪类：<code>hover</code>（悬浮）、<code>active</code>（点击）、<code>focus</code>（聚焦）；</li><li>JS 操作：修改元素 <code>class</code>、直接修改 CSS 属性；</li><li>表单元素状态：<code>checked</code>（复选框选中）。</li></ul><p>示例：JS 触发过渡</p><pre><code class="html">&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background: yellow;    transition: all 0.3s;  &#125;  .box.active &#123;    width: 300px;    background: purple;  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;&lt;/div&gt;&lt;button onclick=&quot;document.getElementById(&#39;box&#39;).classList.toggle(&#39;active&#39;)&quot;&gt;切换状态&lt;/button&gt;</code></pre><h2 id="三、关键帧动画（animation）：复杂多阶段动画"><a href="#三、关键帧动画（animation）：复杂多阶段动画" class="headerlink" title="三、关键帧动画（animation）：复杂多阶段动画"></a>三、关键帧动画（animation）：复杂多阶段动画</h2><p><code>animation</code> 是更强大的 CSS 动画，通过 <code>@keyframes</code> 定义多个关键帧（阶段），支持循环、暂停、反向播放等，适合实现复杂动画（如加载动画、元素穿梭、多步骤变换）。</p><h3 id="1-核心语法"><a href="#1-核心语法" class="headerlink" title="1. 核心语法"></a>1. 核心语法</h3><h4 id="（1）定义关键帧（-keyframes）"><a href="#（1）定义关键帧（-keyframes）" class="headerlink" title="（1）定义关键帧（@keyframes）"></a>（1）定义关键帧（<code>@keyframes</code>）</h4><pre><code class="css">/* 方式 1：用 from（开始）和 to（结束）定义两阶段动画 */@keyframes 动画名称 &#123;  from &#123; /* 初始状态 */    transform: translateX(0);  &#125;  to &#123; /* 结束状态 */    transform: translateX(300px);  &#125;&#125;/* 方式 2：用百分比定义多阶段动画（更灵活） */@keyframes 动画名称 &#123;  0% &#123; /* 初始状态 */    opacity: 0;    transform: scale(0.5);  &#125;  50% &#123; /* 中间阶段（动画进行到一半） */    opacity: 1;    transform: scale(1.1);  &#125;  100% &#123; /* 结束状态 */    opacity: 1;    transform: scale(1);  &#125;&#125;</code></pre><h4 id="（2）应用动画（animation-简写）"><a href="#（2）应用动画（animation-简写）" class="headerlink" title="（2）应用动画（animation 简写）"></a>（2）应用动画（<code>animation</code> 简写）</h4><pre><code class="css">animation: [动画名称] [持续时间] [时间函数] [延迟时间] [循环次数] [方向] [填充模式] [播放状态];</code></pre><ul><li>各参数顺序可灵活调整（但持续时间必须在延迟时间前）；</li><li>未指定的参数取默认值。</li></ul><h3 id="2-animation-各参数详解"><a href="#2-animation-各参数详解" class="headerlink" title="2. animation 各参数详解"></a>2. <code>animation</code> 各参数详解</h3><table><thead><tr><th>参数</th><th>说明</th><th>可选值</th></tr></thead><tbody><tr><td>动画名称</td><td>对应 <code>@keyframes</code> 定义的名称（必须指定）</td><td>自定义名称（如 <code>fadeIn</code>、<code>slide</code>）</td></tr><tr><td>持续时间</td><td>动画完成一次的时间（必须指定，否则无效）</td><td><code>s</code>&#x2F;<code>ms</code>（如 <code>1s</code>）</td></tr><tr><td>时间函数</td><td>动画速度曲线</td><td>同 <code>transition</code>（<code>linear</code>、<code>ease</code> 等）</td></tr><tr><td>延迟时间</td><td>触发后延迟多久开始</td><td><code>s</code>&#x2F;<code>ms</code>（默认 <code>0s</code>）</td></tr><tr><td>循环次数</td><td>动画重复次数</td><td>数字（如 <code>3</code>） &#x2F; <code>infinite</code>（无限循环，常用）</td></tr><tr><td>方向</td><td>动画播放方向</td><td><code>normal</code>（默认：正向）、<code>reverse</code>（反向）、<code>alternate</code>（交替：正向→反向→正向…）、<code>alternate-reverse</code>（反向交替）</td></tr><tr><td>填充模式</td><td>动画结束后元素保留的状态</td><td><code>none</code>（默认：回到初始状态）、<code>forwards</code>（保留结束状态）、<code>backwards</code>（延迟期间显示第一帧）、<code>both</code>（同时应用 <code>forwards</code> 和 <code>backwards</code>）</td></tr><tr><td>播放状态</td><td>控制动画播放 &#x2F; 暂停</td><td><code>running</code>（默认：播放）、<code>paused</code>（暂停）</td></tr></tbody></table><h3 id="3-基础示例：加载动画（无限旋转）"><a href="#3-基础示例：加载动画（无限旋转）" class="headerlink" title="3. 基础示例：加载动画（无限旋转）"></a>3. 基础示例：加载动画（无限旋转）</h3><pre><code class="html">&lt;style&gt;  /* 定义关键帧：旋转 360 度 */  @keyframes spin &#123;    from &#123;      transform: rotate(0deg);    &#125;    to &#123;      transform: rotate(360deg);    &#125;  &#125;  .loader &#123;    width: 50px;    height: 50px;    border: 5px solid #eee;    border-top: 5px solid blue;    border-radius: 50%; /* 圆形 */    /* 应用动画：无限循环、匀速、1s 一圈 */    animation: spin 1s linear infinite;  &#125;&lt;/style&gt;&lt;div class=&quot;loader&quot;&gt;&lt;/div&gt;</code></pre><ul><li>效果：圆形持续旋转，实现经典加载动画。</li></ul><h3 id="4-多阶段动画示例：淡入-缩放"><a href="#4-多阶段动画示例：淡入-缩放" class="headerlink" title="4. 多阶段动画示例：淡入 + 缩放"></a>4. 多阶段动画示例：淡入 + 缩放</h3><pre><code class="html">&lt;style&gt;  /* 定义多阶段关键帧 */  @keyframes fadeInScale &#123;    0% &#123;      opacity: 0; /* 完全透明 */      transform: scale(0.5); /* 缩小 50% */    &#125;    70% &#123;      opacity: 1; /* 完全显示 */      transform: scale(1.2); /* 放大 20% */    &#125;    100% &#123;      transform: scale(1); /* 恢复原大小 */    &#125;  &#125;  .box &#123;    width: 100px;    height: 100px;    background: red;    /* 应用动画：持续 1.5s，先慢后快，保留结束状态 */    animation: fadeInScale 1.5s ease forwards;  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><ul><li>效果：元素从透明缩小状态，逐渐淡入并放大，最后恢复原大小并保持。</li></ul><h3 id="5-动画控制：暂停-播放、反向"><a href="#5-动画控制：暂停-播放、反向" class="headerlink" title="5. 动画控制：暂停 &#x2F; 播放、反向"></a>5. 动画控制：暂停 &#x2F; 播放、反向</h3><pre><code class="html">&lt;style&gt;  @keyframes move &#123;    0% &#123; transform: translateX(0); &#125;    100% &#123; transform: translateX(300px); &#125;  &#125;  .box &#123;    width: 100px;    height: 100px;    background: green;    animation: move 3s linear infinite alternate; /* 交替方向循环 */  &#125;  .box:hover &#123;    animation-play-state: paused; /* 鼠标悬浮暂停动画 */  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><ul><li>效果：盒子左右往复移动，鼠标悬浮时暂停。</li></ul><h2 id="四、常用动画属性（transform、opacity-等）"><a href="#四、常用动画属性（transform、opacity-等）" class="headerlink" title="四、常用动画属性（transform、opacity 等）"></a>四、常用动画属性（transform、opacity 等）</h2><p>CSS 动画通常配合 “可过渡的 CSS 属性” 使用，核心属性如下：</p><h3 id="1-transform：元素变换（无布局偏移）"><a href="#1-transform：元素变换（无布局偏移）" class="headerlink" title="1. transform：元素变换（无布局偏移）"></a>1. transform：元素变换（无布局偏移）</h3><p><code>transform</code> 用于对元素进行旋转、缩放、位移、倾斜等变换，<strong>不会影响其他元素布局</strong>（性能最优），是动画核心属性。</p><h4 id="常用变换函数"><a href="#常用变换函数" class="headerlink" title="常用变换函数"></a>常用变换函数</h4><table><thead><tr><th>函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>translateX(n)</code></td><td>水平位移（<code>n</code> 为 <code>px</code> 或百分比）</td><td><code>translateX(50px)</code>（向右移 50px）</td></tr><tr><td><code>translateY(n)</code></td><td>垂直位移</td><td><code>translateY(-20px)</code>（向上移 20px）</td></tr><tr><td><code>translate(n,m)</code></td><td>水平 + 垂直位移</td><td><code>translate(30px, 40px)</code></td></tr><tr><td><code>scale(n)</code></td><td>缩放（<code>n=1</code> 原大小，<code>n&gt;1</code> 放大）</td><td><code>scale(1.5)</code>（放大 1.5 倍）</td></tr><tr><td><code>scaleX(n)</code>&#x2F;<code>scaleY(n)</code></td><td>水平 &#x2F; 垂直单独缩放</td><td><code>scaleX(2)</code>（水平放大 2 倍）</td></tr><tr><td><code>rotate(ndeg)</code></td><td>旋转（<code>n</code> 为角度，正顺时针，负逆时针）</td><td><code>rotate(45deg)</code>（顺时针转 45 度）</td></tr><tr><td><code>skewX(ndeg)</code>&#x2F;<code>skewY(ndeg)</code></td><td>水平 &#x2F; 垂直倾斜</td><td><code>skewX(10deg)</code>（水平倾斜 10 度）</td></tr></tbody></table><p>示例：组合变换（位移 + 旋转 + 缩放）</p><pre><code class="css">.box &#123;  transform: translateX(50px) rotate(30deg) scale(1.2);&#125;</code></pre><h3 id="2-opacity：透明度（无布局偏移）"><a href="#2-opacity：透明度（无布局偏移）" class="headerlink" title="2. opacity：透明度（无布局偏移）"></a>2. opacity：透明度（无布局偏移）</h3><p>控制元素透明度（<code>0</code> 完全透明，<code>1</code> 完全不透明），适合淡入淡出效果，性能优异。</p><p>示例：淡入动画</p><pre><code class="css">@keyframes fadeIn &#123;  from &#123; opacity: 0; &#125;  to &#123; opacity: 1; &#125;&#125;</code></pre><h3 id="3-其他可动画属性（可能触发布局重绘）"><a href="#3-其他可动画属性（可能触发布局重绘）" class="headerlink" title="3. 其他可动画属性（可能触发布局重绘）"></a>3. 其他可动画属性（可能触发布局重绘）</h3><p>以下属性也支持动画，但会改变元素布局（触发浏览器重绘 &#x2F; 回流，性能略差），尽量少用：</p><ul><li>尺寸类：<code>width</code>、<code>height</code>、<code>padding</code>、<code>margin</code>；</li><li>位置类：<code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>（需配合定位）；</li><li>颜色类：<code>background</code>、<code>color</code>、<code>border-color</code>；</li><li>其他：<code>border-radius</code>、<code>box-shadow</code>。</li></ul><blockquote><p>性能优化建议：优先使用 <code>transform</code> + <code>opacity</code> 实现动画（浏览器可通过 GPU 加速，避免重绘回流）。</p></blockquote><h2 id="五、动画的性能优化"><a href="#五、动画的性能优化" class="headerlink" title="五、动画的性能优化"></a>五、动画的性能优化</h2><h3 id="1-优先使用-GPU-加速属性"><a href="#1-优先使用-GPU-加速属性" class="headerlink" title="1. 优先使用 GPU 加速属性"></a>1. 优先使用 GPU 加速属性</h3><ul><li>推荐：<code>transform</code>、<code>opacity</code>（这两个属性不会触发布局重绘，仅触发合成层更新）；</li><li>避免：<code>width</code>、<code>height</code>、<code>top</code>、<code>left</code> 等会改变布局的属性。</li></ul><h3 id="2-减少动画元素数量"><a href="#2-减少动画元素数量" class="headerlink" title="2. 减少动画元素数量"></a>2. 减少动画元素数量</h3><p>过多同时运行的动画会占用大量 GPU 资源，导致卡顿，尽量精简动画元素。</p><h3 id="3-避免过度使用-animation-all"><a href="#3-避免过度使用-animation-all" class="headerlink" title="3. 避免过度使用 animation: all"></a>3. 避免过度使用 <code>animation: all</code></h3><p><code>all</code> 会让所有属性参与过渡，可能包含无需动画的属性，增加浏览器计算压力，建议明确指定动画属性。</p><h3 id="4-合理设置-will-change（提前告知浏览器）"><a href="#4-合理设置-will-change（提前告知浏览器）" class="headerlink" title="4. 合理设置 will-change（提前告知浏览器）"></a>4. 合理设置 <code>will-change</code>（提前告知浏览器）</h3><p>给即将动画的元素添加 <code>will-change</code>，让浏览器提前准备优化（如分配 GPU 资源），避免动画启动时卡顿：</p><pre><code class="css">.box &#123;  will-change: transform, opacity; /* 告知浏览器即将动画这两个属性 */&#125;</code></pre><ul><li>注意：不要滥用 <code>will-change</code>（如给所有元素添加），否则会占用额外资源。</li></ul><h3 id="5-控制动画持续时间和帧率"><a href="#5-控制动画持续时间和帧率" class="headerlink" title="5. 控制动画持续时间和帧率"></a>5. 控制动画持续时间和帧率</h3><ul><li>持续时间建议在 <code>0.3s~0.6s</code> 之间（过短生硬，过长拖沓）；</li><li>浏览器默认帧率 60fps（每帧约 16.7ms），确保动画每帧计算时间不超过 16.7ms。</li></ul><h2 id="六、动画的常见问题与解决方案"><a href="#六、动画的常见问题与解决方案" class="headerlink" title="六、动画的常见问题与解决方案"></a>六、动画的常见问题与解决方案</h2><h3 id="1-动画结束后回到初始状态"><a href="#1-动画结束后回到初始状态" class="headerlink" title="1. 动画结束后回到初始状态"></a>1. 动画结束后回到初始状态</h3><p>问题：<code>animation</code>默认动画结束后回到初始状态，无法保留结束样式。解决方案：设置<code>animation-fill-mode: forwards</code></p><pre><code class="css">.box &#123;  animation: fadeIn 1s forwards; /* 保留结束状态 */&#125;</code></pre><h3 id="2-动画触发时的-“闪烁”"><a href="#2-动画触发时的-“闪烁”" class="headerlink" title="2. 动画触发时的 “闪烁”"></a>2. 动画触发时的 “闪烁”</h3><p>问题：动画开始前元素可能出现瞬间闪烁（尤其  </p><p>解决方案：</p><ul><li>给元素初始状态添加 <code>opacity: 0</code>（避免初始显示）；</li><li>配合 <code>animation-fill-mode: backwards</code>（延迟期间显示第一帧）：</li></ul><pre><code class="css">.box &#123;  opacity: 0; /* 初始透明 */  animation: fadeIn 1s forwards backwards;&#125;</code></pre><h3 id="3-transform-动画抖动"><a href="#3-transform-动画抖动" class="headerlink" title="3. transform 动画抖动"></a>3. transform 动画抖动</h3><p>问题：元素用 </p><p>解决方案：给动画元素添加  ，避免 GPU 渲染时的 “像素对齐问题”：</p><pre><code class="css">.box &#123;  backface-visibility: hidden;  perspective: 1000px;&#125;</code></pre><h3 id="4-多动画冲突"><a href="#4-多动画冲突" class="headerlink" title="4. 多动画冲突"></a>4. 多动画冲突</h3><p>问题：给同一元素添加多个 </p><p>解决方案：</p><ul><li>合并关键帧（将多个动画逻辑写在一个 <code>@keyframes</code> 中）；</li><li>用逗号分隔多个动画（确保不冲突）：</li></ul><pre><code class="css">.box &#123;  animation: fadeIn 1s, move 2s; /* 同时执行两个动画 */&#125;</code></pre><h2 id="七、过渡（transition）vs-关键帧（animation）：如何选择？"><a href="#七、过渡（transition）vs-关键帧（animation）：如何选择？" class="headerlink" title="七、过渡（transition）vs 关键帧（animation）：如何选择？"></a>七、过渡（transition）vs 关键帧（animation）：如何选择？</h2><table><thead><tr><th>特性</th><th>transition（过渡）</th><th>animation（关键帧）</th></tr></thead><tbody><tr><td>核心用途</td><td>简单状态切换（如 hover、点击）</td><td>复杂多阶段动画（如加载、循环、多步骤）</td></tr><tr><td>触发方式</td><td>需状态变化触发（被动）</td><td>自动触发（或 JS 控制），支持主动控制</td></tr><tr><td>阶段数</td><td>仅支持 “初始→目标” 两阶段</td><td>支持任意多阶段（百分比定义）</td></tr><tr><td>循环能力</td><td>不支持循环（需 JS 反复触发状态）</td><td>支持 <code>infinite</code> 无限循环、交替方向</td></tr><tr><td>控制灵活性</td><td>低（仅能控制过渡参数）</td><td>高（支持暂停、反向、填充模式等）</td></tr></tbody></table><h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ul><li>简单交互效果（如 hover 变色、缩放）→ 用 <code>transition</code>（简洁高效）；</li><li>复杂动画（如加载旋转、多步骤变换、循环动画）→ 用 <code>animation</code>（灵活强大）；</li><li>需 JS 控制播放 &#x2F; 暂停、循环次数 → 用 <code>animation</code>。</li></ul><h2 id="八、实战场景示例"><a href="#八、实战场景示例" class="headerlink" title="八、实战场景示例"></a>八、实战场景示例</h2><h3 id="1-导航栏-hover-效果（transition）"><a href="#1-导航栏-hover-效果（transition）" class="headerlink" title="1. 导航栏 hover 效果（transition）"></a>1. 导航栏 hover 效果（transition）</h3><pre><code class="css">.nav-item &#123;  color: #333;  padding: 10px 15px;  transition: color 0.3s, background 0.3s, transform 0.2s;&#125;.nav-item:hover &#123;  color: white;  background: #0066cc;  transform: translateY(-2px); /* 轻微上移，增强交互感 */&#125;</code></pre><h3 id="2-弹窗淡入弹出（animation）"><a href="#2-弹窗淡入弹出（animation）" class="headerlink" title="2. 弹窗淡入弹出（animation）"></a>2. 弹窗淡入弹出（animation）</h3><pre><code class="css">@keyframes modalFadeIn &#123;  0% &#123;    opacity: 0;    transform: scale(0.9) translateY(-20px);  &#125;  100% &#123;    opacity: 1;    transform: scale(1) translateY(0);  &#125;&#125;.modal &#123;  position: fixed;  top: 50%;  left: 50%;  transform: translate(-50%, -50%);  animation: modalFadeIn 0.4s ease forwards;  background: white;  padding: 30px;  border-radius: 8px;&#125;</code></pre><h3 id="3-滚动触发动画（JS-animation）"><a href="#3-滚动触发动画（JS-animation）" class="headerlink" title="3. 滚动触发动画（JS + animation）"></a>3. 滚动触发动画（JS + animation）</h3><pre><code class="html">&lt;style&gt;  @keyframes slideUp &#123;    from &#123;      opacity: 0;      transform: translateY(50px);    &#125;    to &#123;      opacity: 1;      transform: translateY(0);    &#125;  &#125;  .animate-on-scroll &#123;    opacity: 0; /* 初始透明 */  &#125;  .animate-on-scroll.active &#123;    animation: slideUp 0.6s ease forwards;  &#125;&lt;/style&gt;&lt;div class=&quot;animate-on-scroll&quot;&gt;滚动到此处时触发动画&lt;/div&gt;&lt;script&gt;  // 监听滚动事件  window.addEventListener(&#39;scroll&#39;, () =&gt; &#123;    const elements = document.querySelectorAll(&#39;.animate-on-scroll&#39;);    elements.forEach(el =&gt; &#123;      // 计算元素是否进入视口      const rect = el.getBoundingClientRect();      if (rect.top &lt; window.innerHeight - 100) &#123;        el.classList.add(&#39;active&#39;); // 触发动画      &#125;    &#125;);  &#125;);&lt;/script&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSS 动画是通过 CSS 属性控制元素从一种样式状态平滑过渡到另一种状态的技术，无需 JavaScript 即可实现丰富的视觉效果（如渐变、旋转、缩放、位移等）。核心分为 &lt;strong&gt;过渡动画（&lt;code&gt;transition&lt;/code&gt;）&lt;/strong&gt; 和 &lt;strong&gt;关键帧动画（&lt;code&gt;animation&lt;/code&gt;）&lt;/strong&gt; 两大类，前者适合简单的 “状态切换”，后者适合复杂的 “多阶段动画”。本文将从基础概念、用法、特性、实战场景及优化全面解析。&lt;/p&gt;</summary>
    
    
    
    
    <category term="web前端" scheme="http://example.com/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSS_定位</title>
    <link href="http://example.com/2025/11/11/CSS-%E5%AE%9A%E4%BD%8D/"/>
    <id>http://example.com/2025/11/11/CSS-%E5%AE%9A%E4%BD%8D/</id>
    <published>2025-11-11T14:02:53.000Z</published>
    <updated>2025-11-11T14:24:05.265Z</updated>
    
    <content type="html"><![CDATA[<p>定位（<code>position</code>）是 CSS 中控制元素<strong>精确位置</strong>的核心属性，通过改变元素在页面中的布局规则（脱离标准文档流或保留文档流位置），实现浮动无法完成的复杂布局（如固定导航、弹窗、元素叠加等）。本文将从核心概念、属性值、定位规则、应用场景及常见问题全面解析。</p><span id="more"></span><h1 id="CSS-定位"><a href="#CSS-定位" class="headerlink" title="CSS 定位"></a>CSS 定位</h1><h2 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h2><h3 id="1-定位的本质"><a href="#1-定位的本质" class="headerlink" title="1. 定位的本质"></a>1. 定位的本质</h3><p>定位通过 <code>position</code> 属性定义元素的 “定位类型”，再通过 <code>top</code>&#x2F;<code>bottom</code>&#x2F;<code>left</code>&#x2F;<code>right</code>（偏移属性）控制元素的具体位置，同时可能影响元素与其他元素的层叠关系（<code>z-index</code>）。</p><h3 id="2-关键术语"><a href="#2-关键术语" class="headerlink" title="2. 关键术语"></a>2. 关键术语</h3><ul><li><strong>标准文档流</strong>：元素默认排列规则（块级独占一行、行内横向排列），定位会改变元素在文档流中的行为；</li><li><strong>包含块</strong>：定位元素的 “参考容器”，偏移属性（<code>top</code>&#x2F;<code>left</code> 等）基于包含块计算，默认是最近的已定位祖先元素，若无则为根元素（&#96;&#96;）；</li><li><strong>偏移属性</strong>：<code>top</code>（上偏移）、<code>bottom</code>（下偏移）、<code>left</code>（左偏移）、<code>right</code>（右偏移），仅对非 <code>static</code> 定位的元素有效；</li><li><strong>z-index</strong>：控制定位元素的层叠顺序（数值越大越靠上），仅对非 <code>static</code> 定位的元素有效。</li></ul><h2 id="二、position-的-5-个属性值"><a href="#二、position-的-5-个属性值" class="headerlink" title="二、position 的 5 个属性值"></a>二、position 的 5 个属性值</h2><p><code>position</code> 的取值决定了元素的定位规则，共 5 种类型，核心差异在于 “是否脱离文档流” 和 “参考容器是谁”：</p><table><thead><tr><th>定位类型</th><th>是否脱离文档流</th><th>参考容器（包含块）</th><th>核心特点</th><th>典型场景</th></tr></thead><tbody><tr><td><code>static</code>（默认）</td><td>否</td><td>无（遵循标准流）</td><td>无法使用偏移属性和 <code>z-index</code>，元素正常排列</td><td>默认布局，无需特殊定位</td></tr><tr><td><code>relative</code>（相对）</td><td>否（保留位置）</td><td>自身在标准流中的原始位置</td><td>偏移后不影响其他元素，仍占据原文档流空间</td><td>微调元素位置、作为绝对定位的父容器</td></tr><tr><td><code>absolute</code>（绝对）</td><td>是</td><td>最近的非 <code>static</code> 定位祖先元素</td><td>脱离文档流，不占据原位置，可叠加、精确布局</td><td>弹窗、下拉菜单、元素叠加</td></tr><tr><td><code>fixed</code>（固定）</td><td>是</td><td>浏览器视口（viewport）</td><td>脱离文档流，位置不随滚动条滚动</td><td>固定导航、回到顶部按钮、弹窗遮罩</td></tr><tr><td><code>sticky</code>（粘性）</td><td>半脱离（滚动时）</td><td>父元素（滚动容器）</td><td>滚动前遵循标准流，滚动到阈值后固定在视口</td><td>粘性导航、列表标题吸顶</td></tr></tbody></table><h2 id="三、逐个解析定位类型"><a href="#三、逐个解析定位类型" class="headerlink" title="三、逐个解析定位类型"></a>三、逐个解析定位类型</h2><h3 id="1-static：默认定位（无定位）"><a href="#1-static：默认定位（无定位）" class="headerlink" title="1. static：默认定位（无定位）"></a>1. static：默认定位（无定位）</h3><p><code>static</code> 是所有元素的默认定位类型，元素遵循标准文档流，**无法使用 <code>top</code>&#x2F;<code>left</code>&#x2F;<code>z-index</code>**，任何偏移设置都会被忽略。</p><pre><code class="css">.box &#123;  position: static; /* 默认值，可省略 */  left: 50px; /* 无效，元素仍在标准流位置 */&#125;</code></pre><h3 id="2-relative：相对定位"><a href="#2-relative：相对定位" class="headerlink" title="2. relative：相对定位"></a>2. relative：相对定位</h3><p>相对定位是 “相对于自身原始位置” 的定位，<strong>不脱离标准文档流</strong>，仅视觉上偏移，原位置仍被保留（其他元素不会填充）。</p><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li>偏移属性（<code>top</code>&#x2F;<code>left</code> 等）基于自身原始位置计算（例：<code>left: 20px</code> 表示向右偏移 20px）；</li><li>不影响其他元素的布局，仅自身视觉偏移；</li><li>常作为 <code>absolute</code> 定位的 “包含块”（父元素设为 <code>relative</code>，子元素设为 <code>absolute</code>）。</li></ul><h4 id="示例：微调元素位置"><a href="#示例：微调元素位置" class="headerlink" title="示例：微调元素位置"></a>示例：微调元素位置</h4><pre><code class="html">&lt;style&gt;  .box &#123;    position: relative;    left: 30px; /* 相对于原始位置向右偏移 30px */    top: -10px; /* 相对于原始位置向上偏移 10px（负值向上） */    width: 100px;    height: 100px;    background: red;  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;相对定位元素&lt;/div&gt;&lt;p&gt;其他元素不会填充.box的原始位置（因为.box仍在文档流中）&lt;/p&gt;</code></pre><h4 id="示例：作为绝对定位的父容器（关键用法）"><a href="#示例：作为绝对定位的父容器（关键用法）" class="headerlink" title="示例：作为绝对定位的父容器（关键用法）"></a>示例：作为绝对定位的父容器（关键用法）</h4><pre><code class="html">&lt;style&gt;  .parent &#123;    position: relative; /* 父元素设为 relative，成为包含块 */    width: 300px;    height: 300px;    background: #eee;  &#125;  .child &#123;    position: absolute;    top: 20px; /* 相对于父元素顶部偏移 20px */    right: 20px; /* 相对于父元素右侧偏移 20px */    width: 100px;    height: 100px;    background: blue;  &#125;&lt;/style&gt;&lt;div class=&quot;parent&quot;&gt;  父容器（relative）  &lt;div class=&quot;child&quot;&gt;绝对定位子元素&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>若父元素不设 <code>relative</code>，子元素的 <code>absolute</code> 会向上查找，最终以 &#96;&#96; 为参考容器（视口左上角）。</li></ul><h3 id="3-absolute：绝对定位"><a href="#3-absolute：绝对定位" class="headerlink" title="3. absolute：绝对定位"></a>3. absolute：绝对定位</h3><p>绝对定位是 “相对于包含块” 的定位，<strong>完全脱离标准文档流</strong>，不占据原位置（其他元素会填充其原始位置），可通过偏移属性精确控制位置。</p><h4 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li>脱离文档流，元素位置独立于其他元素；</li><li>包含块规则：优先找最近的 <code>relative</code>&#x2F;<code>absolute</code>&#x2F;<code>fixed</code>&#x2F;<code>sticky</code> 祖先元素，若无则以根元素（<code>&lt;html&gt;</code>）为参考；</li><li>行内元素设为 <code>absolute</code> 后，自动转为 “行内块级元素”（可设置宽高，不独占一行）；</li><li>若未设置偏移属性（<code>top</code>&#x2F;<code>left</code> 等），元素会默认停留在其原始文档流中的位置，但已脱离文档流（其他元素会覆盖它）。</li></ul><h4 id="示例：弹窗布局"><a href="#示例：弹窗布局" class="headerlink" title="示例：弹窗布局"></a>示例：弹窗布局</h4><pre><code class="html">&lt;style&gt;  .modal &#123;    position: absolute;    top: 50%; /* 相对于视口（无定位父元素）垂直居中 */    left: 50%; /* 水平居中 */    transform: translate(-50%, -50%); /* 修正居中（基于自身宽高） */    width: 200px;    height: 150px;    background: white;    border: 1px solid #ccc;    padding: 20px;    z-index: 100; /* 确保弹窗在最上层 */  &#125;  .overlay &#123;    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;    background: rgba(0,0,0,0.5); /* 半透明遮罩 */    z-index: 99; /* 遮罩在弹窗下方 */  &#125;&lt;/style&gt;&lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;&lt;div class=&quot;modal&quot;&gt;这是一个绝对定位的弹窗&lt;/div&gt;</code></pre><ul><li>注：<code>transform: translate(-50%, -50%)</code> 是实现绝对定位元素居中的常用技巧，无需知道元素自身宽高。</li></ul><h3 id="4-fixed：固定定位"><a href="#4-fixed：固定定位" class="headerlink" title="4. fixed：固定定位"></a>4. fixed：固定定位</h3><p>固定定位是 “相对于浏览器视口” 的定位，<strong>完全脱离文档流</strong>，位置不随滚动条滚动（始终固定在视口的某个位置）。</p><h4 id="核心特性-2"><a href="#核心特性-2" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li>参考容器是浏览器视口（无论页面如何滚动，元素位置不变）；</li><li>脱离文档流，不占据原位置；</li><li>常与 <code>top: 0</code>&#x2F;<code>bottom: 0</code>&#x2F;<code>left: 0</code>&#x2F;<code>right: 0</code> 配合实现 “全屏” 或 “固定边距” 效果。</li></ul><h4 id="示例：固定导航栏"><a href="#示例：固定导航栏" class="headerlink" title="示例：固定导航栏"></a>示例：固定导航栏</h4><pre><code class="html">&lt;style&gt;  .nav &#123;    position: fixed;    top: 0; /* 固定在视口顶部 */    left: 0;    right: 0; /* 左右贴边，宽度自适应 */    height: 60px;    background: #333;    color: white;    line-height: 60px;    padding: 0 20px;    z-index: 999; /* 确保导航在最上层，不被其他元素覆盖 */  &#125;  .content &#123;    margin-top: 80px; /* 避免内容被固定导航遮挡 */    height: 2000px; /* 模拟长页面滚动 */  &#125;&lt;/style&gt;&lt;nav class=&quot;nav&quot;&gt;固定导航栏（滚动不消失）&lt;/nav&gt;&lt;div class=&quot;content&quot;&gt;页面内容...&lt;/div&gt;</code></pre><h4 id="示例：回到顶部按钮"><a href="#示例：回到顶部按钮" class="headerlink" title="示例：回到顶部按钮"></a>示例：回到顶部按钮</h4><pre><code class="css">.back-to-top &#123;  position: fixed;  bottom: 30px; /* 距离视口底部 30px */  right: 30px; /* 距离视口右侧 30px */  width: 50px;  height: 50px;  background: #000;  color: white;  text-align: center;  line-height: 50px;  border-radius: 50%;  cursor: pointer;&#125;</code></pre><h3 id="5-sticky：粘性定位（CSS3-新增）"><a href="#5-sticky：粘性定位（CSS3-新增）" class="headerlink" title="5. sticky：粘性定位（CSS3 新增）"></a>5. sticky：粘性定位（CSS3 新增）</h3><p>粘性定位是 “相对定位 + 固定定位” 的混合体，<strong>滚动前遵循标准流，滚动到阈值后转为固定定位</strong>（相对于父滚动容器，而非视口）。</p><h4 id="核心特性-3"><a href="#核心特性-3" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li>未滚动到阈值时：表现如 <code>relative</code>，保留文档流位置；</li><li>滚动到阈值时：表现如 <code>fixed</code>，固定在父容器的指定位置（不随滚动继续移动）；</li><li>必须设置 <code>top</code>&#x2F;<code>bottom</code>&#x2F;<code>left</code>&#x2F;<code>right</code> 中的一个（阈值），否则无效；</li><li>父元素不能有 <code>overflow: hidden</code>&#x2F;<code>auto</code>&#x2F;<code>scroll</code>（除非父元素是滚动容器），否则会失效。</li></ul><h4 id="示例：粘性导航（列表标题吸顶）"><a href="#示例：粘性导航（列表标题吸顶）" class="headerlink" title="示例：粘性导航（列表标题吸顶）"></a>示例：粘性导航（列表标题吸顶）</h4><pre><code class="html">&lt;style&gt;  .list &#123;    width: 300px;    height: 300px;    overflow-y: auto; /* 父元素设为滚动容器 */    border: 1px solid #ccc;  &#125;  .list-title &#123;    position: sticky;    top: 0; /* 滚动到顶部时固定 */    background: #f0f0f0;    padding: 10px;    margin: 0;    border-bottom: 1px solid #ccc;  &#125;  .list-item &#123;    padding: 10px;  &#125;&lt;/style&gt;&lt;div class=&quot;list&quot;&gt;  &lt;h3 class=&quot;list-title&quot;&gt;列表标题（粘性吸顶）&lt;/h3&gt;  &lt;div class=&quot;list-item&quot;&gt;列表项 1&lt;/div&gt;  &lt;div class=&quot;list-item&quot;&gt;列表项 2&lt;/div&gt;  &lt;div class=&quot;list-item&quot;&gt;列表项 3&lt;/div&gt;  &lt;!-- 更多列表项... --&gt;&lt;/div&gt;</code></pre><ul><li>效果：滚动列表时，标题会固定在父容器顶部，直到列表滚动到底部（标题跟随父容器消失）。</li></ul><h2 id="四、z-index：层叠顺序控制"><a href="#四、z-index：层叠顺序控制" class="headerlink" title="四、z-index：层叠顺序控制"></a>四、z-index：层叠顺序控制</h2><p>当多个定位元素（非 <code>static</code>）重叠时，<code>z-index</code> 控制它们的层叠顺序，<strong>数值越大，元素越靠上</strong>。</p><h3 id="核心规则"><a href="#核心规则" class="headerlink" title="核心规则"></a>核心规则</h3><ol><li>仅对非 <code>static</code> 定位的元素有效（<code>relative</code>&#x2F;<code>absolute</code>&#x2F;<code>fixed</code>&#x2F;<code>sticky</code>）；</li><li>默认 <code>z-index: auto</code>（等价于 <code>z-index: 0</code>）；</li><li>若元素属于同一 “层叠上下文”，直接比较 <code>z-index</code> 数值（大的在上）；</li><li>若元素属于不同层叠上下文，先比较父级层叠上下文的 <code>z-index</code>（父级大的子元素在上）。</li></ol><h3 id="示例：层叠顺序"><a href="#示例：层叠顺序" class="headerlink" title="示例：层叠顺序"></a>示例：层叠顺序</h3><pre><code class="html">&lt;style&gt;  .box1 &#123;    position: absolute;    top: 20px;    left: 20px;    width: 100px;    height: 100px;    background: red;    z-index: 1; /* 层级 1 */  &#125;  .box2 &#123;    position: absolute;    top: 40px;    left: 40px;    width: 100px;    height: 100px;    background: blue;    z-index: 2; /* 层级 2，在 box1 上方 */  &#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;z-index: 1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;z-index: 2&lt;/div&gt;</code></pre><ul><li>效果：蓝色盒子（<code>z-index: 2</code>）覆盖在红色盒子（<code>z-index: 1</code>）上方。</li></ul><h3 id="注意：层叠上下文陷阱"><a href="#注意：层叠上下文陷阱" class="headerlink" title="注意：层叠上下文陷阱"></a>注意：层叠上下文陷阱</h3><p>若父元素设置了 <code>z-index</code>（非 <code>auto</code>），则子元素的 <code>z-index</code> 仅在父元素的层叠上下文中生效，无法超越父元素的层级。</p><pre><code class="css">.parent &#123;  position: relative;  z-index: 1; /* 父元素层级 1 */&#125;.child &#123;  position: absolute;  z-index: 999; /* 子元素层级再高，也无法超越父元素的层级 */&#125;.other &#123;  position: relative;  z-index: 2; /* 该元素会覆盖 parent 及其子元素 */&#125;</code></pre><h2 id="五、定位的常见问题与解决方案"><a href="#五、定位的常见问题与解决方案" class="headerlink" title="五、定位的常见问题与解决方案"></a>五、定位的常见问题与解决方案</h2><h3 id="1-绝对定位元素居中偏差"><a href="#1-绝对定位元素居中偏差" class="headerlink" title="1. 绝对定位元素居中偏差"></a>1. 绝对定位元素居中偏差</h3><p> 问题：用 <code>top: 50%; left: 50%;</code> 居中时，元素会以左上角为基准，导致视觉偏移。 </p><p> 解决方案：添加 <code>transform: translate(-50%, -50%);</code>（基于元素自身宽高修正）： </p><pre><code class="css">.centered &#123;  position: absolute;  top: 50%;  left: 50%;  transform: translate(-50%, -50%); /* 完美居中 */&#125;</code></pre><h3 id="2-固定定位元素被遮挡"><a href="#2-固定定位元素被遮挡" class="headerlink" title="2. 固定定位元素被遮挡"></a>2. 固定定位元素被遮挡</h3><p>问题：<code>fixed</code>元素被其他元素覆盖。解决方案：提高<code>z-index</code>数值（确保父元素没有设置更低的<code>z-index</code></p><pre><code class="css">.fixed-box &#123;  position: fixed;  z-index: 9999; /* 足够大的数值，确保在最上层 */&#125;</code></pre><h3 id="3-sticky-定位失效"><a href="#3-sticky-定位失效" class="headerlink" title="3. sticky 定位失效"></a>3. sticky 定位失效</h3><p>常见原因及解决：</p><ul><li>未设置 <code>top</code>&#x2F;<code>bottom</code>&#x2F;<code>left</code>&#x2F;<code>right</code> 阈值 → 补充设置（如 <code>top: 0</code>）；</li><li>父元素有 <code>overflow: hidden</code> → 移除父元素的 <code>overflow: hidden</code>（或让父元素成为滚动容器）；</li><li>父元素高度小于粘性元素高度 → 确保父元素高度足够滚动。</li></ul><h3 id="4-绝对定位元素超出包含块"><a href="#4-绝对定位元素超出包含块" class="headerlink" title="4. 绝对定位元素超出包含块"></a>4. 绝对定位元素超出包含块</h3><p>问题：绝对定位元素内容过长，超出父容器。</p><p>解决方案：给包含块设置 （显示滚动条）或<code>overflow: hidden</code></p><pre><code class="css">.parent &#123;  position: relative;  width: 300px;  height: 300px;  overflow: auto; /* 超出部分显示滚动条 */&#125;.child &#123;  position: absolute;  width: 400px; /* 超出父容器宽度 */&#125;</code></pre><h2 id="六、定位的适用场景与最佳实践"><a href="#六、定位的适用场景与最佳实践" class="headerlink" title="六、定位的适用场景与最佳实践"></a>六、定位的适用场景与最佳实践</h2><h3 id="1-适用场景"><a href="#1-适用场景" class="headerlink" title="1. 适用场景"></a>1. 适用场景</h3><ul><li><code>relative</code>：微调元素位置、作为绝对定位的父容器；</li><li><code>absolute</code>：弹窗、下拉菜单、元素叠加、精确布局（如图标在按钮右上角）；</li><li><code>fixed</code>：固定导航、回到顶部按钮、弹窗遮罩、悬浮广告；</li><li><code>sticky</code>：粘性导航、列表标题吸顶、滚动时固定的筛选栏。</li></ul><h3 id="2-最佳实践"><a href="#2-最佳实践" class="headerlink" title="2. 最佳实践"></a>2. 最佳实践</h3><ul><li>尽量用 <code>relative</code> 作为 <code>absolute</code> 的父容器，避免绝对定位元素参考根元素（难以维护）；</li><li>固定定位元素需注意 <code>z-index</code>，避免被其他元素遮挡；</li><li>粘性定位需测试父容器的滚动行为，避免失效；</li><li>避免过度使用定位（尤其是 <code>absolute</code>），复杂布局优先用 Flex&#x2F;Grid（更简洁、易维护）。</li></ul><h2 id="七、定位与浮动、Flex-Grid-的区别"><a href="#七、定位与浮动、Flex-Grid-的区别" class="headerlink" title="七、定位与浮动、Flex&#x2F;Grid 的区别"></a>七、定位与浮动、Flex&#x2F;Grid 的区别</h2><table><thead><tr><th>布局方式</th><th>核心用途</th><th>脱离文档流</th><th>灵活性</th></tr></thead><tbody><tr><td>浮动</td><td>文字环绕、简单水平排列</td><td>是（半脱离）</td><td>低（仅水平方向）</td></tr><tr><td>定位</td><td>精确布局、元素叠加、固定</td><td>部分 &#x2F; 完全</td><td>高（任意方向控制）</td></tr><tr><td>Flex</td><td>一维布局（横向 &#x2F; 纵向）</td><td>否</td><td>中高（对齐、均分方便）</td></tr><tr><td>Grid</td><td>二维布局（行列控制）</td><td>否</td><td>最高（复杂布局高效）</td></tr></tbody></table><ul><li>简单水平排列 → 用 Flex；</li><li>复杂行列布局 → 用 Grid；</li><li>文字环绕 → 用浮动；</li><li>精确位置、固定 &#x2F; 悬浮元素 → 用定位。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;定位（&lt;code&gt;position&lt;/code&gt;）是 CSS 中控制元素&lt;strong&gt;精确位置&lt;/strong&gt;的核心属性，通过改变元素在页面中的布局规则（脱离标准文档流或保留文档流位置），实现浮动无法完成的复杂布局（如固定导航、弹窗、元素叠加等）。本文将从核心概念、属性值、定位规则、应用场景及常见问题全面解析。&lt;/p&gt;</summary>
    
    
    
    
    <category term="web前端" scheme="http://example.com/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSS_浮动</title>
    <link href="http://example.com/2025/11/11/CSS-%E6%B5%AE%E5%8A%A8/"/>
    <id>http://example.com/2025/11/11/CSS-%E6%B5%AE%E5%8A%A8/</id>
    <published>2025-11-11T13:03:46.000Z</published>
    <updated>2025-11-11T13:12:53.352Z</updated>
    
    <content type="html"><![CDATA[<p>浮动（<code>float</code>）是 CSS 中用于<strong>实现元素水平排列、文字环绕</strong>的核心属性，曾是网页布局的基础（如多列布局），虽如今被 Flex&#x2F;Grid 替代，但在文字环绕、局部布局等场景仍广泛使用。本文将从核心概念、用法、特性、问题及解决方案全面解析。</p><span id="more"></span><h1 id="CSS-浮动（float）详解"><a href="#CSS-浮动（float）详解" class="headerlink" title="CSS 浮动（float）详解"></a>CSS 浮动（float）详解</h1><h2 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h2><p>浮动的本质是：<strong>让元素 “脱离标准文档流”，并向左 &#x2F; 向右浮动，直到碰到父元素边界或其他浮动元素</strong>。</p><ul><li>标准文档流：元素默认的排列规则（块级元素独占一行、行内元素横向排列）。</li><li>浮动后元素特性：<ol><li>脱离文档流，但<strong>不脱离文本流</strong>（文字会环绕浮动元素）；</li><li>块级元素、行内元素浮动后，都会自动转为 “行内块级元素”（可设置宽高，且不独占一行）；</li><li>浮动元素的父元素若未特殊处理，会 “塌陷”（高度为 0）。</li></ol></li></ul><h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><pre><code class="css">float: none | left | right | inherit;</code></pre><ul><li><code>none</code>：默认值，不浮动（遵循标准文档流）；</li><li><code>left</code>：元素向左浮动；</li><li><code>right</code>：元素向右浮动；</li><li><code>inherit</code>：继承父元素的 <code>float</code> 属性（极少用）。</li></ul><h3 id="2-基础示例"><a href="#2-基础示例" class="headerlink" title="2. 基础示例"></a>2. 基础示例</h3><h4 id="（1）文字环绕图片（最经典场景）"><a href="#（1）文字环绕图片（最经典场景）" class="headerlink" title="（1）文字环绕图片（最经典场景）"></a>（1）文字环绕图片（最经典场景）</h4><pre><code class="html">&lt;style&gt;  .img-float &#123;    float: left; /* 图片向左浮动 */    width: 150px;    margin-right: 15px; /* 与文字间距 */  &#125;&lt;/style&gt;&lt;div&gt;  &lt;img src=&quot;image.jpg&quot; class=&quot;img-float&quot; alt=&quot;示例图&quot;&gt;  &lt;p&gt;这是一段环绕图片的文字... 文字会自动避开浮动的图片，形成自然的环绕效果，常用于文章配图场景。&lt;/p&gt;&lt;/div&gt;</code></pre><h4 id="（2）多元素水平排列（早期布局方式）"><a href="#（2）多元素水平排列（早期布局方式）" class="headerlink" title="（2）多元素水平排列（早期布局方式）"></a>（2）多元素水平排列（早期布局方式）</h4><pre><code class="html">&lt;style&gt;  .box &#123;    float: left; /* 三个盒子均向左浮动 */    width: 30%;    height: 100px;    margin: 0 1.5%;    background: #f0f0f0;  &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;盒子3&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>效果：三个盒子横向排列（需确保总宽度 ≤ 父容器宽度，避免换行）。</li></ul><h2 id="三、浮动的关键特性"><a href="#三、浮动的关键特性" class="headerlink" title="三、浮动的关键特性"></a>三、浮动的关键特性</h2><h3 id="1-脱离标准文档流，但不脱离文本流"><a href="#1-脱离标准文档流，但不脱离文本流" class="headerlink" title="1. 脱离标准文档流，但不脱离文本流"></a>1. 脱离标准文档流，但不脱离文本流</h3><ul><li>脱离文档流：浮动元素不再占据原文档流的位置，后续的标准流元素会 “向上顶”（覆盖浮动元素的位置）；</li><li>不脱离文本流：后续的文字 &#x2F; 行内元素会自动环绕浮动元素，不会被覆盖。</li></ul><p>示例对比：</p><pre><code class="html">&lt;style&gt;  .float-box &#123;    float: left;    width: 100px;    height: 100px;    background: red;  &#125;  .normal-box &#123;    width: 200px;    height: 200px;    background: #ccc; /* 灰色盒子会向上顶，但文字会环绕红色浮动盒 */  &#125;&lt;/style&gt;&lt;div class=&quot;float-box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;normal-box&quot;&gt;我是标准流盒子的文字，会环绕浮动元素&lt;/div&gt;</code></pre><h3 id="2-浮动元素的-“包裹性”"><a href="#2-浮动元素的-“包裹性”" class="headerlink" title="2. 浮动元素的 “包裹性”"></a>2. 浮动元素的 “包裹性”</h3><p>浮动元素的宽度默认由<strong>内容决定</strong>（类似 <code>inline-block</code>），而非占满父容器（块级元素默认行为）。</p><p>示例：</p><pre><code class="css">.float-box &#123;  float: left;  background: blue;  color: white;&#125;</code></pre><pre><code class="html">&lt;div class=&quot;float-box&quot;&gt;我是浮动元素，宽度由内容决定&lt;/div&gt;</code></pre><ul><li>效果：元素宽度仅包裹内容，而非占满父容器。</li></ul><h3 id="3-浮动元素的-“堆叠”-规则"><a href="#3-浮动元素的-“堆叠”-规则" class="headerlink" title="3. 浮动元素的 “堆叠” 规则"></a>3. 浮动元素的 “堆叠” 规则</h3><p>多个浮动元素会按浮动方向依次排列，不会重叠：</p><ul><li>左浮动：元素从左到右依次排列，超出父容器则换行；</li><li>右浮动：元素从右到左依次排列。</li></ul><pre><code class="css">.box &#123;  float: left;  width: 100px;  height: 100px;  margin: 10px;  background: green;&#125;</code></pre><pre><code class="html">&lt;div class=&quot;box&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;3&lt;/div&gt;</code></pre><ul><li>效果：三个盒子从左到右排列，间距由 <code>margin</code> 控制。</li></ul><h2 id="四、浮动的核心问题：父元素塌陷"><a href="#四、浮动的核心问题：父元素塌陷" class="headerlink" title="四、浮动的核心问题：父元素塌陷"></a>四、浮动的核心问题：父元素塌陷</h2><h3 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1. 问题现象"></a>1. 问题现象</h3><p>当父元素的所有子元素都是浮动元素时，父元素会失去高度（高度为 0），导致页面布局错乱。</p><p>示例：</p><pre><code class="html">&lt;style&gt;  .parent &#123;    border: 2px solid #000; /* 父元素边框 */  &#125;  .child &#123;    float: left;    width: 100px;    height: 100px;    background: yellow;  &#125;&lt;/style&gt;&lt;div class=&quot;parent&quot;&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>效果：父元素的边框仅显示一条线（高度为 0），子元素 “溢出” 父容器。</li></ul><h3 id="2-解决方案（清除浮动）"><a href="#2-解决方案（清除浮动）" class="headerlink" title="2. 解决方案（清除浮动）"></a>2. 解决方案（清除浮动）</h3><p>清除浮动的核心是：<strong>让父元素重新感知浮动子元素的高度</strong>，常用 4 种方法：</p><h4 id="（1）额外标签法（最简单，不推荐）"><a href="#（1）额外标签法（最简单，不推荐）" class="headerlink" title="（1）额外标签法（最简单，不推荐）"></a>（1）额外标签法（最简单，不推荐）</h4><p>在父元素末尾添加一个空的块级元素，设置 <code>clear: both</code>：</p><pre><code class="html">&lt;div class=&quot;parent&quot;&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;  &lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt; &lt;!-- 额外空标签 --&gt;&lt;/div&gt;</code></pre><ul><li>原理：<code>clear: both</code> 表示该元素不允许左右两侧有浮动元素，迫使父元素拉伸高度包裹子元素；</li><li>缺点：增加无意义 DOM 元素，影响代码整洁。</li></ul><h4 id="（2）父元素设置-overflow-hidden（简单，慎用）"><a href="#（2）父元素设置-overflow-hidden（简单，慎用）" class="headerlink" title="（2）父元素设置 overflow: hidden（简单，慎用）"></a>（2）父元素设置 <code>overflow: hidden</code>（简单，慎用）</h4><p>给父元素添加 <code>overflow: hidden</code> 或 <code>overflow: auto</code>：</p><pre><code class="css">.parent &#123;  border: 2px solid #000;  overflow: hidden; /* 触发 BFC，清除浮动 */&#125;</code></pre><ul><li><p>原理：<code>overflow: hidden</code> 会触发父元素的 <strong>BFC（块级格式化上下文）</strong>，BFC 元素会包裹所有子元素（包括浮动元素）；</p></li><li><p>缺点：若子元素有溢出（如下拉菜单、弹出层），会被父元素裁剪，适用于无溢出场景。</p></li><li><p>补充：<code>overflow</code></p><p>CSS样式<code>overflow</code>用于控制元素内容溢出时的处理方式。<code>overflow</code>属性有以下常见取值：</p><p><code>visible</code>：默认值，内容会溢出到元素框之外。<br><code>hidden</code>：内容会被裁剪，并且不可见。<br><code>scroll</code>：如果内容溢出，会显示滚动条。<br><code>auto</code>：如果内容溢出，会显示滚动条，只有在需要时才显示。<br><code>inherit</code>：继承父元素的overflow属性。</p></li></ul><h4 id="（3）父元素也浮动（不推荐）"><a href="#（3）父元素也浮动（不推荐）" class="headerlink" title="（3）父元素也浮动（不推荐）"></a>（3）父元素也浮动（不推荐）</h4><p>给父元素添加 <code>float: left/right</code>：</p><pre><code class="css">.parent &#123;  border: 2px solid #000;  float: left;  width: 100%; /* 需手动设置宽度，否则由内容决定 */&#125;</code></pre><ul><li>原理：浮动的父元素会自动包裹浮动子元素；</li><li>缺点：父元素浮动后会脱离文档流，可能导致后续元素布局错乱，需嵌套更多容器解决。</li></ul><h4 id="（4）伪元素清除法（推荐，无副作用）"><a href="#（4）伪元素清除法（推荐，无副作用）" class="headerlink" title="（4）伪元素清除法（推荐，无副作用）"></a>（4）伪元素清除法（推荐，无副作用）</h4><p>利用父元素的 <code>::after</code> 伪元素模拟 “额外标签”，不增加真实 DOM：</p><pre><code class="css">/* 通用清除浮动类 */.clearfix::after &#123;  content: &quot;&quot;; /* 伪元素必须有 content */  display: block; /* 转为块级元素 */  clear: both; /* 清除左右浮动 */  visibility: hidden; /* 隐藏伪元素 */  height: 0; /* 高度为 0，不占空间 */&#125;/* 兼容 IE6/7（已淘汰，可选） */.clearfix &#123;  *zoom: 1;&#125;</code></pre><p>使用时给父元素添加 <code>clearfix</code> 类：</p><pre><code class="html">&lt;div class=&quot;parent clearfix&quot;&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>优点：无额外 DOM、无副作用，兼容所有现代浏览器，是工业界标准方案。</li></ul><h2 id="五、clear-属性详解"><a href="#五、clear-属性详解" class="headerlink" title="五、clear 属性详解"></a>五、<code>clear</code> 属性详解</h2><p><code>clear</code> 用于控制元素是否允许周围有浮动元素，仅对<strong>块级元素</strong>有效。</p><h3 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1. 语法"></a>1. 语法</h3><pre><code class="css">clear: none | left | right | both;</code></pre><ul><li><code>none</code>：默认值，允许左右两侧有浮动元素；</li><li><code>left</code>：不允许左侧有浮动元素；</li><li><code>right</code>：不允许右侧有浮动元素；</li><li><code>both</code>：不允许左右两侧有浮动元素（最常用）。</li></ul><h3 id="2-示例：清除右侧浮动"><a href="#2-示例：清除右侧浮动" class="headerlink" title="2. 示例：清除右侧浮动"></a>2. 示例：清除右侧浮动</h3><pre><code class="html">&lt;style&gt;  .float-right &#123;    float: right;    width: 100px;    height: 100px;    background: purple;  &#125;  .clear-right &#123;    clear: right; /* 不允许右侧有浮动元素 */    background: #eee;  &#125;&lt;/style&gt;&lt;div class=&quot;float-right&quot;&gt;&lt;/div&gt;&lt;p class=&quot;clear-right&quot;&gt;这段文字不允许右侧有浮动元素，会自动换行到浮动元素下方。&lt;/p&gt;</code></pre><h2 id="六、浮动的适用场景与替代方案"><a href="#六、浮动的适用场景与替代方案" class="headerlink" title="六、浮动的适用场景与替代方案"></a>六、浮动的适用场景与替代方案</h2><h3 id="1-适用场景（现代开发仍常用）"><a href="#1-适用场景（现代开发仍常用）" class="headerlink" title="1. 适用场景（现代开发仍常用）"></a>1. 适用场景（现代开发仍常用）</h3><ul><li>文字环绕图片 &#x2F; 元素；</li><li>局部小布局（如导航栏按钮横向排列）；</li><li>兼容旧浏览器的简单布局。</li></ul><h3 id="2-替代方案（现代布局首选）"><a href="#2-替代方案（现代布局首选）" class="headerlink" title="2. 替代方案（现代布局首选）"></a>2. 替代方案（现代布局首选）</h3><p>如今浮动已不再是布局首选，以下方案更简洁、强大：</p><ul><li><strong>Flex 布局</strong>：适合一维布局（横向 &#x2F; 纵向排列），替代浮动实现多列布局、居中对齐等；</li><li><strong>Grid 布局</strong>：适合二维布局（行列同时控制），替代复杂的浮动嵌套布局；</li><li><strong>inline-block</strong>：适合简单横向排列（无父元素塌陷问题，但需处理缝隙）。</li></ul><p>示例：Flex 替代浮动实现多列布局</p><pre><code class="html">&lt;style&gt;  .container &#123;    display: flex; /* 父元素设为 Flex 容器 */    gap: 20px; /* 子元素间距（替代 margin） */  &#125;  .box &#123;    flex: 1; /* 子元素等分宽度 */    height: 100px;    background: #f0f0f0;  &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;盒子3&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>优点：无需清除浮动、自动适配、易于对齐，代码更简洁。</li></ul><h2 id="七、常见误区"><a href="#七、常见误区" class="headerlink" title="七、常见误区"></a>七、常见误区</h2><ol><li><p>浮动元素会被 <code>margin: auto</code> 居中？ </p><p>不会！<code>margin: auto</code>仅对标准流的块级元素有效，浮动元素需通过父容器<code>text-align: center</code>+ 自身<code>display: inline-block</code>实现居中（或直接用 Flex）。</p></li><li><p>浮动元素可以覆盖文字？</p><p>不能！浮动元素脱离文档流但不脱离文本流，文字会自动环绕，若想覆盖需用 （绝对定位）。</p></li><li><p>清除浮动后，浮动元素会回到标准流？</p><p>不会！清除浮动仅影响 “后续元素” 和 “父元素高度”，浮动元素本身仍脱离标准流。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;浮动（&lt;code&gt;float&lt;/code&gt;）是 CSS 中用于&lt;strong&gt;实现元素水平排列、文字环绕&lt;/strong&gt;的核心属性，曾是网页布局的基础（如多列布局），虽如今被 Flex&amp;#x2F;Grid 替代，但在文字环绕、局部布局等场景仍广泛使用。本文将从核心概念、用法、特性、问题及解决方案全面解析。&lt;/p&gt;</summary>
    
    
    
    
    <category term="web前端" scheme="http://example.com/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="http://example.com/2025/11/11/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2025/11/11/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</id>
    <published>2025-11-11T12:35:48.000Z</published>
    <updated>2025-11-11T12:40:53.601Z</updated>
    
    <content type="html"><![CDATA[<p>优先队列是一种<strong>特殊的队列数据结构</strong>，核心区别于普通队列的 “先进先出（FIFO）” 规则 —— 它按元素的<strong>优先级</strong>排序，每次出队时，总是取出优先级最高（或最低）的元素。无论是算法优化（如最短路径、排序）还是工程场景（如任务调度），优先队列都是解决 “动态选择最优元素” 问题的核心工具。</p><span id="more"></span><h1 id="优先队列（Priority-Queue）"><a href="#优先队列（Priority-Queue）" class="headerlink" title="优先队列（Priority Queue）"></a>优先队列（Priority Queue）</h1><h2 id="一、核心概念与核心特性"><a href="#一、核心概念与核心特性" class="headerlink" title="一、核心概念与核心特性"></a>一、核心概念与核心特性</h2><h3 id="1-与普通队列的本质区别"><a href="#1-与普通队列的本质区别" class="headerlink" title="1. 与普通队列的本质区别"></a>1. 与普通队列的本质区别</h3><table><thead><tr><th>特性</th><th>普通队列（FIFO）</th><th>优先队列</th></tr></thead><tbody><tr><td>排序依据</td><td>元素入队顺序</td><td>元素的优先级（自定义规则）</td></tr><tr><td>出队元素</td><td>最早入队的元素</td><td>优先级最高 &#x2F; 最低的元素</td></tr><tr><td>核心操作效率</td><td>入队 &#x2F; 出队均 O (1)</td><td>取决于实现（最优 O (logn)）</td></tr><tr><td>典型应用</td><td>消息队列、广度优先搜索（BFS）</td><td>最短路径、任务调度、堆排序</td></tr></tbody></table><h3 id="2-优先级的两种核心约定"><a href="#2-优先级的两种核心约定" class="headerlink" title="2. 优先级的两种核心约定"></a>2. 优先级的两种核心约定</h3><p>优先队列的优先级由 “关键值” 定义，最常用两种规则：</p><ul><li><strong>大顶堆（Max-Heap）</strong>：优先级最高 &#x3D; 关键值最大（默认优先出最大元素，如 “优先级 10&gt; 优先级 5”）；</li><li><strong>小顶堆（Min-Heap）</strong>：优先级最高 &#x3D; 关键值最小（默认优先出最小元素，如 “距离 1 &lt; 距离 3”）；</li><li>扩展：可自定义优先级（如任务 “截止时间早” 优先、订单 “加急标识” 优先）。</li></ul><h3 id="3-必须支持的核心操作"><a href="#3-必须支持的核心操作" class="headerlink" title="3. 必须支持的核心操作"></a>3. 必须支持的核心操作</h3><p>优先队列的价值在于 “高效动态维护最优元素”，标准核心操作如下：</p><table><thead><tr><th>操作名称</th><th>功能描述</th><th>目标时间复杂度</th></tr></thead><tbody><tr><td><code>insert(x)</code> &#x2F; <code>push(x)</code></td><td>向队列中插入元素 x，维持优先级排序</td><td>O(logn)</td></tr><tr><td><code>extract-max()</code> &#x2F; <code>extract-min()</code></td><td>取出并删除优先级最高的元素</td><td>O(logn)</td></tr><tr><td><code>peek()</code> &#x2F; <code>top()</code></td><td>查看（不删除）优先级最高的元素</td><td>O(1)</td></tr><tr><td><code>delete(x)</code></td><td>删除队列中指定元素 x（可选，按需实现）</td><td>O(logn)</td></tr><tr><td><code>update-priority(x)</code></td><td>修改元素 x 的优先级（可选，按需实现）</td><td>O(logn)</td></tr></tbody></table><h2 id="二、优先队列的三种实现方式（对比分析）"><a href="#二、优先队列的三种实现方式（对比分析）" class="headerlink" title="二、优先队列的三种实现方式（对比分析）"></a>二、优先队列的三种实现方式（对比分析）</h2><p>优先队列的效率核心是 “如何快速找到并维护最优元素”，三种常见实现各有优劣，<strong>堆实现是工业界标准</strong>：</p><h3 id="1-数组-链表（朴素实现）"><a href="#1-数组-链表（朴素实现）" class="headerlink" title="1. 数组 &#x2F; 链表（朴素实现）"></a>1. 数组 &#x2F; 链表（朴素实现）</h3><ul><li><strong>原理</strong>：元素直接存储在数组或链表中，插入时直接尾插（O (1)），取最优元素时遍历整个集合查找（O (n)）。</li><li>时间复杂度：<ul><li>插入：O (1)（无需排序，直接追加）；</li><li>取最优元素：O (n)（遍历所有元素找最值）；</li><li>删除最优元素：O (n)（查找后需移动元素填补空位）。</li></ul></li><li><strong>适用场景</strong>：元素数量极少（n &lt; 100），或插入操作远多于查询操作（几乎不用在实际开发）。</li></ul><h3 id="2-有序数组-有序链表（改进实现）"><a href="#2-有序数组-有序链表（改进实现）" class="headerlink" title="2. 有序数组 &#x2F; 有序链表（改进实现）"></a>2. 有序数组 &#x2F; 有序链表（改进实现）</h3><ul><li><strong>原理</strong>：插入时维持数组 &#x2F; 链表有序（按优先级排序），取最优元素时直接取表头 &#x2F; 表尾（O (1)）。</li><li>时间复杂度：<ul><li>插入：O (n)（需找到插入位置，移动后续元素）；</li><li>取最优元素：O (1)（有序结构的首尾即为最值）；</li><li>删除最优元素：O (1)（链表表头删除，数组仍需移动元素 O (n)）。</li></ul></li><li><strong>适用场景</strong>：查询操作远多于插入操作（仍不推荐，效率低于堆）。</li></ul><h3 id="3-堆（Heap）（最优实现）"><a href="#3-堆（Heap）（最优实现）" class="headerlink" title="3. 堆（Heap）（最优实现）"></a>3. 堆（Heap）（最优实现）</h3><p>堆是优先队列的<strong>标准实现方式</strong>，本质是一棵满足 “堆性质” 的<strong>完全二叉树</strong>（完全二叉树：除最后一层外，每一层节点数均满，最后一层从左到右连续排列）。</p><h4 id="堆的核心性质"><a href="#堆的核心性质" class="headerlink" title="堆的核心性质"></a>堆的核心性质</h4><ul><li>大顶堆：每个父节点的关键值 ≥ 左右子节点的关键值；</li><li>小顶堆：每个父节点的关键值 ≤ 左右子节点的关键值；</li><li>存储优势：完全二叉树可通过<strong>数组</strong>高效存储（无需指针，通过索引计算父子关系），空间开销极小。</li></ul><h4 id="数组与堆的索引映射（核心！）"><a href="#数组与堆的索引映射（核心！）" class="headerlink" title="数组与堆的索引映射（核心！）"></a>数组与堆的索引映射（核心！）</h4><p>假设数组索引从 0 开始，对于任意节点 i：</p><ul><li>左子节点索引 &#x3D; <code>2i + 1</code></li><li>右子节点索引 &#x3D; <code>2i + 2</code></li><li>父节点索引 &#x3D; <code>(i - 1) // 2</code>（整数除法）</li></ul><p>例：索引 0（根节点）的左子节点是 1，右子节点是 2；索引 3 的父节点是 (3-1)&#x2F;2 &#x3D; 1。</p><h4 id="堆的高效操作原理（核心！上浮与下沉）"><a href="#堆的高效操作原理（核心！上浮与下沉）" class="headerlink" title="堆的高效操作原理（核心！上浮与下沉）"></a>堆的高效操作原理（核心！上浮与下沉）</h4><p>堆的所有操作（插入、删除）都依赖两个核心调整动作，确保操作后仍满足堆性质，时间复杂度均为 O (logn)（树的高度为 logn）。</p><h5 id="（1）插入元素（insert-push）：上浮（sift-up）"><a href="#（1）插入元素（insert-push）：上浮（sift-up）" class="headerlink" title="（1）插入元素（insert&#x2F;push）：上浮（sift up）"></a>（1）插入元素（insert&#x2F;push）：上浮（sift up）</h5><ol><li>将新元素插入数组<strong>末尾</strong>（完全二叉树的最后一个位置，保证结构完整）；</li><li>执行 “上浮”：将新元素与父节点比较，若不满足堆性质（如大顶堆中子节点 &gt; 父节点），则交换父子节点；</li><li>重复步骤 2，直到元素到达根节点或满足堆性质。</li></ol><h5 id="（2）取出最优元素（extract-max-extract-min）：下沉（sift-down）"><a href="#（2）取出最优元素（extract-max-extract-min）：下沉（sift-down）" class="headerlink" title="（2）取出最优元素（extract-max&#x2F;extract-min）：下沉（sift down）"></a>（2）取出最优元素（extract-max&#x2F;extract-min）：下沉（sift down）</h5><ol><li>取出数组<strong>第一个元素</strong>（根节点，即最值）；</li><li>将数组<strong>末尾元素</strong>移到根节点位置（维持完全二叉树结构）；</li><li>执行 “下沉”：将当前节点与左右子节点中 “符合堆性质的最值子节点”（如大顶堆找最大子节点）比较，若不满足堆性质则交换；</li><li>重复步骤 3，直到元素到达叶子节点或满足堆性质。</li></ol><h5 id="（3）查看最优元素（top-peek）"><a href="#（3）查看最优元素（top-peek）" class="headerlink" title="（3）查看最优元素（top&#x2F;peek）"></a>（3）查看最优元素（top&#x2F;peek）</h5><p>直接返回数组第一个元素（根节点），O (1) 时间。</p><h4 id="堆实现的优势"><a href="#堆实现的优势" class="headerlink" title="堆实现的优势"></a>堆实现的优势</h4><ul><li>兼顾插入和查询效率：所有核心操作均为 O (logn)，是三种实现中综合性能最优的；</li><li>空间高效：数组存储，无额外指针开销；</li><li>实现简单：仅依赖 “上浮”“下沉” 两个核心函数，易工程化。</li></ul><h2 id="三、主流语言的优先队列使用（实战重点）"><a href="#三、主流语言的优先队列使用（实战重点）" class="headerlink" title="三、主流语言的优先队列使用（实战重点）"></a>三、主流语言的优先队列使用（实战重点）</h2><h3 id="C-标准库-priority-queue"><a href="#C-标准库-priority-queue" class="headerlink" title="C++ 标准库 priority_queue"></a>C++ 标准库 <code>priority_queue</code></h3><p>C++ 中 <code>priority_queue</code> 是<strong>容器适配器</strong>（定义在 &#96;&#96; 头文件），默认基于大顶堆实现，底层依赖 <code>vector</code> 存储。</p><h4 id="基本模板定义"><a href="#基本模板定义" class="headerlink" title="基本模板定义"></a>基本模板定义</h4><pre><code class="cpp">template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;T&gt;&gt;class priority_queue;</code></pre><ul><li><code>T</code>：元素类型（如 <code>int</code>、自定义结构体）；</li><li><code>Container</code>：底层存储容器（默认 <code>vector</code>，支持 <code>deque</code>）；</li><li><code>Compare</code>：比较函数（默认 <code>less</code> 大顶堆，<code>greater</code> 小顶堆）。</li></ul><h4 id="核心用法示例"><a href="#核心用法示例" class="headerlink" title="核心用法示例"></a>核心用法示例</h4><h5 id="（1）默认大顶堆（int-类型）"><a href="#（1）默认大顶堆（int-类型）" class="headerlink" title="（1）默认大顶堆（int 类型）"></a>（1）默认大顶堆（int 类型）</h5><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123;    priority_queue&lt;int&gt; max_heap;  // 大顶堆：大元素优先出队    // 插入元素    max_heap.push(3);    max_heap.push(1);    max_heap.push(5);    max_heap.push(2);    // 查看堆顶（最大值）    cout &lt;&lt; &quot;堆顶元素：&quot; &lt;&lt; max_heap.top() &lt;&lt; endl;  // 输出 5    // 出队（删除堆顶）    max_heap.pop();    cout &lt;&lt; &quot;出队后堆顶：&quot; &lt;&lt; max_heap.top() &lt;&lt; endl;  // 输出 3    // 遍历（需出队，遍历后队列空）    cout &lt;&lt; &quot;出队顺序：&quot;;    while (!max_heap.empty()) &#123;        cout &lt;&lt; max_heap.top() &lt;&lt; &quot; &quot;;        max_heap.pop();    &#125;  // 输出 3 2 1    return 0;&#125;</code></pre><h5 id="（2）小顶堆（用-greater）"><a href="#（2）小顶堆（用-greater）" class="headerlink" title="（2）小顶堆（用 greater）"></a>（2）小顶堆（用 <code>greater</code>）</h5><p>需包含 <code>&lt;functional&gt;</code> 头文件（<code>greater</code> 定义在此）：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;functional&gt;  // 包含 greater&lt;T&gt;using namespace std;int main() &#123;    // 小顶堆：小元素优先出队    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap;    min_heap.push(3);    min_heap.push(1);    min_heap.push(5);    min_heap.push(2);    cout &lt;&lt; &quot;堆顶元素：&quot; &lt;&lt; min_heap.top() &lt;&lt; endl;  // 输出 1    cout &lt;&lt; &quot;出队顺序：&quot;;    while (!min_heap.empty()) &#123;        cout &lt;&lt; min_heap.top() &lt;&lt; &quot; &quot;;        min_heap.pop();    &#125;  // 输出 1 2 3 5    return 0;&#125;</code></pre><h5 id="（3）自定义结构体（任务调度场景）"><a href="#（3）自定义结构体（任务调度场景）" class="headerlink" title="（3）自定义结构体（任务调度场景）"></a>（3）自定义结构体（任务调度场景）</h5><p>需重载 <code>operator&lt;</code> 或自定义比较结构体，定义优先级规则：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;// 自定义任务结构体：包含名称、优先级（10最高）、IDstruct Task &#123;    string name;    int priority;    int id;    // 重载 &lt; 运算符：定义大顶堆规则（优先级高的先执行，同优先级ID小的先执行）    bool operator&lt;(const Task&amp; other) const &#123;        if (priority != other.priority) &#123;            return priority &lt; other.priority;  // 优先级大的优先        &#125; else &#123;            return id &gt; other.id;  // ID小的优先        &#125;    &#125;&#125;;int main() &#123;    priority_queue&lt;Task&gt; task_queue;    // 插入任务    task_queue.push(&#123;&quot;紧急修复&quot;, 10, 101&#125;);    task_queue.push(&#123;&quot;功能开发&quot;, 8, 102&#125;);    task_queue.push(&#123;&quot;优化测试&quot;, 8, 103&#125;);    task_queue.push(&#123;&quot;文档编写&quot;, 5, 104&#125;);    // 执行任务（按优先级排序）    cout &lt;&lt; &quot;任务执行顺序：\n&quot;;    while (!task_queue.empty()) &#123;        Task t = task_queue.top();        task_queue.pop();        cout &lt;&lt; &quot;ID:&quot; &lt;&lt; t.id &lt;&lt; &quot; | 名称:&quot; &lt;&lt; t.name &lt;&lt; &quot; | 优先级:&quot; &lt;&lt; t.priority &lt;&lt; endl;    &#125;    /* 输出：    ID:101 | 名称:紧急修复 | 优先级:10    ID:102 | 名称:功能开发 | 优先级:8    ID:103 | 名称:优化测试 | 优先级:8    ID:104 | 名称:文档编写 | 优先级:5    */    return 0;&#125;</code></pre><h2 id="五、典型应用场景"><a href="#五、典型应用场景" class="headerlink" title="五、典型应用场景"></a>五、典型应用场景</h2><p>优先队列的核心价值是 “动态获取最优元素”，以下是最经典的应用场景：</p><h3 id="1-堆排序（时间复杂度-O-nlogn-）"><a href="#1-堆排序（时间复杂度-O-nlogn-）" class="headerlink" title="1. 堆排序（时间复杂度 O (nlogn)）"></a>1. 堆排序（时间复杂度 O (nlogn)）</h3><p>利用堆的性质实现高效排序，步骤：</p><ol><li>构建大顶堆（O (n) 时间）；</li><li>反复弹出堆顶（最大值），放入结果数组末尾，同时调整堆（O (nlogn) 时间）；</li><li>最终结果数组为升序（小顶堆可实现降序）。</li></ol><h3 id="2-Dijkstra-最短路径算法（无负权图）"><a href="#2-Dijkstra-最短路径算法（无负权图）" class="headerlink" title="2. Dijkstra 最短路径算法（无负权图）"></a>2. Dijkstra 最短路径算法（无负权图）</h3><p>在带权无负边图中，需不断选择 “当前距离起点最近的节点” 扩展，优先队列（小顶堆）用于高效获取该节点：</p><ul><li>队列元素为 <code>(当前距离, 节点)</code>，按距离排序；</li><li>每次弹出距离最小的节点，更新其邻接节点的距离，若更新后更优则加入队列。</li></ul><h3 id="3-任务调度系统"><a href="#3-任务调度系统" class="headerlink" title="3. 任务调度系统"></a>3. 任务调度系统</h3><p>按任务优先级执行，例如：</p><ul><li>操作系统进程调度（高优先级进程先占用 CPU）；</li><li>外卖 &#x2F; 快递调度（加急订单优先配送）；</li><li>服务器请求处理（VIP 用户请求优先响应）。</li></ul><h3 id="4-合并-k-个有序链表（LeetCode-困难题）"><a href="#4-合并-k-个有序链表（LeetCode-困难题）" class="headerlink" title="4. 合并 k 个有序链表（LeetCode 困难题）"></a>4. 合并 k 个有序链表（LeetCode 困难题）</h3><p>需反复选择 “所有链表头中最小的节点”，优先队列（小顶堆）用于高效获取：</p><ul><li>队列元素为 <code>(节点值, 链表索引, 节点)</code>，按节点值排序；</li><li>每次弹出最小节点，将其下一个节点（若有）加入队列，直到所有链表合并完成。</li></ul><h3 id="5-Huffman-编码（数据压缩）"><a href="#5-Huffman-编码（数据压缩）" class="headerlink" title="5. Huffman 编码（数据压缩）"></a>5. Huffman 编码（数据压缩）</h3><p>构建最优前缀编码树时，需反复合并 “频率最低的两个节点”，优先队列（小顶堆）用于高效获取这两个节点，最终实现最小冗余编码。</p><h3 id="6-求-Top-K-问题（如前-K-个高频元素、第-K-大元素）"><a href="#6-求-Top-K-问题（如前-K-个高频元素、第-K-大元素）" class="headerlink" title="6. 求 Top K 问题（如前 K 个高频元素、第 K 大元素）"></a>6. 求 Top K 问题（如前 K 个高频元素、第 K 大元素）</h3><p>用小顶堆维护 K 个元素，遍历所有元素时，若元素大于堆顶则替换堆顶并调整，最终堆内即为 Top K 大元素（时间复杂度 O (nlogK)，比排序 O (nlogn) 更高效）。</p><h2 id="六、注意事项与进阶技巧"><a href="#六、注意事项与进阶技巧" class="headerlink" title="六、注意事项与进阶技巧"></a>六、注意事项与进阶技巧</h2><ol><li><strong>优先级队列的 “无序性”</strong>：底层是堆结构，存储容器中的元素并非完全有序，仅保证堆顶是最优元素，不能直接遍历获取有序序列（需通过出队实现）；</li><li>自定义优先级的两种方式：<ul><li>基本类型：C++ 用 <code>greater</code>&#x2F;<code>less</code>，Python 用负数反转；</li><li>自定义结构体：C++ 重载 <code>operator&lt;</code> 或定义比较结构体，Python 可传入自定义比较函数（需配合 <code>functools.cmp_to_key</code>）；</li></ul></li><li>效率优化：<ul><li>已知元素数量时，提前为底层容器分配空间（如 C++ <code>vector.reserve()</code>），减少扩容开销；</li><li>批量构建堆时，用 <code>heapify</code>（Python）或手动实现的批量建堆（O (n) 时间），比逐个插入（O (nlogn)）更高效；</li></ul></li><li>与其他数据结构的选择：<ul><li>若需 “动态插入 + 频繁查最值”：优先队列（堆实现）是最优选择；</li><li>若需 “静态查最值”（无插入删除）：直接遍历找最值（O (n)）更简单；</li><li>若需 “有序遍历 + 频繁插入删除”：平衡二叉搜索树（如 C++ <code>set</code>&#x2F;<code>map</code>）更合适（但优先级队列效率更高）。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;优先队列是一种&lt;strong&gt;特殊的队列数据结构&lt;/strong&gt;，核心区别于普通队列的 “先进先出（FIFO）” 规则 —— 它按元素的&lt;strong&gt;优先级&lt;/strong&gt;排序，每次出队时，总是取出优先级最高（或最低）的元素。无论是算法优化（如最短路径、排序）还是工程场景（如任务调度），优先队列都是解决 “动态选择最优元素” 问题的核心工具。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CSS3弹性盒子模型</title>
    <link href="http://example.com/2025/11/10/CSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2025/11/10/CSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-11-10T12:11:47.000Z</published>
    <updated>2025-11-10T12:20:17.122Z</updated>
    
    <content type="html"><![CDATA[<p>CSS3 弹性盒子模型（Flexible Box，简称 Flexbox）是一种<strong>一维布局模型</strong>，专为解决传统布局（<code>float</code>、<code>position</code>）的对齐复杂、自适应繁琐等问题设计，现已成为前端布局的首选方案。它通过「容器 - 项目」的结构，轻松实现元素的对齐、分布、伸缩和自适应，兼容性覆盖所有现代浏览器（IE11 部分支持）。</p><span id="more"></span><h1 id="CSS3-弹性盒子（Flexbox"><a href="#CSS3-弹性盒子（Flexbox" class="headerlink" title="CSS3 弹性盒子（Flexbox"></a>CSS3 弹性盒子（Flexbox</h1><h2 id="一、核心原理与概念"><a href="#一、核心原理与概念" class="headerlink" title="一、核心原理与概念"></a>一、核心原理与概念</h2><p>Flexbox 的布局逻辑围绕「主轴」和「交叉轴」展开，核心是通过控制容器和项目的属性，实现灵活的布局效果。先明确以下关键概念：</p><table><thead><tr><th>概念</th><th>定义与说明</th></tr></thead><tbody><tr><td>弹性容器（Flex Container）</td><td>父元素通过 <code>display: flex</code> 或 <code>display: inline-flex</code> 声明，其直接子元素自动成为弹性项目</td></tr><tr><td>弹性项目（Flex Item）</td><td>弹性容器的<strong>直接子元素</strong>（不包含嵌套子元素），默认沿主轴排列</td></tr><tr><td>主轴（Main Axis）</td><td>项目排列的主方向，由 <code>flex-direction</code> 控制（默认水平向左→右）</td></tr><tr><td>交叉轴（Cross Axis）</td><td>与主轴垂直的方向（默认垂直向上→下），所有交叉轴相关属性（如 <code>align-items</code>）均作用于此方向</td></tr><tr><td>主轴起点 &#x2F; 终点（Main Start&#x2F;End）</td><td>主轴的开始和结束位置（如水平主轴的左 &#x2F; 右）</td></tr><tr><td>交叉轴起点 &#x2F; 终点（Cross Start&#x2F;End）</td><td>交叉轴的开始和结束位置（如垂直交叉轴的上 &#x2F; 下）</td></tr><tr><td>基线（Baseline）</td><td>项目内文字的基准线（<code>align-items: baseline</code> 时按此对齐）</td></tr></tbody></table><h2 id="二、基础入门：创建弹性容器"><a href="#二、基础入门：创建弹性容器" class="headerlink" title="二、基础入门：创建弹性容器"></a>二、基础入门：创建弹性容器</h2><h3 id="1-声明弹性容器"><a href="#1-声明弹性容器" class="headerlink" title="1. 声明弹性容器"></a>1. 声明弹性容器</h3><p>给父元素添加 <code>display</code> 属性，即可将其变为弹性容器，两种取值区别如下：</p><pre><code class="css">/* 1. 块级弹性容器：独占一行，宽度默认 100%（常用） */.container &#123;  display: flex;&#125;/* 2. 行内弹性容器：宽度自适应内容，与其他行内元素同行排列 */.container &#123;  display: inline-flex;&#125;</code></pre><h3 id="2-项目的默认行为"><a href="#2-项目的默认行为" class="headerlink" title="2. 项目的默认行为"></a>2. 项目的默认行为</h3><p>容器声明为 <code>flex</code> 后，子项目（Flex Item）会自动呈现以下特性：</p><ul><li>沿主轴（默认水平）排列，不再独占一行（打破块级元素默认行为）</li><li>项目高度默认拉伸至与容器等高（<code>align-items: stretch</code>）</li><li>项目不会换行，空间不足时自动收缩（<code>flex-shrink: 1</code>）</li><li>忽略 <code>float</code>、<code>clear</code>、<code>vertical-align</code> 属性（失效）</li></ul><h2 id="三、容器属性（控制整体布局）"><a href="#三、容器属性（控制整体布局）" class="headerlink" title="三、容器属性（控制整体布局）"></a>三、容器属性（控制整体布局）</h2><p>弹性容器的属性用于定义项目的排列方向、换行规则、对齐方式等，共 6 个核心属性，是 Flexbox 布局的核心。</p><h3 id="1-flex-direction：控制主轴方向（项目排列方向）"><a href="#1-flex-direction：控制主轴方向（项目排列方向）" class="headerlink" title="1. flex-direction：控制主轴方向（项目排列方向）"></a>1. flex-direction：控制主轴方向（项目排列方向）</h3><p>决定主轴的方向，直接改变项目的排列顺序（水平 &#x2F; 垂直），取值如下：</p><table><thead><tr><th>取值</th><th>主轴方向</th><th>项目排列效果</th><th>适用场景</th></tr></thead><tbody><tr><td><code>row</code>（默认）</td><td>水平（左→右）</td><td>从左到右横向排列</td><td>导航栏、水平布局</td></tr><tr><td><code>row-reverse</code></td><td>水平（右→左）</td><td>从右到左横向排列</td><td>反向水平布局</td></tr><tr><td><code>column</code></td><td>垂直（上→下）</td><td>从上到下纵向排列</td><td>垂直导航、表单布局</td></tr><tr><td><code>column-reverse</code></td><td>垂直（下→上）</td><td>从下到上纵向排列</td><td>反向垂直布局</td></tr></tbody></table><p><strong>示例：垂直排列项目</strong></p><pre><code class="css">.container &#123;  display: flex;  flex-direction: column; /* 主轴垂直，项目从上到下排列 */  height: 200px; /* 容器高度决定交叉轴空间 */&#125;</code></pre><h3 id="2-flex-wrap：控制项目是否换行"><a href="#2-flex-wrap：控制项目是否换行" class="headerlink" title="2. flex-wrap：控制项目是否换行"></a>2. flex-wrap：控制项目是否换行</h3><p>默认情况下，项目会压缩在一行（<code>nowrap</code>），通过 <code>flex-wrap</code> 控制溢出时的换行规则：</p><table><thead><tr><th>取值</th><th>效果说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>nowrap</code>（默认）</td><td>不换行，项目自动收缩以适应容器宽度</td><td>少量项目的水平布局</td></tr><tr><td><code>wrap</code></td><td>换行，溢出的项目在下一行排列（从上到下）</td><td>响应式卡片、多项目布局</td></tr><tr><td><code>wrap-reverse</code></td><td>反向换行，溢出的项目在上一行排列（从下到上）</td><td>特殊反向布局</td></tr></tbody></table><p><strong>示例：自动换行布局</strong></p><pre><code class="css">.container &#123;  display: flex;  flex-wrap: wrap; /* 空间不足时自动换行 */  width: 500px; /* 容器固定宽度，触发换行 */&#125;</code></pre><h3 id="3-flex-flow：flex-direction-flex-wrap-简写"><a href="#3-flex-flow：flex-direction-flex-wrap-简写" class="headerlink" title="3. flex-flow：flex-direction + flex-wrap 简写"></a>3. flex-flow：<code>flex-direction</code> + <code>flex-wrap</code> 简写</h3><p>为简化代码，将两个属性合并为 <code>flex-flow</code>，默认值 <code>row nowrap</code>：</p><pre><code class="css">/* 水平排列 + 自动换行（常用组合） */.container &#123;  display: flex;  flex-flow: row wrap;&#125;/* 垂直排列 + 不换行 */.container &#123;  flex-flow: column nowrap;&#125;</code></pre><h3 id="4-justify-content：主轴对齐方式（核心）"><a href="#4-justify-content：主轴对齐方式（核心）" class="headerlink" title="4. justify-content：主轴对齐方式（核心）"></a>4. justify-content：主轴对齐方式（核心）</h3><p>控制项目在<strong>主轴方向</strong>的对齐和分布，是最常用的属性之一（以 <code>flex-direction: row</code> 为例，主轴为水平方向）：</p><table><thead><tr><th>取值</th><th>效果说明</th><th>视觉示意（水平主轴）</th><th>适用场景</th></tr></thead><tbody><tr><td><code>flex-start</code>（默认）</td><td>靠主轴起点对齐（左对齐）</td><td>[项目 1 项目 2 项目 3] ——</td><td>左对齐布局</td></tr><tr><td><code>flex-end</code></td><td>靠主轴终点对齐（右对齐）</td><td>—— [项目 1 项目 2 项目 3]</td><td>右对齐布局</td></tr><tr><td><code>center</code></td><td>主轴居中对齐</td><td>—— [项目 1 项目 2 项目 3] ——</td><td>水平居中（如弹窗内容）</td></tr><tr><td><code>space-between</code></td><td>两端对齐，项目间间距相等（无首尾间距）</td><td>[项目 1] —- [项目 2] —- [项目 3]</td><td>导航栏、均匀分布布局</td></tr><tr><td><code>space-around</code></td><td>项目两侧间距相等（首尾间距为项目间间距的 1&#x2F;2）</td><td>– [项目 1] – [项目 2] – [项目 3] –</td><td>均匀分布（需首尾留白）</td></tr><tr><td><code>space-evenly</code></td><td>项目间间距 + 首尾间距完全相等</td><td>– [项目 1] – [项目 2] – [项目 3] –</td><td>严格均匀分布</td></tr></tbody></table><p><strong>示例：水平居中且项目间均匀分布</strong></p><pre><code class="css">.container &#123;  display: flex;  justify-content: space-between; /* 两端对齐，中间间距相等 */&#125;</code></pre><h3 id="5-align-items：交叉轴对齐方式（核心）"><a href="#5-align-items：交叉轴对齐方式（核心）" class="headerlink" title="5. align-items：交叉轴对齐方式（核心）"></a>5. align-items：交叉轴对齐方式（核心）</h3><p>控制项目在<strong>交叉轴方向</strong>的对齐（仅适用于「单行项目」），以 <code>flex-direction: row</code> 为例（交叉轴为垂直方向）：</p><table><thead><tr><th>取值</th><th>效果说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>stretch</code>（默认）</td><td>项目高度拉伸至与容器等高（项目无固定高度时）</td><td>等高卡片布局</td></tr><tr><td><code>flex-start</code></td><td>靠交叉轴起点对齐（顶部对齐）</td><td>顶部对齐的列表</td></tr><tr><td><code>flex-end</code></td><td>靠交叉轴终点对齐（底部对齐）</td><td>底部对齐的按钮组</td></tr><tr><td><code>center</code></td><td>交叉轴居中对齐（垂直居中）</td><td>水平 + 垂直居中布局</td></tr><tr><td><code>baseline</code></td><td>按项目内文字基线对齐（文字底部对齐）</td><td>文字对齐的卡片</td></tr></tbody></table><p><strong>示例：水平垂直居中（最常用布局）</strong></p><pre><code class="css">.container &#123;  display: flex;  justify-content: center; /* 主轴（水平）居中 */  align-items: center;     /* 交叉轴（垂直）居中 */  height: 300px; /* 容器必须有高度，否则交叉轴无拉伸空间 */&#125;</code></pre><h3 id="6-align-content：多行项目的交叉轴对齐"><a href="#6-align-content：多行项目的交叉轴对齐" class="headerlink" title="6. align-content：多行项目的交叉轴对齐"></a>6. align-content：多行项目的交叉轴对齐</h3><p>仅当项目<strong>换行</strong>（<code>flex-wrap: wrap</code>）时生效，控制「多行项目整体」在交叉轴的对齐方式（区别于 <code>align-items</code> 控制单个项目）：</p><table><thead><tr><th>取值</th><th>效果说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>stretch</code>（默认）</td><td>多行拉伸至容器高度，行间距相等</td><td>多行等高布局</td></tr><tr><td><code>flex-start</code></td><td>多行靠交叉轴起点对齐（顶部对齐）</td><td>多行顶部对齐</td></tr><tr><td><code>flex-end</code></td><td>多行靠交叉轴终点对齐（底部对齐）</td><td>多行底部对齐</td></tr><tr><td><code>center</code></td><td>多行交叉轴居中对齐（整体垂直居中）</td><td>多行居中布局</td></tr><tr><td><code>space-between</code></td><td>多行两端对齐，行间距相等</td><td>多行均匀分布</td></tr><tr><td><code>space-around</code></td><td>多行两侧间距相等</td><td>多行均匀分布（需留白）</td></tr></tbody></table><p><strong>示例：多行项目整体垂直居中</strong></p><pre><code class="css">.container &#123;  display: flex;  flex-wrap: wrap; /* 必须换行才生效 */  align-content: center; /* 多行整体垂直居中 */  height: 500px; /* 容器高度足够容纳多行 */&#125;</code></pre><h2 id="四、项目属性（控制单个项目）"><a href="#四、项目属性（控制单个项目）" class="headerlink" title="四、项目属性（控制单个项目）"></a>四、项目属性（控制单个项目）</h2><p>弹性项目的属性用于单独调整某个项目的大小、对齐方式或排列顺序，覆盖容器的默认设置，共 6 个核心属性。</p><h3 id="1-flex-grow：项目的放大比例"><a href="#1-flex-grow：项目的放大比例" class="headerlink" title="1. flex-grow：项目的放大比例"></a>1. flex-grow：项目的放大比例</h3><p>控制项目在容器有<strong>剩余空间</strong>时的放大比例，默认值 <code>0</code>（不放大）：</p><ul><li>取值为非负数字（整数 &#x2F; 小数），比例越大，占有的剩余空间越多</li><li>多个项目的 <code>flex-grow</code> 按比例分配剩余空间（如 1:2 则分别占 1&#x2F;3、2&#x2F;3）</li></ul><p><strong>示例：2 个项目按 1:2 分配剩余空间</strong></p><pre><code class="css">.container &#123;  display: flex;  width: 500px;&#125;.item1 &#123; flex-grow: 1; &#125; /* 占 1/3 剩余空间 */.item2 &#123; flex-grow: 2; &#125; /* 占 2/3 剩余空间 */</code></pre><h3 id="2-flex-shrink：项目的收缩比例"><a href="#2-flex-shrink：项目的收缩比例" class="headerlink" title="2. flex-shrink：项目的收缩比例"></a>2. flex-shrink：项目的收缩比例</h3><p>控制项目在容器<strong>空间不足</strong>时的收缩比例，默认值 <code>1</code>（自动收缩）：</p><ul><li>取值为非负数字，<code>0</code> 表示不收缩（固定宽度，避免被压缩）</li><li>多个项目的 <code>flex-shrink</code> 按比例收缩（如 1:2 则 item1 收缩幅度是 item2 的 1&#x2F;2）</li></ul><p><strong>示例：禁止项目收缩（常用）</strong></p><pre><code class="css">.item &#123;  flex-shrink: 0; /* 容器空间不足时，项目不收缩 */  width: 200px; /* 固定宽度不被压缩 */&#125;</code></pre><h3 id="3-flex-basis：项目的基准宽度"><a href="#3-flex-basis：项目的基准宽度" class="headerlink" title="3. flex-basis：项目的基准宽度"></a>3. flex-basis：项目的基准宽度</h3><p>定义项目在主轴上的<strong>初始宽度</strong>（在分配剩余空间前的宽度），默认值 <code>auto</code>（项目自身宽度）：</p><ul><li>优先级：<code>flex-basis</code> &gt; 项目自身 <code>width</code>（若同时设置，<code>width</code> 失效）</li><li>可取值：<code>px</code>&#x2F;<code>%</code>&#x2F;<code>em</code> 等具体单位，或 <code>auto</code>（自动适应内容）</li></ul><p><strong>示例：设置项目初始宽度</strong></p><pre><code class="css">.item &#123;  flex-basis: 200px; /* 初始宽度 200px，剩余空间按 flex-grow 分配 */&#125;</code></pre><h3 id="4-flex：flex-grow-flex-shrink-flex-basis-简写（常用）"><a href="#4-flex：flex-grow-flex-shrink-flex-basis-简写（常用）" class="headerlink" title="4. flex：flex-grow + flex-shrink + flex-basis 简写（常用）"></a>4. flex：<code>flex-grow</code> + <code>flex-shrink</code> + <code>flex-basis</code> 简写（常用）</h3><p>为简化代码，将三个属性合并为 <code>flex</code>，默认值 <code>0 1 auto</code>，常用简写形式如下：</p><table><thead><tr><th>简写</th><th>等价于</th><th>效果说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>flex: 1</code></td><td><code>1 1 0%</code></td><td>项目自动放大 &#x2F; 收缩，基准宽度为 0（按比例分配空间）</td><td>等分布局、自适应宽度</td></tr><tr><td><code>flex: auto</code></td><td><code>1 1 auto</code></td><td>项目自动放大 &#x2F; 收缩，基准宽度为自身宽度</td><td>自适应内容宽度</td></tr><tr><td><code>flex: none</code></td><td><code>0 0 auto</code></td><td>项目不放大、不收缩，固定自身宽度</td><td>固定宽度项目（如侧边栏）</td></tr><tr><td><code>flex: 2 0 300px</code></td><td><code>2 0 300px</code></td><td>放大比例 2，不收缩，基准宽度 300px</td><td>固定基准宽度的自适应项目</td></tr></tbody></table><p><strong>示例：等分布局（最常用）</strong></p><pre><code class="css">.container &#123;  display: flex;&#125;.item &#123;  flex: 1; /* 所有项目等比例分配容器宽度 */  margin: 0 10px; /* 项目间距 */&#125;</code></pre><h3 id="5-align-self：单个项目的交叉轴对齐"><a href="#5-align-self：单个项目的交叉轴对齐" class="headerlink" title="5. align-self：单个项目的交叉轴对齐"></a>5. align-self：单个项目的交叉轴对齐</h3><p>覆盖容器的 <code>align-items</code> 属性，单独设置某个项目的交叉轴对齐方式，取值与 <code>align-items</code> 一致：</p><pre><code class="css">.container &#123;  display: flex;  align-items: flex-start; /* 所有项目顶部对齐 */&#125;.item-special &#123;  align-self: center; /* 该项目单独垂直居中 */&#125;</code></pre><h3 id="6-order：项目的排列顺序"><a href="#6-order：项目的排列顺序" class="headerlink" title="6. order：项目的排列顺序"></a>6. order：项目的排列顺序</h3><p>控制项目的显示顺序，默认值 <code>0</code>，取值为整数（负数在前，正数在后，数值越小越靠前）：</p><pre><code class="css">.item1 &#123; order: 2; &#125; /* 第 2 个显示 */.item2 &#123; order: 1; &#125; /* 第 1 个显示 */.item3 &#123; order: -1; &#125; /* 最前面显示（数值最小） */</code></pre><h2 id="五、常用应用场景（附代码）"><a href="#五、常用应用场景（附代码）" class="headerlink" title="五、常用应用场景（附代码）"></a>五、常用应用场景（附代码）</h2><p>Flexbox 几乎能解决所有前端布局问题，以下是最常用的场景示例：</p><h3 id="1-水平垂直居中（弹窗、卡片内容）"><a href="#1-水平垂直居中（弹窗、卡片内容）" class="headerlink" title="1. 水平垂直居中（弹窗、卡片内容）"></a>1. 水平垂直居中（弹窗、卡片内容）</h3><pre><code class="css">.modal-content &#123;  display: flex;  justify-content: center; /* 水平居中 */  align-items: center;     /* 垂直居中 */  height: 200px;  width: 300px;&#125;</code></pre><h3 id="2-等分布局（导航栏、选项卡）"><a href="#2-等分布局（导航栏、选项卡）" class="headerlink" title="2. 等分布局（导航栏、选项卡）"></a>2. 等分布局（导航栏、选项卡）</h3><pre><code class="css">.nav &#123;  display: flex;  list-style: none;  padding: 0;&#125;.nav-item &#123;  flex: 1; /* 等比例分配宽度 */  text-align: center;  padding: 10px 0;&#125;</code></pre><h3 id="3-两栏布局（侧边栏固定-主内容自适应）"><a href="#3-两栏布局（侧边栏固定-主内容自适应）" class="headerlink" title="3. 两栏布局（侧边栏固定 + 主内容自适应）"></a>3. 两栏布局（侧边栏固定 + 主内容自适应）</h3><pre><code class="css">.container &#123;  display: flex;  height: 100vh; /* 占满视口高度 */&#125;.sidebar &#123;  width: 200px;  flex-shrink: 0; /* 侧边栏不收缩 */  background: #f5f5f5;&#125;.main &#123;  flex: 1; /* 主内容自适应剩余宽度 */  padding: 20px;&#125;</code></pre><h3 id="4-响应式换行布局（卡片、产品列表）"><a href="#4-响应式换行布局（卡片、产品列表）" class="headerlink" title="4. 响应式换行布局（卡片、产品列表）"></a>4. 响应式换行布局（卡片、产品列表）</h3><pre><code class="css">.card-container &#123;  display: flex;  flex-wrap: wrap; /* 自动换行 */  gap: 16px; /* 项目间距（替代 margin，更简洁） */  padding: 20px;&#125;.card &#123;  flex: 1 1 250px; /* 最小宽度 250px，超出自动换行 */  background: #fff;  padding: 20px;  border-radius: 8px;&#125;</code></pre><h3 id="5-底部固定布局（内容不足时底部贴底）"><a href="#5-底部固定布局（内容不足时底部贴底）" class="headerlink" title="5. 底部固定布局（内容不足时底部贴底）"></a>5. 底部固定布局（内容不足时底部贴底）</h3><pre><code class="css">body &#123;  margin: 0;  min-height: 100vh; /* 视口高度 */  display: flex;  flex-direction: column; /* 主轴垂直 */&#125;.header &#123;  height: 60px;  background: #333;  color: #fff;&#125;.content &#123;  flex: 1; /* 内容区占满剩余空间，推底部到底部 */  padding: 20px;&#125;.footer &#123;  height: 60px;  background: #333;  color: #fff;  text-align: center;  line-height: 60px;&#125;</code></pre><h3 id="6-文字基线对齐（卡片内文字对齐）"><a href="#6-文字基线对齐（卡片内文字对齐）" class="headerlink" title="6. 文字基线对齐（卡片内文字对齐）"></a>6. 文字基线对齐（卡片内文字对齐）</h3><pre><code class="css">.card-container &#123;  display: flex;  align-items: baseline; /* 按文字基线对齐 */  gap: 20px;&#125;.card h3 &#123;  margin: 0;  font-size: 24px;&#125;.card p &#123;  margin: 0;  font-size: 16px;&#125;</code></pre><h2 id="六、关键注意事项"><a href="#六、关键注意事项" class="headerlink" title="六、关键注意事项"></a>六、关键注意事项</h2><ol><li><p><strong>容器高度与交叉轴对齐</strong>：<code>align-items: center</code>、<code>align-content: center</code> 等属性需要容器有明确高度（如 <code>height</code>、<code>min-height: 100vh</code>），否则交叉轴无空间，对齐效果失效。</p></li><li><p><strong><code>gap</code> 属性的使用</strong>：Flexbox 支持 <code>gap</code>（项目间距）和 <code>row-gap</code>&#x2F;<code>column-gap</code>（行列间距），无需用 <code>margin</code> 实现，更简洁（IE 不支持 <code>gap</code>，需兼容时用 <code>margin</code>）。</p></li><li><p>**项目的 <code>width</code> 与 <code>flex-basis</code>**：<code>flex-basis</code> 优先级高于 <code>width</code>，若同时设置，<code>width</code> 失效；若 <code>flex-basis: auto</code>，则以 <code>width</code> 为准。</p></li><li><p>兼容性处理：IE11 支持 Flexbox，但存在部分差异（如<code>flex-basis</code>需配合<code>width</code>，<code>gap</code>不支持），可通过以下兼容写法修复：</p><pre><code class="css">/* IE11 兼容 flex-basis */.item &#123;  flex-basis: 200px;  width: 200px; /* 兜底 IE11 */&#125;</code></pre></li><li><p><strong>嵌套 Flex 布局</strong>：弹性项目可以再声明为弹性容器，实现复杂的嵌套布局（如卡片内部的元素对齐）。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSS3 弹性盒子模型（Flexible Box，简称 Flexbox）是一种&lt;strong&gt;一维布局模型&lt;/strong&gt;，专为解决传统布局（&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;position&lt;/code&gt;）的对齐复杂、自适应繁琐等问题设计，现已成为前端布局的首选方案。它通过「容器 - 项目」的结构，轻松实现元素的对齐、分布、伸缩和自适应，兼容性覆盖所有现代浏览器（IE11 部分支持）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="web前端" scheme="http://example.com/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSS核心属性</title>
    <link href="http://example.com/2025/11/07/CSS%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7/"/>
    <id>http://example.com/2025/11/07/CSS%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7/</id>
    <published>2025-11-07T14:57:18.000Z</published>
    <updated>2025-11-07T15:03:28.996Z</updated>
    
    <content type="html"><![CDATA[<p>开发中最常用的 <strong>字体、背景、文本、表格</strong> 属性，包含语法、取值、示例，兼顾实用性和易理解性，直接可复制到项目中使用。</p><span id="more"></span><h1 id="CSS-核心属性详解（字体、背景、文本、表格）"><a href="#CSS-核心属性详解（字体、背景、文本、表格）" class="headerlink" title="CSS 核心属性详解（字体、背景、文本、表格）"></a>CSS 核心属性详解（字体、背景、文本、表格）</h1><h2 id="一、字体属性（控制文字样式）"><a href="#一、字体属性（控制文字样式）" class="headerlink" title="一、字体属性（控制文字样式）"></a>一、字体属性（控制文字样式）</h2><p>核心用于设置文字的 <strong>字体、大小、粗细、风格、行高</strong> 等，是页面文字排版的基础。</p><table><thead><tr><th>属性名</th><th>作用</th><th>取值 &#x2F; 说明</th><th>示例</th></tr></thead><tbody><tr><td><code>font-family</code></td><td>设置字体（优先匹配）</td><td>具体字体名（如 <code>Arial</code>）、通用字体族（如 <code>sans-serif</code> 无衬线、<code>serif</code> 衬线）；多个字体用逗号分隔（fallback 机制）</td><td><code>font-family: &quot;微软雅黑&quot;, &quot;Microsoft YaHei&quot;, sans-serif;</code></td></tr><tr><td><code>font-size</code></td><td>设置字体大小（核心）</td><td>固定值（<code>16px</code> 常用）、相对值（<code>1.2em</code> 相对于父元素、<code>120%</code> 百分比、<code>small/large</code> 关键字）</td><td><code>font-size: 16px;</code>（网页默认 16px）</td></tr><tr><td><code>font-weight</code></td><td>设置字体粗细</td><td>关键字（<code>normal</code> 正常 &#x2F;<code>bold</code> 加粗 &#x2F;<code>bolder</code> 更粗 &#x2F;<code>lighter</code> 更细）、数字（100-900，400&#x3D;normal，700&#x3D;bold）</td><td><code>font-weight: 600;</code>（半加粗，常用）</td></tr><tr><td><code>font-style</code></td><td>设置字体风格（斜体 &#x2F; 正常）</td><td><code>normal</code>（正常）、<code>italic</code>（斜体，字体自带）、<code>oblique</code>（强制斜体）</td><td><code>font-style: italic;</code>（斜体文字）</td></tr><tr><td><code>line-height</code></td><td>设置行高（文字垂直间距）</td><td>数字（如 <code>1.5</code>，相对于字体大小的倍数，推荐）、固定值（<code>24px</code>）、百分比（<code>150%</code>）</td><td><code>line-height: 1.5;</code>（行高 &#x3D; 字体大小 ×1.5，易读）</td></tr><tr><td><code>font</code></td><td>复合属性（简化写法）</td><td>顺序：<code>font-style font-weight font-size/line-height font-family</code>（必须包含 <code>font-size</code> 和 <code>font-family</code>）</td><td><code>font: italic 600 16px/1.5 &quot;微软雅黑&quot;, sans-serif;</code></td></tr><tr><td><code>color</code></td><td>设置文字颜色（关联字体）</td><td>颜色值（<code>red</code>、<code>#333</code>、<code>rgb(51,51,51)</code>、<code>rgba(51,51,51,0.8)</code> 带透明度）</td><td><code>color: #666;</code>（浅灰色文字）</td></tr></tbody></table><h3 id="字体属性常用示例"><a href="#字体属性常用示例" class="headerlink" title="字体属性常用示例"></a>字体属性常用示例</h3><pre><code class="css">.text &#123;  font-family: &quot;PingFang SC&quot;, &quot;微软雅黑&quot;, sans-serif; /* 适配 macOS/Windows */  font-size: 14px;  font-weight: normal; /* 取消加粗 */  line-height: 1.6; /* 优化可读性 */  color: rgba(33, 33, 33, 0.9); /* 深灰带轻微透明度 */&#125;</code></pre><h2 id="二、背景属性（控制元素背景）"><a href="#二、背景属性（控制元素背景）" class="headerlink" title="二、背景属性（控制元素背景）"></a>二、背景属性（控制元素背景）</h2><p>用于设置元素的 <strong>背景色、背景图、背景平铺、位置、大小</strong> 等，丰富元素视觉效果。</p><table><thead><tr><th>属性名</th><th>作用</th><th>取值 &#x2F; 说明</th><th>示例</th></tr></thead><tbody><tr><td><code>background-color</code></td><td>设置背景颜色</td><td>颜色值、<code>transparent</code>（透明，默认）</td><td><code>background-color: #f5f5f5;</code>（浅灰背景）</td></tr><tr><td><code>background-image</code></td><td>设置背景图片</td><td><code>url(&quot;图片路径&quot;)</code>（相对 &#x2F; 绝对路径）、<code>none</code>（无背景图，默认）</td><td><code>background-image: url(&quot;bg.jpg&quot;);</code></td></tr><tr><td><code>background-repeat</code></td><td>控制背景图平铺方式</td><td><code>repeat</code>（默认，全平铺）、<code>no-repeat</code>（不平铺）、<code>repeat-x</code>（水平平铺）、<code>repeat-y</code>（垂直平铺）</td><td><code>background-repeat: no-repeat;</code></td></tr><tr><td><code>background-position</code></td><td>控制背景图位置</td><td>关键字（<code>center</code> 居中、<code>left top</code> 左上）、数值（<code>50px 30px</code> 左 50px 上 30px）、百分比（<code>50% 50%</code> 居中）</td><td><code>background-position: center;</code></td></tr><tr><td><code>background-size</code></td><td>控制背景图大小</td><td><code>cover</code>（覆盖元素，可能裁剪）、<code>contain</code>（完全显示，可能留白）、数值（<code>100px 80px</code> 宽高）、百分比（<code>100% 100%</code> 拉伸填充）</td><td><code>background-size: cover;</code>（常用背景铺满）</td></tr><tr><td><code>background-attachment</code></td><td>背景图滚动行为</td><td><code>scroll</code>（随页面滚动，默认）、<code>fixed</code>（固定不动，类似视差效果）</td><td><code>background-attachment: fixed;</code></td></tr><tr><td><code>background</code></td><td>复合属性（简化写法）</td><td>顺序：<code>background-color background-image background-repeat background-position / background-size background-attachment</code>（<code>size</code> 前必须加 <code>/</code>）</td><td><code>background: #f5f5f5 url(&quot;bg.jpg&quot;) no-repeat center / cover fixed;</code></td></tr></tbody></table><h3 id="背景属性常用示例（全屏背景图）"><a href="#背景属性常用示例（全屏背景图）" class="headerlink" title="背景属性常用示例（全屏背景图）"></a>背景属性常用示例（全屏背景图）</h3><pre><code class="css">body &#123;  background: url(&quot;full-screen-bg.jpg&quot;) no-repeat center / cover;  background-color: #eee; /* 背景图加载失败时的 fallback 色 */&#125;</code></pre><h2 id="三、文本属性（控制文本排版）"><a href="#三、文本属性（控制文本排版）" class="headerlink" title="三、文本属性（控制文本排版）"></a>三、文本属性（控制文本排版）</h2><p>用于设置文本的 <strong>对齐方式、缩进、间距、装饰线</strong> 等，优化文本布局的可读性。</p><table><thead><tr><th>属性名</th><th>作用</th><th>取值 &#x2F; 说明</th><th>示例</th></tr></thead><tbody><tr><td><code>text-align</code></td><td>文本水平对齐</td><td><code>left</code>（左对齐，默认）、<code>center</code>（居中）、<code>right</code>（右对齐）、<code>justify</code>（两端对齐，仅多行有效）</td><td><code>text-align: center;</code>（标题居中）</td></tr><tr><td><code>text-indent</code></td><td>文本首行缩进</td><td>数值（<code>2em</code> 常用，对应 2 个字符宽度）、百分比（<code>10%</code>）</td><td><code>text-indent: 2em;</code>（段落首行缩进 2 字）</td></tr><tr><td><code>letter-spacing</code></td><td>字符间距（字与字之间）</td><td>数值（<code>2px</code> 加宽、<code>-1px</code> 收紧）、<code>normal</code>（默认）</td><td><code>letter-spacing: 1px;</code>（加宽字符间距）</td></tr><tr><td><code>word-spacing</code></td><td>单词间距（英文单词之间）</td><td>数值（<code>5px</code> 加宽）、<code>normal</code>（默认）；中文无效（中文无单词概念）</td><td><code>word-spacing: 3px;</code>（英文单词间距）</td></tr><tr><td><code>text-decoration</code></td><td>文本装饰线（下划线 &#x2F; 删除线等）</td><td><code>none</code>（无装饰，默认，常用於清除 <code>&lt;a&gt;</code> 标签下划线）、<code>underline</code>（下划线）、<code>line-through</code>（删除线）、<code>overline</code>（上划线）；可加颜色（如 <code>underline red</code>）</td><td><code>text-decoration: none;</code>（清除 a 标签下划线）</td></tr><tr><td><code>text-transform</code></td><td>英文文本大小写转换</td><td><code>none</code>（默认）、<code>uppercase</code>（全大写）、<code>lowercase</code>（全小写）、<code>capitalize</code>（首字母大写）</td><td><code>text-transform: uppercase;</code>（英文全大写）</td></tr><tr><td><code>white-space</code></td><td>空白字符处理（换行 &#x2F; 空格）</td><td><code>normal</code>（默认，合并空格 + 自动换行）、<code>nowrap</code>（不换行，溢出隐藏或滚动）、<code>pre</code>（保留空格和换行，类似 <code>&lt;pre&gt;</code> 标签）</td><td><code>white-space: nowrap;</code>（强制不换行）</td></tr><tr><td><code>overflow-wrap</code></td><td>长文本换行（防止溢出）</td><td><code>normal</code>（默认）、<code>break-word</code>（单词内换行，适合中文 &#x2F; 长英文单词）</td><td><code>overflow-wrap: break-word;</code>（避免长文本撑破容器）</td></tr></tbody></table><h3 id="文本属性常用示例（段落排版）"><a href="#文本属性常用示例（段落排版）" class="headerlink" title="文本属性常用示例（段落排版）"></a>文本属性常用示例（段落排版）</h3><pre><code class="css">.paragraph &#123;  text-align: justify; /* 两端对齐 */  text-indent: 2em; /* 首行缩进2字 */  letter-spacing: 0.5px; /* 字符间距轻微加宽 */  line-height: 1.8; /* 行高优化可读性 */  overflow-wrap: break-word; /* 长文本换行 */&#125;a &#123;  text-decoration: none; /* 清除下划线 */  color: #0066cc;&#125;a:hover &#123;  text-decoration: underline; /* hover 时显示下划线 */&#125;</code></pre><h2 id="四、表格属性（控制表格样式）"><a href="#四、表格属性（控制表格样式）" class="headerlink" title="四、表格属性（控制表格样式）"></a>四、表格属性（控制表格样式）</h2><p>用于设置表格的 <strong>边框、间距、对齐、单元格样式</strong> 等，默认表格样式简陋，需通过 CSS 美化。</p><table><thead><tr><th>属性名</th><th>作用</th><th>取值 &#x2F; 说明</th><th>示例</th></tr></thead><tbody><tr><td><code>border-collapse</code></td><td>表格边框合并（核心）</td><td><code>collapse</code>（边框合并，推荐）、<code>separate</code>（边框分离，默认，有间距）</td><td><code>border-collapse: collapse;</code>（消除边框间隙）</td></tr><tr><td><code>border-spacing</code></td><td>表格边框间距（仅 <code>separate</code> 时有效）</td><td>数值（<code>5px</code> 间距）、<code>0</code>（无间距）</td><td><code>border-spacing: 2px;</code></td></tr><tr><td><code>table-layout</code></td><td>表格布局算法</td><td><code>auto</code>（默认，自适应内容宽度）、<code>fixed</code>（固定列宽，性能更好，需设置 <code>width</code>）</td><td><code>table-layout: fixed;</code>（固定表格宽度）</td></tr><tr><td><code>width/height</code></td><td>表格 &#x2F; 单元格宽高</td><td>数值（<code>600px</code>）、百分比（<code>100%</code> 自适应父容器）</td><td><code>width: 100%;</code>（表格占满父容器）</td></tr><tr><td><code>text-align</code></td><td>单元格文本水平对齐</td><td>继承文本属性的 <code>left/center/right/justify</code></td><td><code>td &#123; text-align: center; &#125;</code>（单元格文本居中）</td></tr><tr><td><code>vertical-align</code></td><td>单元格文本垂直对齐（核心）</td><td><code>middle</code>（垂直居中，常用）、<code>top</code>（顶部对齐）、<code>bottom</code>（底部对齐）、<code>baseline</code>（基线对齐）</td><td><code>td &#123; vertical-align: middle; &#125;</code>（单元格垂直居中）</td></tr><tr><td><code>border</code></td><td>表格 &#x2F; 单元格边框</td><td>复合属性（<code>宽度 样式 颜色</code>），如 <code>1px solid #ddd</code>（1px 灰色实线）</td><td><code>table, td, th &#123; border: 1px solid #ddd; &#125;</code></td></tr><tr><td><code>empty-cells</code></td><td>空单元格是否显示边框</td><td><code>show</code>（显示，默认）、<code>hide</code>（隐藏空单元格边框）</td><td><code>empty-cells: hide;</code></td></tr></tbody></table><h3 id="表格属性常用示例（美化表格）"><a href="#表格属性常用示例（美化表格）" class="headerlink" title="表格属性常用示例（美化表格）"></a>表格属性常用示例（美化表格）</h3><pre><code class="html">&lt;!-- HTML 结构 --&gt;&lt;table class=&quot;beautiful-table&quot;&gt;  &lt;thead&gt;    &lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;城市&lt;/th&gt;&lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;北京&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td&gt;李四&lt;/td&gt;&lt;td&gt;30&lt;/td&gt;&lt;td&gt;上海&lt;/td&gt;&lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;</code></pre><pre><code class="css">/* CSS 样式 */.beautiful-table &#123;  width: 100%; /* 占满父容器 */  border-collapse: collapse; /* 边框合并 */  table-layout: fixed; /* 固定列宽 */  font-size: 14px;&#125;.beautiful-table th,.beautiful-table td &#123;  border: 1px solid #e8e8e8; /* 边框颜色 */  padding: 12px 8px; /* 单元格内边距 */  text-align: center; /* 水平居中 */  vertical-align: middle; /* 垂直居中 */&#125;.beautiful-table th &#123;  background-color: #f8f8f8; /* 表头背景色 */  font-weight: 600; /* 表头文字加粗 */  color: #333;&#125;/* 奇偶行交替颜色（斑马纹） */.beautiful-table tbody tr:nth-child(even) &#123;  background-color: #fafafa;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发中最常用的 &lt;strong&gt;字体、背景、文本、表格&lt;/strong&gt; 属性，包含语法、取值、示例，兼顾实用性和易理解性，直接可复制到项目中使用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="web前端" scheme="http://example.com/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSS简介与基础语法</title>
    <link href="http://example.com/2025/11/07/CSS%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2025/11/07/CSS%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2025-11-07T13:20:09.000Z</published>
    <updated>2025-11-07T14:54:56.268Z</updated>
    
    <content type="html"><![CDATA[<p>CSS（层叠样式表）的核心作用是为 HTML 元素设置样式，其语法规则简洁清晰，核心由「选择器」「声明块」「属性 - 值对」三部分构成，同时包含注释、引入方式等基础规范。</p><span id="more"></span><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="一、核心语法结构"><a href="#一、核心语法结构" class="headerlink" title="一、核心语法结构"></a>一、核心语法结构</h2><p>CSS 规则的基本格式如下，核心是「选中元素 + 定义样式」：</p><pre><code class="css">/* 选择器：指定要样式化的 HTML 元素 */选择器 &#123;  /* 声明块：包裹一组样式声明（属性-值对） */  属性1: 值1; /* 样式声明：属性和值用冒号分隔，结尾必须加分号（可省略最后一个，但推荐都加） */  属性2: 值2;&#125;</code></pre><h3 id="1-关键组成部分说明"><a href="#1-关键组成部分说明" class="headerlink" title="1. 关键组成部分说明"></a>1. 关键组成部分说明</h3><table><thead><tr><th>组成部分</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>选择器</td><td>定位 HTML 中需要样式化的元素（如标签、类、ID 等）</td><td><code>p</code>（选中所有 &#96;&#96; 标签）、<code>.box</code>（选中所有 <code>class=&quot;box&quot;</code> 的元素）</td></tr><tr><td>声明块</td><td>用 <code>&#123;&#125;</code> 包裹，包含一个或多个样式声明</td><td><code>&#123; color: red; font-size: 16px; &#125;</code></td></tr><tr><td>属性</td><td>CSS 预定义的样式名（如颜色、字体、宽度等）</td><td><code>color</code>（文字颜色）、<code>width</code>（宽度）、<code>background</code>（背景）</td></tr><tr><td>值</td><td>对应属性的具体设置（需符合属性的取值规范）</td><td><code>red</code>（颜色值）、<code>16px</code>（尺寸值）、<code>center</code>（对齐方式）</td></tr></tbody></table><h3 id="2-基础示例"><a href="#2-基础示例" class="headerlink" title="2. 基础示例"></a>2. 基础示例</h3><pre><code class="css">/* 选中所有 &lt;h1&gt; 标签，设置文字颜色红色、字体大小 24px */h1 &#123;  color: red;  font-size: 24px;&#125;/* 选中 class=&quot;container&quot; 的元素，设置宽度 1200px、水平居中 */.container &#123;  width: 1200px;  margin: 0 auto;&#125;</code></pre><h2 id="二、选择器：如何选中元素？"><a href="#二、选择器：如何选中元素？" class="headerlink" title="二、选择器：如何选中元素？"></a>二、选择器：如何选中元素？</h2><p>选择器是 CSS 的核心，用于精准定位 HTML 元素，以下是最常用的基础选择器：</p><table><thead><tr><th>选择器类型</th><th>语法</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>元素选择器</td><td>标签名</td><td>选中所有该标签的元素</td><td><code>div &#123; ... &#125;</code>（选中所有 <code>&lt;div&gt;</code>）</td></tr><tr><td>类选择器</td><td><code>.类名</code></td><td>选中所有 <code>class=&quot;类名&quot;</code> 的元素（可复用）</td><td><code>.active &#123; color: blue; &#125;</code>（选中 <code>&lt;p class=&quot;active&quot;&gt;</code>）</td></tr><tr><td>ID 选择器</td><td><code>#ID名</code></td><td>选中唯一 <code>id=&quot;ID名&quot;</code> 的元素（不可重复）</td><td><code>#header &#123; height: 80px; &#125;</code>（选中 <code>&lt;header id=&quot;header&quot;&gt;</code>）</td></tr><tr><td>通配符选择器</td><td><code>*</code></td><td>选中页面所有元素（慎用，性能较低）</td><td><code>* &#123; margin: 0; padding: 0; &#125;</code>（清除所有元素默认边距）</td></tr><tr><td>后代选择器</td><td>选择器 1 选择器 2</td><td>选中选择器 1 内部的所有选择器 2 元素</td><td><code>nav a &#123; text-decoration: none; &#125;</code>（选中 <code>&lt;nav&gt;</code> 内所有 <code>&lt;a&gt;</code>）</td></tr><tr><td>交集选择器</td><td>选择器 1 选择器 2</td><td>同时满足两个选择器的元素（无空格）</td><td><code>p.active &#123; font-weight: bold; &#125;</code>（选中 <code>&lt;p class=&quot;active&quot;&gt;</code>）</td></tr><tr><td>并集选择器</td><td>选择器 1, 选择器 2</td><td>同时选中多个选择器的元素（用逗号分隔）</td><td><code>h1, h2, h3 &#123; color: #333; &#125;</code>（选中所有 <code>h1/h2/h3</code>）</td></tr></tbody></table><h2 id="三、样式声明：属性与值的规则"><a href="#三、样式声明：属性与值的规则" class="headerlink" title="三、样式声明：属性与值的规则"></a>三、样式声明：属性与值的规则</h2><h3 id="1-属性值的常见类型"><a href="#1-属性值的常见类型" class="headerlink" title="1. 属性值的常见类型"></a>1. 属性值的常见类型</h3><p>CSS 属性值需符合对应属性的规范，常见类型：</p><ul><li>颜色值：<code>red</code>（英文）、<code>#ff0000</code>（十六进制）、<code>rgb(255,0,0)</code>（RGB）、<code>rgba(255,0,0,0.5)</code>（带透明度）</li><li>尺寸值：<code>10px</code>（像素，固定尺寸）、<code>2em</code>（相对当前字体大小）、<code>50%</code>（相对父元素尺寸）、<code>auto</code>（自动）</li><li>关键字：<code>center</code>（居中）、<code>block</code>（块级）、<code>none</code>（无）、<code>bold</code>（加粗）</li></ul><h3 id="2-声明的注意事项"><a href="#2-声明的注意事项" class="headerlink" title="2. 声明的注意事项"></a>2. 声明的注意事项</h3><ul><li>分号必须：每个声明结尾必须加 <code>;</code>，否则后续样式可能失效（最后一个声明可省略，但推荐统一添加，避免出错）</li><li>大小写不敏感：CSS 对大小写不敏感（如 <code>Color: Red</code> 等价于 <code>color: red</code>），但建议统一小写（规范）</li><li>空格不影响：声明中可适当加空格（如 <code>font-size: 16px</code> 等价于 <code>font-size:16px</code>），增强可读性</li></ul><h2 id="四、注释：代码说明（不生效）"><a href="#四、注释：代码说明（不生效）" class="headerlink" title="四、注释：代码说明（不生效）"></a>四、注释：代码说明（不生效）</h2><p>CSS 注释用于解释代码，浏览器会忽略注释内容，语法：</p><pre><code class="css">/* 单行注释 */p &#123;  color: #333; /* 文字颜色：深灰色（行内注释） */&#125;/*  多行注释  选中 .box 元素，设置背景色和内边距*/.box &#123;  background: #f5f5f5;  padding: 20px;&#125;</code></pre><blockquote><p>注意：CSS 没有 <code>//</code> 注释语法，<code>//</code> 会导致后续代码失效！</p></blockquote><h2 id="五、CSS-的引入方式（3-种核心）"><a href="#五、CSS-的引入方式（3-种核心）" class="headerlink" title="五、CSS 的引入方式（3 种核心）"></a>五、CSS 的引入方式（3 种核心）</h2><p>CSS 需引入 HTML 才能生效，3 种常用方式：</p><h3 id="1-内联样式（行内样式）"><a href="#1-内联样式（行内样式）" class="headerlink" title="1. 内联样式（行内样式）"></a>1. 内联样式（行内样式）</h3><p>直接写在 HTML 元素的 <code>style</code> 属性中，优先级最高（仅作用于当前元素）：</p><pre><code class="html">&lt;p style=&quot;color: green; font-size: 18px;&quot;&gt;这是内联样式的文字&lt;/p&gt;</code></pre><blockquote><p>缺点：样式与结构耦合，复用性差，仅适合临时修改单个元素。</p></blockquote><h3 id="2-内部样式表（嵌入式）"><a href="#2-内部样式表（嵌入式）" class="headerlink" title="2. 内部样式表（嵌入式）"></a>2. 内部样式表（嵌入式）</h3><p>写在 HTML 的 <code>标签中（通常放在</code> 内），作用于当前 HTML 文件：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;style&gt;    /* 内部样式表 */    h1 &#123; color: purple; &#125;    .content &#123; line-height: 1.5; &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;标题&lt;/h1&gt;  &lt;div class=&quot;content&quot;&gt;内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>优点：样式与结构分离（同一文件内），适合单页面样式。</p></blockquote><h3 id="3-外部样式表（链接式）"><a href="#3-外部样式表（链接式）" class="headerlink" title="3. 外部样式表（链接式）"></a>3. 外部样式表（链接式）</h3><p>将 CSS 写在独立的 <code>.css</code> 文件中，通过 &#96;&#96; 标签引入 HTML，最推荐（复用性强、维护方便）：</p><h4 id="步骤-1：创建-CSS-文件（如-style-css）"><a href="#步骤-1：创建-CSS-文件（如-style-css）" class="headerlink" title="步骤 1：创建 CSS 文件（如 style.css）"></a>步骤 1：创建 CSS 文件（如 <code>style.css</code>）</h4><pre><code class="css">/* style.css */body &#123; background: #f9f9f9; &#125;a &#123; color: #0066cc; text-decoration: none; &#125;</code></pre><h4 id="步骤-2：HTML-中引入"><a href="#步骤-2：HTML-中引入" class="headerlink" title="步骤 2：HTML 中引入"></a>步骤 2：HTML 中引入</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;!-- 引入外部 CSS 文件 --&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;a href=&quot;#&quot;&gt;这是链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>优点：样式与结构完全分离，多个页面可共用一个 CSS 文件，便于统一维护。</p></blockquote><h2 id="六、基础语法总结"><a href="#六、基础语法总结" class="headerlink" title="六、基础语法总结"></a>六、基础语法总结</h2><ol><li>核心结构：<code>选择器 &#123; 属性: 值; &#125;</code></li><li>选择器：优先掌握「类选择器」「元素选择器」「后代选择器」（最常用）</li><li>声明：属性和值需匹配，分号不能漏，注释用 <code>/* */</code></li><li>引入方式：推荐「外部样式表」，少量样式可用「内部样式表」，避免滥用「内联样式」</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSS（层叠样式表）的核心作用是为 HTML 元素设置样式，其语法规则简洁清晰，核心由「选择器」「声明块」「属性 - 值对」三部分构成，同时包含注释、引入方式等基础规范。&lt;/p&gt;</summary>
    
    
    
    
    <category term="web前端" scheme="http://example.com/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://example.com/2025/11/07/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://example.com/2025/11/07/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2025-11-07T10:54:19.000Z</published>
    <updated>2025-11-07T13:14:11.751Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表（Hash Table），也叫散列表，是一种<strong>基于哈希函数</strong>实现的高效数据结构，核心目标是在 <strong>O (1) 平均时间复杂度</strong> 内完成插入、查找、删除操作，是工程中最常用的数据结构之一（例如 Java 的 HashMap、Python 的 dict、C++ 的 unordered_map 等底层均基于哈希表实现）。</p><span id="more"></span><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="一、哈希表的核心思想"><a href="#一、哈希表的核心思想" class="headerlink" title="一、哈希表的核心思想"></a>一、哈希表的核心思想</h2><p>哈希表的本质是 <strong>“键（Key）→ 值（Value）” 的映射</strong>，核心解决 “如何快速通过 Key 找到 Value” 的问题：</p><ol><li>传统数组：通过<strong>索引</strong>访问元素（O (1)），但索引是连续整数，无法直接映射非整数 Key（如字符串、对象）；</li><li>链表 &#x2F; 二叉搜索树：查找需遍历（O (n) 或 O (log n)），效率较低；</li><li>哈希表的方案：<ul><li>用<strong>哈希函数</strong>将任意类型的 Key 转换为一个整数（称为 “哈希值”）；</li><li>将哈希值映射为数组的索引（通过取模等操作）；</li><li>数组的该索引位置存储对应的 Value，实现 “Key→索引→Value” 的快速映射。</li></ul></li></ol><p>简单说：<strong>哈希函数是 “翻译官”，将 Key 翻译成数组能理解的索引；数组是 “存储容器”，直接通过索引存取数据</strong>。</p><h2 id="二、哈希表的核心组成"><a href="#二、哈希表的核心组成" class="headerlink" title="二、哈希表的核心组成"></a>二、哈希表的核心组成</h2><p>哈希表由 3 个核心部分构成：</p><table><thead><tr><th>组成部分</th><th>作用</th></tr></thead><tbody><tr><td>键（Key）</td><td>唯一标识（如用户名、ID），需支持哈希函数计算（不可变类型，如整数、字符串、元组）</td></tr><tr><td>哈希函数（Hash Function）</td><td>将 Key 转换为哈希值（整数），要求：① 相同 Key 必须得到相同哈希值；② 尽量分散不同 Key 的哈希值</td></tr><tr><td>哈希桶（Hash Bucket）</td><td>存储数据的数组（“桶” 即数组的每个元素位置），通过哈希值映射到桶的索引</td></tr></tbody></table><h3 id="1-哈希函数的设计原则"><a href="#1-哈希函数的设计原则" class="headerlink" title="1. 哈希函数的设计原则"></a>1. 哈希函数的设计原则</h3><p>哈希函数的质量直接决定哈希表的效率，需满足以下要求：</p><ul><li><strong>确定性</strong>：同一 Key 多次计算，哈希值必须相同（否则无法找到对应 Value）；</li><li><strong>高效性</strong>：计算过程简单，时间复杂度 O (1)（不能比查找本身更耗时）；</li><li><strong>均匀性</strong>：不同 Key 的哈希值尽量均匀分布在哈希桶的索引范围内（减少 “哈希冲突”）；</li><li><strong>抗碰撞性</strong>：尽量避免不同 Key 计算出相同哈希值（完全避免不可能，需后续解决）。</li></ul><h4 id="常见哈希函数示例"><a href="#常见哈希函数示例" class="headerlink" title="常见哈希函数示例"></a>常见哈希函数示例</h4><ul><li>整数 Key：直接用 Key 本身（或对桶数取模）；</li><li>字符串 Key：多项式哈希（如 <code>hash = s[0]*base^(n-1) + s[1]*base^(n-2) + ... + s[n-1]</code>，base 取 31&#x2F;127 等质数）；</li><li>对象 Key：结合对象的多个属性计算哈希值（如 Java 的 <code>hashCode()</code> 方法）。</li></ul><h3 id="2-哈希冲突（Hash-Collision）"><a href="#2-哈希冲突（Hash-Collision）" class="headerlink" title="2. 哈希冲突（Hash Collision）"></a>2. 哈希冲突（Hash Collision）</h3><h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p>不同的 Key 通过哈希函数计算后，得到了<strong>相同的哈希值</strong>，进而映射到同一个哈希桶索引，这种情况称为哈希冲突。</p><p>例如：Key1 &#x3D; “abc”，Key2 &#x3D; “cba”，可能通过哈希函数计算后得到相同的哈希值，映射到同一个桶。</p><h4 id="为什么冲突无法避免？"><a href="#为什么冲突无法避免？" class="headerlink" title="为什么冲突无法避免？"></a>为什么冲突无法避免？</h4><p>根据 <strong>鸽巢原理</strong>：若哈希桶的数量为 M，待存储的 Key 数量为 N，当 N &gt; M 时，必然有至少两个 Key 映射到同一个桶。即使 N ≤ M，也可能因哈希函数的分布性不足导致冲突。</p><h3 id="3-哈希冲突的解决方法"><a href="#3-哈希冲突的解决方法" class="headerlink" title="3. 哈希冲突的解决方法"></a>3. 哈希冲突的解决方法</h3><p>工程中最常用的两种方案：<strong>链地址法（拉链法）</strong> 和 <strong>开放地址法</strong>。</p><h4 id="（1）链地址法（拉链法）——-最常用"><a href="#（1）链地址法（拉链法）——-最常用" class="headerlink" title="（1）链地址法（拉链法）—— 最常用"></a>（1）链地址法（拉链法）—— 最常用</h4><ul><li><strong>核心思路</strong>：每个哈希桶中存储一个链表（或红黑树），当冲突发生时，将冲突的 Key-Value 对加入到链表的尾部。</li><li><strong>查询过程</strong>：<ol><li>计算 Key 的哈希值 → 映射到桶索引；</li><li>遍历该桶的链表，对比每个节点的 Key（哈希值可能相同，但 Key 本身不同）；</li><li>找到匹配的 Key 则返回 Value，否则返回不存在。</li></ol></li><li><strong>优点</strong>：<ul><li>实现简单，冲突处理高效；</li><li>不会导致其他桶的占用（开放地址法可能出现 “聚集” 问题）；</li><li>负载因子（存储元素数 &#x2F; 桶数）可大于 1（链表可无限延伸，但效率会下降）。</li></ul></li><li><strong>优化</strong>：当链表长度超过阈值（如 Java HashMap 阈值为 8），会将链表转为红黑树，将查询时间复杂度从 O (k) 优化为 O (log k)（k 为链表长度）。</li></ul><h4 id="（2）开放地址法"><a href="#（2）开放地址法" class="headerlink" title="（2）开放地址法"></a>（2）开放地址法</h4><ul><li><strong>核心思路</strong>：当冲突发生时，不使用链表存储，而是在哈希桶数组中重新寻找一个 “空闲桶” 存储数据。</li><li><strong>常见探测方式</strong>：<ul><li>线性探测：冲突后依次检查下一个桶（<code>index+1, index+2, ...</code>），直到找到空闲桶；</li><li>二次探测：冲突后检查 <code>index+1², index-1², index+2², index-2², ...</code>（避免线性探测的 “聚集” 问题）；</li><li>双重哈希：使用第二个哈希函数计算探测步长（<code>step = hash2(Key)</code>），避免聚集。</li></ul></li><li><strong>优点</strong>：无需额外存储链表节点，空间利用率更高；</li><li><strong>缺点</strong>：<ul><li>会出现 “聚集现象”（多个冲突 Key 连续占用桶，导致后续插入 &#x2F; 查询需多次探测）；</li><li>负载因子不能太大（通常 ≤ 0.7），否则探测次数会急剧增加；</li><li>删除元素时不能直接置空（会破坏探测链），需标记为 “已删除”，增加复杂度。</li></ul></li></ul><h4 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h4><ul><li>再哈希法：冲突时使用另一个哈希函数重新计算哈希值，直到找到空闲桶；</li><li>公共溢出区：将所有冲突的元素统一存储到一个 “溢出桶” 中，查询时先查原桶，再查溢出桶。</li></ul><h2 id="三、哈希表的关键参数：负载因子"><a href="#三、哈希表的关键参数：负载因子" class="headerlink" title="三、哈希表的关键参数：负载因子"></a>三、哈希表的关键参数：负载因子</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>负载因子（Load Factor）&#x3D; 哈希表中存储的元素个数（N） &#x2F; 哈希桶的数量（M），即 <code>α = N/M</code>。</p><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><p>负载因子是衡量哈希表 “拥挤程度” 的核心指标：</p><ul><li>α 越小：桶的空闲率越高，冲突概率越低，查询 &#x2F; 插入效率越高，但空间利用率低；</li><li>α 越大：桶的空闲率越低，冲突概率越高，查询 &#x2F; 插入效率越低（链表变长或探测次数增多）。</li></ul><h3 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h3><p>当负载因子超过阈值（工程中通常为 0.7），哈希表会自动进行 <strong>扩容</strong>：</p><ol><li>创建一个新的、容量更大的哈希桶数组（通常是原容量的 2 倍）；</li><li>重新计算所有原有元素的哈希值（因桶数变化，映射的索引会改变）；</li><li>将原有元素迁移到新的哈希桶中（该过程称为 “rehash”）。</li></ol><p>扩容的时间复杂度是 O (N)（需迁移所有元素），但因扩容是<strong>阶段性触发</strong>（平均每个元素只参与一次扩容），所以哈希表的平均时间复杂度仍为 O (1)。</p><h2 id="四、哈希表的时间复杂度"><a href="#四、哈希表的时间复杂度" class="headerlink" title="四、哈希表的时间复杂度"></a>四、哈希表的时间复杂度</h2><table><thead><tr><th>操作</th><th>平均时间复杂度</th><th>最坏时间复杂度（链地址法）</th><th>最坏时间复杂度（开放地址法）</th></tr></thead><tbody><tr><td>插入（put）</td><td>O(1)</td><td>O (k)（k 为链表长度，红黑树 O (log k)）</td><td>O (M)（桶满，需多次探测）</td></tr><tr><td>查找（get）</td><td>O(1)</td><td>O (k)（红黑树 O (log k)）</td><td>O(M)</td></tr><tr><td>删除（remove）</td><td>O(1)</td><td>O (k)（红黑树 O (log k)）</td><td>O(M)</td></tr></tbody></table><ul><li>最坏情况仅发生在：哈希函数设计极差（所有 Key 映射到同一个桶），或负载因子极大（未及时扩容）；</li><li>实际工程中，通过合理设计哈希函数和扩容机制，哈希表的操作基本接近 O (1)。</li></ul><h2 id="五、哈希表的应用场景"><a href="#五、哈希表的应用场景" class="headerlink" title="五、哈希表的应用场景"></a>五、哈希表的应用场景</h2><p>哈希表的核心优势是 “快速查找 &#x2F; 映射”，常见应用：</p><ol><li><strong>缓存系统</strong>：如 Redis（底层用哈希表 + 跳表），Key 是缓存键，Value 是缓存数据，实现 O (1) 存取；</li><li><strong>字典 &#x2F; 映射</strong>：如 Python 的 dict、Java 的 HashMap，存储键值对（如用户名→用户信息）；</li><li><strong>去重</strong>：如统计数组中不重复元素、日志去重，通过 Key 的唯一性快速判断元素是否已存在；</li><li><strong>哈希集合（HashSet）</strong>：基于哈希表实现，仅存储 Key（Value 为占位符），用于快速判断元素是否存在（如 Java 的 HashSet）；</li><li><strong>LRU 缓存</strong>：哈希表 + 双向链表实现，哈希表负责 O (1) 查找，双向链表负责维护访问顺序；</li><li><strong>计数统计</strong>：如统计字符串中字符出现次数（Key 是字符，Value 是次数）。</li></ol><h2 id="六、哈希表的优缺点"><a href="#六、哈希表的优缺点" class="headerlink" title="六、哈希表的优缺点"></a>六、哈希表的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>平均时间复杂度 O (1)，效率极高；</li><li>支持任意类型的 Key（只要能计算哈希值）；</li><li>实现简单，工程中成熟易用（大部分语言内置哈希表类）。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>哈希函数设计不当会导致冲突频繁，效率下降；</li><li>扩容时会产生性能开销（rehash 过程）；</li><li>元素存储无序（哈希值映射是随机的，无法保证插入顺序）；</li><li>空间利用率较低（需预留空闲桶以减少冲突）。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;哈希表（Hash Table），也叫散列表，是一种&lt;strong&gt;基于哈希函数&lt;/strong&gt;实现的高效数据结构，核心目标是在 &lt;strong&gt;O (1) 平均时间复杂度&lt;/strong&gt; 内完成插入、查找、删除操作，是工程中最常用的数据结构之一（例如 Java 的 HashMap、Python 的 dict、C++ 的 unordered_map 等底层均基于哈希表实现）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线段树与序列树</title>
    <link href="http://example.com/2025/10/30/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%BA%8F%E5%88%97%E6%A0%91/"/>
    <id>http://example.com/2025/10/30/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%BA%8F%E5%88%97%E6%A0%91/</id>
    <published>2025-10-30T15:10:36.000Z</published>
    <updated>2025-10-30T15:34:38.666Z</updated>
    
    <content type="html"><![CDATA[<p>QAQ</p><span id="more"></span><h1 id="线段树与序列树详解"><a href="#线段树与序列树详解" class="headerlink" title="线段树与序列树详解"></a>线段树与序列树详解</h1><h2 id="线段树（Segment-Tree）"><a href="#线段树（Segment-Tree）" class="headerlink" title="线段树（Segment Tree）"></a>线段树（Segment Tree）</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p><strong>线段树</strong>是一种二叉树数据结构，主要用于解决<strong>区间查询</strong>和<strong>区间更新</strong>问题。</p><h3 id="二、核心特性"><a href="#二、核心特性" class="headerlink" title="二、核心特性"></a>二、核心特性</h3><ul><li><strong>适用场景</strong>：区间求和、区间最值、区间更新等</li><li><strong>时间复杂度</strong>：<ul><li>建树：O(n)</li><li>区间查询：O(log n)</li><li>单点更新：O(log n)</li><li>区间更新：O(log n)（使用懒惰传播）</li></ul></li><li><strong>空间复杂度</strong>：O(4n)（数组实现）</li></ul><h3 id="三、数据结构定义"><a href="#三、数据结构定义" class="headerlink" title="三、数据结构定义"></a>三、数据结构定义</h3><pre><code class="c++">class SegmentTree &#123;private:    vector&lt;int&gt; tree;  // 线段树数组    vector&lt;int&gt; arr;   // 原始数组    vector&lt;int&gt; lazy;  // 懒惰标记数组（用于区间更新）    int n;    public:    SegmentTree(vector&lt;int&gt;&amp; nums) &#123;        n = nums.size();        arr = nums;        tree.resize(4 * n);        lazy.resize(4 * n, 0);        build(0, n-1, 0);    &#125;&#125;;</code></pre><h3 id="四、建树过程"><a href="#四、建树过程" class="headerlink" title="四、建树过程"></a>四、建树过程</h3><pre><code class="c++">// 递归建树void build(int start, int end, int node) &#123;    if (start == end) &#123;        // 叶子节点，存储单个元素        tree[node] = arr[start];        return;    &#125;        int mid = (start + end) / 2;    int leftNode = 2 * node + 1;    int rightNode = 2 * node + 2;        // 递归构建左右子树    build(start, mid, leftNode);    build(mid + 1, end, rightNode);        // 合并左右子树结果（这里是求和）    tree[node] = tree[leftNode] + tree[rightNode];&#125;</code></pre><h3 id="五、区间查询"><a href="#五、区间查询" class="headerlink" title="五、区间查询"></a>五、区间查询</h3><pre><code class="c++">// 查询区间 [l, r] 的和int query(int l, int r, int start, int end, int node) &#123;    if (l &lt;= start &amp;&amp; end &lt;= r) &#123;        // 当前区间完全在查询范围内        return tree[node];    &#125;        int mid = (start + end) / 2;    int leftNode = 2 * node + 1;    int rightNode = 2 * node + 2;    int sum = 0;        if (l &lt;= mid) &#123;        sum += query(l, r, start, mid, leftNode);    &#125;    if (r &gt; mid) &#123;        sum += query(l, r, mid + 1, end, rightNode);    &#125;        return sum;&#125;// 对外接口int queryRange(int l, int r) &#123;    return query(l, r, 0, n-1, 0);&#125;</code></pre><h3 id="六、单点更新"><a href="#六、单点更新" class="headerlink" title="六、单点更新"></a>六、单点更新</h3><pre><code class="c++">// 更新单个元素void update(int index, int value, int start, int end, int node) &#123;    if (start == end) &#123;        // 找到目标叶子节点        arr[index] = value;        tree[node] = value;        return;    &#125;        int mid = (start + end) / 2;    int leftNode = 2 * node + 1;    int rightNode = 2 * node + 2;        if (index &lt;= mid) &#123;        update(index, value, start, mid, leftNode);    &#125; else &#123;        update(index, value, mid + 1, end, rightNode);    &#125;        // 更新父节点    tree[node] = tree[leftNode] + tree[rightNode];&#125;</code></pre><h3 id="七、懒惰传播（区间更新）"><a href="#七、懒惰传播（区间更新）" class="headerlink" title="七、懒惰传播（区间更新）"></a>七、懒惰传播（区间更新）</h3><pre><code class="c++">// 懒惰传播更新void updateLazy(int l, int r, int value, int start, int end, int node) &#123;    // 先处理懒惰标记    if (lazy[node] != 0) &#123;        tree[node] += (end - start + 1) * lazy[node];        if (start != end) &#123;            // 将懒惰标记传递给子节点            lazy[2*node+1] += lazy[node];            lazy[2*node+2] += lazy[node];        &#125;        lazy[node] = 0;    &#125;        if (start &gt; r || end &lt; l) return; // 完全不重叠        if (l &lt;= start &amp;&amp; end &lt;= r) &#123;        // 当前区间完全在更新范围内        tree[node] += (end - start + 1) * value;        if (start != end) &#123;            lazy[2*node+1] += value;            lazy[2*node+2] += value;        &#125;        return;    &#125;        int mid = (start + end) / 2;    updateLazy(l, r, value, start, mid, 2*node+1);    updateLazy(l, r, value, mid+1, end, 2*node+2);    tree[node] = tree[2*node+1] + tree[2*node+2];&#125;</code></pre><h2 id="序列树（树状数组）"><a href="#序列树（树状数组）" class="headerlink" title="序列树（树状数组）"></a>序列树（树状数组）</h2><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-什么是序列树？"><a href="#1-1-什么是序列树？" class="headerlink" title="1.1 什么是序列树？"></a>1.1 什么是序列树？</h3><p><strong>序列树（Fenwick Tree &#x2F; Binary Indexed Tree）</strong> 是一种用于高效处理<strong>前缀和查询</strong>和<strong>单点更新</strong>的数据结构。</p><h3 id="1-2-核心思想"><a href="#1-2-核心思想" class="headerlink" title="1.2 核心思想"></a>1.2 核心思想</h3><p>利用<strong>二进制表示</strong>的特性，将前缀和分解为多个子区间的和，从而实现：</p><ul><li><strong>前缀和查询</strong>：O(log n)</li><li><strong>单点更新</strong>：O(log n)</li></ul><h2 id="二、核心原理-Lowbit操作"><a href="#二、核心原理-Lowbit操作" class="headerlink" title="二、核心原理 - Lowbit操作"></a>二、核心原理 - Lowbit操作</h2><h3 id="2-1-Lowbit定义"><a href="#2-1-Lowbit定义" class="headerlink" title="2.1 Lowbit定义"></a>2.1 Lowbit定义</h3><p>**Lowbit(x)**：获取x的二进制表示中最低位的1所代表的数值</p><pre><code class="c++">int lowbit(int x) &#123;    return x &amp; (-x);&#125;</code></pre><h3 id="2-2-Lowbit示例"><a href="#2-2-Lowbit示例" class="headerlink" title="2.2 Lowbit示例"></a>2.2 Lowbit示例</h3><pre><code>x = 6  (二进制: 110)  → lowbit(6) = 2  (二进制: 010)x = 12 (二进制: 1100) → lowbit(12) = 4 (二进制: 0100)x = 7  (二进制: 111)  → lowbit(7) = 1  (二进制: 001)</code></pre><h2 id="三、序列树的结构原理"><a href="#三、序列树的结构原理" class="headerlink" title="三、序列树的结构原理"></a>三、序列树的结构原理</h2><h3 id="3-1-基本结构"><a href="#3-1-基本结构" class="headerlink" title="3.1 基本结构"></a>3.1 基本结构</h3><p>序列树不是一棵显式的树，而是通过数组和下标关系隐含的树形结构。</p><p><strong>数组下标从1开始</strong>（重要！）</p><ul><li><code>tree[i]</code>：存储区间<code>[i - lowbit(i) + 1, i]</code>的和</li></ul><h3 id="3-2-存储区间示意图"><a href="#3-2-存储区间示意图" class="headerlink" title="3.2 存储区间示意图"></a>3.2 存储区间示意图</h3><p>对于长度为8的数组：</p><pre><code>tree[1] = arr[1]                                          [1,1]tree[2] = arr[1] + arr[2]                                 [1,2]  tree[3] = arr[3]                                          [3,3]tree[4] = arr[1] + arr[2] + arr[3] + arr[4]               [1,4]tree[5] = arr[5]                                          [5,5]tree[6] = arr[5] + arr[6]                                 [5,6]tree[7] = arr[7]                                          [7,7]tree[8] = arr[1] + arr[2] + ... + arr[8]                  [1,8]</code></pre><h3 id="3-3-树形结构关系"><a href="#3-3-树形结构关系" class="headerlink" title="3.3 树形结构关系"></a>3.3 树形结构关系</h3><pre><code>                tree[8]               /       \          tree[4]     tree[6]   tree[7]          /     \     /          tree[2] tree[3] tree[5]      /tree[1]</code></pre><h2 id="四、关键操作原理"><a href="#四、关键操作原理" class="headerlink" title="四、关键操作原理"></a>四、关键操作原理</h2><h3 id="4-1-单点更新原理"><a href="#4-1-单点更新原理" class="headerlink" title="4.1 单点更新原理"></a>4.1 单点更新原理</h3><p><strong>目标</strong>：更新<code>arr[i]</code>时，更新所有包含<code>arr[i]</code>的<code>tree</code>节点</p><p><strong>更新路径</strong>：沿着二进制下标不断加上lowbit(i)</p><ul><li>从<code>i</code>开始</li><li><code>i = i + lowbit(i)</code></li><li>重复直到<code>i &gt; n</code></li></ul><pre><code class="C++">void update(int index, int value) &#123;    int i = index + 1;  // 序列树下标从1开始    while (i &lt;= n) &#123;        tree[i] += value;        i += lowbit(i);  // 跳到父节点    &#125;&#125;</code></pre><h4 id="更新示例：更新arr-3-（即tree-4-中的元素）"><a href="#更新示例：更新arr-3-（即tree-4-中的元素）" class="headerlink" title="更新示例：更新arr[3]（即tree[4]中的元素）"></a>更新示例：更新arr[3]（即tree[4]中的元素）</h4><p>更新路径：3 → 4 → 8</p><pre><code>更新arr[3] = 5:1. tree[3] += 5    (包含arr[3])2. tree[4] += 5    (包含arr[1]-arr[4])  3. tree[8] += 5    (包含arr[1]-arr[8])</code></pre><h3 id="4-2-前缀和查询原理"><a href="#4-2-前缀和查询原理" class="headerlink" title="4.2 前缀和查询原理"></a>4.2 前缀和查询原理</h3><p><strong>目标</strong>：计算<code>arr[1] + arr[2] + ... + arr[i]</code>的和</p><p><strong>查询路径</strong>：沿着二进制下标不断减去lowbit(i)</p><ul><li>从<code>i</code>开始</li><li><code>i = i - lowbit(i)</code></li><li>重复直到<code>i == 0</code></li></ul><pre><code>int query(int index) &#123;    int sum = 0;    int i = index + 1;  // 序列树下标从1开始    while (i &gt; 0) &#123;        sum += tree[i];        i -= lowbit(i);  // 跳到前一个区间    &#125;    return sum;&#125;</code></pre><h4 id="查询示例：查询前缀和-1-7"><a href="#查询示例：查询前缀和-1-7" class="headerlink" title="查询示例：查询前缀和[1,7]"></a>查询示例：查询前缀和[1,7]</h4><p>查询路径：7 → 6 → 4 → 结束</p><pre><code>查询前缀和[1,7]:sum = tree[7] + tree[6] + tree[4]tree[7] = arr[7]                    [7,7]tree[6] = arr[5] + arr[6]           [5,6]  tree[4] = arr[1] + arr[2] + arr[3] + arr[4]  [1,4]总和 = arr[1]到arr[7]的和</code></pre><h2 id="五、数学原理深度解析"><a href="#五、数学原理深度解析" class="headerlink" title="五、数学原理深度解析"></a>五、数学原理深度解析</h2><h3 id="5-1-二进制分解原理"><a href="#5-1-二进制分解原理" class="headerlink" title="5.1 二进制分解原理"></a>5.1 二进制分解原理</h3><p><strong>关键观察</strong>：任何数字都可以表示为2的幂次之和</p><pre><code>7 = 4 + 2 + 113 = 8 + 4 + 1</code></pre><p>序列树利用这个性质将前缀和分解：</p><pre><code>sum[1,7] = sum[1,4] + sum[5,6] + sum[7,7]         = tree[4] + tree[6] + tree[7]</code></pre><h3 id="5-2-区间覆盖证明"><a href="#5-2-区间覆盖证明" class="headerlink" title="5.2 区间覆盖证明"></a>5.2 区间覆盖证明</h3><p><strong>定理</strong>：对于任意i，区间<code>[i-lowbit(i)+1, i]</code>的长度正好是<code>lowbit(i)</code></p><p><strong>证明</strong>：</p><ul><li>设<code>i</code>的二进制为：<code>xxxx100...0</code>（最后k个0）</li><li><code>lowbit(i) = 2^k</code></li><li><code>i - lowbit(i) = xxxx000...0</code></li><li>区间长度 &#x3D; <code>i - (i - lowbit(i)) = lowbit(i)</code></li></ul><h3 id="5-3-操作正确性证明"><a href="#5-3-操作正确性证明" class="headerlink" title="5.3 操作正确性证明"></a>5.3 操作正确性证明</h3><p><strong>更新正确性</strong>：每个被更新的节点确实包含目标元素</p><ul><li>因为更新路径是不断加上lowbit，覆盖的区间越来越大</li><li>每个父节点都包含子节点的区间</li></ul><p><strong>查询正确性</strong>：所有子区间正好覆盖<code>[1, i]</code></p><ul><li>每次减去lowbit，得到不相交的区间</li><li>这些区间的并集正好是<code>[1, i]</code></li></ul><h2 id="六、完整实现与示例"><a href="#六、完整实现与示例" class="headerlink" title="六、完整实现与示例"></a>六、完整实现与示例</h2><h3 id="6-1-完整序列树实现"><a href="#6-1-完整序列树实现" class="headerlink" title="6.1 完整序列树实现"></a>6.1 完整序列树实现</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class FenwickTree &#123;private:    vector&lt;int&gt; tree;    int n;        int lowbit(int x) &#123;        return x &amp; (-x);    &#125;    public:    // 构造函数：从数组构建    FenwickTree(vector&lt;int&gt;&amp; nums) &#123;        n = nums.size();        tree.resize(n + 1, 0);        for (int i = 0; i &lt; n; i++) &#123;            update(i, nums[i]);        &#125;    &#125;        // 单点更新：在位置index增加value    void update(int index, int value) &#123;        int i = index + 1;  // 转为1-based索引        while (i &lt;= n) &#123;            tree[i] += value;            i += lowbit(i);        &#125;    &#125;        // 查询前缀和：[0, index]的和    int query(int index) &#123;        int sum = 0;        int i = index + 1;  // 转为1-based索引        while (i &gt; 0) &#123;            sum += tree[i];            i -= lowbit(i);        &#125;        return sum;    &#125;        // 查询区间和：[l, r]的和    int queryRange(int l, int r) &#123;        if (l == 0) return query(r);        return query(r) - query(l - 1);    &#125;        // 打印树结构（用于调试）    void printTree() &#123;        cout &lt;&lt; &quot;序列树结构:&quot; &lt;&lt; endl;        for (int i = 1; i &lt;= n; i++) &#123;            cout &lt;&lt; &quot;tree[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; tree[i]                  &lt;&lt; &quot; (覆盖区间: [&quot; &lt;&lt; i - lowbit(i) + 1 &lt;&lt; &quot;, &quot; &lt;&lt; i &lt;&lt; &quot;])&quot; &lt;&lt; endl;        &#125;    &#125;&#125;;</code></pre><h3 id="6-2-运行示例"><a href="#6-2-运行示例" class="headerlink" title="6.2 运行示例"></a>6.2 运行示例</h3><pre><code class="c++">int main() &#123;    vector&lt;int&gt; arr = &#123;1, 3, 5, 7, 9, 11&#125;;    FenwickTree ft(arr);        ft.printTree();        cout &lt;&lt; &quot;\n前缀和查询:&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;前缀和[0,2]: &quot; &lt;&lt; ft.query(2) &lt;&lt; &quot; (应为: 1+3+5=9)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;前缀和[0,4]: &quot; &lt;&lt; ft.query(4) &lt;&lt; &quot; (应为: 1+3+5+7+9=25)&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;\n区间和查询:&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;区间[2,4]: &quot; &lt;&lt; ft.queryRange(2, 4) &lt;&lt; &quot; (应为: 5+7+9=21)&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;\n更新测试:&quot; &lt;&lt; endl;    ft.update(3, 10);  // arr[3]从7增加到17    cout &lt;&lt; &quot;更新后区间[2,4]: &quot; &lt;&lt; ft.queryRange(2, 4) &lt;&lt; &quot; (应为: 5+17+9=31)&quot; &lt;&lt; endl;        return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;QAQ&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树与哈夫曼编码</title>
    <link href="http://example.com/2025/10/30/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <id>http://example.com/2025/10/30/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</id>
    <published>2025-10-30T14:54:11.000Z</published>
    <updated>2025-11-01T14:51:48.479Z</updated>
    
    <content type="html"><![CDATA[<p>QAQ</p><span id="more"></span><h1 id="哈夫曼树与哈夫曼编码详解"><a href="#哈夫曼树与哈夫曼编码详解" class="headerlink" title="哈夫曼树与哈夫曼编码详解"></a>哈夫曼树与哈夫曼编码详解</h1><h2 id="一、哈夫曼树构建原理"><a href="#一、哈夫曼树构建原理" class="headerlink" title="一、哈夫曼树构建原理"></a>一、哈夫曼树构建原理</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p><strong>哈夫曼树（Huffman Tree）</strong>：是一种带权路径长度最短的二叉树，也称为最优二叉树。</p><p><strong>关键术语：</strong></p><ul><li><strong>权值（Weight）</strong>：每个字符的出现频率或概率</li><li><strong>路径长度</strong>：从根节点到该节点的边数</li><li><strong>节点的带权路径长度</strong>：权值 × 路径长度</li><li><strong>树的带权路径长度（WPL）</strong>：所有叶子节点的带权路径长度之和</li></ul><h3 id="1-2-构建算法步骤"><a href="#1-2-构建算法步骤" class="headerlink" title="1.2 构建算法步骤"></a>1.2 构建算法步骤</h3><h4 id="步骤1：初始化"><a href="#步骤1：初始化" class="headerlink" title="步骤1：初始化"></a>步骤1：初始化</h4><p>将每个字符看作一个独立的二叉树，权值为该字符的频率，组成森林F。</p><p><strong>示例</strong>：假设有字符集 {A, B, C, D}，频率分别为 {5, 3, 2, 1}</p><p>初始森林：</p><pre><code>A(5)  B(3)  C(2)  D(1)</code></pre><h4 id="步骤2：选择最小权值树"><a href="#步骤2：选择最小权值树" class="headerlink" title="步骤2：选择最小权值树"></a>步骤2：选择最小权值树</h4><p>从森林F中选择<strong>权值最小的两棵树</strong>（如果有多棵树权值相同，任意选择）。</p><p>第一次选择：C(2) 和 D(1) 最小</p><h4 id="步骤3：合并树"><a href="#步骤3：合并树" class="headerlink" title="步骤3：合并树"></a>步骤3：合并树</h4><p>将选中的两棵树合并，新树的根节点权值为两棵树权值之和，原来的两棵树作为新树的左右子树。</p><p>合并C和D：</p><pre><code>新根节点(3)     /   \   C(2)  D(1)</code></pre><p>更新后的森林：</p><pre><code>A(5)  B(3)  新树(3)</code></pre><h4 id="步骤4：重复过程"><a href="#步骤4：重复过程" class="headerlink" title="步骤4：重复过程"></a>步骤4：重复过程</h4><p>重复步骤2-3，直到森林中只剩一棵树。</p><p><strong>第二次选择</strong>：B(3) 和新树(3) 最小（权值相同，任意选择）</p><pre><code>  新根节点(6)       /    \     B(3)   新树(3)              /   \            C(2)  D(1)</code></pre><p>更新后的森林：</p><pre><code>A(5)  新树(6)</code></pre><p><strong>第三次选择</strong>：A(5) 和新树(6) 合并</p><pre><code>    根节点(11)        /    \     A(5)    新树(6)              /   \            B(3)   子树(3)                    /   \                  C(2)  D(1)</code></pre><h3 id="1-3-构建过程可视化"><a href="#1-3-构建过程可视化" class="headerlink" title="1.3 构建过程可视化"></a>1.3 构建过程可视化</h3><pre><code>初始: A(5)  B(3)  C(2)  D(1)第1次合并:    C(2) + D(1) = 新树1(3)   森林: A(5)  B(3)  新树1(3)第2次合并:   B(3) + 新树1(3) = 新树2(6)   森林: A(5)  新树2(6)第3次合并:   A(5) + 新树2(6) = 根节点(11)   完成构建</code></pre><p>最终哈夫曼树：</p><pre><code>      11     /  \    5     6   A(5)  / \       3     3      B(3)  / \          2     1         C(2) D(1)</code></pre><h2 id="二、哈夫曼编码原理"><a href="#二、哈夫曼编码原理" class="headerlink" title="二、哈夫曼编码原理"></a>二、哈夫曼编码原理</h2><h3 id="2-1-编码规则"><a href="#2-1-编码规则" class="headerlink" title="2.1 编码规则"></a>2.1 编码规则</h3><p><strong>前缀编码特性</strong>：任何一个字符的编码都不是另一个字符编码的前缀，保证了解码的唯一性。</p><p><strong>编码规则：</strong></p><ol><li>从根节点开始，向左子树走编码为’0’，向右子树走编码为’1’</li><li>到达叶子节点时，路径上的0和1序列就是该字符的编码</li></ol><h3 id="2-2-编码过程"><a href="#2-2-编码过程" class="headerlink" title="2.2 编码过程"></a>2.2 编码过程</h3><p>基于上面构建的哈夫曼树：</p><pre><code>       11     0/  \1    5     6   A    0/ \1       3     3      B    0/ \1          2     1         C     D</code></pre><p><strong>编码生成：</strong></p><ul><li><strong>A</strong>：从根向左 → <code>0</code></li><li><strong>B</strong>：从根向右(1)，再向左(0) → <code>10</code></li><li><strong>C</strong>：从根向右(1)，再向右(1)，再向左(0) → <code>110</code></li><li><strong>D</strong>：从根向右(1)，再向右(1)，再向右(1) → <code>111</code></li></ul><p>编码表：</p><pre><code>A: 0B: 10  C: 110D: 111</code></pre><h3 id="2-3-编码验证"><a href="#2-3-编码验证" class="headerlink" title="2.3 编码验证"></a>2.3 编码验证</h3><p><strong>前缀编码验证：</strong></p><ul><li>A的编码<code>0</code>不是B<code>10</code>、C<code>110</code>、D<code>111</code>的前缀</li><li>B的编码<code>10</code>不是C<code>110</code>、D<code>111</code>的前缀</li><li>C的编码<code>110</code>不是D<code>111</code>的前缀</li></ul><p><strong>满足前缀编码条件，可以无歧义解码。</strong></p><h3 id="2-4-编码示例"><a href="#2-4-编码示例" class="headerlink" title="2.4 编码示例"></a>2.4 编码示例</h3><p>文本：<code>&quot;ABACABAD&quot;</code></p><p>编码过程：</p><pre><code>A: 0B: 10A: 0  C: 110A: 0B: 10A: 0D: 111</code></pre><p>编码结果：<code>0 10 0 110 0 10 0 111</code>→ <code>01001100100111</code></p><h3 id="2-5-解码过程"><a href="#2-5-解码过程" class="headerlink" title="2.5 解码过程"></a>2.5 解码过程</h3><p>编码流：<code>01001100100111</code></p><p>解码：</p><ol><li>从根开始，读入<code>0</code>→ 到达A，输出A，回到根</li><li>读入<code>1</code>→ 向右，读入<code>0</code>→ 到达B，输出B，回到根</li><li>读入<code>0</code>→ 到达A，输出A，回到根</li><li>读入<code>1</code>→ 向右，读入<code>1</code>→ 向右，读入<code>0</code>→ 到达C，输出C，回到根</li><li>继续解码…</li></ol><p>最终得到：<code>ABACABAD</code></p><h2 id="三、数学原理分析"><a href="#三、数学原理分析" class="headerlink" title="三、数学原理分析"></a>三、数学原理分析</h2><h3 id="3-1-最优性证明"><a href="#3-1-最优性证明" class="headerlink" title="3.1 最优性证明"></a>3.1 最优性证明</h3><p><strong>贪心选择性质</strong>：每次选择频率最小的两个节点合并，可以保证全局最优。</p><p><strong>数学证明思路：</strong></p><ol><li>频率最小的两个字符在最优编码中深度最大</li><li>这两个字符应该是兄弟节点</li><li>将问题规模缩小，数学归纳法证明</li></ol><h3 id="3-2-压缩效率计算"><a href="#3-2-压缩效率计算" class="headerlink" title="3.2 压缩效率计算"></a>3.2 压缩效率计算</h3><p><strong>原始编码</strong>（定长编码）：</p><ul><li>4个字符需要2位：A:00, B:01, C:10, D:11</li><li>文本”ABACABAD”长度：8字符 × 2位 &#x3D; 16位</li></ul><p><strong>哈夫曼编码</strong>：</p><ul><li>A(频率5): 1位 × 5次 &#x3D; 5位</li><li>B(频率3): 2位 × 3次 &#x3D; 6位</li><li>C(频率2): 3位 × 2次 &#x3D; 6位</li><li>D(频率1): 3位 × 1次 &#x3D; 3位</li><li>总位数：5 + 6 + 6 + 3 &#x3D; 20位</li></ul><p><strong>压缩率</strong>：(16 - 20)&#x2F;16 × 100% &#x3D; -25%（实际是膨胀，因为示例数据量小）</p><p><strong>注意</strong>：对于实际的大文本，高频字符用短编码，总体效果是压缩。</p><h3 id="3-3-复杂度分析"><a href="#3-3-复杂度分析" class="headerlink" title="3.3 复杂度分析"></a>3.3 复杂度分析</h3><p><strong>时间复杂度</strong>：O(n log n)</p><ul><li>使用最小堆选择最小权值节点</li></ul><p><strong>空间复杂度</strong>：O(n)</p><ul><li>存储哈夫曼树节点和编码表</li></ul><h2 id="四、核心特点总结"><a href="#四、核心特点总结" class="headerlink" title="四、核心特点总结"></a>四、核心特点总结</h2><h3 id="4-1-哈夫曼树特点"><a href="#4-1-哈夫曼树特点" class="headerlink" title="4.1 哈夫曼树特点"></a>4.1 哈夫曼树特点</h3><ol><li><strong>带权路径最短</strong>：WPL最小</li><li><strong>没有度为1的节点</strong>：严格的二叉树</li><li><strong>频率高的字符靠近根节点</strong></li><li><strong>频率低的字符在深层</strong></li></ol><h3 id="4-2-哈夫曼编码特点"><a href="#4-2-哈夫曼编码特点" class="headerlink" title="4.2 哈夫曼编码特点"></a>4.2 哈夫曼编码特点</h3><ol><li><strong>前缀编码</strong>：无歧义解码</li><li><strong>最优压缩</strong>：对于给定频率分布是最优的</li><li><strong>变长编码</strong>：高频字符用短编码，低频字符用长编码</li><li><strong>需要编码表</strong>：解码时需要哈夫曼树或编码表</li></ol><h2 id="五、哈夫曼树构建示例（cpp）"><a href="#五、哈夫曼树构建示例（cpp）" class="headerlink" title="五、哈夫曼树构建示例（cpp）"></a>五、哈夫曼树构建示例（cpp）</h2><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;// 哈夫曼树节点结构struct HuffmanNode &#123;    char data;           // 字符    int frequency;       // 频率    HuffmanNode *left;   // 左子树    HuffmanNode *right;  // 右子树        // 构造函数    HuffmanNode(char data, int frequency) : data(data), frequency(frequency),                                            left(nullptr), right(nullptr) &#123;&#125;&#125;;// 比较器，用于优先队列（最小堆）struct CompareNodes &#123;    bool operator()(HuffmanNode* a, HuffmanNode* b) &#123;        return a-&gt;frequency &gt; b-&gt;frequency; // 频率小的节点优先级高    &#125;&#125;;// 构建哈夫曼树HuffmanNode* buildHuffmanTree(const unordered_map&lt;char, int&gt;&amp; frequencies) &#123;    // 创建优先队列（最小堆）    priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, CompareNodes&gt; minHeap;        // 将所有字符节点加入堆    for (const auto&amp; pair : frequencies) &#123;        minHeap.push(new HuffmanNode(pair.first, pair.second));    &#125;        // 构建哈夫曼树    while (minHeap.size() &gt; 1) &#123;        // 取出频率最小的两个节点        HuffmanNode* left = minHeap.top();        minHeap.pop();                HuffmanNode* right = minHeap.top();        minHeap.pop();                // 创建新的内部节点，频率为两个节点频率之和        HuffmanNode* internalNode = new HuffmanNode(&#39;$&#39;, left-&gt;frequency + right-&gt;frequency);        internalNode-&gt;left = left;        internalNode-&gt;right = right;                // 将新节点加入堆        minHeap.push(internalNode);    &#125;        // 剩下的节点就是根节点    return minHeap.top();&#125;// 生成哈夫曼编码void generateHuffmanCodes(HuffmanNode* root, string currentCode,                          unordered_map&lt;char, string&gt;&amp; huffmanCodes) &#123;    if (root == nullptr) &#123;        return;    &#125;        // 如果是叶子节点，保存其编码    if (root-&gt;data != &#39;$&#39;) &#123;        huffmanCodes[root-&gt;data] = currentCode;        return;    &#125;        // 递归遍历左子树和右子树    generateHuffmanCodes(root-&gt;left, currentCode + &quot;0&quot;, huffmanCodes);    generateHuffmanCodes(root-&gt;right, currentCode + &quot;1&quot;, huffmanCodes);&#125;// 编码字符串string encodeString(const string&amp; text, const unordered_map&lt;char, string&gt;&amp; huffmanCodes) &#123;    string encodedString;    for (char c : text) &#123;        encodedString += huffmanCodes.at(c);    &#125;    return encodedString;&#125;// 解码哈夫曼编码string decodeString(const string&amp; encodedString, HuffmanNode* root) &#123;    string decodedString;    HuffmanNode* current = root;        for (char bit : encodedString) &#123;        if (bit == &#39;0&#39;) &#123;            current = current-&gt;left;        &#125; else &#123;            current = current-&gt;right;        &#125;                // 如果到达叶子节点        if (current-&gt;left == nullptr &amp;&amp; current-&gt;right == nullptr) &#123;            decodedString += current-&gt;data;            current = root; // 回到根节点，开始下一个字符的解码        &#125;    &#125;        return decodedString;&#125;// 计算字符频率unordered_map&lt;char, int&gt; calculateFrequencies(const string&amp; text) &#123;    unordered_map&lt;char, int&gt; frequencies;    for (char c : text) &#123;        frequencies[c]++;    &#125;    return frequencies;&#125;// 释放哈夫曼树内存void deleteHuffmanTree(HuffmanNode* root) &#123;    if (root == nullptr) return;    deleteHuffmanTree(root-&gt;left);    deleteHuffmanTree(root-&gt;right);    delete root;&#125;int main() &#123;    string text = &quot;this is an example for huffman encoding&quot;;        // 计算字符频率    unordered_map&lt;char, int&gt; frequencies = calculateFrequencies(text);        // 构建哈夫曼树    HuffmanNode* root = buildHuffmanTree(frequencies);        // 生成哈夫曼编码    unordered_map&lt;char, string&gt; huffmanCodes;    generateHuffmanCodes(root, &quot;&quot;, huffmanCodes);        // 输出哈夫曼编码    cout &lt;&lt; &quot;哈夫曼编码：&quot; &lt;&lt; endl;    for (const auto&amp; pair : huffmanCodes) &#123;        cout &lt;&lt; pair.first &lt;&lt; &quot; : &quot; &lt;&lt; pair.second &lt;&lt; endl;    &#125;        // 编码字符串    string encodedString = encodeString(text, huffmanCodes);    cout &lt;&lt; &quot;\n编码后的字符串：&quot; &lt;&lt; encodedString &lt;&lt; endl;        // 解码字符串    string decodedString = decodeString(encodedString, root);    cout &lt;&lt; &quot;\n解码后的字符串：&quot; &lt;&lt; decodedString &lt;&lt; endl;        // 计算压缩率    int originalSize = text.size() * 8; // 假设每个字符占8位    int compressedSize = encodedString.size();    double compressionRatio = (1.0 - (double)compressedSize / originalSize) * 100;    cout &lt;&lt; &quot;\n原始大小：&quot; &lt;&lt; originalSize &lt;&lt; &quot; 位&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;压缩后大小：&quot; &lt;&lt; compressedSize &lt;&lt; &quot; 位&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;压缩率：&quot; &lt;&lt; compressionRatio &lt;&lt; &quot;%&quot; &lt;&lt; endl;        // 释放内存    deleteHuffmanTree(root);        return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;QAQ&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>html简介与基本框架</title>
    <link href="http://example.com/2025/10/29/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2025/10/29/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</id>
    <published>2025-10-29T12:07:12.000Z</published>
    <updated>2025-11-05T14:22:10.719Z</updated>
    
    <content type="html"><![CDATA[<p> HTML（HyperText Markup Language，超文本标记语言） </p><span id="more"></span><h2 id="一、HTML-简介"><a href="#一、HTML-简介" class="headerlink" title="一、HTML 简介"></a><strong>一、HTML 简介</strong></h2><p>HTML（HyperText Markup Language，超文本标记语言）是用于创建网页的标准标记语言。它通过一系列<strong>标签（tags）</strong> 描述网页的结构和内容（如文本、图片、链接、表格等），浏览器会解析这些标签并将其渲染为可视化的网页。</p><ul><li>核心特点：<ul><li>不是编程语言，而是标记语言（通过标签定义内容的含义和结构）。</li><li>标签通常成对出现（如 &#96;&#96;），由开始标签、内容和结束标签组成。</li><li>不区分大小写，但推荐使用小写（符合规范）。</li></ul></li></ul><h2 id="二、HTML-基础框架"><a href="#二、HTML-基础框架" class="headerlink" title="二、HTML 基础框架"></a><strong>二、HTML 基础框架</strong></h2><p>一个完整的 HTML 文档有固定的基本结构，以下是最基础的框架：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;网页标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 这里是网页的可见内容 --&gt;    &lt;h1&gt;这是一级标题&lt;/h1&gt;    &lt;p&gt;这是一段文本。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="三、框架各部分说明"><a href="#三、框架各部分说明" class="headerlink" title="三、框架各部分说明"></a><strong>三、框架各部分说明</strong></h2><ol><li><strong><code>&lt;!DOCTYPE html&gt;</code></strong><ul><li>声明文档类型，告诉浏览器这是一个 HTML5 文档（必须放在文档最开头）。</li><li>不属于 HTML 标签，仅作为声明。</li></ul></li><li><strong><code>&lt;html&gt;</code>标签</strong><ul><li>整个 HTML 文档的根标签，所有内容都包裹在其中。</li><li><code>lang=&quot;zh-CN&quot;</code> 属性：指定文档主要语言为中文（有助于搜索引擎和辅助工具识别）。</li></ul></li><li><strong><code>&lt;head&gt;</code> 标签</strong><ul><li>包含文档的<strong>元数据（metadata）</strong>，即不直接显示在页面上的信息（如标题、编码方式、样式等）。</li><li>常见子标签：<ul><li><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：指定文档编码为 UTF-8（支持中文等多语言）。</li><li><code>&lt;meta name=&quot;viewport&quot; ...&gt;</code>：用于响应式设计，确保移动端页面正确缩放。</li><li><code>&lt;title&gt;</code>：定义网页标题（显示在浏览器标签页上，是搜索引擎优化的重要元素）。</li></ul></li></ul></li><li><strong><code>&lt;body&gt;</code> 标签</strong><ul><li>包含网页的<strong>可见内容</strong>，如文本、图片、链接、按钮等，浏览器会将这里的内容渲染到页面上。</li></ul></li></ol><h2 id="四、入门示例"><a href="#四、入门示例" class="headerlink" title="四、入门示例"></a><strong>四、入门示例</strong></h2><p>以下是一个简单的完整 HTML 页面示例，可直接保存为 <code>.html</code> 文件（如 <code>index.html</code>），用浏览器打开即可查看效果：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;我的第一个网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;欢迎来到我的网页&lt;/h1&gt;    &lt;p&gt;这是我用 HTML 写的第一个页面。&lt;/p&gt;    &lt;a href=&quot;https://www.example.com&quot;&gt;点击访问示例网站&lt;/a&gt;    &lt;img src=&quot;https://picsum.photos/200/100&quot; alt=&quot;示例图片&quot;&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="五、子标签"><a href="#五、子标签" class="headerlink" title="五、&lt;body&gt;子标签"></a>五、<code>&lt;body&gt;</code>子标签</h2><h3 id="文本与标题标签"><a href="#文本与标题标签" class="headerlink" title="文本与标题标签"></a>文本与标题标签</h3><p>用于组织页面文本内容，明确层级关系。</p><ol><li><p><strong>标题标签</strong>（ <code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>）表示不同级别的标题，<code>&lt;h1&gt;</code>级别最高 （通常一个页面只有一个）， <code>&lt;h6&gt;</code>最低。</p><p>属性：<code>align</code>（有left | center | right 三个值）。</p><pre><code class="html">&lt;h1&gt;一级标题（页面主标题）&lt;/h1&gt;&lt;h2&gt;二级标题（章节标题）&lt;/h2&gt;&lt;h3&gt;三级标题（小节标题）&lt;/h3&gt;&lt;!-- 以此类推到 h6 --&gt;&lt;h6 align=&quot;left&quot;&gt;六级标题 &lt;/h6&gt;</code></pre></li><li><p><strong>段落标签</strong>（<code>&lt;p&gt;</code>）定义一段文本，浏览器会自动在段落前后添加换行和间距。</p><pre><code class="html">&lt;p&gt;这是一段普通文本，用于描述内容。&lt;/p&gt;&lt;p&gt;段落标签会自动分隔内容，让页面更易读。&lt;/p&gt;</code></pre></li><li><p><strong>换行标签</strong>（<code>&lt;br&gt;</code>）强制换行（单标签，无需闭合），常用于段落内的换行。</p><pre><code class="html">&lt;p&gt;第一行文本&lt;br&gt;第二行文本（通过 br 标签换行）&lt;/p&gt;</code></pre></li><li><p><strong>水平线标签</strong>（<code>&lt;hr&gt;</code>）</p><pre><code class="html">&lt;hr color=&quot;grean&quot; width=&quot;300px&quot; size=&quot;20px&quot; align=&quot;left | right&quot; /&gt;&lt;!-- 默认居中 --&gt;</code></pre></li><li><p><strong>文本格式化标签</strong></p><p>用于强调或修饰文本：</p><pre><code class="html"></code></pre></li></ol><p><strong>加重语气</strong>  <!-- 语义上的强调，定义加重语气 --><br><em>定义着重字</em>        <!-- 语义上的强调，定义着重字 --><br><del>删除线文本</del>      <!-- 定义删除字 --><br><i>定义斜体文本</i>        <!-- 定义斜体文本 --><br><b>定义粗体文本</b>        <!-- 定义粗体文本 --><br><span> </spans>          <!-- 元素没有特定含义 --></p><pre><code>![1762346266156](../images/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/1762346266156.png)### 链接标签（`&lt;a&gt;`）定义超链接，用于跳转至其他页面、文件或同一页面的指定位置。核心属性：`href`（目标地址）`target`（打开方式，`_blank`表示新窗口）。```html&lt;!-- 跳转到外部网站 --&gt;&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度一下&lt;/a&gt;&lt;!-- 跳转到本地页面（同一文件夹下的 page.html） --&gt;&lt;a href=&quot;page.html&quot;&gt;访问内部页面&lt;/a&gt;&lt;!-- 跳转到页面内的指定位置（需配合 id 属性） --&gt;&lt;a href=&quot;#section1&quot;&gt;跳至第一部分&lt;/a&gt;&lt;h2 id=&quot;section1&quot;&gt;第一部分内容&lt;/h2&gt;&lt;!-- 邮件链接（点击打开邮件客户端） --&gt;&lt;a href=&quot;mailto:example@mail.com&quot;&gt;发送邮件&lt;/a&gt;</code></pre><h3 id="图像标签（）"><a href="#图像标签（）" class="headerlink" title="图像标签（&lt;img&gt;）"></a>图像标签（<code>&lt;img&gt;</code>）</h3><p>插入图片（单标签），核心属性：</p><ul><li><code>src</code>：图片路径（本地路径或网络 URL）。</li><li><code>alt</code>：图片加载失败时的替代文本（必填，提升可访问性）。</li><li><code>width</code>&#x2F;<code>height</code>：图片宽度 &#x2F; 高度（单位：像素或百分比）。</li></ul><pre><code class="html">&lt;!-- 插入网络图片 --&gt;&lt;img src=&quot;https://picsum.photos/400/200&quot; alt=&quot;示例风景图&quot; width=&quot;400&quot;&gt;&lt;!-- 插入本地图片（假设图片在 images 文件夹下 --&gt;&lt;img src=&quot;images/photo.jpg&quot; alt=&quot;本地照片&quot; height=&quot;200&quot;&gt;&lt;!-- alt为规定图片替代的文本，title为鼠标指向时显示的图片文本 --&gt;&lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot; alt=&quot;&quot; tile&quot;&quot;&gt;</code></pre><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p>用于展示有序或无序的列表项。</p><ol><li><p><strong>无序列表</strong>（<code>&lt;ul&gt;</code> + <code>&lt;li&gt;</code>）列表项前默认显示圆点（样式可通过 CSS 修改）。</p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;苹果&lt;/li&gt;  &lt;li&gt;香蕉&lt;/li&gt;  &lt;li&gt;橙子&lt;/li&gt;&lt;/ul&gt;</code></pre><p><img src="/../images/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/1762347245808.png" alt="1762347245808"></p><p><img src="/../images/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/1762347744621.png" alt="1762347744621"></p></li><li><p><strong>有序列表</strong>（<code>&lt;ol&gt;</code> + <code>&lt;li&gt;</code>）列表项前显示数字（默认）、字母等序号。</p><p><img src="/../images/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/1762346818862.png" alt="1762346818862"></p><pre><code class="html">&lt;ol&gt;  &lt;li&gt;第一步：打开浏览器&lt;/li&gt;  &lt;li&gt;第二步：输入网址&lt;/li&gt;  &lt;li&gt;第三步：按下回车&lt;/li&gt;&lt;/ol&gt;</code></pre></li><li><p><strong>定义列表</strong>（<code>&lt;dl&gt;</code> + <code>&lt;dt&gt;</code> + <code>&lt;dd&gt;</code>）用于展示 “术语 - 解释” 类内容。</p><pre><code class="html">&lt;dl&gt;  &lt;dt&gt;HTML&lt;/dt&gt;  &lt;dd&gt;超文本标记语言，用于构建网页结构。&lt;/dd&gt;  &lt;dt&gt;CSS&lt;/dt&gt;  &lt;dd&gt;层叠样式表，用于美化网页。&lt;/dd&gt;&lt;/dl&gt;</code></pre></li></ol><h3 id="容器标签"><a href="#容器标签" class="headerlink" title="容器标签"></a>容器标签</h3><p>用于布局和分组内容，无默认样式，需配合 CSS 使用。</p><ol><li><p><code>&lt;div&gt;</code>：块级容器（独占一行），常用于大区块布局（如头部、主体、底部）。</p></li><li><p><code>&lt;span&gt;</code>：行内容器（不独占一行），常用于包裹文本中的部分内容（如单独修饰某段文字）。</p><pre><code class="html">&lt;p&gt;我喜欢 &lt;span style=&quot;color: red;&quot;&gt;红色&lt;/span&gt; 和 &lt;span style=&quot;color: blue;&quot;&gt;蓝色&lt;/span&gt;。&lt;/p&gt;</code></pre></li></ol><h3 id="表格标签（）"><a href="#表格标签（）" class="headerlink" title="表格标签（&lt;table&gt;）"></a>表格标签（<code>&lt;table&gt;</code>）</h3><p>用于展示结构化数据（如成绩单、价格表）。</p><p>核心标签：<code>&lt;table&gt;</code>（表格）、<code>&lt;tr&gt;</code>（行）、<code>&lt;td&gt;</code>（单元格）、<code>&lt;th&gt;</code>（表头单元格，默认加粗居中）。</p><pre><code class="html">&lt;table border=&quot;1&quot;&gt;  &lt;!-- border 属性添加边框（仅示例用，实际推荐用 CSS） --&gt;  &lt;tr&gt;    &lt;th&gt;姓名&lt;/th&gt;    &lt;th&gt;年龄&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;张三&lt;/td&gt;    &lt;td&gt;20&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;李四&lt;/td&gt;    &lt;td&gt;22&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;</code></pre><p><img src="/../images/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/1762348075853.png" alt="1762348075853"></p><p><img src="C:/Users/zxy/AppData/Roaming/Typora/typora-user-images/1762348197398.png" alt="1762348197398"></p><p><img src="/../images/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/1762348658556.png" alt="1762348658556"></p><pre><code class="html">&lt;table&gt;    &lt;tr&gt;        &lt;td colspan=&quot;2&quot;&gt;单元格1和2&lt;/td&gt;        &lt;td&gt;单元格3&lt;/td&gt;        &lt;td&gt;单元格4&lt;/td&gt;    &lt;/tr&gt;        &lt;tr&gt;        &lt;td&gt;单元格5&lt;/td&gt;        &lt;td&gt;单元格6&lt;/td&gt;        &lt;td&gt;单元格7&lt;/td&gt;        &lt;td rowspan=&quot;2&quot;&gt;单元格8和12&lt;/td&gt;    &lt;/tr&gt;        &lt;tr&gt;        &lt;td&gt;单元格9&lt;/td&gt;        &lt;td&gt;单元格10&lt;/td&gt;        &lt;td&gt;单元格11&lt;/td&gt;    &lt;/tr&gt;    &lt;/table&gt;</code></pre><h3 id="表单标签（）"><a href="#表单标签（）" class="headerlink" title="表单标签（&lt;form&gt;）"></a>表单标签（<code>&lt;form&gt;</code>）</h3><p>用于收集用户输入（如登录、注册、搜索），配合输入类标签使用。</p><p>核心属性：<code>action</code>（提交数据的地址）、<code>method</code>（提交方式、<code>get</code>或<code>post</code>）</p><p><img src="/../images/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/1762349731335.png" alt="1762349731335"></p><p>常用输入标签：</p><ul><li><code>&lt;input&gt;</code>：单行文本、密码、复选框等（通过 <code>type</code> 属性控制类型）。</li><li><code>&lt;textarea&gt;</code>：多行文本输入。</li><li><code>&lt;select&gt;</code> + <code>&lt;option&gt;</code>：下拉选择框。</li><li><code>&lt;button&gt;</code>：提交或重置按钮。</li></ul><pre><code class="html">&lt;form action=&quot;/submit&quot; method=&quot;post&quot;&gt;  &lt;p&gt;    &lt;label for=&quot;name&quot;&gt;姓名：&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;username&quot;&gt;  &lt;!-- name 用于后端接收数据 --&gt;  &lt;/p&gt;  &lt;p&gt;    &lt;label for=&quot;pwd&quot;&gt;密码：&lt;/label&gt;    &lt;input type=&quot;password&quot; id=&quot;pwd&quot; name=&quot;password&quot;&gt;  &lt;/p&gt;  &lt;p&gt;    &lt;label&gt;性别：&lt;/label&gt;    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女  &lt;/p&gt;  &lt;p&gt;    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;    &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;  &lt;/p&gt;&lt;/form&gt;</code></pre><p>这些标签是构建网页内容的基础，实际开发中会结合 CSS（美化样式）和 JavaScript（添加交互），让页面更丰富。</p><h2 id="六、块元素与内联元素"><a href="#六、块元素与内联元素" class="headerlink" title="六、块元素与内联元素"></a>六、块元素与内联元素</h2><p><img src="/../images/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/1762351373456.png" alt="1762351373456"></p><p><img src="C:/Users/zxy/AppData/Roaming/Typora/typora-user-images/1762351394120.png" alt="1762351394120"></p><h2 id="七、HTML5新增标签"><a href="#七、HTML5新增标签" class="headerlink" title="七、HTML5新增标签"></a>七、HTML5新增标签</h2><p><img src="/../images/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/1762352492016.png" alt="1762352492016"></p><p><img src="/../images/html%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/1762352305826.png" alt="1762352305826"></p><p>上方为传统写法，下方为新标签。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; HTML（HyperText Markup Language，超文本标记语言） &lt;/p&gt;</summary>
    
    
    
    
    <category term="web前端" scheme="http://example.com/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>鼹鼠报数</title>
    <link href="http://example.com/2025/10/25/%E9%BC%B9%E9%BC%A0%E6%8A%A5%E6%95%B0/"/>
    <id>http://example.com/2025/10/25/%E9%BC%B9%E9%BC%A0%E6%8A%A5%E6%95%B0/</id>
    <published>2025-10-25T11:54:38.000Z</published>
    <updated>2025-10-25T12:04:47.894Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树的应用示例。</p><span id="more"></span><h2 id="鼹鼠报数"><a href="#鼹鼠报数" class="headerlink" title="鼹鼠报数"></a>鼹鼠报数</h2><h2 id="★实验任务"><a href="#★实验任务" class="headerlink" title="★实验任务"></a>★实验任务</h2><p>Winder 养了一群会报数的鼹鼠，而且Winder喜欢用数字给他的鼹鼠们编号，如“311”、“1048”等。当然，为了不混淆，鼹鼠们的编号都是不同的。为了锻炼鼹鼠们的身体健康，Winder决定让鼹鼠们进行掘土训练，顺便提高鼹鼠们的挖掘能力。<br>鼹鼠们排成一列，由第一个开始向下挖洞，并待在洞中。第二只与第一只相比，若编号值大的鼹鼠，则向右下方挖洞，否则向左下方。接下来的鼹鼠们以此类推，若比洞中所在鼹鼠编号值大，则向右下方走，否则向左下方。<br>训练结束后，Winder会让他的鼹鼠们报数（既报出各自的编号）。通过报数的序列Winder想知道经过训练之后，鼹鼠们的位置是怎样的。<br>报数规则为：如果A鼹鼠的下方分别存在ALeft鼹鼠和ARight鼹鼠，则ALeft鼹鼠在ARight鼹鼠之前报数，ARight鼹鼠在A鼹鼠之前报数。<br>位置表达式规则为：“根节点&lt;左子树表达式&gt;&lt;右子树表达式&gt;”,如左子树不存在,则只输出“根节点&lt;右子树表达式&gt;”，右子树同理。</p><p><img src="/../images/%E9%BC%B9%E9%BC%A0%E6%8A%A5%E6%95%B0/1761393457224.png" alt="1761393457224"></p><p>例如上图，报数顺序为2，4，7，5，3可以表示为 3&lt;2&gt;&lt;5&lt;4&gt;&lt;7&gt;&gt;</p><h2 id="★数据输入"><a href="#★数据输入" class="headerlink" title="★数据输入"></a>★数据输入</h2><p>第一行为N（2&lt;N&lt;&#x3D;1000），表示有N只鼹鼠。<br>第二行为N个整数bi（0&lt;bi&lt;10000），表示报数顺序。</p><h2 id="★数据输出"><a href="#★数据输出" class="headerlink" title="★数据输出"></a>★数据输出</h2><p>输出鼹鼠们的位置表达式。</p><table><thead><tr><th>输入示例</th></tr></thead><tbody><tr><td>5</td></tr><tr><td>2 4 7 5 3</td></tr></tbody></table><table><thead><tr><th>输出示例</th></tr></thead><tbody><tr><td>3&lt;2&gt;&lt;5&lt;4&gt;&lt;7&gt;&gt;</td></tr></tbody></table><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class TreeNode &#123;public:    int id;    TreeNode* left;    TreeNode* right;    TreeNode(int id) : id(id), left(nullptr), right(nullptr) &#123;&#125;&#125;;TreeNode* insertBST(TreeNode* root, int id) &#123;    if (root == nullptr) return new TreeNode(id);    if (id &lt; root-&gt;id) &#123;        root-&gt;left = insertBST(root-&gt;left, id);    &#125;    else if (id &gt; root-&gt;id)&#123;        root-&gt;right = insertBST(root-&gt;right, id);    &#125;    return root;&#125;void preOrder(TreeNode* root) &#123;    if (root == nullptr) return;    cout &lt;&lt; root-&gt;id;    if (root-&gt;left) &#123;        cout &lt;&lt; &#39;&lt;&#39;;        preOrder(root-&gt;left);        cout &lt;&lt; &#39;&gt;&#39;;    &#125;    if (root-&gt;right) &#123;        cout &lt;&lt; &#39;&lt;&#39;;        preOrder(root-&gt;right);        cout &lt;&lt; &#39;&gt;&#39;;            &#125;        return;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    TreeNode* T = nullptr;    vector&lt;int&gt; arr;    for (int i = 0; i &lt; n;i ++) &#123;        int id;        cin &gt;&gt; id;        arr.push_back(id);    &#125;    for (int i = 0; i &lt; n; i++) &#123;        T = insertBST(T, arr[n - 1 - i]);    &#125;    preOrder(T);    return 0;&#125;</code></pre><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p><strong>解题需要先清楚</strong>： 将 BST 的后序遍历序列逆序后，按 BST 插入规则重建的树，与原 BST 结构相同。</p><p>题目给出的是BST的后序遍历序列，我们可以将其逆序，再依次插入BST，得到原BST，最后再前序遍历BST就可以得到结果。 </p><h3 id="1-数据结构与核心操作"><a href="#1-数据结构与核心操作" class="headerlink" title="1. 数据结构与核心操作"></a>1. 数据结构与核心操作</h3><ul><li><strong>TreeNode 类</strong>：定义二叉树节点，包含节点值<code>id</code>和左右子树指针<code>left</code>&#x2F;<code>right</code>。</li><li><strong>insertBST 函数</strong>：按 BST 规则插入节点（左子树节点值小于根，右子树节点值大于根），保证树的有序性。</li></ul><h3 id="2-核心逻辑"><a href="#2-核心逻辑" class="headerlink" title="2. 核心逻辑"></a>2. 核心逻辑</h3><h4 id="逆序插入构建-BST"><a href="#逆序插入构建-BST" class="headerlink" title="逆序插入构建 BST"></a>逆序插入构建 BST</h4><ul><li><p>输入一个整数序列<code>arr</code>（长度为<code>n</code>）。</p></li><li><p>从序列的</p><p>最后一个元素开始，依次向前遍历（即按<code>arr[n-1] → arr[n-2] → ... → arr[0]</code>的顺序），将每个元素插入 BST。</p><ul><li>目的：以逆序序列的第一个元素（原序列最后一个元素）为根，逐步构建 BST。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉搜索树的应用示例。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>文件管理器</title>
    <link href="http://example.com/2025/10/25/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://example.com/2025/10/25/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8/</id>
    <published>2025-10-25T11:08:26.000Z</published>
    <updated>2025-10-25T11:17:38.326Z</updated>
    
    <content type="html"><![CDATA[<p> 二叉搜索树的应用示例。</p><span id="more"></span><h1 id="文件管理器"><a href="#文件管理器" class="headerlink" title="文件管理器"></a>文件管理器</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>操作系统具有对计算机硬件资源管理和调度的功能。文件是对占用了硬盘一定空间的对象的描述和抽象。考虑一般的文件具有文件名、大小和创建时间。文件管理在任何操作系统中都是必不可少的。文件管理器是用户用来观察和操作文件的一个软件。考虑一个简易的文件管理器，用户可以通过这个简易的文件管理器对某个目录下文件最大&#x2F;小、文件名(字符串)字典序最大&#x2F;最小的一些文件，即按XX排序功能，此外文件管理器具有删除和添加文件的功能。输入保证目录只有一级，操作随机。</p><h2 id="输入及输出格式"><a href="#输入及输出格式" class="headerlink" title="输入及输出格式"></a>输入及输出格式</h2><p>第1行输入一个Q(1&lt;&#x3D;Q&lt;&#x3D;100000)，表示操作的次数。</p><p>第2-Q+1行输入一行操作序列</p><p>操作序列的格式为 op args</p><p>当op&#x3D;1,即第一种操作时，args的格式为 folder name size 表示将要在某个folder目录(1&lt;&#x3D;folder&lt;&#x3D;5的整数)下添加文件名为name(1&lt;&#x3D;name&lt;&#x3D;100000的整数)的文件，文件大小为size(1&lt;&#x3D;size&lt;&#x3D;100000的整数)，如果文件名重复，就先删除原来的文件再进行1操作；</p><p>当op&#x3D;2,即第二种操作时，args的格式为 folder name表示将要在某个folder目录(1&lt;&#x3D;folder&lt;&#x3D;5的整数)下删除文件名为name(1&lt;&#x3D;name&lt;&#x3D;100000的整数)的文件，如果文件名不存在，操作不执行；</p><p>当op&#x3D;3,即第三种操作时，args的格式为 folder k 表示输出某个目录下文件大小最大至第k大的文件名，如果大小相同按文件名数字从小到大输出，如果不满k个文件只需要输出已有的文件名，如果文件夹为空或不存在则输出一个空行；</p><p>当op&#x3D;4,即第四种操作时，args的格式为 folder k 表示输出某个目录下文件名数字大小最小至第k小的文件名，如果不满k个文件只需要输出已有的文件名，如果文件夹为空或不存在则输出一个空行；</p><p>保证1&lt;&#x3D; k &lt;&#x3D;10</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>输出文件名以空格隔开，不输出多余的换行和空格</p><table><thead><tr><th><strong>输入示例</strong></th></tr></thead><tbody><tr><td>10</td></tr><tr><td>2 3 74071</td></tr><tr><td>3 1 2</td></tr><tr><td>3 2 8</td></tr><tr><td>2 3 71337</td></tr><tr><td>3 3 7</td></tr><tr><td>3 2 7</td></tr><tr><td>4 2 10</td></tr><tr><td>4 3 6</td></tr><tr><td>4 3 4</td></tr><tr><td>3 1 4</td></tr></tbody></table><table><thead><tr><th><strong>输出示例</strong></th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>上方输出为8个空行</p><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><pre><code class="c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class TreeNode &#123;public:    int size;    int name;    TreeNode* left;    TreeNode* right;    TreeNode(int size,int name) : size(size),name(name), left(nullptr), right(nullptr)&#123;&#125;&#125;;TreeNode* deleteNodebySize(TreeNode* root, int size);TreeNode* deleteNodebyName(TreeNode* root, int name);TreeNode* insertBSTbySize(TreeNode* root, int size,int name) &#123;    if (root == nullptr) &#123;        return new TreeNode(size,name);    &#125;    if (size &lt; root-&gt;size) &#123;        root-&gt;left = insertBSTbySize(root-&gt;left, size, name);    &#125;    else if (size &gt; root-&gt;size) &#123;        root-&gt;right = insertBSTbySize(root-&gt;right, size, name);    &#125;    return root;&#125;TreeNode* insertBSTbyName(TreeNode* root, int size, int name,TreeNode* root_Size) &#123;    if (root == nullptr) &#123;        return new TreeNode(size, name);    &#125;    if (name &lt; root-&gt;name) &#123;        root-&gt;left = insertBSTbyName(root-&gt;left, size, name, root_Size);    &#125;    else if (name &gt; root-&gt;name) &#123;        root-&gt;right = insertBSTbyName(root-&gt;right, size, name, root_Size);    &#125;    else &#123;        root_Size = deleteNodebySize(root_Size,root-&gt;size);        root_Size = insertBSTbySize(root_Size, size, name);        root = deleteNodebyName(root, name);        root = insertBSTbyName(root, size, name, root_Size);    &#125;    return root;&#125;TreeNode* findMin(TreeNode* root) &#123;    while (root-&gt;left != nullptr) &#123;        root = root-&gt;left;    &#125;    return root;&#125;TreeNode* deleteNodebyName(TreeNode* root, int name) &#123;    if (root == nullptr) return nullptr;    if (name &lt; root-&gt;name) &#123;        root-&gt;left = deleteNodebyName(root-&gt;left, name);    &#125;    else if (name &gt; root-&gt;name) &#123;        root-&gt;right = deleteNodebyName(root-&gt;right, name);    &#125;    else &#123;        if (root-&gt;left == nullptr) &#123;            TreeNode* temp = root-&gt;right;            delete root;            return temp;        &#125;        else if (root-&gt;right == nullptr) &#123;            TreeNode* temp = root-&gt;left;            delete root;            return temp;        &#125;        else &#123;            TreeNode* temp = findMin(root-&gt;right);            root-&gt;name = temp-&gt;name;            root-&gt;right = deleteNodebyName(root-&gt;right, temp-&gt;name);        &#125;    &#125;    return root;&#125;TreeNode* deleteNodebySize(TreeNode* root, int size) &#123;    if (root == nullptr) return nullptr;    if (size &lt; root-&gt;size) &#123;        root-&gt;left = deleteNodebySize(root-&gt;left, size);    &#125;    else if (size &gt; root-&gt;size) &#123;        root-&gt;right = deleteNodebySize(root-&gt;right, size);    &#125;    else &#123;        if (root-&gt;left == nullptr) &#123;            TreeNode* temp = root-&gt;right;            delete root;            return temp;        &#125;        else if (root-&gt;right == nullptr) &#123;            TreeNode* temp = root-&gt;left;            delete root;            return temp;        &#125;        else &#123;            TreeNode* temp = findMin(root-&gt;right);            root-&gt;size = temp-&gt;size;            root-&gt;right = deleteNodebySize(root-&gt;right, temp-&gt;size);        &#125;    &#125;    return root;&#125;TreeNode* searchBSTbyName(TreeNode* root, int name) &#123;    if (root == nullptr) &#123;        return root;    &#125;    if (name &lt; root-&gt;name) &#123;        return searchBSTbyName(root-&gt;left, name);    &#125;    else if (name &gt; root-&gt;name) &#123;        return searchBSTbyName(root-&gt;right, name);    &#125;    else &#123;        return root;    &#125;&#125;void inOrder(TreeNode* root,vector&lt;int&gt;&amp; arr) &#123;    if (root == nullptr) return;    inOrder(root-&gt;left,arr);       arr.push_back(root-&gt;name);    inOrder(root-&gt;right,arr);&#125;int main()&#123;    int n;    vector&lt;TreeNode*&gt; T_Name(6);    vector&lt;TreeNode*&gt; T_Size(6);    cin &gt;&gt; n;    while (n--) &#123;        int op;        cin &gt;&gt; op;        if (op == 1) &#123;            int folder, name, size;            cin &gt;&gt; folder &gt;&gt; name &gt;&gt; size;            T_Name[folder] = insertBSTbyName(T_Name[folder], size, name, T_Size[folder]);            T_Size[folder] = insertBSTbySize(T_Size[folder], size, name);        &#125;        else if (op == 2) &#123;            int name,folder;            cin &gt;&gt; folder &gt;&gt;  name;            TreeNode* temp = searchBSTbyName(T_Name[folder], name);            if (temp != nullptr) &#123;                int size = temp-&gt;size;                T_Name[folder] = deleteNodebyName(T_Name[folder], name);                T_Size[folder] = deleteNodebySize(T_Size[folder], size);            &#125;        &#125;        else if (op == 3) &#123;            int k,folder;            cin &gt;&gt; folder &gt;&gt; k;            vector&lt;int&gt; arr;            inOrder(T_Name[folder], arr);            int i = arr.size() - 1;            int count = arr.size() - k;            while (i &gt;= count &amp;&amp; i &gt;= 0) &#123;                cout &lt;&lt; arr[i] &lt;&lt; &#39; &#39;;                i--;            &#125;            cout &lt;&lt; endl;        &#125;        else if (op == 4) &#123;            int k, folder;            cin &gt;&gt; folder &gt;&gt; k;            vector&lt;int&gt; arr;            inOrder(T_Size[folder], arr);            int i = 0;            while (i &lt; k &amp;&amp; i &lt; arr.size()) &#123;                cout &lt;&lt; arr[i] &lt;&lt; &#39; &#39;;                i++;            &#125;        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>由于本题的操作次数和搜索量非常大，一般的线性数据存储和搜索时间会爆，因此采用二叉搜索树。</p><h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a><strong>数据结构设计</strong></h3><ol><li><strong>TreeNode 类</strong>：每个节点点存储两个关键信息<ul><li><code>size</code>：元素大小（用于按大小排序的 BST）</li><li><code>name</code>：元素名称（用于按名称排序的 BST）</li><li>左右指针（<code>left</code>&#x2F;<code>right</code>）维护 BST 结构</li></ul></li><li><strong>双 BST 设计</strong>：<ul><li><code>T_Name[folder]</code>：按 <code>name</code> 升序的 BST（同一文件夹下的元素按名称组织）</li><li><code>T_Size[folder]</code>：按 <code>size</code> 升序的 BST（同一文件夹下的元素按大小组织）</li><li>两个 BST 存储相同的元素集合，只是排序依据不同，通过操作同步保证数据一致性</li></ul></li></ol><h3 id="核心操作实现"><a href="#核心操作实现" class="headerlink" title="核心操作实现"></a><strong>核心操作实现</strong></h3><h4 id="1-插入元素（op-1）"><a href="#1-插入元素（op-1）" class="headerlink" title="1. 插入元素（op == 1）"></a>1. 插入元素（<code>op == 1</code>）</h4><ul><li><strong>输入</strong>：文件夹编号 <code>folder</code>、元素名称 <code>name</code>、元素大小 <code>size</code></li><li><strong>操作</strong>：<ul><li>调用 <code>insertBSTbyName</code> 向 <code>T_Name[folder]</code> 插入元素（按名称排序）</li><li>调用 <code>insertBSTbySize</code> 向 <code>T_Size[folder]</code> 插入元素（按大小排序）</li><li>若插入的 <code>name</code> 已存在，则先删除原元素（同步更新两个 BST），再插入新元素</li></ul></li></ul><h4 id="2-删除元素（op-2）"><a href="#2-删除元素（op-2）" class="headerlink" title="2. 删除元素（op == 2）"></a>2. 删除元素（<code>op == 2</code>）</h4><ul><li><strong>输入</strong>：文件夹编号 <code>folder</code>、元素名称 <code>name</code></li><li><strong>操作</strong>：<ul><li>通过 <code>searchBSTbyName</code> 在 <code>T_Name[folder]</code> 中查找该名称对应的节点</li><li>若找到，获取其<code>size</code>，同步执行：<ul><li>在 <code>T_Name[folder]</code> 中按 <code>name</code> 删除节点（<code>deleteNodebyName</code>）</li><li>在 <code>T_Size[folder]</code> 中按 <code>size</code> 删除节点（<code>deleteNodebySize</code>）</li></ul></li></ul></li></ul><h4 id="3-查询名称最大的-k-个元素（op-3）"><a href="#3-查询名称最大的-k-个元素（op-3）" class="headerlink" title="3. 查询名称最大的 k 个元素（op == 3）"></a>3. 查询名称最大的 k 个元素（<code>op == 3</code>）</h4><ul><li><strong>输入</strong>：文件夹编号 <code>folder</code>、数量 <code>k</code></li><li><strong>操作</strong>：<ul><li>对 <code>T_Name[folder]</code> 执行中序遍历（中序遍历 BST 可得到升序序列）</li><li>取遍历结果的最后 <code>k</code> 个元素（即名称最大的 k 个），逆序输出</li></ul></li></ul><h4 id="4-查询大小最小的-k-个元素（op-4）"><a href="#4-查询大小最小的-k-个元素（op-4）" class="headerlink" title="4. 查询大小最小的 k 个元素（op == 4）"></a>4. 查询大小最小的 k 个元素（<code>op == 4</code>）</h4><ul><li><strong>输入</strong>：文件夹编号 <code>folder</code>、数量 <code>k</code></li><li><strong>操作</strong>：<ul><li>对 <code>T_Size[folder]</code> 执行中序遍历（得到按大小升序的序列）</li><li>取遍历结果的前 <code>k</code> 个元素（即大小最小的 k 个）输出</li></ul></li></ul><h3 id="BST-辅助函数"><a href="#BST-辅助函数" class="headerlink" title="BST 辅助函数"></a><strong>BST 辅助函数</strong></h3><ul><li><strong>插入</strong>：<code>insertBSTbyName</code> 和 <code>insertBSTbySize</code> 分别按 <code>name</code> 和 <code>size</code> 递归插入节点，维持 BST 性质</li><li><strong>删除</strong>：<code>deleteNodebyName</code> 和 <code>deleteNodebySize</code> 处理三种节点情况（叶子、单孩子、双孩子），双孩子节点用右子树最小节点替换</li><li><strong>查找</strong>：<code>searchBSTbyName</code> 按名称递归查找节点</li><li><strong>中序遍历</strong>：<code>inOrder</code> 递归遍历 BST，收集节点信息（用于查询操作）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; 二叉搜索树的应用示例。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树与AVL树</title>
    <link href="http://example.com/2025/10/23/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/"/>
    <id>http://example.com/2025/10/23/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/</id>
    <published>2025-10-23T15:13:34.000Z</published>
    <updated>2025-10-24T14:09:29.606Z</updated>
    
    <content type="html"><![CDATA[<p>​              </p><span id="more"></span><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="一、二叉搜索树的定义与特性"><a href="#一、二叉搜索树的定义与特性" class="headerlink" title="一、二叉搜索树的定义与特性"></a>一、二叉搜索树的定义与特性</h3><ol><li><p><strong>结构定义</strong></p><p>二叉搜索树是由节点组成的二叉树，每个节点包含：</p><ul><li>一个值（关键字）；</li><li>左子节点指针（指向左子树）；</li><li>右子节点指针（指向右子树）。</li></ul></li><li><p><strong>核心特性</strong></p><p>对任意节点 ：</p><ul><li>左子树中所有节点的值 &lt; <code>node</code> 的值；</li><li>右子树中所有节点的值 &gt; <code>node</code> 的值；</li><li>左、右子树本身也必须是二叉搜索树（递归定义）；</li><li>（可选）通常不允许重复值（若允许，需额外定义规则，如重复值放在右子树）。</li></ul></li></ol><h3 id="二、二叉搜索树的基本操作"><a href="#二、二叉搜索树的基本操作" class="headerlink" title="二、二叉搜索树的基本操作"></a>二、二叉搜索树的基本操作</h3><h4 id="1-查找操作"><a href="#1-查找操作" class="headerlink" title="1. 查找操作"></a>1. 查找操作</h4><p><strong>思路</strong>：利用 BST 的特性，通过与当前节点值比较，逐步缩小查找范围：</p><ul><li>若目标值 &#x3D;&#x3D; 当前节点值：找到目标，返回节点；</li><li>若目标值 &lt; 当前节点值：递归查找左子树；</li><li>若目标值 &gt; 当前节点值：递归查找右子树；</li><li>若遍历到空节点：目标不存在。</li></ul><p><strong>示例代码（C++）</strong>：</p><pre><code class="cpp">struct TreeNode &#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;// 查找值为target的节点TreeNode* searchBST(TreeNode* root, int target) &#123;    if (root == nullptr || root-&gt;val == target) &#123;        return root; // 空树或找到目标    &#125;    if (target &lt; root-&gt;val) &#123;        return searchBST(root-&gt;left, target); // 查左子树    &#125; else &#123;        return searchBST(root-&gt;right, target); // 查右子树    &#125;&#125;</code></pre><p><strong>时间复杂度</strong>：O (h)，其中 <code>h</code> 是树的高度。理想情况下（平衡树）h&#x3D;log n，最坏情况（斜树）h&#x3D;n。</p><h4 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2. 插入操作"></a>2. 插入操作</h4><p><strong>思路</strong>：类似查找，先找到插入位置（空节点），再创建新节点并连接到父节点的左 &#x2F; 右指针：</p><ul><li>若树为空：新节点作为根节点；</li><li>若插入值 &lt; 当前节点值：递归插入到左子树；</li><li>若插入值 &gt; 当前节点值：递归插入到右子树；</li><li>（重复值处理）通常直接返回（不插入）。</li></ul><p><strong>示例代码（C++）</strong>：</p><pre><code class="cpp">// 插入值为val的节点，返回新树的根TreeNode* insertIntoBST(TreeNode* root, int val) &#123;    if (root == nullptr) &#123;        return new TreeNode(val); // 找到插入位置    &#125;    if (val &lt; root-&gt;val) &#123;        root-&gt;left = insertIntoBST(root-&gt;left, val); // 插入左子树    &#125; else if (val &gt; root-&gt;val) &#123;        root-&gt;right = insertIntoBST(root-&gt;right, val); // 插入右子树    &#125;    return root; // 不处理重复值&#125;</code></pre><p><strong>时间复杂度</strong>：O (h)，同查找操作。</p><h4 id="3-删除操作"><a href="#3-删除操作" class="headerlink" title="3. 删除操作"></a>3. 删除操作</h4><p>删除操作较复杂，需根据目标节点的子树情况分三种情形处理，确保删除后仍满足 BST 特性：</p><table><thead><tr><th>情形</th><th>处理方式</th></tr></thead><tbody><tr><td>目标节点无左、右子树（叶子节点）</td><td>直接删除，父节点指针置空</td></tr><tr><td>目标节点只有左子树或只有右子树</td><td>用子树的根节点替换目标节点</td></tr><tr><td>目标节点有左、右子树</td><td>找到右子树中最小的节点（或左子树中最大的节点），用其值替换目标节点值，再删除该最小 &#x2F; 最大节点</td></tr></tbody></table><p><strong>示例代码（C++）</strong>：</p><pre><code class="cpp">// 找到以root为根的树中最小值的节点TreeNode* findMin(TreeNode* root) &#123;    while (root-&gt;left != nullptr) &#123;        root = root-&gt;left;    &#125;    return root;&#125;// 删除值为val的节点，返回新树的根TreeNode* deleteNode(TreeNode* root, int val) &#123;    if (root == nullptr) return nullptr; // 树为空，无需删除    // 1. 查找目标节点    if (val &lt; root-&gt;val) &#123;        root-&gt;left = deleteNode(root-&gt;left, val); // 左子树删除    &#125; else if (val &gt; root-&gt;val) &#123;        root-&gt;right = deleteNode(root-&gt;right, val); // 右子树删除    &#125; else &#123;        // 2. 找到目标节点，处理删除        if (root-&gt;left == nullptr) &#123; // 只有右子树或无子树            TreeNode* temp = root-&gt;right;            delete root;            return temp;        &#125; else if (root-&gt;right == nullptr) &#123; // 只有左子树            TreeNode* temp = root-&gt;left;            delete root;            return temp;        &#125; else &#123; // 左右子树都存在            // 找右子树最小节点（或左子树最大节点）            TreeNode* temp = findMin(root-&gt;right);            root-&gt;val = temp-&gt;val; // 替换值            // 删除右子树中最小节点            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val);        &#125;    &#125;    return root;&#125;</code></pre><p><strong>时间复杂度</strong>：O (h)，同查找操作。</p><h3 id="三、二叉搜索树的遍历"><a href="#三、二叉搜索树的遍历" class="headerlink" title="三、二叉搜索树的遍历"></a>三、二叉搜索树的遍历</h3><p>BST 的中序遍历（左→根→右）具有特殊意义：<strong>遍历结果是严格递增的有序序列</strong>。这是 BST 的重要特性，可用于验证树是否为 BST。</p><p><strong>中序遍历示例代码（C++）</strong>：</p><pre><code class="cpp">void inorderTraversal(TreeNode* root) &#123;    if (root == nullptr) return;    inorderTraversal(root-&gt;left);   // 遍历左子树    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;       // 访问根节点    inorderTraversal(root-&gt;right);  // 遍历右子树&#125;</code></pre><p>例如，对如下 BST：</p><pre><code class="plaintext">    4   / \  2   6 / \ / \1  3 5  7</code></pre><p>中序遍历结果为：<code>1 2 3 4 5 6 7</code>（严格递增）。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><h3 id="一、AVL-树的核心定义"><a href="#一、AVL-树的核心定义" class="headerlink" title="一、AVL 树的核心定义"></a>一、AVL 树的核心定义</h3><ol><li><strong>二叉搜索树特性</strong>：对于任意节点，左子树所有节点值 &lt;该节点值，右子树所有节点值&gt; 该节点值（与 BST 一致）。</li><li><strong>平衡约束</strong>：任意节点的<strong>左右子树高度差（平衡因子）的绝对值 ≤ 1</strong>。<ul><li>平衡因子 &#x3D; 左子树高度 - 右子树高度。</li><li>若平衡因子为 2 或 - 2，则称该节点<strong>失衡</strong>，需要通过旋转调整恢复平衡。</li></ul></li></ol><h3 id="二、AVL-树的节点结构"><a href="#二、AVL-树的节点结构" class="headerlink" title="二、AVL 树的节点结构"></a>二、AVL 树的节点结构</h3><p>AVL 树的节点在 BST 节点基础上增加了<strong>高度（height）</strong> 字段，用于快速计算平衡因子：</p><pre><code class="cpp">struct AVLNode &#123;    int val;           // 节点值    AVLNode* left;     // 左子节点    AVLNode* right;    // 右子节点    int height;        // 以该节点为根的子树高度（空节点高度为0）    AVLNode(int x) : val(x), left(nullptr), right(nullptr), height(1) &#123;&#125;&#125;;</code></pre><ul><li>新节点的初始高度为 1（自身作为叶子节点）。</li><li>非叶子节点的高度 &#x3D; max (左子树高度，右子树高度) + 1。</li></ul><h3 id="三、AVL-树的核心操作"><a href="#三、AVL-树的核心操作" class="headerlink" title="三、AVL 树的核心操作"></a>三、AVL 树的核心操作</h3><h4 id="1-辅助函数"><a href="#1-辅助函数" class="headerlink" title="1. 辅助函数"></a>1. 辅助函数</h4><p>为实现平衡维护，需要以下辅助函数：</p><ul><li><p><strong>获取节点高度</strong>：处理空节点的边界情况。</p><pre><code class="cpp">int getHeight(AVLNode* node) &#123;    return (node == nullptr) ? 0 : node-&gt;height;&#125;</code></pre></li><li><p><strong>计算平衡因子</strong>：判断节点是否失衡。</p><pre><code class="cpp">int getBalance(AVLNode* node) &#123;    return (node == nullptr) ? 0 : getHeight(node-&gt;left) - getHeight(node-&gt;right);&#125;</code></pre></li><li><p><strong>更新节点高度</strong>：插入或旋转后需更新节点高度。</p><pre><code class="cpp">void updateHeight(AVLNode* node) &#123;    if (node != nullptr) &#123;        node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));    &#125;&#125;</code></pre></li></ul><h4 id="2-旋转操作（核心）"><a href="#2-旋转操作（核心）" class="headerlink" title="2. 旋转操作（核心）"></a>2. 旋转操作（核心）</h4><p>当节点失衡（平衡因子为 ±2）时，需通过<strong>旋转</strong>调整树结构以恢复平衡。旋转的目标是：</p><ul><li>降低失衡节点的子树高度。</li><li>维持二叉搜索树的特性（左小右大）。</li></ul><p>根据失衡节点的左 &#x2F; 右子树的平衡状态，分为 4 种旋转场景：</p><h5 id="（1）LL-旋转（左左失衡）"><a href="#（1）LL-旋转（左左失衡）" class="headerlink" title="（1）LL 旋转（左左失衡）"></a>（1）LL 旋转（左左失衡）</h5><ul><li><p><strong>触发条件</strong>：失衡节点的平衡因子为 2，且其左子节点的平衡因子 ≥ 0（左子树的左子树更高）。</p></li><li><p><strong>操作</strong>：将失衡节点的左子节点提升为新根，失衡节点作为其右子节点，原左子节点的右子树转为失衡节点的左子树。</p><p><img src="/../images/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/1761233948568.png" alt="1761233948568"></p><pre><code class="cpp">AVLNode* llRotate(AVLNode* y) &#123;    AVLNode* x = y-&gt;left;       // x是y的左子节点    AVLNode* T2 = x-&gt;right;     // T2是x的右子树    x-&gt;right = y;               // y成为x的右子节点    y-&gt;left = T2;               // T2成为y的左子树    // 更新高度（先更新y，再更新x，因x是y的父节点）    updateHeight(y);    updateHeight(x);    return x; // x成为新的根节点&#125;</code></pre></li></ul><h5 id="（2）RR-旋转（右右失衡）"><a href="#（2）RR-旋转（右右失衡）" class="headerlink" title="（2）RR 旋转（右右失衡）"></a>（2）RR 旋转（右右失衡）</h5><ul><li><p><strong>触发条件</strong>：失衡节点的平衡因子为 - 2，且其右子节点的平衡因子 ≤ 0（右子树的右子树更高）。</p></li><li><p><strong>操作</strong>：将失衡节点的右子节点提升为新根，失衡节点作为其左子节点，原右子节点的左子树转为失衡节点的右子树。</p><p><img src="/../images/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/1761234031632.png" alt="1761234031632"></p></li></ul><pre><code class="c++">AVLNode* rrRotate(AVLNode* y) &#123;    AVLNode* x = y-&gt;right;      // x是y的右子节点    AVLNode* T2 = x-&gt;left;      // T2是x的左子树    x-&gt;left = y;                // y成为x的左子节点    y-&gt;right = T2;              // T2成为y的右子树    // 更新高度    updateHeight(y);    updateHeight(x);    return x; // x成为新的根节点&#125;</code></pre><h5 id="（3）LR-旋转（左右失衡）"><a href="#（3）LR-旋转（左右失衡）" class="headerlink" title="（3）LR 旋转（左右失衡）"></a>（3）LR 旋转（左右失衡）</h5><ul><li><p><strong>触发条件</strong>：失衡节点的平衡因子为 2，且其左子节点的平衡因子 &lt; 0（左子树的右子树更高）。</p></li><li><p><strong>操作</strong>：先对左子节点执行 RR 旋转（转为 LL 型），再对失衡节点执行 LL 旋转。</p><p><img src="/../images/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/1761234065591.png" alt="1761234065591"></p><pre><code class="cpp">AVLNode* lrRotate(AVLNode* y) &#123;    y-&gt;left = rrRotate(y-&gt;left); // 先将左子树转为LL型    return llRotate(y);          // 再做LL旋转&#125;</code></pre></li></ul><h5 id="（4）RL-旋转（右左失衡）"><a href="#（4）RL-旋转（右左失衡）" class="headerlink" title="（4）RL 旋转（右左失衡）"></a>（4）RL 旋转（右左失衡）</h5><ul><li><p><strong>触发条件</strong>：失衡节点的平衡因子为 - 2，且其右子节点的平衡因子 &gt; 0（右子树的左子树更高）。</p></li><li><p><strong>操作</strong>：先对右子节点执行 LL 旋转（转为 RR 型），再对失衡节点执行 RR 旋转。</p><p><img src="/../images/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8EAVL%E6%A0%91/1761234298746.png" alt="1761234298746"></p></li></ul><pre><code class="c++">AVLNode* rlRotate(AVLNode* y) &#123;    y-&gt;right = llRotate(y-&gt;right); // 先将右子树转为RR型    return rrRotate(y);            // 再做RR旋转&#125;</code></pre><h4 id="3-插入操作"><a href="#3-插入操作" class="headerlink" title="3. 插入操作"></a>3. 插入操作</h4><p>AVL 树的插入流程：</p><ol><li><strong>按 BST 规则插入</strong>：递归找到插入位置，创建新节点。</li><li><strong>更新高度</strong>：从插入节点向上回溯，更新所有祖先节点的高度。</li><li><strong>检查平衡</strong>：计算每个祖先节点的平衡因子，若失衡则执行对应旋转。</li><li><strong>返回新根</strong>：旋转后可能改变子树的根，需将新根返回给父节点。</li></ol><pre><code class="cpp">AVLNode* insert(AVLNode* root, int val) &#123;    // 1. 按BST规则插入新节点    if (root == nullptr) &#123;        return new AVLNode(val); // 空树，直接创建节点    &#125;    if (val &lt; root-&gt;val) &#123;        root-&gt;left = insert(root-&gt;left, val); // 插入左子树    &#125; else if (val &gt; root-&gt;val) &#123;        root-&gt;right = insert(root-&gt;right, val); // 插入右子树    &#125; else &#123;        return root; // 不允许重复值    &#125;    // 2. 更新当前节点高度    updateHeight(root);    // 3. 计算平衡因子，检查是否失衡    int balance = getBalance(root);    // 4. 失衡处理（四种情况）    if (balance &gt; 1) &#123; // 左子树过高        if (val &lt; root-&gt;left-&gt;val) &#123;            return llRotate(root); // LL型        &#125; else &#123;            return lrRotate(root); // LR型        &#125;    &#125;    if (balance &lt; -1) &#123; // 右子树过高        if (val &gt; root-&gt;right-&gt;val) &#123;            return rrRotate(root); // RR型        &#125; else &#123;            return rlRotate(root); // RL型        &#125;    &#125;    // 未失衡，返回原节点    return root;&#125;</code></pre><h4 id="4-删除操作"><a href="#4-删除操作" class="headerlink" title="4. 删除操作"></a>4. 删除操作</h4><p>删除操作与插入类似，但更复杂：</p><ol><li><strong>按 BST 规则删除</strong>：分三种情况（叶子节点、单孩子节点、双孩子节点）删除目标节点。</li><li><strong>更新高度</strong>：从删除位置向上回溯，更新祖先节点高度。</li><li><strong>检查平衡</strong>：若节点失衡，执行对应旋转（旋转逻辑与插入相同）。</li></ol><pre><code class="cpp">// 查找以root为根的树中的最小值节点（用于双孩子节点删除）AVLNode* findMin(AVLNode* root) &#123;    while (root-&gt;left != nullptr) root = root-&gt;left;    return root;&#125;AVLNode* deleteNode(AVLNode* root, int val) &#123;    // 1. 按BST规则删除节点    if (root == nullptr) return nullptr; // 树为空    if (val &lt; root-&gt;val) &#123;        root-&gt;left = deleteNode(root-&gt;left, val); // 左子树删除    &#125; else if (val &gt; root-&gt;val) &#123;        root-&gt;right = deleteNode(root-&gt;right, val); // 右子树删除    &#125; else &#123; // 找到目标节点        // 情况1：叶子节点或只有一个孩子        if (root-&gt;left == nullptr) &#123;            AVLNode* temp = root-&gt;right;            delete root;            return temp;        &#125; else if (root-&gt;right == nullptr) &#123;            AVLNode* temp = root-&gt;left;            delete root;            return temp;        &#125;        // 情况2：有两个孩子，用右子树最小值替换        AVLNode* temp = findMin(root-&gt;right);        root-&gt;val = temp-&gt;val;        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val); // 删除右子树最小值    &#125;    // 若树为空，直接返回    if (root == nullptr) return nullptr;    // 2. 更新当前节点高度    updateHeight(root);    // 3. 计算平衡因子，处理失衡    int balance = getBalance(root);    // 左子树失衡    if (balance &gt; 1) &#123;        if (getBalance(root-&gt;left) &gt;= 0) &#123;            return llRotate(root); // LL型        &#125; else &#123;            return lrRotate(root); // LR型        &#125;    &#125;    // 右子树失衡    if (balance &lt; -1) &#123;        if (getBalance(root-&gt;right) &lt;= 0) &#123;            return rrRotate(root); // RR型        &#125; else &#123;            return rlRotate(root); // RL型        &#125;    &#125;    return root;&#125;</code></pre><h3 id="四、AVL-树的性能分析"><a href="#四、AVL-树的性能分析" class="headerlink" title="四、AVL 树的性能分析"></a>四、AVL 树的性能分析</h3><ul><li><strong>时间复杂度</strong>：插入、删除、查找均为**O(log n)**，因平衡约束保证树高为 O (log n)（n 为节点数）。</li><li><strong>空间复杂度</strong>：O (n)，需存储 n 个节点及高度信息。</li><li><strong>优势</strong>：严格平衡，查询效率稳定。</li><li><strong>劣势</strong>：旋转操作频繁（尤其是插入和删除时），维护成本较高，适用于查询密集、插入删除较少的场景。</li></ul><h3 id="五、AVL树构建C-示例"><a href="#五、AVL树构建C-示例" class="headerlink" title="五、AVL树构建C++示例"></a>五、AVL树构建C++示例</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;algorithm&gt; // 用于max函数using namespace std;// AVL树节点结构struct AVLNode &#123;    int data;    AVLNode* left;    AVLNode* right;    int height; // 节点高度    // 构造函数    AVLNode(int val) : data(val), left(nullptr), right(nullptr), height(1) &#123;&#125;&#125;;// 获取节点高度（空节点高度为0）int getHeight(AVLNode* node) &#123;    return (node == nullptr) ? 0 : node-&gt;height;&#125;// 计算平衡因子（左子树高度 - 右子树高度）int getBalance(AVLNode* node) &#123;    return (node == nullptr) ? 0 : getHeight(node-&gt;left) - getHeight(node-&gt;right);&#125;// LL旋转（左左旋转）AVLNode* llRotate(AVLNode* y) &#123;    AVLNode* x = y-&gt;left;    AVLNode* T2 = x-&gt;right;    // 执行旋转    x-&gt;right = y;    y-&gt;left = T2;    // 更新高度    y-&gt;height = 1 + max(getHeight(y-&gt;left), getHeight(y-&gt;right));    x-&gt;height = 1 + max(getHeight(x-&gt;left), getHeight(x-&gt;right));    // 返回新的根节点    return x;&#125;// RR旋转（右右旋转）AVLNode* rrRotate(AVLNode* y) &#123;    AVLNode* x = y-&gt;right;    AVLNode* T2 = x-&gt;left;    // 执行旋转    x-&gt;left = y;    y-&gt;right = T2;    // 更新高度    y-&gt;height = 1 + max(getHeight(y-&gt;left), getHeight(y-&gt;right));    x-&gt;height = 1 + max(getHeight(x-&gt;left), getHeight(x-&gt;right));    // 返回新的根节点    return x;&#125;// LR旋转（左右旋转）：先对左子树做RR旋转，再做LL旋转AVLNode* lrRotate(AVLNode* y) &#123;    y-&gt;left = rrRotate(y-&gt;left); // 先将左子树转为LL型    return llRotate(y);          // 再做LL旋转&#125;// RL旋转（右左旋转）：先对右子树做LL旋转，再做RR旋转AVLNode* rlRotate(AVLNode* y) &#123;    y-&gt;right = llRotate(y-&gt;right); // 先将右子树转为RR型    return rrRotate(y);            // 再做RR旋转&#125;// 插入节点并维持AVL平衡AVLNode* insert(AVLNode* node, int val) &#123;    // 1. 执行普通二叉搜索树插入    if (node == nullptr) &#123;        return new AVLNode(val); // 插入新节点    &#125;    if (val &lt; node-&gt;data) &#123;        node-&gt;left = insert(node-&gt;left, val); // 插入左子树    &#125; else if (val &gt; node-&gt;data) &#123;        node-&gt;right = insert(node-&gt;right, val); // 插入右子树    &#125; else &#123;        // AVL树不允许重复值（题目说明输入值不同）        return node;    &#125;    // 2. 更新当前节点高度    node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));    // 3. 计算平衡因子，检查是否失衡    int balance = getBalance(node);    // 4. 失衡处理（四种情况）    // LL型：左子树的左子树插入导致失衡    if (balance &gt; 1 &amp;&amp; val &lt; node-&gt;left-&gt;data) &#123;        return llRotate(node);    &#125;    // RR型：右子树的右子树插入导致失衡    if (balance &lt; -1 &amp;&amp; val &gt; node-&gt;right-&gt;data) &#123;        return rrRotate(node);    &#125;    // LR型：左子树的右子树插入导致失衡    if (balance &gt; 1 &amp;&amp; val &gt; node-&gt;left-&gt;data) &#123;        return lrRotate(node);    &#125;    // RL型：右子树的左子树插入导致失衡    if (balance &lt; -1 &amp;&amp; val &lt; node-&gt;right-&gt;data) &#123;        return rlRotate(node);    &#125;    // 未失衡，返回原节点    return node;&#125;int main() &#123;    int n;    cin &gt;&gt; n;    AVLNode* root = nullptr;    for (int i = 0; i &lt; n; ++i) &#123;        int val;        cin &gt;&gt; val;        root = insert(root, val);    &#125;    cout &lt;&lt; root-&gt;data &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;​              &lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://example.com/2025/10/21/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2025/10/21/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2025-10-21T11:08:21.000Z</published>
    <updated>2025-10-25T12:06:49.909Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的概念及性质</p><span id="more"></span><h3 id="一、二叉树的核心概念"><a href="#一、二叉树的核心概念" class="headerlink" title="一、二叉树的核心概念"></a><strong>一、二叉树的核心概念</strong></h3><p>二叉树是每个节点最多有两个子节点（左子节点、右子节点）的树形结构，具有以下特点：</p><ul><li><strong>根节点</strong>：无父节点的唯一节点。</li><li><strong>叶子节点</strong>：无左 &#x2F; 右子节点的节点。</li><li><strong>子树</strong>：以任意节点为根的二叉树（左子树、右子树）。</li><li><strong>深度</strong>：根节点到某节点的路径长度（根节点深度为 1）。</li><li><strong>高度</strong>：某节点到最深叶子节点的路径长度（叶子节点高度为 1）。</li></ul><h4 id="性质-1：节点数量与层数的关系"><a href="#性质-1：节点数量与层数的关系" class="headerlink" title="性质 1：节点数量与层数的关系"></a><strong>性质 1：节点数量与层数的关系</strong></h4><ul><li><p>第 <code>i</code> 层最多有 <code>2^(i-1)</code> 个节点<code>（i ≥ 1）</code>。</p><p>例如：第 1 层（根节点）最多 1 个<code>（2^0）</code>，第 2 层最多 2 个<code>（2^1）</code>，第 3 层最多 4 个<code>（2^2）</code>，以此类推。</p></li></ul><h4 id="性质-2：深度与总节点数的关系"><a href="#性质-2：深度与总节点数的关系" class="headerlink" title="性质 2：深度与总节点数的关系"></a><strong>性质 2：深度与总节点数的关系</strong></h4><ul><li><p>深度为 <code>k</code> 的二叉树最多有 <code>2^k - 1</code> 个节点<code>（k ≥ 1）</code>。</p><p>此时二叉树为满二叉树（每一层节点数都达到最大值）。</p><p>例如：深度为 3 的满二叉树最多有<code>2^3 - 1 = 7</code>个节点。</p></li></ul><h4 id="性质-3：叶子节点与度为-2-的节点的关系"><a href="#性质-3：叶子节点与度为-2-的节点的关系" class="headerlink" title="性质 3：叶子节点与度为 2 的节点的关系"></a><strong>性质 3：叶子节点与度为 2 的节点的关系</strong></h4><ul><li><p>对任意非空二叉树，若叶子节点数为 <code>n₀</code>，度为 2 的节点数为 <code>n₂</code>，则 <code>n₀ = n₂ + 1</code>。</p><p>（度：节点的子节点数，二叉树中节点的度只能是 0、1、2）</p><p>推导：总节点数<code>n = n₀ + n₁ + n₂</code>（<code>n₁</code>为度为 1 的节点数），</p><p>总边数 <code>n-1 = n₁ + 2n₂</code>（每个节点除根外都有一条父节点边），</p><p>联立得<code>n₀ = n₂ + 1</code>。</p></li></ul><h4 id="性质-4：完全二叉树的节点编号特性"><a href="#性质-4：完全二叉树的节点编号特性" class="headerlink" title="性质 4：完全二叉树的节点编号特性"></a><strong>性质 4：完全二叉树的节点编号特性</strong></h4><p>完全二叉树（除最后一层外均满，最后一层节点从左到右连续）中，若节点按层序编号（根为 1，左→右、上→下），则对任意节点 <code>i</code>（<code>i ≥ 1</code>）：</p><ul><li>左子节点编号为 <code>2i</code>（若存在）；</li><li>右子节点编号为 <code>2i + 1</code>（若存在）；</li><li>父节点编号为 <code>⌊i/2⌋</code>（若 <code>i &gt; 1</code>）。</li></ul><h4 id="性质-5：完全二叉树的深度计算"><a href="#性质-5：完全二叉树的深度计算" class="headerlink" title="性质 5：完全二叉树的深度计算"></a><strong>性质 5：完全二叉树的深度计算</strong></h4><ul><li><p>具有 <code>n</code> 个节点的完全二叉树，深度为 <code>⌊log₂n⌋ + 1</code>（<code>⌊x⌋</code>表示向下取整）。</p><p>例如：<code>n=6</code>时，<code>log₂6 ≈ 2.58</code>，深度为<code>2 + 1 = 3</code>。</p></li></ul><h4 id="性质-6：完全二叉树的叶子节点分布"><a href="#性质-6：完全二叉树的叶子节点分布" class="headerlink" title="性质 6：完全二叉树的叶子节点分布"></a><strong>性质 6：完全二叉树的叶子节点分布</strong></h4><ul><li>若完全二叉树有<code>n</code>个节点，则：<ul><li>当 <code>n</code> 为奇数时，无度为 1 的节点（<code>n₁ = 0</code>）；</li><li>当 <code>n</code> 为偶数时，有且仅有 1 个度为 1 的节点（<code>n₁ = 1</code>）。</li></ul></li></ul><h3 id="二、节点定义与基础结构"><a href="#二、节点定义与基础结构" class="headerlink" title="二、节点定义与基础结构"></a><strong>二、节点定义与基础结构</strong></h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;  // 层序遍历用#include &lt;stack&gt;  // 迭代遍历用using namespace std;// 二叉树节点结构struct TreeNode &#123;    int val;         // 节点值    TreeNode* left;  // 左子节点指针    TreeNode* right; // 右子节点指针    // 构造函数    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;</code></pre><h3 id="三、遍历算法（核心操作）"><a href="#三、遍历算法（核心操作）" class="headerlink" title="三、遍历算法（核心操作）"></a><strong>三、遍历算法（核心操作）</strong></h3><p>遍历是按规则访问所有节点，分为<strong>深度优先（DFS）</strong> 和<strong>广度优先（BFS）</strong> 两类。</p><h4 id="1-深度优先遍历（DFS）"><a href="#1-深度优先遍历（DFS）" class="headerlink" title="1. 深度优先遍历（DFS）"></a><strong>1. 深度优先遍历（DFS）</strong></h4><p>包括前序、中序、后序遍历，核心是递归或用栈模拟递归。</p><h5 id="（1）前序遍历（根-→-左-→-右）"><a href="#（1）前序遍历（根-→-左-→-右）" class="headerlink" title="（1）前序遍历（根 → 左 → 右）"></a><strong>（1）前序遍历（根 → 左 → 右）</strong></h5><pre><code class="cpp">// 递归实现void preorderRecursive(TreeNode* root) &#123;    if (root == nullptr) return;    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;       // 访问根    preorderRecursive(root-&gt;left);  // 遍历左子树    preorderRecursive(root-&gt;right); // 遍历右子树&#125;// 迭代实现（用栈）void preorderIterative(TreeNode* root) &#123;    if (root == nullptr) return;    stack&lt;TreeNode*&gt; st;    st.push(root);    while (!st.empty()) &#123;        TreeNode* cur = st.top();        st.pop();        cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;;   // 访问根        // 右子树先入栈（栈是后进先出，保证左子树先访问）        if (cur-&gt;right != nullptr) st.push(cur-&gt;right);        if (cur-&gt;left != nullptr) st.push(cur-&gt;left);    &#125;&#125;</code></pre><h5 id="（2）中序遍历（左-→-根-→-右）"><a href="#（2）中序遍历（左-→-根-→-右）" class="headerlink" title="（2）中序遍历（左 → 根 → 右）"></a><strong>（2）中序遍历（左 → 根 → 右）</strong></h5><p>对二叉搜索树（BST）遍历可得到升序序列。</p><pre><code class="cpp">// 递归实现void inorderRecursive(TreeNode* root) &#123;    if (root == nullptr) return;    inorderRecursive(root-&gt;left);   // 遍历左子树    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;       // 访问根    inorderRecursive(root-&gt;right);  // 遍历右子树&#125;// 迭代实现（用栈）void inorderIterative(TreeNode* root) &#123;    if (root == nullptr) return;    stack&lt;TreeNode*&gt; st;    TreeNode* cur = root;    while (cur != nullptr || !st.empty()) &#123;        // 左子树全部入栈        while (cur != nullptr) &#123;            st.push(cur);            cur = cur-&gt;left;        &#125;        // 访问节点，转向右子树        cur = st.top();        st.pop();        cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;;        cur = cur-&gt;right;    &#125;&#125;</code></pre><h5 id="（3）后序遍历（左-→-右-→-根）"><a href="#（3）后序遍历（左-→-右-→-根）" class="headerlink" title="（3）后序遍历（左 → 右 → 根）"></a><strong>（3）后序遍历（左 → 右 → 根）</strong></h5><p>常用于删除节点或计算表达式树。</p><pre><code class="cpp">// 递归实现void postorderRecursive(TreeNode* root) &#123;    if (root == nullptr) return;    postorderRecursive(root-&gt;left);  // 遍历左子树    postorderRecursive(root-&gt;right); // 遍历右子树    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;        // 访问根&#125;// 迭代实现（双栈法）void postorderIterative(TreeNode* root) &#123;    if (root == nullptr) return;    stack&lt;TreeNode*&gt; st1, st2;    st1.push(root);    // 栈1弹出顺序：根→右→左，压入栈2后弹出顺序为左→右→根    while (!st1.empty()) &#123;        TreeNode* cur = st1.top();        st1.pop();        st2.push(cur);        if (cur-&gt;left != nullptr) st1.push(cur-&gt;left);        if (cur-&gt;right != nullptr) st1.push(cur-&gt;right);    &#125;    // 输出栈2    while (!st2.empty()) &#123;        cout &lt;&lt; st2.top()-&gt;val &lt;&lt; &quot; &quot;;        st2.pop();    &#125;&#125;</code></pre><h4 id="2-广度优先遍历（BFS）：层序遍历"><a href="#2-广度优先遍历（BFS）：层序遍历" class="headerlink" title="2. 广度优先遍历（BFS）：层序遍历"></a><strong>2. 广度优先遍历（BFS）：层序遍历</strong></h4><p>按层次访问节点，用队列实现。</p><pre><code class="cpp">void levelorder(TreeNode* root) &#123;    if (root == nullptr) return;    queue&lt;TreeNode*&gt; q;    q.push(root); // 根节点入队    while (!q.empty()) &#123;        int size = q.size(); // 当前层节点数        // 遍历当前层所有节点        for (int i = 0; i &lt; size; ++i) &#123;            TreeNode* cur = q.front();            q.pop();            cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;;            // 子节点入队（下一层）            if (cur-&gt;left != nullptr) q.push(cur-&gt;left);            if (cur-&gt;right != nullptr) q.push(cur-&gt;right);        &#125;    &#125;&#125;</code></pre><h3 id="四、常用操作"><a href="#四、常用操作" class="headerlink" title="四、常用操作"></a><strong>四、常用操作</strong></h3><pre><code class="cpp">// 计算二叉树高度（递归）int getHeight(TreeNode* root) &#123;    if (root == nullptr) return 0; // 空树高度为0    return max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;&#125;// 计算节点总数（递归）int getNodeCount(TreeNode* root) &#123;    if (root == nullptr) return 0;    return 1 + getNodeCount(root-&gt;left) + getNodeCount(root-&gt;right);&#125;// 销毁二叉树（后序遍历释放节点，避免内存泄漏）void destroyTree(TreeNode*&amp; root) &#123; // 传引用，确保root置空    if (root == nullptr) return;    destroyTree(root-&gt;left);    destroyTree(root-&gt;right);    delete root;    root = nullptr;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;二叉树的概念及性质&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://example.com/2025/10/12/%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2025/10/12/%E6%8E%92%E5%BA%8F/</id>
    <published>2025-10-12T06:08:17.000Z</published>
    <updated>2025-10-12T08:34:32.347Z</updated>
    
    <content type="html"><![CDATA[<p>简单排序（冒泡、插入、比较），快速排序，归并排序。</p><span id="more"></span><h1 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h1><h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><pre><code class="c++">void bubbleSort(vector&lt;int&gt;&amp; arr, int l, int r) &#123;    for (int i = l; i &lt; r; i++) &#123;        bool swapped = false;        for (int j = l; j &lt; r - (i - l); j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr[j], arr[j + 1]);                swapped = true;            &#125;        &#125;        if (!swapped) &#123;            break;        &#125;    &#125;&#125;int main ()&#123;    bubbleSort(arr, 0, n - 1);    return 0;&#125;</code></pre><p><strong>核心思想</strong>：通过相邻元素的两两比较，每轮将最大的元素 “冒泡” 到当前未排序部分的末尾。优化点在于若某轮未发生交换，说明数组已有序，可提前终止。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><pre><code class="c++">void insertionSort(vector&lt;int&gt;&amp; arr,int l,int r) &#123;    for (int i = l + 1;i &lt;= r;i ++)&#123;        int key = arr[i];        int j = i - 1;        while (j &gt;= l &amp;&amp; arr[j] &gt; key)&#123;            arr[j + 1] = arr[j];            j--;        &#125;        arr[j + 1] = key;    &#125;&#125;int main ()&#123;    insertionSort(arr, 0, n - 1);    return 0;&#125;</code></pre><p><strong>核心思想</strong>：将数组分为 “已排序”（初始为 ）和 “未排序” 两部分，依次将未排序元素插入到已排序部分的合适位置（通过移动元素腾出位置）。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><pre><code class="c++">void selectionSort(vector&lt;int&gt;&amp; arr, int l, int r) &#123;    for (int i = l; i &lt; r; i++) &#123;        int minIndex = i;        for (int j = i + 1; j &lt;= r; j++) &#123;            if (arr[j] &lt; arr[minIndex]) &#123;                minIndex = j;            &#125;        &#125;        swap(arr[i], arr[minIndex]);    &#125;&#125;int main ()&#123;    selectionSort(arr, 0, n - 1);    return 0;&#125;</code></pre><p><strong>核心思想</strong>：每轮从当前未排序部分中找到最小元素，与未排序部分的首位交换，逐步扩大已排序部分。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><pre><code class="c++">void quickSort(vector&lt;int&gt;&amp; arr, int l,int r)&#123;    if (l &gt;= r) return;    int privotIndex = partition(arr, l, r);    quickSort(arr, l, privotIndex - 1);    quickSort(arr, privotIndex + 1, r);&#125;int partition(vector&lt;int&gt;&amp; arr, int l, int r) &#123;    int privot = arr[r];    int i = l - 1;    for (int j = l; j &lt; r; j++) &#123;        if (arr[j] &lt;= privot) &#123;            i++;            swap(arr[i], arr[j]);        &#125;    &#125;    swap(arr[i + 1], arr[r]);    return i + 1;&#125;int main ()&#123;    quickSort(arr, 0, n - 1);    return 0;&#125;</code></pre><p><strong>核心思想</strong>：基于分治，选择基准值（此处为 ），通过分区操作将数组分为 “小于等于基准” 和 “大于基准” 两部分，递归排序子数组。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><pre><code class="c++">void mergeSort(vector&lt;int&gt;&amp; arr,int l, int r) &#123;    if (l &gt;= r) return;    int m = (l + r) / 2;    mergeSort(arr ,l, m);    mergeSort(arr ,m + 1, r);    merge(arr,l, m, r);&#125;void merge(vector&lt;int&gt;&amp; arr,int l, int m, int r) &#123;    int n1 = m - l + 1;    int n2 = r - m;    vector&lt;int&gt;L(n1);    vector&lt;int&gt;R(n2);    for (int i = 0; i &lt; n1; i++) L[i] = arr[l + i];    for (int i = 0; i &lt; n2; i++) R[i] = arr[m + 1 + i];    int i = 0, j = 0, k = l;    while (i &lt; n1 &amp;&amp; j &lt; n2) &#123;        if (L[i] &lt; R[j]) &#123;            arr[k++] = L[i++];        &#125;        else &#123;            arr[k++] = R[j++];        &#125;    &#125;    while (i &lt; n1) arr[k++] = L[i++];    while (j &lt; n2) arr[k++] = R[j++];&#125;int main ()&#123;    mergeSort(arr, 0, n - 1);    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单排序（冒泡、插入、比较），快速排序，归并排序。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>队列4.2 Rescue the princess</title>
    <link href="http://example.com/2025/10/08/princess/"/>
    <id>http://example.com/2025/10/08/princess/</id>
    <published>2025-10-08T06:00:01.000Z</published>
    <updated>2025-10-08T06:44:36.943Z</updated>
    
    <content type="html"><![CDATA[<p>广度优先搜索</p><span id="more"></span><h3 id="数据结构与算法实验题-4-2-Rescue-the-princess"><a href="#数据结构与算法实验题-4-2-Rescue-the-princess" class="headerlink" title="数据结构与算法实验题 4.2 Rescue the princess"></a>数据结构与算法实验题 4.2 Rescue the princess</h3><p>★实验任务</p><p>有一天，公主被一个魔王抓走关在一个城堡里面，城堡可以用 N<em>M 的矩阵来描述，1&lt;N,M&lt;&#x3D;200。监狱由 N</em>M 个方格组成，每个方格中可能为墙壁，空地，怪物，公主或者是勇士。</p><p>现在勇士想去营救公主。他的任务是找到公主。约定，“找到公主”的意思是到达公主被关的位置。如果勇士想到达某个方格，但方格中有怪物，那么必须杀死怪物，才能到达这个方格。假设勇士只能向上，下，左，右四个方向移动一步。移动一步的需要花费 1 个单位的时间，杀死怪物也需要一个单位的时间。</p><p>试着计算勇士找到公主需要多长时间。只能上，下，左，右移动，而且墙壁不能通过。</p><p>★数据输入</p><p>输入第一行包含 2 个整数 N，M，接下来 N 行，每行 M 个字符：“.”代表空地，“a”表示公主，“r”表示勇士，“#”代表墙壁，“x”表示怪物。（测试数据中“a”和“r”只有一个）。</p><p>★数据输出</p><p>输出一个整数，表示找到公主所需要最短的时间。如果无法找到公主，输出-1。</p><table><thead><tr><th>输入示例</th></tr></thead><tbody><tr><td>7 8</td></tr><tr><td>#.#####.</td></tr><tr><td>#.a#..r.</td></tr><tr><td>#..#x…</td></tr><tr><td>..#..#.#</td></tr><tr><td>#…##..</td></tr><tr><td>.#……</td></tr><tr><td>……..</td></tr></tbody></table><table><thead><tr><th>输出示例</th></tr></thead><tbody><tr><td>13</td></tr></tbody></table><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><pre><code class="c++">#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int n, m;int ans = 1996;queue&lt;pair&lt;int, int&gt;&gt; p;int nx[4] = &#123; 0,1,0,-1 &#125;;int ny[4] = &#123; 1,0,-1,0 &#125;;void search(char** map,pair&lt;int, int&gt; loc,char count) &#123;    int x = loc.first;    int y = loc.second;    for (int i = 0; i &lt; 4; i++) &#123;        int dx = x + nx[i];        int dy = y + ny[i];        if (map[dx][dy] == &#39;.&#39;) &#123;            map[dx][dy] = count + 1;            p.push(pair&lt;int,int&gt;(dx, dy));        &#125;        else if (map[dx][dy] == &#39;x&#39;) &#123;            map[dx][dy] = count + 2;            p.push(pair&lt;int,int&gt;(dx, dy));        &#125;        else if (map[dx][dy] == &#39;a&#39;) &#123;            int temp = (int)(count + 1 - &#39;0&#39;);            if (temp &lt; ans) &#123;                ans = temp;            &#125;            p.pop();            return;        &#125;    &#125;    p.pop();    while (!p.empty()) &#123;        search(map, p.front(), map[p.front().first][p.front().second]);    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    int x, y;    char** map = new char* [n + 2];    for (int i = 0; i &lt;= n + 1; i++) &#123;        map[i] = new char[m + 2];    &#125;    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= m; j++) &#123;            cin &gt;&gt; map[i][j];            if (map[i][j] == &#39;r&#39;) &#123;                x = i;                y = j;            &#125;        &#125;    &#125;    for (int i = 0; i &lt; m + 2; i++) &#123;        map[0][i] = &#39;#&#39;;        map[n + 1][i] = &#39;#&#39;;    &#125;    for (int i = 0; i &lt; n + 2; i++) &#123;        map[i][0] = &#39;#&#39;;        map[i][m + 1] = &#39;#&#39;;    &#125;    pair &lt;int, int&gt;temp = &#123;x,y&#125;;    p.push(temp);    search(map, temp, &#39;0&#39;);    if (ans != 1996) &#123;        cout &lt;&lt; ans;    &#125;    else&#123;        cout &lt;&lt; -1;    &#125;    return 0;&#125;</code></pre><p>自己凭感觉写的，虽然用了队列，但是更接近深度优先搜索。</p><p><strong>核心思路：</strong>尝试通过 “队列辅助的递归搜索” 从起点<code>&#39;r&#39;</code>找到终点<code>&#39;a&#39;</code>，并计算路径长度，本质上是想实现 “最短路径搜索”，但因逻辑设计问题实际偏向深度优先搜索（DFS）。具体可拆解为以下几点：</p><ol><li><strong>初始设定</strong><ul><li>用二维数组<code>map</code>存储迷宫，<code>&#39;r&#39;</code>是起点，<code>&#39;a&#39;</code>是终点，<code>&#39;.&#39;</code>和<code>&#39;x&#39;</code>是可通行区域（可能<code>&#39;x&#39;</code>被视为特殊可走节点），<code>&#39;#&#39;</code>是边界（不可通行）。</li><li>用队列<code>p</code>存储待探索的坐标，初始将起点<code>&#39;r&#39;</code>的坐标入队。</li></ul></li><li><strong>搜索逻辑</strong><ul><li>定义<code>search</code>函数，参数为当前地图、当前坐标<code>loc</code>、当前路径长度<code>count</code>（用字符表示，如<code>&#39;0&#39;</code>代表 0 步）。</li><li>对当前坐标的 4 个方向（上下左右）进行探索：<ul><li>若遇到<code>&#39;.&#39;</code>（普通可走），标记为<code>count + 1</code>（更新路径长度），并将该坐标入队。</li><li>若遇到<code>&#39;x&#39;</code>（特殊可走），标记为<code>count + 2</code>（可能想区分路径类型），并将该坐标入队。</li><li>若遇到<code>&#39;a&#39;</code>（终点），计算当前路径长度并更新最短路径<code>ans</code>，然后退出。</li></ul></li></ul></li><li><strong>队列与递归的结合</strong><ul><li>每次处理完当前节点后，弹出队列头部元素，再通过递归依次处理队列中剩余的节点，试图遍历所有可能的路径。</li></ul></li></ol><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><pre><code class="c++">#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;int n, m;int ans = 1996;queue&lt;pair&lt;int, int&gt;&gt; p;int nx[4] = &#123; 0,1,0,-1 &#125;;int ny[4] = &#123; 1,0,-1,0 &#125;;void search(char** map,pair&lt;int, int&gt; loc,char count) &#123;    while (!p.empty()) &#123;        int x = p.front().first;        int y = p.front().second;        for (int i = 0; i &lt; 4; i++) &#123;            int dx = x + nx[i];            int dy = y + ny[i];            if (map[dx][dy] == &#39;.&#39;) &#123;                map[dx][dy] = map[x][y] + 1;                p.push(pair&lt;int, int&gt;(dx, dy));            &#125;            else if (map[dx][dy] == &#39;x&#39;) &#123;                map[dx][dy] = map[x][y] + 2;                p.push(pair&lt;int, int&gt;(dx, dy));            &#125;            else if (map[dx][dy] == &#39;a&#39;) &#123;                int temp = (int)(map[x][y] + 1 - &#39;0&#39;);                if (temp &lt; ans) &#123;                    ans = temp;                &#125;            &#125;            else if (map[dx][dy] != &#39;#&#39;) &#123;                if (map[x][y] + 1 &lt; map[dx][dy]) &#123;                    map[dx][dy] = map[x][y] + 1;                &#125;            &#125;        &#125;        p.pop();    &#125;   &#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    int x, y;    char** map = new char* [n + 2];    for (int i = 0; i &lt;= n + 1; i++) &#123;        map[i] = new char[m + 2];    &#125;    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= m; j++) &#123;            cin &gt;&gt; map[i][j];            if (map[i][j] == &#39;r&#39;) &#123;                map[i][j] = &#39;0&#39;;                x = i;                y = j;            &#125;        &#125;    &#125;    for (int i = 0; i &lt; m + 2; i++) &#123;        map[0][i] = &#39;#&#39;;        map[n + 1][i] = &#39;#&#39;;    &#125;    for (int i = 0; i &lt; n + 2; i++) &#123;        map[i][0] = &#39;#&#39;;        map[i][m + 1] = &#39;#&#39;;    &#125;    pair &lt;int, int&gt;temp = &#123;x,y&#125;;    p.push(temp);    search(map, temp, &#39;0&#39;);    if (ans != 1996) &#123;        cout &lt;&lt; ans;    &#125;    else&#123;        cout &lt;&lt; -1;    &#125;    return 0;&#125;</code></pre><p>这个代码的核心思路是 <strong>用队列实现 BFS 框架，从起点<code>&#39;r&#39;</code>出发探索迷宫，寻找终点<code>&#39;a&#39;</code>，并尝试让节点保留更小的路径步数</strong>，具体分 4 步：</p><ol><li><p><strong>初始化与准备</strong></p><ul><li>地图外围填<code>&#39;#&#39;</code>当边界，避免越界；起点<code>&#39;r&#39;</code>改成字符<code>&#39;0&#39;</code>（作为路径长度的起始基准），并把起点坐标加入队列。</li><li>用队列<code>p</code>存储待探索的节点，按 “先进先出” 顺序处理，符合 BFS “逐层扩散” 的特点。</li></ul></li><li><p><strong>BFS 核心探索</strong></p><ul><li><p>循环从队列取节点</p><pre><code>(x,y)</code></pre><p>，遍历它的上下左右 4 个邻居</p><pre><code>(dx,dy)</code></pre><p>，根据邻居类型处理：</p><ul><li>若邻居是<code>&#39;.&#39;</code>（普通可走）：把邻居标记为 “当前节点步数 + 1”（字符累加，比如<code>&#39;0&#39;→&#39;1&#39;</code>），并加入队列；</li><li>若邻居是<code>&#39;x&#39;</code>（特殊可走）：把邻居标记为 “当前节点步数 + 2”（给<code>&#39;x&#39;</code>更高的路径成本），也加入队列；</li><li>若邻居是<code>&#39;a&#39;</code>（终点）：计算当前节点到终点的步数，更新全局最小步数<code>ans</code>。</li></ul></li></ul></li><li><p><strong>新增的 “小步数更新” 逻辑</strong></p><ul><li><p>当邻居既不是<code>&#39;.&#39;</code>,<code>&#39;x&#39;</code>,<code>&#39;a&#39;</code>,<code>&#39;#&#39;</code></p><p>（即已被标记为数字的节点）时，判断 “当前节点的步数 + 1” 是否比邻居现有步数小：</p><ul><li>若是，就把邻居的步数更新为更小的值（试图修正之前可能因<code>&#39;x&#39;</code>导致的大步数）。</li></ul></li></ul></li><li><p><strong>结果判断</strong></p><ul><li>探索结束后，若<code>ans</code>被更新（不是初始的 1996），输出最小步数；否则输出<code>-1</code>（没找到终点）。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;广度优先搜索&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈value</title>
    <link href="http://example.com/2025/09/29/%E6%A0%88value/"/>
    <id>http://example.com/2025/09/29/%E6%A0%88value/</id>
    <published>2025-09-29T10:43:48.000Z</published>
    <updated>2025-09-29T10:48:48.534Z</updated>
    
    <content type="html"><![CDATA[<p>单调栈的应用</p><span id="more"></span><h2 id="算法与数据结构实验题-3-8-价值"><a href="#算法与数据结构实验题-3-8-价值" class="headerlink" title="算法与数据结构实验题 3.8 价值"></a>算法与数据结构实验题 3.8 价值</h2><p>★实验任务</p><p>K 神最近喜欢上了刷题，一天不刷浑身难受。最近他研究发现，自己的人生价值在于他某段时间内的刷题总数乘上这几天刷题数的最小值，现在 K 神很寂寞（无敌是多么寂寞），想知道他人生价值最高的时候究竟有多高（krz）</p><p>★数据输入</p><p>第一行为总天数 N(1&lt;&#x3D;N&lt;&#x3D;100000)</p><p>接下来一行 N 个整数 ai（1&lt;&#x3D;ai&lt;&#x3D;100000），表示 K 神第 i 天的刷题数。</p><p>★数据输出</p><p>输出 K 神在连续一段时间内可能的最高价值 W。</p><table><thead><tr><th>输入示例</th></tr></thead><tbody><tr><td>6</td></tr><tr><td>3 1 6 4 5 2</td></tr></tbody></table><table><thead><tr><th>输出示例</th></tr></thead><tbody><tr><td>60</td></tr></tbody></table><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h3><ol><li><strong>核心观察</strong>：对于数组中的每个元素 <code>a[i]</code>，考虑以 <code>a[i]</code> 为最小值的所有连续子数组。在这些子数组中，找到总和最大的子数组，其价值（总和 × <code>a[i]</code>）可能是最大值。</li><li><strong>单调栈应用</strong>：使用单调栈可以高效地找到每个元素 <code>a[i]</code> 左侧第一个小于它的元素（左边界）和右侧第一个小于或等于它的元素（右边界）。这样就确定了以 <code>a[i]</code> 为最小值的最大子数组范围 <code>[left+1, right-1]</code>。</li><li><strong>前缀和优化</strong>：通过前缀和数组可以快速计算任意子数组的总和，避免重复求和，提高效率。</li></ol><pre><code class="c++">#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;stack&lt;int&gt; st;int n;int main()&#123;    cin &gt;&gt; n;    int* a = new int[n + 1];    int* value = new int[n + 1];    int* sum = new int[n + 1];    int* left = new int[n + 1];    int* right = new int[n + 1];    sum[0] = 0;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; a[i];        sum[i] = sum[i - 1] + a[i];    &#125;    for (int i = 1; i &lt;= n; i++) &#123;        while (!st.empty() &amp;&amp; a[st.top()] &gt;= a[i]) &#123;            st.pop();        &#125;        left[i] = st.empty() ? 0 : st.top();        st.push(i);    &#125;    while (!st.empty()) st.pop();    for (int i = n; i &gt;= 1; i--) &#123;        while (!st.empty() &amp;&amp; a[st.top()] &gt;= a[i]) &#123;            st.pop();        &#125;        right[i] = st.empty() ? n + 1 : st.top();        st.push(i);    &#125;    int ans = -1;    for (int i = 1; i &lt;= n; i++) &#123;        value[i] = (sum[right[i] - 1] - sum[left[i]]) * a[i];        if (value[i] &gt; ans) &#123;            ans = value[i];        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;</code></pre><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a><strong>详细解释</strong></h3><ol><li><strong>输入与前缀和</strong>：<ul><li>读取输入的天数 <code>n</code> 和每天的刷题数 <code>a</code>。</li><li>计算前缀和数组 <code>sum</code>，其中 <code>sum[i]</code> 表示前 <code>i</code> 天的刷题总数，便于快速计算任意子数组的总和。</li></ul></li><li><strong>左边界计算</strong>：<ul><li>使用单调栈找到每个元素 <code>a[i]</code> 左侧第一个小于它的元素的索引 <code>left[i]</code>。若不存在，则 <code>left[i]</code> 为 0。</li><li>单调栈保证栈内元素递增，每次弹出栈顶大于等于 <code>a[i]</code> 的元素，剩余栈顶即为左边界。</li></ul></li><li><strong>右边界计算</strong>：<ul><li>类似地，使用单调栈找到每个元素 <code>a[i]</code> 右侧第一个小于或等于它的元素的索引 <code>right[i]</code>。若不存在，则 <code>right[i]</code> 为 <code>n+1</code>。</li><li>单调栈保证栈内元素递增，每次弹出栈顶大于 <code>a[i]</code> 的元素，剩余栈顶即为右边界。</li></ul></li><li><strong>最大价值计算</strong>：<ul><li>对于每个元素 <code>a[i]</code>，以它为最小值的最大子数组范围是 <code>[left[i], right[i]-1]</code>。</li><li>计算该子数组的总和（利用前缀和），并计算价值（总和 × <code>a[i]</code>），更新最大值。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;单调栈的应用&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>内存泄漏</title>
    <link href="http://example.com/2025/09/27/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://example.com/2025/09/27/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2025-09-27T11:51:22.000Z</published>
    <updated>2025-09-27T11:58:39.774Z</updated>
    
    <content type="html"><![CDATA[<p> 在 Android 开发中，内存泄露是一个常见且棘手的问题，它指的是程序中不再使用的对象无法被垃圾回收器回收，导致内存占用持续增加，最终可能引发应用崩溃（OOM：OutOfMemoryError）。</p><span id="more"></span><p>内存泄漏（Memory Leak）是指在程序运行过程中，<strong>不再需要使用的内存空间无法被系统回收</strong>，导致这部分内存被永久占用，最终可能引发内存耗尽（OOM，OutOfMemoryError）的现象。</p><p>从技术角度更精确地说：当一个对象<strong>已经失去了所有使用价值</strong>（即程序中没有任何活跃的引用指向它），但由于某种原因，<strong>垃圾回收器（Garbage Collector，GC）无法识别这种状态</strong>，导致该对象仍然被保留在内存中，就形成了内存泄漏。</p><h3 id="内存泄漏的核心特征："><a href="#内存泄漏的核心特征：" class="headerlink" title="内存泄漏的核心特征："></a>内存泄漏的核心特征：</h3><ol><li><strong>无用性</strong>：泄漏的对象已经不再被程序的任何部分使用（没有实际业务意义）。</li><li><strong>不可回收性</strong>：由于引用链未断裂等原因，垃圾回收器无法将其判定为 “可回收对象”，导致内存无法释放。</li><li><strong>累积性</strong>：单个内存泄漏可能影响微小，但长期运行或高频触发下，泄漏的内存会持续累积，最终耗尽可用内存。</li></ol><h3 id="与相关概念的区别："><a href="#与相关概念的区别：" class="headerlink" title="与相关概念的区别："></a>与相关概念的区别：</h3><ul><li><strong>内存溢出（OOM）</strong>：内存泄漏是原因之一，OOM 是结果（内存耗尽时抛出的错误）。</li><li><strong>内存占用高</strong>：合理的内存占用是程序正常运行所需，而内存泄漏是 “无效占用”。</li></ul><h3 id="为什么会发生内存泄漏？"><a href="#为什么会发生内存泄漏？" class="headerlink" title="为什么会发生内存泄漏？"></a>为什么会发生内存泄漏？</h3><p>现代编程语言（如 Java、Kotlin）都有自动垃圾回收机制，但仍可能因<strong>错误的引用管理</strong>导致内存泄漏。例如：</p><ul><li>长生命周期对象（如单例）持有短生命周期对象（如 Activity）的强引用。</li><li>未及时移除的监听器、回调或事件订阅。</li><li>缓存中的对象未设置过期策略，导致无用对象长期驻留。</li></ul><p>这些场景会形成 “无效引用链”，让垃圾回收器误认为对象仍在使用，从而无法回收。</p><h3 id="常见的内存泄露场景"><a href="#常见的内存泄露场景" class="headerlink" title="常见的内存泄露场景"></a>常见的内存泄露场景</h3><ol><li><p><strong>静态 Activity&#x2F;Context 引用</strong></p><p>Activity 或 Context 包含大量资源（如视图、Bitmap 等），若被静态变量引用，会导致 Activity 无法被回收，即使页面已关闭。</p><pre><code class="java">// 错误示例public class MyActivity extends AppCompatActivity &#123;    private static Context sContext; // 静态引用        @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        sContext = this; // 持有Activity引用    &#125;&#125;</code></pre></li><li><p><strong>长生命周期对象持有短生命周期对象</strong></p><p>例如，单例模式（全局生命周期）持有 Activity（页面生命周期）的引用，会导致 Activity 无法释放。</p><pre><code class="java">// 错误示例public class Singleton &#123;    private static Singleton sInstance;    private Context mContext;        private Singleton(Context context) &#123;        mContext = context; // 若传入Activity，会导致泄露    &#125;        public static Singleton getInstance(Context context) &#123;        if (sInstance == null) &#123;            sInstance = new Singleton(context);        &#125;        return sInstance;    &#125;&#125;</code></pre></li><li><p><strong>未取消的监听器 &#x2F; 回调</strong></p><p>如注册了系统服务监听器（如传感器、广播）、EventBus 事件等，未在适当时候取消注册，会导致监听器持有 Activity 引用。</p></li><li><p><strong>Handler 内存泄露</strong></p><p>Handler 若为非静态内部类，会隐式持有外部类（如 Activity）的引用。若 Handler 发送的消息在消息队列中未处理完，Activity 会被一直持有。</p><pre><code class="java">// 错误示例public class MyActivity extends AppCompatActivity &#123;    private Handler mHandler = new Handler() &#123; // 非静态内部类        @Override        public void handleMessage(Message msg) &#123;            // 处理消息        &#125;    &#125;;        @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        mHandler.postDelayed(new Runnable() &#123;            @Override            public void run() &#123; /* 延迟任务 */ &#125;        &#125;, 10000); // 若10秒内关闭页面，Activity会被泄露    &#125;&#125;</code></pre></li><li><p><strong>资源未关闭</strong></p><p>如文件流（FileInputStream）、数据库连接（SQLiteDatabase）、网络连接等未关闭，会导致资源无法释放。</p></li><li><p><strong>WebView 泄露</strong></p><p>WebView 本身容易内存泄露，若不妥善处理（如在单独进程中使用，或销毁时移除并置空），可能导致整个 Activity 无法回收。</p></li></ol><h3 id="Android-Studio-检测内存泄露的工具"><a href="#Android-Studio-检测内存泄露的工具" class="headerlink" title="Android Studio 检测内存泄露的工具"></a>Android Studio 检测内存泄露的工具</h3><ol><li><strong>Profiler（内存分析器）</strong><ul><li>路径：<code>View &gt; Tool Windows &gt; Profiler</code></li><li>功能：实时监控应用内存使用情况，手动触发 GC（垃圾回收），记录内存快照（Heap Dump）。</li><li>操作：在内存波动异常时，点击 “Dump Java Heap” 生成快照，分析对象引用链，定位泄露根源。</li></ul></li><li><strong>LeakCanary（第三方库，推荐集成）</strong><ul><li>由 Square 开发的内存泄露检测库，可自动检测 Activity&#x2F;Fragment 的泄露并生成详细报告。</li><li>集成后，应用运行时若发生泄露，会在通知栏提示，并展示引用链（如 “Activity 被 Singleton 持有”）。</li></ul></li><li><strong>Lint 静态检查</strong><ul><li>Android Studio 内置的代码检查工具，可识别潜在的内存泄露风险（如静态 Context 引用）。</li><li>路径：<code>Analyze &gt; Inspect Code</code>，在结果中查看 “Memory issues” 相关警告。</li></ul></li></ol><h3 id="避免内存泄露的最佳实践"><a href="#避免内存泄露的最佳实践" class="headerlink" title="避免内存泄露的最佳实践"></a>避免内存泄露的最佳实践</h3><ol><li><p><strong>减少静态引用</strong></p><ul><li>避免静态变量持有 Activity&#x2F;Context，若需使用 Context，优先用 <code>getApplicationContext()</code>（生命周期与应用一致）。</li></ul></li><li><p><strong>使用弱引用（WeakReference）</strong></p><p>对短生命周期对象（如 Activity）使用弱引用，避免强引用导致无法回收：</p><pre><code class="java">// 正确示例：Handler + 弱引用private static class MyHandler extends Handler &#123;    private final WeakReference&lt;MyActivity&gt; mActivityRef;        public MyHandler(MyActivity activity) &#123;        mActivityRef = new WeakReference&lt;&gt;(activity);    &#125;        @Override    public void handleMessage(Message msg) &#123;        MyActivity activity = mActivityRef.get();        if (activity != null) &#123;            // 处理消息（需判断Activity是否已回收）        &#125;    &#125;&#125;</code></pre></li><li><p><strong>及时取消注册 &#x2F; 释放资源</strong></p><ul><li><p>在<code>onDestroy()</code>中取消监听器、EventBus 注册、Handler 消息等：</p><pre><code class="java">@Overrideprotected void onDestroy() &#123;    super.onDestroy();    mHandler.removeCallbacksAndMessages(null); // 移除所有消息    EventBus.getDefault().unregister(this); // 取消EventBus注册&#125;</code></pre></li><li><p>关闭文件流、数据库连接等资源（可使用 try-with-resources 自动关闭）。</p></li></ul></li><li><p><strong>单例模式优化</strong></p><p>单例若需 Context，应传入 Application Context：</p><pre><code class="java">public static Singleton getInstance(Context context) &#123;    if (sInstance == null) &#123;        sInstance = new Singleton(context.getApplicationContext()); // 用Application Context    &#125;    return sInstance;&#125;</code></pre></li><li><p><strong>WebView 处理</strong></p><ul><li><p>尽量在单独进程中使用 WebView（在 Manifest 中配置 <code>android:process</code>）。</p></li><li><p>销毁时移除父布局并置空：</p><pre><code class="java">@Overrideprotected void onDestroy() &#123;    if (mWebView != null) &#123;        mWebView.removeAllViews();        mWebView.destroy();        mWebView = null;    &#125;    super.onDestroy();&#125;</code></pre></li></ul></li></ol><h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2><h3 id="传入Application与Activity的区别"><a href="#传入Application与Activity的区别" class="headerlink" title="传入Application与Activity的区别"></a>传入Application与Activity的区别</h3><h4 id="一、本质区别：生命周期与作用范围"><a href="#一、本质区别：生命周期与作用范围" class="headerlink" title="一、本质区别：生命周期与作用范围"></a>一、本质区别：生命周期与作用范围</h4><ol><li><strong>Application</strong><ul><li><strong>生命周期</strong>：与应用进程一致，从应用启动到进程被杀死（如系统回收资源时），全局唯一且贯穿整个应用生命周期。</li><li><strong>作用范围</strong>：代表整个应用，是全局上下文，不与任何特定页面绑定。</li><li><strong>特性</strong>：内存占用稳定，不会因页面切换而销毁。</li></ul></li><li><strong>Activity</strong><ul><li><strong>生命周期</strong>：与页面绑定，随用户操作（如打开、关闭、旋转屏幕）经历 <code>onCreate()</code> 到 <code>onDestroy()</code> 的完整周期，可能被频繁创建和销毁。</li><li><strong>作用范围</strong>：代表单个页面，包含页面相关的视图、资源和状态。</li><li><strong>特性</strong>：持有大量页面相关资源（如布局、控件、图片等），内存占用较大。</li></ul></li></ol><h4 id="二、传入作为-Context-时的核心差异"><a href="#二、传入作为-Context-时的核心差异" class="headerlink" title="二、传入作为 Context 时的核心差异"></a>二、传入作为 Context 时的核心差异</h4><p>当需要传递 <code>Context</code> 时（如初始化工具类、单例、系统服务调用等），选择 <code>Application</code> 还是 <code>Activity</code> 会直接影响内存管理：</p><table><thead><tr><th>场景</th><th>传入 Application Context</th><th>传入 Activity Context</th></tr></thead><tbody><tr><td><strong>生命周期匹配</strong></td><td>适合长生命周期对象（如单例、全局工具类），生命周期一致。</td><td>仅适合与 Activity 生命周期绑定的场景（如弹出对话框、加载布局）。</td></tr><tr><td><strong>内存泄漏风险</strong></td><td>无风险，因为其生命周期与应用一致，不会因页面销毁而导致泄露。</td><td>高风险！若被长生命周期对象（如单例）持有，会导致 Activity 无法回收，引发内存泄漏。</td></tr><tr><td><strong>功能限制</strong></td><td>无法用于与页面相关的操作（如启动 Dialog、创建菜单），因缺少页面窗口信息。</td><td>可用于所有需要 Context 的场景，包括页面相关操作（如 <code>startActivity()</code>、<code>setContentView()</code>）。</td></tr></tbody></table><h4 id="三、典型使用场景对比"><a href="#三、典型使用场景对比" class="headerlink" title="三、典型使用场景对比"></a>三、典型使用场景对比</h4><ol><li><p><strong>单例模式中使用 Context</strong></p><ul><li><p>错误示例：传入 Activity 导致内存泄漏</p><pre><code class="java">// 单例（长生命周期）持有 Activity（短生命周期）引用 → 内存泄漏public class DataManager &#123;    private static DataManager sInstance;    private Context mContext;        private DataManager(Context context) &#123;        mContext = context; // 若传入 Activity，会导致 Activity 无法回收    &#125;        public static DataManager getInstance(Context context) &#123;        if (sInstance == null) &#123;            sInstance = new DataManager(context);         &#125;        return sInstance;    &#125;&#125;</code></pre></li><li><p>正确示例：传入 Application Context</p><pre><code class="java">public static DataManager getInstance(Context context) &#123;    if (sInstance == null) &#123;        // 传入 Application Context，避免持有 Activity 引用        sInstance = new DataManager(context.getApplicationContext());     &#125;    return sInstance;&#125;</code></pre></li></ul></li><li><p><strong>显示对话框（必须用 Activity Context）</strong></p><p>对话框需要依附于某个页面的窗口，必须使用 Activity Context：</p><pre><code class="java">// 正确：使用 Activity 作为 Context 显示对话框new AlertDialog.Builder(this) // this 指向当前 Activity    .setMessage(&quot;提示&quot;)    .show();// 错误：使用 Application Context 会崩溃（无窗口依附）new AlertDialog.Builder(getApplicationContext())     .setMessage(&quot;提示&quot;)    .show(); // 崩溃：android.view.WindowManager$BadTokenException</code></pre></li></ol><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><ul><li><strong>优先原则</strong>：若场景允许（如全局工具类、单例），尽量使用 <code>Application Context</code>，避免内存泄漏。</li><li><strong>限制场景</strong>：涉及页面交互（如对话框、启动新 Activity、加载布局）时，必须使用 <code>Activity Context</code>，但需注意避免被长生命周期对象持有。</li><li><strong>核心区别</strong>：<code>Application</code> 是全局上下文，生命周期与应用一致；<code>Activity</code> 是页面上下文，生命周期与页面绑定，滥用会导致内存泄漏。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; 在 Android 开发中，内存泄露是一个常见且棘手的问题，它指的是程序中不再使用的对象无法被垃圾回收器回收，导致内存占用持续增加，最终可能引发应用崩溃（OOM：OutOfMemoryError）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ViewModel+LiveData+DataBinding</title>
    <link href="http://example.com/2025/09/24/ViewModel-LiveData-DataBinding/"/>
    <id>http://example.com/2025/09/24/ViewModel-LiveData-DataBinding/</id>
    <published>2025-09-24T08:41:40.000Z</published>
    <updated>2025-09-24T09:25:19.930Z</updated>
    
    <content type="html"><![CDATA[<p> ViewModel + LiveData + DataBinding 是 Android 官方推荐的 MVVM 架构核心组合，三者协同实现了<strong>数据驱动 UI</strong>、<strong>生命周期安全</strong>和<strong>双向绑定</strong>，彻底解决了传统 MVC 架构的内存泄漏和代码耦合问题。 </p><span id="more"></span><h4 id="一、核心组件解析"><a href="#一、核心组件解析" class="headerlink" title="一、核心组件解析"></a>一、核心组件解析</h4><h5 id="1-ViewModel"><a href="#1-ViewModel" class="headerlink" title="1. ViewModel"></a>1. ViewModel</h5><ul><li><strong>作用</strong>：存储与 UI 相关的数据，生命周期独立于 Activity&#x2F;Fragment，屏幕旋转等配置变化时不会重建，避免数据丢失。</li><li>核心特性：<ul><li>不持有 View 引用（Activity&#x2F;Fragment），通过 LiveData 通知 UI 更新</li><li>可通过 <code>AndroidViewModel</code> 子类获取 Application 上下文（需谨慎使用）</li><li>自带 <code>viewModelScope</code> 协程作用域，自动在销毁时取消任务</li></ul></li></ul><pre><code class="kotlin">// 基础 ViewModelclass MainViewModel : ViewModel() &#123;    private val _userName = MutableLiveData&lt;String&gt;(&quot;默认名称&quot;)    val userName: LiveData&lt;String&gt; = _userName // 对外暴露只读LiveData    fun updateName(newName: String) &#123;        _userName.value = newName // 主线程更新        // 子线程用 _userName.postValue(newName)    &#125;&#125;// 需上下文的 AndroidViewModel（继承自 ViewModel）class MyAndroidViewModel(application: Application) : AndroidViewModel(application) &#123;    fun getAppVersion(): String &#123;        return getApplication&lt;Application&gt;().packageManager            .getPackageInfo(getApplication&lt;Application&gt;().packageName, 0).versionName    &#125;&#125;</code></pre><h5 id="2-LiveData"><a href="#2-LiveData" class="headerlink" title="2. LiveData"></a>2. LiveData</h5><ul><li><strong>作用</strong>：可观察的数据持有者，感知 Activity&#x2F;Fragment 生命周期，仅在活跃状态（STARTED&#x2F;RESUMED）通知更新，避免内存泄漏。</li><li>核心子类：<ul><li><code>MutableLiveData</code>：可修改数据（内部使用），提供 <code>setValue()</code>（主线程）和 <code>postValue()</code>（子线程）</li><li><code>Transformations</code>：数据转换工具类，如 <code>map</code>（转换数据格式）、<code>switchMap</code>（根据数据切换观察目标）</li></ul></li></ul><pre><code class="kotlin">// 一般定义方式private val _data = MutableLiveData&lt;String&gt;() // 内部可变val data: LiveData&lt;String&gt; = _data // 外部只读// 数据转换示例class UserViewModel : ViewModel() &#123;    private val _userId = MutableLiveData&lt;String&gt;(&quot;1001&quot;)    val userInfo: LiveData&lt;String&gt; = Transformations.map(_userId) &#123; id -&gt;        &quot;用户ID: $id，名称: 张三&quot; // 将userId转换为用户信息字符串    &#125;    fun changeUserId(newId: String) &#123;        _userId.value = newId // 触发userInfo自动更新    &#125;&#125;</code></pre><h5 id="3-DataBinding"><a href="#3-DataBinding" class="headerlink" title="3. DataBinding"></a>3. DataBinding</h5><ul><li><strong>作用</strong>：将布局文件与数据直接绑定，省去 <code>findViewById</code> 和手动更新 UI 的代码，支持双向绑定。</li><li>核心特性：<ul><li>布局文件以 <code>&lt;layout&gt;</code> 为根标签，可声明变量和表达式</li><li>支持 <code>@&#123;variable&#125;</code> 单向绑定和 <code>@=&#123;variable&#125;</code> 双向绑定</li><li>自动关联 LiveData，数据变化时 UI 自动刷新</li></ul></li></ul><pre><code class="xml">&lt;!-- activity_main.xml --&gt;&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;data&gt;        &lt;variable name=&quot;viewModel&quot; type=&quot;com.example.MyViewModel&quot; /&gt;    &lt;/data&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;&gt;        &lt;!-- 单向绑定：UI展示ViewModel数据 --&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@&#123;viewModel.userName&#125;&quot; /&gt;        &lt;!-- 双向绑定：UI输入同步到ViewModel --&gt;        &lt;EditText            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@=&#123;viewModel.inputText&#125;&quot; /&gt;    &lt;/LinearLayout&gt;&lt;/layout&gt;</code></pre><h4 id="二、Activity-中使用流程"><a href="#二、Activity-中使用流程" class="headerlink" title="二、Activity 中使用流程"></a>二、Activity 中使用流程</h4><ol><li><p>开启 DataBinding</p><p>在<code>build.gradle.kts</code>中启用：</p></li></ol><pre><code class="kotlin">android &#123;    buildFeatures &#123;        dataBinding = true    &#125;&#125;</code></pre><ol><li><strong>初始化绑定与 ViewModel</strong></li></ol><pre><code class="kotlin">class MainActivity : AppCompatActivity() &#123;    private lateinit var binding: ActivityMainBinding    private val viewModel: MainViewModel by viewModels() // 委托初始化    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)                // 初始化DataBinding        binding = DataBindingUtil.setContentView(this, R.layout.activity_main)        // 绑定ViewModel到布局        binding.viewModel = viewModel        // 关键：让DataBinding感知生命周期，自动处理LiveData        binding.lifecycleOwner = this    &#125;&#125;</code></pre><h4 id="三、Fragment-中使用流程"><a href="#三、Fragment-中使用流程" class="headerlink" title="三、Fragment 中使用流程"></a>三、Fragment 中使用流程</h4><p>Fragment 中获取 ViewModel 需注意<strong>共享范围</strong>：默认是 Fragment 自身，如需与宿主 Activity 共享，需指定 <code>ViewModelStoreOwner</code> 为 Activity。</p><pre><code class="kotlin">class MyFragment : Fragment() &#123;    private lateinit var binding: FragmentMyBinding    // 方案1：Fragment独立ViewModel    private val fragmentViewModel: MyFragmentViewModel by viewModels()        // 方案2：与Activity共享ViewModel    private val sharedViewModel: SharedViewModel by activityViewModels()    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View &#123;        // 初始化Fragment布局绑定        binding = DataBindingUtil.inflate(inflater, R.layout.fragment_my, container, false)        // 绑定ViewModel        binding.fragmentVm = fragmentViewModel        binding.sharedVm = sharedViewModel        // 绑定生命周期所有者（Fragment自身）        binding.lifecycleOwner = viewLifecycleOwner        return binding.root    &#125;&#125;</code></pre><h4 id="四、双向绑定进阶（以登录为例）"><a href="#四、双向绑定进阶（以登录为例）" class="headerlink" title="四、双向绑定进阶（以登录为例）"></a>四、双向绑定进阶（以登录为例）</h4><ol><li><strong>ViewModel 定义可观察数据</strong></li></ol><pre><code class="kotlin">class LoginViewModel : ViewModel() &#123;    val username = MutableLiveData&lt;String&gt;(&quot;&quot;)    val password = MutableLiveData&lt;String&gt;(&quot;&quot;)    // 登录按钮状态（根据输入是否为空决定）    val loginEnabled: LiveData&lt;Boolean&gt; = Transformations.map(username) &#123;        it.isNotEmpty() &amp;&amp; password.value?.isNotEmpty() == true    &#125;    fun login() &#123;        // 处理登录逻辑    &#125;&#125;</code></pre><ol><li><strong>布局中双向绑定与事件绑定</strong></li></ol><pre><code class="xml">&lt;layout&gt;    &lt;data&gt;        &lt;variable name=&quot;vm&quot; type=&quot;com.example.LoginViewModel&quot; /&gt;    &lt;/data&gt;    &lt;EditText        android:hint=&quot;用户名&quot;        android:text=&quot;@=&#123;vm.username&#125;&quot; /&gt; &lt;!-- 双向绑定 --&gt;    &lt;EditText        android:hint=&quot;密码&quot;        android:inputType=&quot;textPassword&quot;        android:text=&quot;@=&#123;vm.password&#125;&quot; /&gt; &lt;!-- 双向绑定 --&gt;    &lt;Button        android:text=&quot;登录&quot;        android:enabled=&quot;@&#123;vm.loginEnabled&#125;&quot; &lt;!-- 按钮状态随数据变化 --&gt;        android:onClick=&quot;@&#123;() -&gt; vm.login()&#125;&quot; /&gt; &lt;!-- 点击事件绑定 --&gt;&lt;/layout&gt;</code></pre><h4 id="五、最佳实践"><a href="#五、最佳实践" class="headerlink" title="五、最佳实践"></a>五、最佳实践</h4><ol><li><p><strong>数据单向流动原则</strong>：</p><ul><li>UI 事件（点击、输入）→ ViewModel 处理 → 更新 LiveData → UI 自动刷新</li><li>禁止 ViewModel 直接操作 UI 组件</li></ul></li><li><p><strong>ViewModel 与 Repository 分层</strong>：</p><pre><code class="kotlin">class UserViewModel(private val repo: UserRepository) : ViewModel() &#123;    fun loadUser() &#123;        viewModelScope.launch &#123;            val user = repo.fetchUser() // 数据层操作（网络/数据库）            _user.value = user        &#125;    &#125;&#125;</code></pre></li><li><p><strong>避免过度使用双向绑定</strong>：仅在用户输入场景（如表单）使用，其他场景优先单向绑定，减少数据流向复杂性。</p></li><li><p><strong>Fragment 与 Activity 通信</strong>：通过共享 ViewModel 实现，避免使用接口回调。</p></li></ol><h4 id="六、UI组件监听的实现"><a href="#六、UI组件监听的实现" class="headerlink" title="六、UI组件监听的实现"></a>六、UI组件监听的实现</h4><p>组件监听（如点击、文本变化）应在 View 层（Activity&#x2F;Fragment）处理，然后通过调用 ViewModel 的方法将事件 “转发” 给 ViewModel，由 ViewModel 处理业务逻辑并更新 LiveData，最终通过 DataBinding 自动反映到 UI 上。</p><h5 id="示例：EditText-文本变化监听"><a href="#示例：EditText-文本变化监听" class="headerlink" title="示例：EditText 文本变化监听"></a>示例：EditText 文本变化监听</h5><pre><code class="kotlin">// ViewModel（只处理数据逻辑，不涉及任何View）class SearchViewModel : ViewModel() &#123;    private val _searchText = MutableLiveData&lt;String&gt;(&quot;&quot;)    val searchText: LiveData&lt;String&gt; = _searchText    // 处理文本变化的业务逻辑（如过滤、搜索）    fun onTextChanged(newText: String) &#123;        _searchText.value = newText        // 其他逻辑：如防抖搜索、过滤条件判断等    &#125;&#125;// Activity（View层，负责组件监听并转发事件）class SearchActivity : AppCompatActivity() &#123;    private val viewModel: SearchViewModel by viewModels()    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        val binding = ActivitySearchBinding.inflate(layoutInflater)        setContentView(binding.root)        binding.lifecycleOwner = this        binding.vm = viewModel        // 组件监听在View层实现，调用ViewModel方法转发事件        binding.searchEt.addTextChangedListener(object : TextWatcher &#123;            override fun afterTextChanged(s: Editable?) &#123;                // 将文本变化事件转发给ViewModel                viewModel.onTextChanged(s?.toString() ?: &quot;&quot;)            &#125;            // 其他方法省略...        &#125;)    &#125;&#125;</code></pre><h4 id="七、ViewModel委托初始化"><a href="#七、ViewModel委托初始化" class="headerlink" title="七、ViewModel委托初始化"></a>七、ViewModel委托初始化</h4><h5 id="核心委托方式：viewModels-与-activityViewModels"><a href="#核心委托方式：viewModels-与-activityViewModels" class="headerlink" title="核心委托方式：viewModels() 与 activityViewModels()"></a>核心委托方式：<code>viewModels()</code> 与 <code>activityViewModels()</code></h5><p>AndroidX 提供了 <strong><code>androidx.activity.viewModels</code></strong> 和 <strong><code>androidx.fragment.app.viewModels</code></strong> 扩展函数，通过委托自动处理 <code>AndroidViewModel</code> 的初始化，无需手动创建 <code>ViewModelProvider.Factory</code>。</p><p>确保 <code>build.gradle.kts</code> 中包含 ViewModel 扩展库（通常已默认包含）：</p><pre><code class="kotlin">dependencies &#123;    implementation(&quot;androidx.activity:activity-ktx:1.8.0&quot;) // 提供Activity的viewModels()    implementation(&quot;androidx.fragment:fragment-ktx:1.6.2&quot;) // 提供Fragment的viewModels()&#125;</code></pre><pre><code class="kotlin"> private val viewModel: MyAndroidViewModel by viewModels()</code></pre><h4 id="八、MutableLiveData：-setValue-（主线程）和-postValue-（子线程）"><a href="#八、MutableLiveData：-setValue-（主线程）和-postValue-（子线程）" class="headerlink" title="八、MutableLiveData： setValue()（主线程）和 postValue()（子线程）"></a>八、<code>MutableLiveData</code>： <code>setValue()</code>（主线程）和 <code>postValue()</code>（子线程）</h4><h5 id="1-调用线程限制"><a href="#1-调用线程限制" class="headerlink" title="1. 调用线程限制"></a>1. 调用线程限制</h5><ul><li>**<code>setValue</code>**：要求必须在主线程（UI 线程）中调用。因为<code>LiveData</code>主要用于和 UI 交互，在主线程更新数据可以保证 UI 的及时更新以及线程安全，避免多线程并发访问导致的 UI 错乱等问题。如果在子线程中调用<code>setValue</code>，会抛出<code>IllegalStateException</code>异常。例如：</li></ul><pre><code class="kotlin">import androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelclass MyViewModel : ViewModel() &#123;    private val _data = MutableLiveData&lt;String&gt;(&quot;初始值&quot;)    val data: MutableLiveData&lt;String&gt; = _data    fun updateDataOnMainThread() &#123;        // 正确，在主线程调用setValue        _data.setValue(&quot;更新后的值&quot;)     &#125;&#125;</code></pre><ul><li>**<code>postValue</code>**：没有线程限制，可以在子线程中调用。它内部会通过<code>Handler</code>机制将数据更新操作切换到主线程执行，从而实现子线程更新<code>LiveData</code>数据。这在进行异步操作（如网络请求、数据库操作）后更新数据时非常有用。示例如下：</li></ul><pre><code class="kotlin">import androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.launchimport kotlinx.coroutines.runBlockingclass AnotherViewModel : ViewModel() &#123;    private val _result = MutableLiveData&lt;String&gt;()    val result: MutableLiveData&lt;String&gt; = _result    fun fetchData() &#123;        runBlocking &#123;            launch(Dispatchers.IO) &#123;                val data = &quot;从子线程获取的数据&quot;                // 在子线程中使用postValue更新LiveData                _result.postValue(data)             &#125;        &#125;    &#125;&#125;</code></pre><h5 id="2-更新时机与方式"><a href="#2-更新时机与方式" class="headerlink" title="2. 更新时机与方式"></a>2. 更新时机与方式</h5><ul><li>**<code>setValue</code>**：会立即更新<code>LiveData</code>所持有的值，并通知所有处于活跃状态（<code>STARTED</code> 或 <code>RESUMED</code> 状态）的观察者，让它们可以及时更新 UI 或执行相应逻辑。</li><li>**<code>postValue</code>**：不会立即更新数据，而是将更新操作发送到主线程的消息队列中。当主线程空闲时，才会从消息队列中取出该操作并执行，进而更新<code>LiveData</code>的值并通知观察者。如果在短时间内多次调用<code>postValue</code>，<code>LiveData</code>只会保留最后一次设置的值，并在合适的时候进行更新。比如：</li></ul><pre><code class="kotlin">class TestViewModel : ViewModel() &#123;    private val _number = MutableLiveData&lt;Int&gt;()    val number: MutableLiveData&lt;Int&gt; = _number    fun multiplePostValue() &#123;        // 短时间内多次调用postValue        for (i in 1..3) &#123;            _number.postValue(i)        &#125;        // 最终LiveData的值是3    &#125;&#125;</code></pre><h5 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h5><ul><li>**<code>setValue</code>**：适用于在主线程中，当数据的更新是由主线程中的操作（如按钮点击事件）触发，并且希望数据能立即更新并通知观察者的场景。</li><li>**<code>postValue</code>**：适用于在异步任务（如网络请求、读取文件等）完成后，需要更新<code>LiveData</code>数据并通知 UI 的场景，因为异步任务通常在子线程中执行。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; ViewModel + LiveData + DataBinding 是 Android 官方推荐的 MVVM 架构核心组合，三者协同实现了&lt;strong&gt;数据驱动 UI&lt;/strong&gt;、&lt;strong&gt;生命周期安全&lt;/strong&gt;和&lt;strong&gt;双向绑定&lt;/strong&gt;，彻底解决了传统 MVC 架构的内存泄漏和代码耦合问题。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
</feed>
