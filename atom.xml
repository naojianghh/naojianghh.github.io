<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白脑浆糊的进化之旅</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-03-12T14:41:34.591Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>脑浆糊</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java-notes</title>
    <link href="http://example.com/2025/02/24/java-notes/"/>
    <id>http://example.com/2025/02/24/java-notes/</id>
    <published>2025-02-24T10:33:45.000Z</published>
    <updated>2025-03-12T14:41:34.591Z</updated>
    
    <content type="html"><![CDATA[<p>安卓逆向基础</p><span id="more"></span> <h1 id="cmd与环境变量"><a href="#cmd与环境变量" class="headerlink" title="cmd与环境变量"></a>cmd与环境变量</h1><p><img src="/../images/java/1740393417191.png" alt="1740393417191"></p><h2 id="cmd基本操作"><a href="#cmd基本操作" class="headerlink" title="cmd基本操作"></a>cmd基本操作</h2><p><strong>dir：展现当前目录</strong></p><p><strong>cd：转目录</strong></p><p><strong>cd  .. ：</strong> <strong>转上级目录</strong></p><p><strong>输入“D: ”  ：转到D盘</strong></p><p><strong>按Tab键可以补全文件命</strong></p><p><strong>右键复制粘贴</strong></p><p><strong>按上下键可以选择之前执行过的命令</strong></p><p><strong>cmd可以直接运行文件</strong></p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><ul><li><strong>定义</strong>：相对路径是相对于当前工作目录或当前文件所在位置来表示文件或目录位置的路径。它不包含从文件系统根目录开始的完整路径信息，而是基于当前位置来描述目标的位置。相对路径使用 “.”（表示当前目录）、“..”（表示上级目录）以及文件名或目录名来构建路径。</li><li><strong>示例</strong>：假设当前工作目录是<code>C:\Users\John\Documents</code>，如果要访问<code>Documents</code>目录下的<code>Projects</code>文件夹中的<code>file.txt</code>文件，相对路径可以表示为<code>Projects/file.txt</code>。如果要访问当前目录的上一级目录中的<code>Images</code>文件夹，相对路径可以写成<code>../Images</code>。</li></ul><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><ul><li><strong>定义</strong>：绝对路径是从文件系统的根目录开始，完整地指定文件或目录在整个文件系统中的位置的路径。它包含了从根目录到目标文件或目录的所有目录层次信息，具有唯一性和确定性，无论在什么环境下，绝对路径都能准确地定位到目标文件或目录。</li><li><strong>示例</strong>：在 Windows 系统中，例如<code>C:\Users\John\Documents\Projects\file.txt</code>就是一个绝对路径，它明确地指出了<code>file.txt</code>文件位于<code>C</code>盘的<code>Users</code>文件夹下的<code>John</code>文件夹中的<code>Documents</code>文件夹的<code>Projects</code>文件夹内。在 Linux 系统中，<code>/home/user/Documents/file.txt</code>也是一个绝对路径，从根目录 “&#x2F;” 开始，依次指定了各个目录层级直到目标文件。</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li><strong>用户变量</strong>：是针对特定用户设置的变量，只对当前用户的环境和应用程序起作用，不同用户的用户变量相互独立，可用于存储该用户特有的配置信息等。</li><li><strong>系统变量</strong>：是对整个系统所有用户都有效的变量，用于存储系统级的配置信息和参数，为系统和所有用户的应用程序提供通用的设置和数据。</li><li><strong>环境变量作用</strong>：在环境变量中，Path 用于指定可执行文件的搜索路径。当在命令行或程序中执行一个命令或启动一个程序时，系统会按照 Path 中指定的路径顺序去查找对应的可执行文件，以便能够找到并运行它们，而无需用户输入完整路径。</li></ul><h1 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h1><p><img src="/../images/java/1740407096683.png" alt="1740407096683"></p><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><p><img src="/../images/java/1741268784357.png" alt="1741268784357"></p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p><img src="/../images/java/1741269021214.png" alt="1741269021214"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><img src="/../images/java/1741269364034.png" alt="1741269364034"></p><p><img src="/../images/java/1741269706290.png" alt="1741269706290"></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><img src="/../images/java/1741269821892.png" alt="1741269821892"></p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p><img src="/../images/java/1741349945259.png" alt="1741349945259"></p><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>设置断点是调试的第一步，它可以让程序在指定的代码行暂停执行。</p><ul><li><strong>普通断点</strong>：在编辑器的行号旁边单击，会出现一个红色圆点，即设置了一个普通断点。当程序执行到这一行时，会暂停执行。例如，在以下代码中，在 <code>System.out.println(&quot;这是要调试的代码行&quot;);</code> 这一行的行号旁边单击设置断点：</li></ul><pre><code class="java">public class DebugExample &#123;    public static void main(String[] args) &#123;        int a = 10;        int b = 20;        int sum = a + b;        System.out.println(&quot;这是要调试的代码行&quot;);        System.out.println(&quot;两数之和为：&quot; + sum);    &#125;&#125;</code></pre><ul><li><strong>条件断点</strong>：右键单击已经设置的普通断点，选择 “Edit Breakpoint”，在弹出的对话框中可以设置条件。只有当条件满足时，程序才会在该断点处暂停。比如，在上述代码中，如果想在 <code>sum</code> 等于 30 时暂停程序，可以在条件框中输入 <code>sum == 30</code>。</li></ul><h3 id="启动调试模式"><a href="#启动调试模式" class="headerlink" title="启动调试模式"></a>启动调试模式</h3><p>设置好断点后，需要以调试模式启动程序。在 IDEA 的工具栏中，找到绿色虫子图标（Debug），点击它或者使用快捷键（通常是 Shift + F9），程序会开始执行，当遇到断点时会暂停。</p><h3 id="调试操作"><a href="#调试操作" class="headerlink" title="调试操作"></a>调试操作</h3><p>程序在断点处暂停后，可以使用以下操作来控制程序的执行和查看程序状态：</p><ul><li>单步执行<ul><li><strong>Step Over（F8）</strong>：逐行执行代码，不会进入方法内部。如果当前行调用了一个方法，会直接执行完该方法并跳到下一行。</li><li><strong>Step Into（F7）</strong>：如果当前行调用了一个方法，会进入该方法内部继续调试；如果是普通语句，则和 Step Over 效果相同。</li><li><strong>Step Out（Shift + F8）</strong>：从当前方法中跳出，继续执行该方法调用处的下一行代码。</li></ul></li><li><strong>查看变量值</strong>：在调试窗口的 “Variables” 面板中，可以查看当前作用域内的变量值。当程序暂停在断点处时，该面板会显示当前方法中所有变量的名称和值。</li><li><strong>表达式求值</strong>：在调试窗口中，有一个 “Evaluate Expression” 按钮（通常是一个带有计算器图标的按钮），点击它可以输入表达式并计算其值。例如，可以输入变量名来查看变量的值，或者输入一个复杂的表达式进行计算。</li></ul><h3 id="其他类型的断点"><a href="#其他类型的断点" class="headerlink" title="其他类型的断点"></a>其他类型的断点</h3><ul><li><strong>方法断点</strong>：在方法的声明行（方法名所在行）设置断点，当该方法被调用或者方法返回时，程序会暂停。方法断点用蓝色菱形表示。</li><li><strong>字段断点</strong>：在类的字段声明行设置断点，当该字段被读取或者写入时，程序会暂停。字段断点用黄色圆点表示。</li></ul><h3 id="管理断点"><a href="#管理断点" class="headerlink" title="管理断点"></a>管理断点</h3><ul><li><strong>禁用 &#x2F; 启用断点</strong>：右键单击断点，选择 “Disable Breakpoint” 可以禁用断点，再次右键单击选择 “Enable Breakpoint” 可以启用断点。禁用的断点不会影响程序的执行。</li><li><strong>删除断点</strong>：直接单击断点（红色圆点）即可删除断点；也可以在 “Breakpoints” 窗口（通常可以通过 “View” -&gt; “Tool Windows” -&gt; “Breakpoints” 打开）中选择要删除的断点，然后按 Delete 键删除。</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="基本调试步骤"><a href="#基本调试步骤" class="headerlink" title="基本调试步骤"></a>基本调试步骤</h3><h4 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1. 设置断点"></a>1. 设置断点</h4><p>断点是调试的关键，它能让程序在指定位置暂停执行，方便开发者查看程序状态。在 IDEA 中设置断点非常简单，只需在代码编辑器的行号旁边单击，出现红色圆点即表示成功设置断点。例如，在以下代码中，若想在 <code>sum</code> 变量计算完成后查看其值，可在 <code>System.out.println(&quot;两数之和为: &quot; + sum);</code> 这一行设置断点：</p><pre><code class="java">public class DebugExample &#123;    public static void main(String[] args) &#123;        int a = 10;        int b = 20;        int sum = a + b;        System.out.println(&quot;两数之和为: &quot; + sum);    &#125;&#125;</code></pre><h4 id="2-启动调试模式"><a href="#2-启动调试模式" class="headerlink" title="2. 启动调试模式"></a>2. 启动调试模式</h4><p>设置好断点后，有两种方式启动调试模式：</p><ul><li>点击 IDEA 工具栏上的绿色虫子图标（Debug）。</li><li>使用快捷键（通常是 <code>Shift + F9</code>）。</li></ul><p>启动调试模式后，程序会开始执行，当遇到设置的断点时会暂停。</p><h3 id="常用调试操作"><a href="#常用调试操作" class="headerlink" title="常用调试操作"></a>常用调试操作</h3><h4 id="1-单步执行"><a href="#1-单步执行" class="headerlink" title="1. 单步执行"></a>1. 单步执行</h4><ul><li><strong>StepOver（<code>F8</code>）</strong>：逐行执行代码，若当前行调用了方法，会直接执行完该方法并跳到下一行，不会进入方法内部。</li><li><strong>Step Into（<code>F7</code>）</strong>：若当前行调用了方法，会进入该方法内部继续调试；若为普通语句，则和 <code>Step Over</code> 效果相同。</li><li><strong>Step Out（<code>Shift + F8</code>）</strong>：从当前方法中跳出，继续执行该方法调用处的下一行代码。</li></ul><h4 id="2-查看变量值"><a href="#2-查看变量值" class="headerlink" title="2. 查看变量值"></a>2. 查看变量值</h4><p>程序暂停在断点处时，可在调试窗口的 “Variables” 面板中查看当前作用域内的变量值。该面板会实时显示变量的名称和值，方便开发者了解程序的运行状态。</p><h4 id="3-表达式求值"><a href="#3-表达式求值" class="headerlink" title="3. 表达式求值"></a>3. 表达式求值</h4><p>点击调窗口中带有计算器图标的 “Evaluate Expression” 按钮，可输入表达式并计算其值。例如，输入变量名查看变量值，或输入复杂表达式进行计算。</p><h3 id="断点类型"><a href="#断点类型" class="headerlink" title="断点类型"></a>断点类型</h3><h4 id="1-普通断点"><a href="#1-普通断点" class="headerlink" title="1. 普通断点"></a>1. 普通断点</h4><p>最常用的断点类型，在代码行号旁边单击即可设置，程序执行到该行时会暂停。</p><h4 id="2-条件断点"><a href="#2-条件断点" class="headerlink" title="2. 条件断点"></a>2. 条件断点</h4><p>右键单击已设置的普通断点，选择 “Edit Breakpoint”，在弹出的对话框中设置条件。只有当条件满足时，程序才会在该断点处暂停。例如，在上述代码中，若想在 <code>sum</code> 等于 30 时暂停程序，可在条件框中输入 <code>sum == 30</code>。</p><h4 id="3-方法断点"><a href="#3-方法断点" class="headerlink" title="3. 方法断点"></a>3. 方法断点</h4><p>在方法的声明行（方法名所在行）设置断点，当该方法被调用或者方法返回时，程序会暂停。方法断点用蓝色菱形表示。</p><h4 id="4-字段断点"><a href="#4-字段断点" class="headerlink" title="4. 字段断点"></a>4. 字段断点</h4><p>在类的字段声明行设置断点，当该字段被读取或者写入时，程序会暂停。字段断点用黄色圆点表示。</p><h3 id="高级调试技巧"><a href="#高级调试技巧" class="headerlink" title="高级调试技巧"></a>高级调试技巧</h3><h4 id="1-强制返回"><a href="#1-强制返回" class="headerlink" title="1. 强制返回"></a>1. 强制返回</h4><p>在调试过程中，若想提前结束当前方法的执行并返回指定值，可使用 “Force Return” 功能。在调试窗口中右键单击，选择 “Force Return”，然后输入要返回的值，程序会立即结束当前方法并返回该值。</p><h4 id="2-多线程调试"><a href="#2-多线程调试" class="headerlink" title="2. 多线程调试"></a>2. 多线程调试</h4><p>若程序包含多个线程，IDEA 支持多线程调试。在调试窗口的 “Threads” 面板中，可以查看所有线程的状态，并选择要调试的线程。</p><h4 id="3-日志断点"><a href="#3-日志断点" class="headerlink" title="3. 日志断点"></a>3. 日志断点</h4><p>在一些情况下，可能不需要暂停程序，只需在特定位置输出日志信息。可以使用日志断点，右键单击断点，在 “Log evaluated expression” 中输入要输出的日志信息，程序执行到该断点时会在控制台输出日志，但不会暂停。</p><h1 id="java-语言特点"><a href="#java-语言特点" class="headerlink" title="java 语言特点"></a>java 语言特点</h1><p><img src="/../images/java/1740458407691.png" alt="1740458407691"></p><h1 id="第一个java程序"><a href="#第一个java程序" class="headerlink" title="第一个java程序"></a>第一个java程序</h1><pre><code class="java">public class Hello &#123;    public static void main (String[] args) &#123;        System.out.println(&quot;Hello China&quot;);    &#125;&#125;</code></pre><h2 id="编译及运行"><a href="#编译及运行" class="headerlink" title="编译及运行"></a>编译及运行</h2><h3 id="编译："><a href="#编译：" class="headerlink" title="编译："></a><strong>编译：</strong></h3><p>将写好的代码保存在桌面上，且类名要与保存的文件名要一样。</p><p><strong>例：</strong> </p><p>类名 ：Hello      则文件名 ： Hello.java </p><p>然后在桌面上打开终端，输入javac + 文件名 进行编译</p><p><img src="/../images/java/1740461800775.png" alt="1740461800775"></p><p>此时桌面会得到一个编译后的文件  Hello.class </p><h3 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h3><p>在终端输入 java  +  (.class文件)文件名（不要后缀）</p><p><img src="/../images/java/1740461909477.png" alt="1740461909477"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/../images/java/1740462178975.png" alt="1740462178975"></p><h1 id="java语言基础组成"><a href="#java语言基础组成" class="headerlink" title="java语言基础组成"></a>java语言基础组成</h1><p><img src="/../images/java/1740462493599.png" alt="1740462493599"></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><img src="/../images/java/1740462613227.png" alt="1740462613227"></p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p><img src="/../images/java/1740575654215.png" alt="1740575654215"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="/../images/java/1740575933497.png" alt="1740575933497"></p><p><img src="/../images/java/1740575960520.png" alt="1740575960520"></p><p><strong>类似C</strong></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/../images/java/1740576109560.png" alt="1740576109560"></p><p><strong>与C不同点：</strong></p><p>有新的 byte</p><p>布尔型为  boolean</p><p>只有  long  没有  long long</p><p>且  char  占两个字节，并可以存中文</p><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><p><img src="/../images/java/1740576334165.png" alt="1740576334165"></p><p><strong>一字节  &#x3D;  8bit</strong></p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p><img src="/../images/java/1740576618037.png" alt="1740576618037"></p><p><strong>注意：</strong></p><p><img src="/../images/java/1740576763880.png" alt="1740576763880"></p><p><img src="/../images/java/1740576774228.png" alt="1740576774228"></p><p><strong>加入运算会影响精度</strong></p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p><img src="/../images/java/1740577000379.png" alt="1740577000379"></p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p><img src="/../images/java/1740577893027.png" alt="1740577893027"></p><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p><img src="/../images/java/1740577927233.png" alt="1740577927233"></p><p><img src="/../images/java/1740578765536.png" alt="1740578765536"></p><p><img src="/../images/java/1740578776537.png" alt="1740578776537"></p><p><strong>若运算类型含有字符串那么每个变量类型都转为字符串</strong></p><p><strong>字符串相加代表字符串连接</strong></p><p><img src="/../images/java/1740578924545.png" alt="1740578924545"></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="/../images/java/1740578980886.png" alt="1740578980886"></p><h2 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h2><ul><li><strong>关键字</strong>：是 Java 语言事先定义好的，具有特殊意义的标识符 ，用于表示一种数据类型、程序的结构等，是编译器和程序员的约定。程序员通过关键字告知编译器声明的变量类型、类、方法特性等信息。例如，<code>int</code>用于声明整数类型变量，<code>class</code>用于声明一个类，<code>if</code>用于条件语句等。关键字不能用作变量名、方法名、类名、包名和参数，并且一律用小写字母标识。Java 定义的关键字包括<code>abstract</code>、<code>assert</code>、<code>boolean</code>、<code>break</code> 等。</li><li><strong>保留字</strong>：通常指未来可能会作为关键字使用的一些单词， 目前在 Java 中没有实际的作用，但为了语言的扩展性和兼容性而保留。比如<code>goto</code>、<code>const</code> 以及<code>future</code>、<code>generic</code>、<code>operator</code>、<code>outer</code>、<code>rest</code>、<code>var</code>等，它们也不能作为标识符使用。此外，<code>null</code>、<code>true</code>、<code>false</code>虽常被认为是保留字，但更准确说是文字，包含 Java 定义的值，同样不可作为标识符 。</li></ul><h2 id="标志符"><a href="#标志符" class="headerlink" title="标志符"></a>标志符</h2><p><img src="/../images/java/1740579835980.png" alt="1740579835980"></p><p><strong>说白了就是自己取的名字</strong></p><p><strong>大驼峰（PascalCase）</strong>：</p><ul><li><strong>定义</strong>：每个单词首字母大写，无分隔符。</li><li><strong>用处</strong>：用于类名、接口名等。</li></ul><p><strong>小驼峰（camelCase）</strong>：</p><ul><li><strong>定义</strong>：首个单词首字母小写，后续单词首字母大写，无分隔符。</li><li><strong>用处</strong>：用于变量名、方法名等。</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><img src="/../images/java/1740580424234.png" alt="1740580424234"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>类似C</strong></p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="/../images/java/1740580531413.png" alt="1740580531413"></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="/../images/java/1740580829536.png" alt="1740580829536"></p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><img src="/../images/java/1740580977369.png" alt="1740580977369"></p><h3 id="三元运算符（三目运算）"><a href="#三元运算符（三目运算）" class="headerlink" title="三元运算符（三目运算）"></a>三元运算符（三目运算）</h3><p><img src="/../images/java/1740581133882.png" alt="1740581133882"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="/../images/java/1740581183917.png" alt="1740581183917"></p><h3 id="进制与位运算符"><a href="#进制与位运算符" class="headerlink" title="进制与位运算符"></a>进制与位运算符</h3><p><strong>常见的位运算符介绍：</strong></p><ol><li><strong>按位与（&amp;）</strong>：将两个数的二进制位进行比较，只有对应位都为 1 时，结果位才为 1，否则为 0。比如，5（二进制 0101）&amp; 3（二进制 0011）的结果是 1（二进制 0001）。常用于清零某些位，或者获取特定位的值。</li><li><strong>按位或（|）</strong>：对两个数的二进制位进行比较，只要对应位中有一个为 1，结果位就为 1，只有都为 0 时结果位才为 0。例如，5（二进制 0101）| 3（二进制 0011）的结果是 7（二进制 0111）。可用于设置某些位。</li><li><strong>按位异或（^）</strong>：比较两个数的二进制位，如果对应位不同，结果为 1；如果相同，结果为 0。比如，5（二进制 0101）^ 3（二进制 0011）的结果是 6（二进制 0110） 。可用于交换两个数的值等场景，无需额外变量。</li><li><strong>按位取反（~）</strong>：将一个数的每个二进制位进行反转，0 变 1，1 变 0。例如，~5（二进制 0101）的结果是 - 6（二进制 1010，补码表示）。因为 Java 中整数以补码形式存储，取反后要按补码规则转换为对应数值。</li><li><strong>左移（&lt;&lt;）</strong>：将二进制数向左移动指定的位数，空缺的位置补 0。左移 n 位相当于乘以 2 的 n 次方。比如，5（二进制 0101）&lt;&lt; 1 的结果是 10（二进制 1010） 。</li><li><strong>有符号右移（&gt;&gt;）</strong>：将二进制数向右移动指定的位数，对于负数，符号位（最高位）会被补充到空缺的位中。正数右移 n 位相当于除以 2 的 n 次方（向下取整）。比如，5（二进制 0101）&gt;&gt; 1 的结果是 2（二进制 0010） 。</li><li><strong>无符号右移（&gt;&gt;&gt;）</strong>：将二进制数向右移动指定的位数，不考虑符号位，所有空缺的位都用 0 补充。比如，5（二进制 0101）&gt;&gt;&gt; 1 的结果是 2（二进制 0010） ，常用于处理无符号数，如位图处理等场景。</li></ol><p><strong>位运算符有以下特点：</strong></p><ul><li><strong>运算高效</strong>：直接在硬件级别进行操作，比算术运算符速度更快。</li><li><strong>位移运算与乘除关系</strong>：左移一位相当于乘以 2，移动 n 位相当于乘以 2 的 n 次方；有符号右移一位相当于除以 2，移动 n 位相当于除以 2 的 n 次方（但负数右移时要注意符号位的处理） 。</li></ul><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p><img src="/../images/java/1740581486078.png" alt="1740581486078"></p><h4 id="Hex编码（十六进制编码）"><a href="#Hex编码（十六进制编码）" class="headerlink" title="Hex编码（十六进制编码）"></a>Hex编码（十六进制编码）</h4><p><strong>定义</strong></p><p>Hex 编码，即十六进制编码（Hexadecimal Encoding），是一种用十六进制数字来表示二进制数据的编码方式。在计算机领域，二进制数据是最基础的表现形式，但由于二进制数书写起来过长且不易阅读，而十六进制能更简洁、方便地表示二进制数据，所以被广泛应用。十六进制使用 0 - 9 和 A - F（或 a - f）这 16 个符号来表示数值，其中 A - F 分别对应十进制的 10 - 15。</p><p><strong>原理</strong></p><p>一个字节（Byte）由 8 位（bit）二进制数组成，其取值范围是从 00000000 到 11111111。而每 4 位二进制数可以用一个十六进制数字来表示，因为 4 位二进制数能表示的最大十进制数是 15（二进制 1111），正好对应十六进制的 F。所以一个字节的二进制数据可以用两个十六进制数字来表示。</p><p>例如，二进制数 10101100 可以拆分为 1010 和 1100 两部分，1010 对应的十进制数是 10，十六进制表示为 A；1100 对应的十进制数是 12，十六进制表示为 C。因此，二进制数 10101100 用十六进制编码后就是 AC。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p><strong>类似C</strong></p><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><img src="/../images/java/1740582597341.png" alt="1740582597341"></p><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><img src="/../images/java/1740582682860.png" alt="1740582682860"></p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><img src="/../images/java/1740582715108.png" alt="1740582715108"></p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><img src="/../images/java/1740582753580.png" alt="1740582753580"></p><h3 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h3><p><img src="/../images/java/1740582794617.png" alt="1740582794617"></p><p><img src="/../images/java/1740583059079.png" alt="1740583059079"></p><p><strong>给循环起名字b</strong></p><p>在<strong>嵌套循环</strong>中， break 和 continue 的作用如下：</p><p><strong>break</strong></p><p> break 语句用于跳出当前所在的循环体，即仅跳出包含该 break 的最内层循环，而不是整个嵌套循环结构。示例代码如下：</p><pre><code class="python">for i in range(3):    for j in range(3):        if j == 1:            break        print(i, j)</code></pre><p>上述代码中，当 j 等于1时， break 会使程序跳出内层 for 循环，继续执行外层 for 循环的下一次迭代，因此不会输出 (0, 1) 、 (1, 1) 、 (2, 1) 。</p><p><strong>continue</strong></p><p> continue 语句用于跳过当前循环的剩余语句，直接开始下一次循环迭代，同样只作用于当前所在的循环层。示例代码如下：</p><pre><code class="python">for i in range(3):    for j in range(3):        if j == 1:            continue        print(i, j)</code></pre><p>在这段代码中，当 j 等于1时， continue 会跳过当前内层循环中 print(i, j) 这一语句，直接进入下一次内层循环，即不会输出 (0, 1) 、 (1, 1) 、 (2, 1) ，但会继续执行其他情况。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>java 数组并不方便，因此后续使用集合</strong></p><p><img src="/../images/java/1740583194527.png" alt="1740583194527"></p><p><img src="/../images/java/1740583249256.png" alt="1740583249256"></p><p><strong>这样也可</strong></p><p><img src="/../images/java/1740583361466.png" alt="1740583361466"></p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p><img src="/../images/java/1740583501523.png" alt="1740583501523"></p><p><img src="/../images/java/1740583564661.png" alt="1740583564661"></p><h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><p><img src="/../images/java/1740661241136.png" alt="1740661241136"></p><p><img src="/../images/java/1740661272806.png" alt="1740661272806"></p><p><strong>将 ints1 赋值给 ints2 是引用传递（c中指针传递，传递首地址）</strong></p><p><img src="/../images/java/1740661334644.png" alt="1740661334644"></p><p><img src="/../images/java/1740661407623.png" alt="1740661407623"></p><p><strong>int[] ints1 是在栈中开辟内存</strong></p><p><strong>ints1 &#x3D; new int[5]  是在堆开辟5个空间再将首地址赋值给ints1</strong></p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p><img src="/../images/java/1740661996604.png" alt="1740661996604"></p><p><img src="/../images/java/1740663595068.png" alt="1740663595068"></p><p><img src="/../images/java/1740663631786.png" alt="1740663631786"></p><p>加入元素</p><p><img src="/../images/java/1740663703428.png" alt="1740663703428"></p><p>反转元素</p><p><img src="/../images/java/1740663950519.png" alt="1740663950519"></p><p><img src="/../images/java/1740663967066.png" alt="1740663967066"></p><p><img src="/../images/java/1740663997184.png" alt="1740663997184"></p><h2 id="java帮助文档的查阅"><a href="#java帮助文档的查阅" class="headerlink" title="java帮助文档的查阅"></a>java帮助文档的查阅</h2><p><img src="/../images/java/1740662612177.png" alt="1740662612177"></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><img src="/../images/java/1740664064218.png" alt="1740664064218"></p><p><strong>新建文件来定义类，因为一个文件只能有一个共有类（其他方面类似C++）</strong></p><p><strong>定义变量也和C++不同</strong></p><p><img src="/../images/java/1740664988967.png" alt="1740664988967"></p><p><img src="/../images/java/1740665144280.png" alt="1740665144280"></p><p><strong>右键类可以并点击Constructor可以让idea自动帮助构建构造函数</strong></p><p><img src="/../images/java/1740665298800.png" alt="1740665298800"></p><p><img src="/../images/java/1740665385855.png" alt="1740665385855"></p><h3 id="方法的定义和调用"><a href="#方法的定义和调用" class="headerlink" title="方法的定义和调用"></a>方法的定义和调用</h3><p><img src="/../images/java/1740665811671.png" alt="1740665811671"></p><p><strong>类内定义函数</strong></p><p><img src="/../images/java/1740666090677.png" alt="1740666090677"></p><p><strong>类外只能调用非静态（非static）的函数</strong></p><h3 id="方法的返回值和参数"><a href="#方法的返回值和参数" class="headerlink" title="方法的返回值和参数"></a>方法的返回值和参数</h3><p><img src="/../images/java/1740666644568.png" alt="1740666644568"></p><h3 id="方法传参机制"><a href="#方法传参机制" class="headerlink" title="方法传参机制"></a>方法传参机制</h3><p><img src="/../images/java/1740722611662.png" alt="1740722611662"></p><p> <strong>Java 的参数传递机制</strong></p><p>Java 采用的是值传递（Pass - by - Value）机制。这意味着当你将一个变量作为参数传递给一个函数时，实际上传递的是该变量的值的副本，而不是变量本身。对于基本数据类型，传递的是其值的副本；对于引用数据类型，传递的是引用（内存地址）的副本。</p><p>String 传递时，在函数中赋值一个新字符串时，是在堆区另外开出空间来存储新字符串，并将字符串地址赋值给 String 变量，当函数结束后释放出新字符串的空间，String 变量获得原字符串地址。</p><p><strong>java代码示例</strong></p><pre><code class="java">public class StringPassingExample &#123;    public static void main(String[] args) &#123;        String original = &quot;Hello&quot;;        System.out.println(&quot;调用 changeString 方法前: &quot; + original);        changeString(original);        System.out.println(&quot;调用 changeString 方法后: &quot; + original);    &#125;    public static void changeString(String str) &#123;        str = &quot;World&quot;;        System.out.println(&quot;方法内部修改后的 str: &quot; + str);    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><strong>调用 <code>changeString</code> 方法前</strong>：在 <code>main</code> 方法中，定义了一个 <code>String</code> 变量 <code>original</code>，其值为 <code>&quot;Hello&quot;</code>。</li><li><strong>调用 <code>changeString</code> 方法时</strong>：将 <code>original</code> 作为参数传递给 <code>changeString</code> 方法。此时，传递的是 <code>original</code> 引用的副本，即该副本指向 <code>&quot;Hello&quot;</code> 这个字符串对象在内存中的地址。</li><li>**方法内部修改 <code>str</code>**：在 <code>changeString</code> 方法内部，将 <code>str</code> 赋值为 <code>&quot;World&quot;</code>。由于 <code>String</code> 是不可变的，这实际上是让 <code>str</code> 这个引用副本指向了一个新的 <code>&quot;World&quot;</code> 字符串对象，而原来的 <code>&quot;Hello&quot;</code> 字符串对象并没有被修改，<code>original</code> 仍然指向 <code>&quot;Hello&quot;</code>。</li><li><strong>调用 <code>changeString</code> 方法后</strong>：在 <code>main</code> 方法中输出 <code>original</code>，其值仍然是 <code>&quot;Hello&quot;</code>，说明 <code>original</code> 本身没有受到 <code>changeString</code> 方法内部操作的影响。</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><img src="/../images/java/1740805529328.png" alt="1740805529328"></p><p><strong>定义</strong></p><ul><li><strong>实例属性</strong>：也称为对象属性，是属于类的每个实例（对象）的属性。每个对象都有自己独立的实例属性副本，这些属性的值可以在不同对象之间有所不同。实例属性在类中定义，但不使用 <code>static</code> 关键字修饰。</li><li><strong>类属性</strong>：也称为静态属性，是属于类本身的属性，而不是属于某个特定的对象。类属性在所有该类的实例之间共享，即无论创建多少个该类的对象，类属性都只有一个副本。类属性使用 <code>static</code> 关键字修饰。</li></ul><pre><code class="java">public class Animal &#123;    // 实例属性    private String name;    private int age;    // 类属性    private static int population;    public Animal(String name, int age) &#123;        this.name = name;        this.age = age;        // 每次创建一个新的 Animal 对象时，增加种群数量        population++;    &#125;    // 获取实例属性 name    public String getName() &#123;        return name;    &#125;    // 获取实例属性 age    public int getAge() &#123;        return age;    &#125;    // 获取类属性 population    public static int getPopulation() &#123;        return population;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><strong>实例属性</strong>：在上述代码中，<code>name</code> 和 <code>age</code> 是实例属性，因为它们没有使用 <code>static</code> 关键字修饰。每个 <code>Animal</code> 对象都有自己的 <code>name</code> 和 <code>age</code> 值，这些值可以在创建对象时通过构造函数进行初始化，并且可以在不同对象之间不同。</li><li><strong>类属性</strong>：<code>population</code> 是类属性，因为它使用了 <code>static</code> 关键字修饰。<code>population</code> 记录了创建的 <code>Animal</code> 对象的总数，所有 <code>Animal</code> 对象共享这个属性。每当创建一个新的 <code>Animal</code> 对象时，<code>population</code> 的值就会增加 1。</li></ul><p><strong>定义</strong></p><ul><li><strong>对象方法（实例方法）</strong>：是属于类的每个实例（对象）的方法，不使用 <code>static</code> 关键字修饰。每个对象都有自己独立的方法调用副本，这些方法可以访问和操作对象的实例属性。</li><li><strong>类方法（静态方法）</strong>：是属于类本身的方法，使用 <code>static</code> 关键字修饰。类方法不依赖于类的任何实例，它可以在不创建对象的情况下直接通过类名调用。</li></ul><pre><code class="java">public class Calculator &#123;    // 实例属性    private int num;    // 构造函数，用于初始化实例属性    public Calculator(int num) &#123;        this.num = num;    &#125;    // 对象方法（实例方法）    public int add(int other) &#123;        return this.num + other;    &#125;    // 类方法（静态方法）    public static int multiply(int a, int b) &#123;        return a * b;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><strong>对象方法</strong>：在上述代码中，<code>add</code> 方法是对象方法，因为它没有使用 <code>static</code> 关键字修饰。<code>add</code> 方法可以访问和操作对象的实例属性 <code>num</code>，它需要通过对象来调用。</li><li><strong>类方法</strong>：<code>multiply</code> 方法是类方法，因为它使用了 <code>static</code> 关键字修饰。<code>multiply</code> 方法不依赖于类的任何实例，它只接受传入的参数进行计算，不需要访问对象的实例属性，可以直接通过类名调用。</li></ul><p><strong>调用方式</strong></p><ul><li><strong>对象方法</strong>：必须通过类的实例（对象）来调用。例如，<code>calculator.add(3)</code> 是通过 <code>calculator</code> 对象来调用 <code>add</code> 方法。</li><li><strong>类方法</strong>：可以直接通过类名调用，也可以通过对象调用（但不推荐，因为这可能会引起混淆）。例如，<code>Calculator.multiply(4, 6)</code> 是通过类名 <code>Calculator</code> 直接调用 <code>multiply</code> 方法。</li></ul><p><strong>访问权限</strong></p><ul><li><p><strong>对象方法</strong>：可以访问和修改对象的实例属性，也可以调用其他对象方法和类方法。</p></li><li><p><strong>类方法</strong>：不能直接访问对象的实例属性和调用对象方法，因为类方法不依赖于任何对象。但类方法可以访问和修改类属性，也可以调用其他类方法。</p></li></ul><p>引用类型比较一般用equals</p><p><img src="/../images/java/1740807781357.png" alt="1740807781357"></p><p>比较存放内容</p><p><img src="/../images/java/1740808183985.png" alt="1740808183985"></p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p><img src="/../images/java/1740808501147.png" alt="1740808501147"></p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p><img src="/../images/java/1740809043333.png" alt="1740809043333"></p><p><img src="/../images/java/1740809320928.png" alt="1740809320928"></p><p><img src="/../images/java/1740809256927.png" alt="1740809256927"></p><p>可变参数只能有一个并且必须放在最后一个参数位置</p><p>或者可以直接传入数组</p><p><img src="/../images/java/1740809393666.png" alt="1740809393666"></p><h3 id="构造器（构造函数）"><a href="#构造器（构造函数）" class="headerlink" title="构造器（构造函数）"></a>构造器（构造函数）</h3><p><img src="/../images/java/1740809605223.png" alt="1740809605223"></p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p><img src="/../images/java/1740828827015.png" alt="1740828827015"></p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><img src="/../images/java/1740829859933.png" alt="1740829859933"></p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p><img src="/../images/java/1740830885877.png" alt="1740830885877"></p><p> 在 Java 中，包（package）是一种对类和接口等进行组织和管理的机制，它有助于避免命名冲突、便于代码的维护和共享。 </p><p><strong>作用</strong></p><ul><li><strong>避免命名冲突</strong>：在大型项目中，可能会有很多类，如果都放在同一个命名空间下，很容易出现类名冲突的情况。通过将类放在不同的包中，可以确保不同包中的类即使名称相同也不会产生冲突。</li><li><strong>便于代码组织和管理</strong>：将相关的类和接口放在同一个包中，能够使代码结构更加清晰，易于理解和维护。比如，所有与数据库操作相关的类可以放在一个名为<code>db</code>的包中，所有与用户界面相关的类可以放在<code>ui</code>包中。</li><li><strong>控制访问权限</strong>：包可以控制类、方法和变量等的访问权限。在 Java 中，默认情况下，如果没有使用<code>public</code>、<code>private</code>或<code>protected</code>修饰符，那么类、方法和变量在同一个包内是可以访问的，而在包外则不能访问。</li></ul><p><strong>定义包</strong></p><p>在 Java 源文件的开头使用<code>package</code>关键字来定义包。例如：</p><pre><code class="java">package com.example.myapp;public class MyClass &#123;    // 类的内容&#125;</code></pre><p>这表示<code>MyClass</code>类属于<code>com.example.myapp</code>包。需要注意的是，包名一般采用小写字母，且通常遵循域名倒置的规则，以确保唯一性。比如，如果你的网站域名是<code>example.com</code>，那么你的包名可以是<code>com.example</code>开头。</p><p><strong>导入包</strong></p><p>当需要使用其他包中的类时，需要使用<code>import</code>关键字导入包。例如：</p><pre><code class="java">package com.example.main;import com.example.myapp.MyClass;public class Main &#123;    public static void main(String[] args) &#123;        MyClass myClass = new MyClass();    &#125;&#125;</code></pre><p>也可以使用通配符<code>*</code>来导入整个包中的所有类：</p><pre><code class="java">package com.example.main;import com.example.myapp.*;public class Main &#123;    public static void main(String[] args) &#123;        MyClass myClass = new MyClass();    &#125;&#125;</code></pre><p>也可以不用import直接用包中的类（包内类与包外类重名时也只能这么用）：</p><p><img src="/../images/java/1740832099375.png" alt="1740832099375"></p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p><img src="/../images/java/1740842682147.png" alt="1740842682147"></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><img src="/../images/java/1740922314336.png" alt="1740922314336"></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>按 <code>Ctrl + h</code>可以在idea中看到类的继承关系</strong></p><p><img src="/../images/java/1740922861761.png" alt="1740922861761"></p><p><strong>继承的基本语法</strong></p><p>在 Java 中，使用 <code>extends</code> 关键字来实现继承。以下是一个简单的示例：</p><pre><code class="java">// 定义父类class Animal &#123;    String name;    public void eat() &#123;        System.out.println(name + &quot; 正在吃东西&quot;);    &#125;&#125;// 定义子类，继承自 Animal 类class Dog extends Animal &#123;    public void bark() &#123;        System.out.println(name + &quot; 正在汪汪叫&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.name = &quot;旺财&quot;;        dog.eat();        dog.bark();    &#125;&#125;</code></pre><p>在上述代码中，<code>Dog</code> 类继承了 <code>Animal</code> 类，因此 <code>Dog</code> 类可以使用 <code>Animal</code> 类中定义的 <code>name</code> 属性和 <code>eat()</code> 方法，同时还可以有自己特有的方法 <code>bark()</code>。</p><p><strong>继承的特点</strong></p><ol><li><strong>单继承</strong>：Java 只支持单继承，即一个子类只能有一个直接父类。这有助于避免多继承带来的复杂问题，如菱形继承问题。不过，Java 支持多层继承，即一个子类可以有父类，父类还可以有自己的父类。</li><li><strong>传递性</strong>：如果 <code>C</code> 类继承自 <code>B</code> 类，<code>B</code> 类继承自 <code>A</code> 类，那么 <code>C</code> 类就拥有 <code>B</code> 类和 <code>A</code> 类的所有可继承的属性和方法。</li></ol><p><strong>访问父类成员</strong></p><p>在子类中，可以使用 <code>super</code> 关键字来访问父类的成员，包括属性和方法。例如：</p><pre><code class="java">class Animal &#123;    String name = &quot;动物&quot;;    public void eat() &#123;        System.out.println(&quot;动物正在吃东西&quot;);    &#125;&#125;class Dog extends Animal &#123;    String name = &quot;旺财&quot;;    public void showInfo() &#123;        // 访问父类的属性        System.out.println(super.name);        // 调用父类的方法        super.eat();    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.showInfo();    &#125;&#125;</code></pre><p>在 <code>Dog</code> 类的 <code>showInfo()</code> 方法中，使用 <code>super.name</code> 访问了父类的 <code>name</code> 属性，使用 <code>super.eat()</code> 调用了父类的 <code>eat()</code> 方法。</p><p><strong>方法重写（Override）</strong></p><p>子类可以重写父类的方法，即子类提供与父类方法具有相同名称、参数列表和返回类型的方法实现。重写方法时，需要使用 <code>@Override</code> 注解来确保重写的正确性。例如：</p><pre><code class="java">class Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;class Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.makeSound();    &#125;&#125;</code></pre><p>在上述代码中，<code>Dog</code> 类重写了 <code>Animal</code> 类的 <code>makeSound()</code> 方法，当调用 <code>dog.makeSound()</code> 时，会执行 <code>Dog</code> 类中重写后的方法。</p><p><strong>构造方法的继承</strong></p><p>子类不会继承父类的构造方法，但子类的构造方法中会默认调用父类的无参构造方法。如果父类没有无参构造方法，子类的构造方法中必须使用 <code>super()</code> 显式调用父类的有参构造方法。例如：</p><pre><code class="java">class Animal &#123;    String name;    public Animal(String name) &#123;        this.name = name;    &#125;&#125;class Dog extends Animal &#123;    public Dog(String name) &#123;        // 显式调用父类的构造方法        super(name);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog(&quot;旺财&quot;);        System.out.println(dog.name);    &#125;&#125;</code></pre><p>在 <code>Dog</code> 类的构造方法中，使用 <code>super(name)</code> 调用了父类 <code>Animal</code> 的构造方法，以初始化从父类继承的 <code>name</code> 属性。</p><h4 id="父类构造器"><a href="#父类构造器" class="headerlink" title="父类构造器"></a>父类构造器</h4><p><img src="/../images/java/1740923961213.png" alt="1740923961213"></p><h4 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h4><p><img src="/../images/java/1740924652916.png" alt="1740924652916"></p><p> 需注意的是，<code>super()</code> 调用父类构造方法的语句必须是子类构造方法中的第一条语句。 </p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p><img src="/../images/java/1741005932153.png" alt="1741005932153"></p><h5 id="定义和基本语法"><a href="#定义和基本语法" class="headerlink" title="定义和基本语法"></a>定义和基本语法</h5><p>方法重写是指在子类中定义一个与父类中具有相同名称、参数列表和返回类型的方法。子类通过重写父类的方法，可以提供自己的实现逻辑。其基本语法如下：</p><pre><code class="java">// 父类class Parent &#123;    public void display() &#123;        System.out.println(&quot;这是父类的 display 方法&quot;);    &#125;&#125;// 子类class Child extends Parent &#123;    @Override    public void display() &#123;        System.out.println(&quot;这是子类重写后的 display 方法&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Child child = new Child();        child.display();     &#125;&#125;</code></pre><p>在上述代码中，<code>Child</code> 类重写了 <code>Parent</code> 类的 <code>display</code> 方法。当调用 <code>child.display()</code> 时，会执行子类中重写后的方法。</p><h5 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h5><ol><li><strong>方法签名必须相同</strong>：方法名、参数列表必须与父类中被重写的方法完全一致。</li><li><strong>返回类型必须兼容</strong>：子类重写方法的返回类型必须与父类被重写方法的返回类型相同，或者是其子类型（从 Java 5 开始支持协变返回类型）。 </li><li><strong>访问修饰符限制</strong>：子类重写方法的访问修饰符不能比父类被重写方法的访问修饰符更严格。例如，如果父类方法是 <code>public</code> 的，子类重写方法不能是 <code>protected</code> 或 <code>private</code> 的。 </li><li><strong>异常抛出限制</strong>：子类重写方法抛出的异常不能比父类被重写方法抛出的异常更宽泛。即子类重写方法可以不抛出异常，或者抛出与父类相同的异常，或者抛出父类异常的子类异常。</li></ol><h5 id="Override-注解"><a href="#Override-注解" class="headerlink" title="@Override 注解"></a><code>@Override</code> 注解</h5><p><code>@Override</code> 是 Java 中的一个注解，用于显式地表明一个方法是重写父类的方法。虽然这个注解不是必需的，但使用它可以让编译器进行检查，如果方法不符合重写规则，编译器会报错，有助于避免一些潜在的错误。例如：</p><pre><code class="java">class Parent &#123;    public void test() &#123;        System.out.println(&quot;父类的 test 方法&quot;);    &#125;&#125;class Child extends Parent &#123;    // 若此处方法名拼写错误，使用 @Override 注解编译器会报错    @Override    public void test() &#123;        System.out.println(&quot;子类重写的 test 方法&quot;);    &#125;&#125;</code></pre><h5 id="调用父类被重写的方法"><a href="#调用父类被重写的方法" class="headerlink" title="调用父类被重写的方法"></a>调用父类被重写的方法</h5><p>在子类的重写方法中，可以使用 <code>super</code> 关键字来调用父类被重写的方法。例如：</p><pre><code class="java">class Parent &#123;    public void show() &#123;        System.out.println(&quot;父类的 show 方法&quot;);    &#125;&#125;class Child extends Parent &#123;    @Override    public void show() &#123;        super.show();         System.out.println(&quot;子类重写的 show 方法&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Child child = new Child();        child.show();    &#125;&#125;</code></pre><p>在 <code>Child</code> 类的 <code>show</code> 方法中，使用 <code>super.show()</code> 调用了父类的 <code>show</code> 方法，然后再执行子类自己的逻辑。</p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p><img src="/../images/java/1741006598498.png" alt="1741006598498"></p><p><img src="/../images/java/1741007322051.png" alt="1741007322051"></p><h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><p><strong>定义</strong></p><p>静态代码块是用花括号 <code>&#123;&#125;</code> 括起来的一段代码，但它使用 <code>static</code> 关键字修饰，并且直接定义在类中。示例如下：</p><pre><code class="java">public class StaticBlockExample &#123;    // 静态代码块    static &#123;        System.out.println(&quot;这是静态代码块&quot;);    &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;这是 main 方法&quot;);    &#125;&#125;</code></pre><p><strong>执行时机</strong></p><p>静态代码块在类被加载时执行，并且只执行一次。类的加载是在程序运行过程中，当第一次使用该类时（如创建对象、调用静态方法、访问静态属性等）由 Java 虚拟机（JVM）进行的操作。</p><h5 id="普通代码块（实例代码块）"><a href="#普通代码块（实例代码块）" class="headerlink" title="普通代码块（实例代码块）"></a>普通代码块（实例代码块）</h5><p><strong>定义</strong></p><p>普通代码块是用花括号 <code>&#123;&#125;</code> 括起来的一段代码，它没有任何修饰符，并且直接定义在类中，但不在任何方法内部。示例如下：</p><pre><code class="java">public class InstanceBlockExample &#123;    // 普通代码块    &#123;        System.out.println(&quot;这是普通代码块&quot;);    &#125;    public InstanceBlockExample() &#123;        System.out.println(&quot;这是构造方法&quot;);    &#125;    public static void main(String[] args) &#123;        InstanceBlockExample obj = new InstanceBlockExample();    &#125;&#125;</code></pre><p><strong>执行时机</strong></p><p>普通代码块会在创建对象时执行，并且在构造方法之前执行。如果创建多个对象，普通代码块会在每次创建对象时都执行一次。</p><p><strong>使用场景</strong></p><p>普通代码块常用于在创建对象时进行一些通用的初始化操作，这些操作可能在多个构造方法中都需要执行，将其放在普通代码块中可以避免代码重复。例如：</p><pre><code class="java">public class Person &#123;    private String name;    private int age;    &#123;        // 初始化日志记录等操作        System.out.println(&quot;开始创建 Person 对象&quot;);    &#125;    public Person() &#123;        this.name = &quot;Unknown&quot;;        this.age = 0;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;</code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><img src="/../images/java/1741180690729.png" alt="1741180690729"></p><p><strong><code>instanceOf</code> 判断</strong></p><p><img src="/../images/java/1741181812077.png" alt="1741181812077"></p><p><strong>多态的概念</strong></p><p>多态意味着一个对象可以有多种形态。具体来说，在程序运行时，同一个方法调用可以根据实际对象的类型产生不同的行为。多态通过将父类类型的引用指向子类对象，在调用方法时根据实际对象的类型来确定执行哪个子类的方法。</p><p><strong>实现多态的条件</strong></p><ol><li><strong>继承关系</strong>：需要有父类和子类之间的继承关系。</li><li><strong>方法重写</strong>：子类需要重写父类的方法，以实现不同的行为。</li><li><strong>父类引用指向子类对象</strong>：使用父类类型的引用指向子类的对象，通过该引用调用重写的方法。</li></ol><p><strong>多态的实现方式</strong></p><p><strong>1.基于继承的多态</strong></p><p>通过子类继承父类，并重写父类的方法，然后使用父类引用指向子类对象来实现多态。</p><pre><code class="java">// 定义父类 Animalclass Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;// 定义子类 Dog，继承自 Animalclass Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;// 定义子类 Cat，继承自 Animalclass Cat extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;public class PolymorphismExample &#123;    public static void main(String[] args) &#123;        // 父类引用指向子类对象        Animal dog = new Dog();        Animal cat = new Cat();        // 调用重写的方法，实现多态        dog.makeSound();         cat.makeSound();     &#125;&#125;</code></pre><p><strong>代码解释</strong>：</p><ul><li><code>Animal</code> 是父类，包含一个 <code>makeSound</code> 方法。</li><li><code>Dog</code> 和 <code>Cat</code> 是 <code>Animal</code> 的子类，分别重写了 <code>makeSound</code> 方法。</li><li>在 <code>main</code> 方法中，使用 <code>Animal</code> 类型的引用指向 <code>Dog</code> 和 <code>Cat</code> 对象，调用 <code>makeSound</code> 方法时，根据实际对象的类型执行相应的方法。</li></ul><p><strong>2. 基于接口的多态</strong></p><p>通过实现接口，不同的类可以实现相同的接口方法，然后使用接口类型的引用指向实现类的对象来实现多态。</p><pre><code class="java">// 定义接口 Shapeinterface Shape &#123;    double area();&#125;// 定义实现类 Circle，实现 Shape 接口class Circle implements Shape &#123;    private double radius;    public Circle(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double area() &#123;        return Math.PI * radius * radius;    &#125;&#125;// 定义实现类 Rectangle，实现 Shape 接口class Rectangle implements Shape &#123;    private double length;    private double width;    public Rectangle(double length, double width) &#123;        this.length = length;        this.width = width;    &#125;    @Override    public double area() &#123;        return length * width;    &#125;&#125;public class InterfacePolymorphismExample &#123;    public static void main(String[] args) &#123;        // 接口引用指向实现类对象        Shape circle = new Circle(5);        Shape rectangle = new Rectangle(4, 6);        // 调用接口方法，实现多态        System.out.println(&quot;圆的面积: &quot; + circle.area());        System.out.println(&quot;矩形的面积: &quot; + rectangle.area());    &#125;&#125;</code></pre><p><strong>代码解释</strong>：</p><ul><li><code>Shape</code> 是一个接口，定义了一个抽象方法 <code>area</code>。</li><li><code>Circle</code> 和 <code>Rectangle</code> 是实现 <code>Shape</code> 接口的类，分别实现了 <code>area</code> 方法。</li><li>在 <code>main</code> 方法中，使用 <code>Shape</code> 类型的引用指向 <code>Circle</code> 和 <code>Rectangle</code> 对象，调用 <code>area</code> 方法时，根据实际对象的类型执行相应的方法。</li></ul><p><strong>强制向下转型</strong></p><p>可以调用子类属性和子类特有方法。</p><p><img src="/../images/java/1741181653325.png" alt="1741181653325"></p><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a><strong>多态数组</strong></h4><p><img src="/../images/java/1741181900887.png" alt="1741181900887"></p><h5 id="基于继承的多态数组"><a href="#基于继承的多态数组" class="headerlink" title="基于继承的多态数组"></a>基于继承的多态数组</h5><p>示例代码</p><pre><code class="java">// 定义父类 Animalclass Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;// 定义子类 Dog，继承自 Animalclass Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;// 定义子类 Cat，继承自 Animalclass Cat extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;public class InheritancePolymorphicArray &#123;    public static void main(String[] args) &#123;        // 创建一个 Animal 类型的数组，该数组可以存储 Animal 及其子类的对象        Animal[] animals = new Animal[2];        animals[0] = new Dog();        animals[1] = new Cat();        // 遍历数组，调用 makeSound 方法，实现多态        for (Animal animal : animals) &#123;            animal.makeSound();        &#125;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ol><li><strong>定义父类和子类</strong>：定义了一个父类 <code>Animal</code>，其中包含 <code>makeSound</code> 方法。<code>Dog</code> 和 <code>Cat</code> 类继承自 <code>Animal</code> 类，并重写了 <code>makeSound</code> 方法，以实现不同的行为。</li><li><strong>创建多态数组</strong>：创建了一个 <code>Animal</code> 类型的数组 <code>animals</code>，该数组可以存储 <code>Animal</code> 类及其子类的对象。</li><li><strong>存储不同子类对象</strong>：将 <code>Dog</code> 和 <code>Cat</code> 类的对象分别存储到数组的不同位置。</li><li><strong>遍历数组并调用方法</strong>：使用增强 <code>for</code> 循环遍历数组，调用 <code>makeSound</code> 方法。由于数组元素是 <code>Animal</code> 类型的引用，但实际指向的是 <code>Dog</code> 和 <code>Cat</code> 对象，因此会根据实际对象的类型调用相应的 <code>makeSound</code> 方法，实现多态。</li></ol><h5 id="基于接口的多态数组"><a href="#基于接口的多态数组" class="headerlink" title="基于接口的多态数组"></a>基于接口的多态数组</h5><p>示例代码</p><pre><code class="java">// 定义接口 Shapeinterface Shape &#123;    double area();&#125;// 定义实现类 Circle，实现 Shape 接口class Circle implements Shape &#123;    private double radius;    public Circle(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double area() &#123;        return Math.PI * radius * radius;    &#125;&#125;// 定义实现类 Rectangle，实现 Shape 接口class Rectangle implements Shape &#123;    private double length;    private double width;    public Rectangle(double length, double width) &#123;        this.length = length;        this.width = width;    &#125;    @Override    public double area() &#123;        return length * width;    &#125;&#125;public class InterfacePolymorphicArray &#123;    public static void main(String[] args) &#123;        // 创建一个 Shape 类型的数组，该数组可以存储实现 Shape 接口的类的对象        Shape[] shapes = new Shape[2];        shapes[0] = new Circle(5);        shapes[1] = new Rectangle(4, 6);        // 遍历数组，调用 area 方法，实现多态        for (Shape shape : shapes) &#123;            System.out.println(&quot;该图形的面积是: &quot; + shape.area());        &#125;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ol><li><strong>定义接口和实现类</strong>：定义了一个接口 <code>Shape</code>，其中包含抽象方法 <code>area</code>。<code>Circle</code> 和 <code>Rectangle</code> 类实现了 <code>Shape</code> 接口，并实现了 <code>area</code> 方法，以计算不同形状的面积。</li><li><strong>创建多态数组</strong>：创建了一个 <code>Shape</code> 类型的数组 <code>shapes</code>，该数组可以存储实现 <code>Shape</code> 接口的类的对象。</li><li><strong>存储不同实现类对象</strong>：将 <code>Circle</code> 和 <code>Rectangle</code> 类的对象分别存储到数组的不同位置。</li><li><strong>遍历数组并调用方法</strong>：使用增强 <code>for</code> 循环遍历数组，调用 <code>area</code> 方法。由于数组元素是 <code>Shape</code> 类型的引用，但实际指向的是 <code>Circle</code> 和 <code>Rectangle</code> 对象，因此会根据实际对象的类型调用相应的 <code>area</code> 方法，实现多态。</li></ol><h4 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h4><p><img src="/../images/java/1741182900629.png" alt="1741182900629"></p><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>在 Java 中，当通过父类引用调用一个被重写的方法时，编译阶段编译器会根据引用的类型（即父类类型）来检查方法是否存在，但在运行阶段，Java 虚拟机（JVM）会根据引用实际指向的对象类型（即子类类型）来决定调用哪个类的方法。这种在运行时确定调用方法的机制就是动态绑定。</p><h5 id="实现动态绑定的条件"><a href="#实现动态绑定的条件" class="headerlink" title="实现动态绑定的条件"></a>实现动态绑定的条件</h5><ol><li><strong>继承关系</strong>：存在父类和子类的继承关系，子类继承自父类。</li><li><strong>方法重写</strong>：子类重写了父类的方法，即子类定义了与父类中具有相同签名（方法名、参数列表和返回类型）的方法。</li><li><strong>父类引用指向子类对象</strong>：使用父类类型的引用变量来引用子类的对象。</li></ol><p>示例代码</p><pre><code class="java">// 定义父类 Animalclass Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;// 定义子类 Dog，继承自 Animalclass Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;// 定义子类 Cat，继承自 Animalclass Cat extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;public class DynamicBindingExample &#123;    public static void main(String[] args) &#123;        // 父类引用指向子类对象        Animal dog = new Dog();        Animal cat = new Cat();        // 调用 makeSound 方法，发生动态绑定        dog.makeSound();        cat.makeSound();    &#125;&#125;</code></pre><p>代码解释</p><ol><li><strong>定义父类和子类</strong>：定义了一个父类 <code>Animal</code>，其中包含 <code>makeSound</code> 方法。<code>Dog</code> 和 <code>Cat</code> 类继承自 <code>Animal</code> 类，并重写了 <code>makeSound</code> 方法，以实现不同的行为。</li><li><strong>父类引用指向子类对象</strong>：在 <code>main</code> 方法中，创建了 <code>Animal</code> 类型的引用变量 <code>dog</code> 和 <code>cat</code>，分别指向 <code>Dog</code> 和 <code>Cat</code> 类的对象。</li><li><strong>动态绑定过程</strong>：<ul><li>编译阶段：编译器根据引用类型 <code>Animal</code> 检查 <code>makeSound</code> 方法是否存在，由于 <code>Animal</code> 类中定义了该方法，编译通过。</li><li>运行阶段：JVM 根据引用实际指向的对象类型（<code>Dog</code> 或 <code>Cat</code>）来决定调用哪个类的 <code>makeSound</code> 方法。因此，<code>dog.makeSound()</code> 会调用 <code>Dog</code> 类的 <code>makeSound</code> 方法，输出 “汪汪汪”；<code>cat.makeSound()</code> 会调用 <code>Cat</code> 类的 <code>makeSound</code> 方法，输出 “喵喵喵”。</li></ul></li></ol><p><strong>注意事项</strong></p><ul><li><strong>静态方法和私有方法不参与动态绑定</strong>：静态方法属于类，而不是对象，它们在编译时就已经确定了调用关系，不依赖于对象的实际类型。私有方法不能被重写，因此也不会发生动态绑定。例如：</li></ul><pre><code class="java">class Parent &#123;    public static void staticMethod() &#123;        System.out.println(&quot;父类的静态方法&quot;);    &#125;    private void privateMethod() &#123;        System.out.println(&quot;父类的私有方法&quot;);    &#125;&#125;class Child extends Parent &#123;    public static void staticMethod() &#123;        System.out.println(&quot;子类的静态方法&quot;);    &#125;    // 这里并不是重写父类的私有方法，因为私有方法不能被重写    private void privateMethod() &#123;        System.out.println(&quot;子类的私有方法&quot;);    &#125;&#125;public class StaticAndPrivateMethodExample &#123;    public static void main(String[] args) &#123;        Parent parent = new Child();        parent.staticMethod(); // 调用父类的静态方法        // parent.privateMethod(); // 编译错误，私有方法不能被外部访问    &#125;&#125;</code></pre><p>在上述代码中，<code>staticMethod</code> 是静态方法，<code>parent.staticMethod()</code> 调用的是父类的静态方法，而不是子类的静态方法；<code>privateMethod</code> 是私有方法，不参与动态绑定。</p><h5 id="静态属性和方法的-“继承”-与实例属性和方法继承的区别"><a href="#静态属性和方法的-“继承”-与实例属性和方法继承的区别" class="headerlink" title="静态属性和方法的 “继承” 与实例属性和方法继承的区别"></a>静态属性和方法的 “继承” 与实例属性和方法继承的区别</h5><p><strong>方法重写方面</strong></p><p>普通的实例方法可以在子类中被重写（override），实现多态；而静态方法不能被重写，当子类中定义了和父类相同签名的静态方法时，这被称为方法隐藏（method hiding），而不是方法重写。</p><p><strong>调用时的绑定机制</strong></p><p>实例方法的调用是动态绑定的，在运行时根据对象的实际类型来确定调用哪个类的方法；而静态方法的调用是静态绑定的，在编译时就根据引用类型确定要调用的方法。</p><h3 id="默认父类方法"><a href="#默认父类方法" class="headerlink" title="默认父类方法"></a>默认父类方法</h3><p><img src="/../images/java/1741185187271.png" alt="1741185187271"></p><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p><img src="/../images/java/1741185171198.png" alt="1741185171198"></p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p><img src="/../images/java/1741185982777.png" alt="1741185982777"></p><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p><img src="/../images/java/1741185995421.png" alt="1741185995421"></p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><img src="/../images/java/1741254352036.png" alt="1741254352036"></p><h4 id="定义抽象类"><a href="#定义抽象类" class="headerlink" title="定义抽象类"></a>定义抽象类</h4><p>在 Java 中，使用 <code>abstract</code> 关键字来定义抽象类。抽象类不能被实例化，也就是不能使用 <code>new</code> 关键字来创建抽象类的对象，它主要用于被其他类继承。</p><pre><code class="java">// 定义一个抽象类 Animalabstract class Animal &#123;    // 成员变量    protected String name;    // 构造方法    public Animal(String name) &#123;        this.name = name;    &#125;    // 普通方法    public void eat() &#123;        System.out.println(name + &quot; 正在吃东西&quot;);    &#125;    // 抽象方法，没有方法体    public abstract void makeSound();&#125;</code></pre><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>抽象类中可以包含抽象方法，抽象方法使用 <code>abstract</code> 关键字修饰，并且没有方法体。抽象方法的作用是定义一个规范，要求子类必须实现这个方法。</p><pre><code class="java">// 抽象方法示例public abstract void makeSound();</code></pre><h4 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h4><p>子类继承抽象类时，必须实现抽象类中的所有抽象方法，否则子类也必须被声明为抽象类。</p><pre><code class="java">// 定义 Dog 类继承自 Animal 抽象类class Dog extends Animal &#123;    public Dog(String name) &#123;        super(name);    &#125;    // 实现抽象方法 makeSound    @Override    public void makeSound() &#123;        System.out.println(name + &quot; 汪汪叫&quot;);    &#125;&#125;// 定义 Cat 类继承自 Animal 抽象类class Cat extends Animal &#123;    public Cat(String name) &#123;        super(name);    &#125;    // 实现抽象方法 makeSound    @Override    public void makeSound() &#123;        System.out.println(name + &quot; 喵喵叫&quot;);    &#125;&#125;</code></pre><h4 id="使用抽象类"><a href="#使用抽象类" class="headerlink" title="使用抽象类"></a>使用抽象类</h4><p>虽然抽象类不能被实例化，但可以使用抽象类的引用指向子类的对象，从而实现多态。</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        // 抽象类的引用指向子类对象        Animal dog = new Dog(&quot;旺财&quot;);        Animal cat = new Cat(&quot;咪咪&quot;);        // 调用普通方法        dog.eat();        cat.eat();        // 调用抽象方法（多态）        dog.makeSound();        cat.makeSound();    &#125;&#125;</code></pre><h4 id="抽象类的特点和使用场景"><a href="#抽象类的特点和使用场景" class="headerlink" title="抽象类的特点和使用场景"></a>抽象类的特点和使用场景</h4><ul><li><strong>特点</strong><ul><li><strong>不能实例化</strong>：抽象类不能使用 <code>new</code> 关键字创建对象，只能作为父类被继承。</li><li><strong>可以包含抽象方法和普通方法</strong>：抽象类中既可以有抽象方法，也可以有普通方法，这样可以提供一些通用的实现，同时要求子类实现特定的行为。</li><li><strong>构造方法</strong>：抽象类可以有构造方法，用于初始化成员变量，但不能通过构造方法直接创建抽象类的对象，构造方法主要用于子类调用。</li></ul></li><li><strong>使用场景</strong><ul><li><strong>定义通用行为和规范</strong>：当多个类有一些共同的行为和属性时，可以将这些共同的部分提取到抽象类中，同时定义一些抽象方法，要求子类根据自身的特点去实现这些方法。</li><li><strong>实现多态</strong>：通过抽象类的引用指向子类的对象，可以实现多态，提高代码的灵活性和可扩展性。</li></ul></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="/../images/java/1741265807966.png" alt="1741265807966"></p><p><img src="/../images/java/1741266765499.png" alt="1741266765499"></p><h4 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h4><p>在 Java 中，使用 <code>interface</code> 关键字来定义接口，接口中的方法默认是 <code>public abstract</code> 类型（即抽象方法），字段默认是 <code>public static final</code> 类型（即常量）。</p><pre><code class="java">// 定义一个接口 Animalinterface Animal &#123;    // 常量    int LEGS = 4;    // 抽象方法    void eat();    void makeSound();&#125;</code></pre><ul><li><strong>不能实例化</strong>：接口不能使用 <code>new</code> 关键字创建对象，它主要用于被类实现或者被其他接口继承。</li><li><strong>抽象方法</strong>：接口中的方法默认是抽象方法，不需要使用 <code>abstract</code> 关键字修饰，而且这些方法必须由实现类来实现。</li><li><strong>常量</strong>：接口中的字段默认是常量，即 <code>public static final</code> 类型，必须在定义时进行初始化，且初始化后不能再修改。</li><li><strong>多实现</strong>：一个类可以实现多个接口，从而实现多重继承的效果，这弥补了 Java 类只能单继承的局限性。</li></ul><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><p>类通过 <code>implements</code> 关键字来实现接口，实现接口的类必须实现接口中定义的所有抽象方法。</p><pre><code class="java">// 定义 Dog 类实现 Animal 接口class Dog implements Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;狗在吃东西&quot;);    &#125;    @Override    public void makeSound() &#123;        System.out.println(&quot;狗汪汪叫&quot;);    &#125;&#125;// 定义 Cat 类实现 Animal 接口class Cat implements Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;猫在吃东西&quot;);    &#125;    @Override    public void makeSound() &#123;        System.out.println(&quot;猫喵喵叫&quot;);    &#125;&#125;</code></pre><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>接口可以继承其他接口，使用 <code>extends</code> 关键字，一个接口可以继承多个接口。</p><pre><code class="java">// 定义一个新的接口 Pet，继承自 Animal 接口interface Pet extends Animal &#123;    void play();&#125;// 定义 Dog 类实现 Pet 接口class Dog implements Pet &#123;    @Override    public void eat() &#123;        System.out.println(&quot;狗在吃东西&quot;);    &#125;    @Override    public void makeSound() &#123;        System.out.println(&quot;狗汪汪叫&quot;);    &#125;    @Override    public void play() &#123;        System.out.println(&quot;狗在玩耍&quot;);    &#125;&#125;</code></pre><h4 id="接口的使用场景"><a href="#接口的使用场景" class="headerlink" title="接口的使用场景"></a>接口的使用场景</h4><ul><li><strong>定义规范</strong>：接口可以定义一组规范，让不同的类去实现这些规范，从而保证这些类具有相同的行为。例如，Java 中的 <code>Runnable</code> 接口，任何实现该接口的类都必须实现 <code>run</code> 方法，这样就可以将这些类的对象作为线程任务来执行。</li><li><strong>实现多态</strong>：通过接口的引用指向实现类的对象，可以实现多态，提高代码的灵活性和可扩展性。</li></ul><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        // 接口的引用指向实现类对象        Animal dog = new Dog();        Animal cat = new Cat();        // 调用接口方法（多态）        dog.eat();        dog.makeSound();        cat.eat();        cat.makeSound();    &#125;&#125;</code></pre><h4 id="Java-8-及以后接口的新特性"><a href="#Java-8-及以后接口的新特性" class="headerlink" title="Java 8 及以后接口的新特性"></a>Java 8 及以后接口的新特性</h4><ul><li><strong>默认方法</strong>：Java 8 引入了默认方法，使用 <code>default</code> 关键字修饰，默认方法可以有方法体，实现类可以选择是否重写默认方法。</li></ul><pre><code class="java">interface Animal &#123;    void eat();    void makeSound();    // 默认方法    default void sleep() &#123;        System.out.println(&quot;动物在睡觉&quot;);    &#125;&#125;</code></pre><ul><li><strong>静态方法</strong>：Java 8 还允许接口中定义静态方法，静态方法使用 <code>static</code> 关键字修饰，通过接口名直接调用。</li></ul><pre><code class="java">interface Animal &#123;    void eat();    void makeSound();    // 静态方法    static void info() &#123;        System.out.println(&quot;这是一个动物接口&quot;);    &#125;&#125;</code></pre><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><img src="/../images/java/1741351878282.png" alt="1741351878282"></p><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p><img src="/../images/java/1741352159174.png" alt="1741352159174"></p><h5 id="定义成员内部类"><a href="#定义成员内部类" class="headerlink" title="定义成员内部类"></a>定义成员内部类</h5><p>成员内部类的定义语法很简单，在外部类的内部直接定义一个新的类即</p><pre><code class="java">// 外部类class Outer &#123;    // 成员内部类    class Inner &#123;        // 内部类的方法        public void innerMethod() &#123;            System.out.println(&quot;这是成员内部类的方法&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="创建成员内部类的对象"><a href="#创建成员内部类的对象" class="headerlink" title="创建成员内部类的对象"></a>创建成员内部类的对象</h5><p>要创建成员内部类的对象，必须先创建外部类的对象，因为成员内部类依赖于外部类的实例存在。创建成员内部类对象的语法如下：</p><pre><code class="java">// 创建外部类对象Outer outer = new Outer();// 通过外部类对象创建成员内部类对象Outer.Inner inner = outer.new Inner();</code></pre><h5 id="成员内部类访问外部类成员"><a href="#成员内部类访问外部类成员" class="headerlink" title="成员内部类访问外部类成员"></a>成员内部类访问外部类成员</h5><p>成员内部类可以访问外部类的所有成员，包括私有成员。</p><pre><code class="java">// 外部类class Outer &#123;    private int outerVariable = 10;    // 成员内部类    class Inner &#123;        public void accessOuterVariable() &#123;            // 访问外部类的私有成员            System.out.println(&quot;外部类的私有变量值: &quot; + outerVariable);        &#125;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        Outer.Inner inner = outer.new Inner();        inner.accessOuterVariable();    &#125;&#125;</code></pre><h5 id="外部类访问成员内部类成员"><a href="#外部类访问成员内部类成员" class="headerlink" title="外部类访问成员内部类成员"></a>外部类访问成员内部类成员</h5><p>外部类也可以访问成员内部类的成员，但需要先创建成员内部类的对象。</p><pre><code class="java">// 外部类class Outer &#123;    // 成员内部类    class Inner &#123;        private int innerVariable = 20;        public void innerMethod() &#123;            System.out.println(&quot;这是成员内部类的方法&quot;);        &#125;    &#125;    public void accessInnerMembers() &#123;        Inner inner = new Inner();        // 访问成员内部类的私有变量        System.out.println(&quot;成员内部类的私有变量值: &quot; + inner.innerVariable);        // 调用成员内部类的方法        inner.innerMethod();    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        outer.accessInnerMembers();    &#125;&#125;</code></pre><h5 id="成员内部类的特点"><a href="#成员内部类的特点" class="headerlink" title="成员内部类的特点"></a>成员内部类的特点</h5><ol><li><strong>依赖外部类实例</strong>：成员内部类的对象必须依赖于外部类的对象才能创建，因为它隐式地持有一个对外部类对象的引用。</li><li><strong>访问外部类成员</strong>：可以访问外部类的所有成员，包括私有成员和静态成员。</li><li><strong>编译后生成独立的.class 文件</strong>：成员内部类编译后会生成独立的 <code>.class</code> 文件，文件名格式为 <code>外部类名$内部类名.class</code>。</li></ol><h5 id="成员内部类的使用场景"><a href="#成员内部类的使用场景" class="headerlink" title="成员内部类的使用场景"></a>成员内部类的使用场景</h5><ol><li><strong>实现多继承效果</strong>：由于 Java 不支持类的多重继承，但通过成员内部类可以在一定程度上实现类似多重继承的效果，一个类可以通过成员内部类继承其他类。</li><li><strong>封装细节</strong>：当一个类的某些功能只与该类的其他成员密切相关，并且不希望被外部直接访问时，可以将这些功能封装在成员内部类中。</li><li><strong>事件处理</strong>：在 GUI 编程中，成员内部类常被用于处理事件，例如按钮点击事件等。</li></ol><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p><img src="/../images/java/1741501103771.png" alt="1741501103771"></p><h5 id="定义静态内部类"><a href="#定义静态内部类" class="headerlink" title="定义静态内部类"></a>定义静态内部类</h5><p>静态内部类的定义和普通内部类类似，只是在类定义前加上 <code>static</code> 关键字。示例代码如下：</p><pre><code class="java">// 外部类class OuterClass &#123;    // 静态内部类    static class StaticInnerClass &#123;        public void display() &#123;            System.out.println(&quot;这是静态内部类的方法&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="创建静态内部类的对象"><a href="#创建静态内部类的对象" class="headerlink" title="创建静态内部类的对象"></a>创建静态内部类的对象</h5><p>静态内部类不依赖于外部类的实例，因此可以直接创建静态内部类的对象，不需要先创建外部类的对象。创建对象的语法如下：</p><pre><code class="java">OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();</code></pre><p>完整示例代码如下：</p><pre><code class="java">class OuterClass &#123;    static class StaticInnerClass &#123;        public void display() &#123;            System.out.println(&quot;这是静态内部类的方法&quot;);        &#125;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();        inner.display();    &#125;&#125;</code></pre><h5 id="静态内部类的访问规则"><a href="#静态内部类的访问规则" class="headerlink" title="静态内部类的访问规则"></a>静态内部类的访问规则</h5><h6 id="访问外部类成员"><a href="#访问外部类成员" class="headerlink" title="访问外部类成员"></a>访问外部类成员</h6><p>静态内部类只能直接访问外部类的静态成员（静态变量和静态方法），不能直接访问外部类的非静态成员。如果要访问外部类的非静态成员，需要先创建外部类的对象。示例代码如下：</p><pre><code class="java">class OuterClass &#123;    private static int staticVariable = 10;    private int nonStaticVariable = 20;    static class StaticInnerClass &#123;        public void accessOuterMembers() &#123;            // 可以直接访问外部类的静态成员            System.out.println(&quot;外部类的静态变量: &quot; + staticVariable);            // 不能直接访问外部类的非静态成员，需要创建外部类对象            OuterClass outer = new OuterClass();            System.out.println(&quot;外部类的非静态变量: &quot; + outer.nonStaticVariable);        &#125;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();        inner.accessOuterMembers();    &#125;&#125;</code></pre><h6 id="外部类访问静态内部类成员"><a href="#外部类访问静态内部类成员" class="headerlink" title="外部类访问静态内部类成员"></a>外部类访问静态内部类成员</h6><p>外部类可以直接访问静态内部类的静态成员，如果要访问静态内部类的非静态成员，需要创建静态内部类的对象。示例代码如下：</p><pre><code class="java">class OuterClass &#123;    static class StaticInnerClass &#123;        private static int staticInnerVariable = 30;        private int nonStaticInnerVariable = 40;        public static void staticInnerMethod() &#123;            System.out.println(&quot;静态内部类的静态方法&quot;);        &#125;        public void nonStaticInnerMethod() &#123;            System.out.println(&quot;静态内部类的非静态方法&quot;);        &#125;    &#125;    public void accessInnerMembers() &#123;        // 直接访问静态内部类的静态成员        System.out.println(&quot;静态内部类的静态变量: &quot; + StaticInnerClass.staticInnerVariable);        StaticInnerClass.staticInnerMethod();        // 创建静态内部类对象访问其非静态成员        StaticInnerClass inner = new StaticInnerClass();        System.out.println(&quot;静态内部类的非静态变量: &quot; + inner.nonStaticInnerVariable);        inner.nonStaticInnerMethod();    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        OuterClass outer = new OuterClass();        outer.accessInnerMembers();    &#125;&#125;</code></pre><h5 id="静态内部类的特点"><a href="#静态内部类的特点" class="headerlink" title="静态内部类的特点"></a>静态内部类的特点</h5><ol><li><strong>不依赖外部类实例</strong>：静态内部类不持有外部类对象的引用，它的创建不依赖于外部类的实例，这使得它在内存使用和独立性上有一定优势。</li><li><strong>只能访问外部类静态成员</strong>：由于静态内部类不依赖外部类实例，所以只能直接访问外部类的静态成员。</li><li><strong>编译后生成独立的.class 文件</strong>：静态内部类编译后会生成独立的 <code>.class</code> 文件，文件名格式为 <code>外部类名$静态内部类名.class</code>。</li></ol><h5 id="静态内部类的使用场景"><a href="#静态内部类的使用场景" class="headerlink" title="静态内部类的使用场景"></a>静态内部类的使用场景</h5><ol><li><strong>封装相关功能</strong>：当一组功能与某个外部类相关，但又不需要访问外部类的非静态成员时，可以将这些功能封装在静态内部类中，提高代码的模块化程度。</li><li><strong>数据结构嵌套</strong>：在实现一些复杂的数据结构时，如树、图等，静态内部类可以用来表示节点等嵌套结构，使代码结构更清晰。</li></ol><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p><img src="/../images/java/1741501971643.png" alt="1741501971643"></p><h5 id="定义局部内部类"><a href="#定义局部内部类" class="headerlink" title="定义局部内部类"></a>定义局部内部类</h5><p>局部内部类定义在方法、构造函数或者代码块内部，其定义语法和普通类类似，但只能在定义它的作用域内使用。以下是在方法内部定义局部内部类的示例：</p><pre><code class="java">public class OuterClass &#123;    public void outerMethod() &#123;        // 局部内部类        class LocalInnerClass &#123;            public void display() &#123;                System.out.println(&quot;这是局部内部类的方法&quot;);            &#125;        &#125;        // 在方法内部创建局部内部类的对象并调用方法        LocalInnerClass inner = new LocalInnerClass();        inner.display();    &#125;&#125;</code></pre><p>在上述代码中，<code>LocalInnerClass</code> 是定义在 <code>outerMethod</code> 方法内部的局部内部类，只能在 <code>outerMethod</code> 方法内部使用。</p><h5 id="局部内部类的特点"><a href="#局部内部类的特点" class="headerlink" title="局部内部类的特点"></a>局部内部类的特点</h5><ol><li><strong>作用域受限</strong>：局部内部类只能在定义它的方法、构造函数或代码块内部使用，出了这个作用域就无法访问。</li><li><strong>访问外部类成员</strong>：局部内部类可以访问外部类的所有成员，包括私有成员。</li><li><strong>访问局部变量</strong>：局部内部类可以访问定义它的方法中的 <code>final</code> 或 <code>effectively final</code>（Java 8 及以后，若变量值在初始化后未被修改，可视为 <code>effectively final</code>）局部变量。</li><li><strong>编译后生成独立的.class 文件</strong>：局部内部类编译后会生成独立的 <code>.class</code> 文件，文件名格式为 <code>外部类名$数字局部内部类名.class</code>，其中数字用于区分不同位置的局部内部类。</li></ol><h5 id="访问规则"><a href="#访问规则" class="headerlink" title="访问规则"></a>访问规则</h5><h6 id="访问外部类成员-1"><a href="#访问外部类成员-1" class="headerlink" title="访问外部类成员"></a>访问外部类成员</h6><p>局部内部类可以直接访问外部类的所有成员，包括私有成员。示例代码如下：</p><pre><code class="java">public class OuterClass &#123;    private int outerVariable = 10;    public void outerMethod() &#123;        class LocalInnerClass &#123;            public void accessOuterVariable() &#123;                // 访问外部类的私有成员                System.out.println(&quot;外部类的私有变量: &quot; + outerVariable);            &#125;        &#125;        LocalInnerClass inner = new LocalInnerClass();        inner.accessOuterVariable();    &#125;&#125;</code></pre><h6 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h6><p>局部内部类可以访问定义它的方法中的 <code>final</code> 或 <code>effectively final</code> 局部变量。示例代码如下：</p><pre><code class="java">public class OuterClass &#123;    public void outerMethod() &#123;        // effectively final 局部变量        int localVar = 20;        class LocalInnerClass &#123;            public void accessLocalVariable() &#123;                // 访问局部变量                System.out.println(&quot;局部变量的值: &quot; + localVar);            &#125;        &#125;        LocalInnerClass inner = new LocalInnerClass();        inner.accessLocalVariable();    &#125;&#125;</code></pre><p>需要注意的是，如果尝试修改 <code>localVar</code> 的值，就会破坏其 <code>effectively final</code> 的特性，局部内部类将无法再访问该变量。</p><h5 id="局部内部类的使用场景"><a href="#局部内部类的使用场景" class="headerlink" title="局部内部类的使用场景"></a>局部内部类的使用场景</h5><ol><li><strong>封装特定逻辑</strong>：当某个功能只在方法内部使用，且该功能有一定的复杂性，需要封装成类时，可以使用局部内部类。</li><li><strong>实现临时接口或抽象类</strong>：在方法内部需要实现某个接口或继承某个抽象类，并且这个实现只在该方法内部使用时，使用局部内部类可以避免创建过多的外部类，使代码更加简洁。</li></ol><h5 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h5><pre><code class="java">public class OuterClass &#123;    private int outerVariable = 10;    public void outerMethod() &#123;        // effectively final 局部变量        int localVar = 20;        // 局部内部类        class LocalInnerClass &#123;            public void accessOuterVariable() &#123;                // 访问外部类的私有成员                System.out.println(&quot;外部类的私有变量: &quot; + outerVariable);            &#125;            public void accessLocalVariable() &#123;                // 访问局部变量                System.out.println(&quot;局部变量的值: &quot; + localVar);            &#125;        &#125;        // 创建局部内部类的对象并调用方法        LocalInnerClass inner = new LocalInnerClass();        inner.accessOuterVariable();        inner.accessLocalVariable();    &#125;    public static void main(String[] args) &#123;        OuterClass outer = new OuterClass();        outer.outerMethod();    &#125;&#125;</code></pre><p>在上述完整示例中，我们展示了局部内部类如何访问外部类的私有成员和方法内的局部变量，同时演示了如何在方法内部创建局部内部类的对象并调用其方法。</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p><img src="/../images/java/1741507808267.png" alt="1741507808267"></p><h5 id="定义与基本语法"><a href="#定义与基本语法" class="headerlink" title="定义与基本语法"></a>定义与基本语法</h5><p>匿名内部类通常用于创建一个实现某个接口或者继承某个类的对象，并且在创建对象的同时实现接口的抽象方法或者重写父类的方法。基本语法如下：</p><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><pre><code class="java">interface MyInterface &#123;    void doSomething();&#125;public class AnonymousInnerClassExample &#123;    public static void main(String[] args) &#123;        // 匿名内部类实现接口        MyInterface myInterface = new MyInterface() &#123;            @Override            public void doSomething() &#123;                System.out.println(&quot;执行接口的方法&quot;);            &#125;        &#125;;        myInterface.doSomething();    &#125;&#125;</code></pre><h5 id="继承类"><a href="#继承类" class="headerlink" title="继承类"></a>继承类</h5><pre><code class="java">class MyClass &#123;    public void display() &#123;        System.out.println(&quot;父类的方法&quot;);    &#125;&#125;public class AnonymousInnerClassExample2 &#123;    public static void main(String[] args) &#123;        // 匿名内部类继承类        MyClass myClass = new MyClass() &#123;            @Override            public void display() &#123;                System.out.println(&quot;重写父类的方法&quot;);            &#125;        &#125;;        myClass.display();    &#125;&#125;</code></pre><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li><strong>没有类名</strong>：匿名内部类没有显式的类名，它的定义和对象的创建是同时进行的。</li><li><strong>一次性使用</strong>：通常用于创建一次性的对象，只在当前使用的地方有效，不会被其他地方复用。</li><li><strong>隐式继承或实现</strong>：匿名内部类必须继承一个类或者实现一个接口，并且只能继承一个类或者实现一个接口。</li><li><strong>访问外部变量</strong>：可以访问外部类的成员变量和方法，对于方法中的局部变量，要求该变量是 <code>final</code> 或 <code>effectively final</code>（Java 8 及以后，若变量值在初始化后未被修改，可视为 <code>effectively final</code>）。</li></ol><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li><strong>事件处理</strong>：在 GUI 编程中，经常使用匿名内部类来处理事件，例如按钮点击事件、鼠标事件等。</li></ol><pre><code class="java">import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class EventHandlingExample &#123;    public static void main(String[] args) &#123;        JFrame frame = new JFrame(&quot;匿名内部类事件处理&quot;);        JButton button = new JButton(&quot;点击我&quot;);        // 匿名内部类处理按钮点击事件        button.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                JOptionPane.showMessageDialog(frame, &quot;按钮被点击了&quot;);            &#125;        &#125;);        frame.add(button);        frame.setSize(300, 200);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        frame.setVisible(true);    &#125;&#125;</code></pre><ol><li><strong>回调机制</strong>：当需要传递一个实现了特定接口的对象作为回调时，可以使用匿名内部类简化代码。</li><li><strong>简化代码</strong>：当某个类只需要使用一次，且实现逻辑比较简单时，使用匿名内部类可以避免创建过多的类文件，使代码更加简洁。</li></ol><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li><strong>构造函数</strong>：由于匿名内部类没有类名，所以不能有显式的构造函数。如果需要进行初始化操作，可以使用实例初始化块。</li></ol><pre><code class="java">abstract class MyAbstractClass &#123;    abstract void display();&#125;public class InitializationExample &#123;    public static void main(String[] args) &#123;        MyAbstractClass myAbstractClass = new MyAbstractClass() &#123;            int value;            // 实例初始化块            &#123;                value = 10;            &#125;            @Override            public void display() &#123;                System.out.println(&quot;值为: &quot; + value);            &#125;        &#125;;        myAbstractClass.display();    &#125;&#125;</code></pre><ol start="2"><li><strong>方法重写</strong>：如果实现接口，必须实现接口中的所有抽象方法；如果继承类，通常需要重写父类的方法来实现特定的逻辑。</li></ol><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p><img src="/../images/java/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-09%20161258.png"></p><h4 id="自定义枚举"><a href="#自定义枚举" class="headerlink" title="自定义枚举"></a>自定义枚举</h4><p><img src="/../images/java/1741509009547.png" alt="1741509009547"></p><h4 id="enum枚举类"><a href="#enum枚举类" class="headerlink" title="enum枚举类"></a>enum枚举类</h4><p><img src="/../images/java/1741509045726.png" alt="1741509045726"></p><h4 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h4><p>使用 <code>enum</code> 关键字来定义枚举类，语法如下：</p><pre><code class="java">enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;</code></pre><p>在上述代码中，<code>Season</code> 是一个枚举类，它包含四个枚举常量：<code>SPRING</code>、<code>SUMMER</code>、<code>AUTUMN</code> 和 <code>WINTER</code>。每个枚举常量都是 <code>Season</code> 类的一个实例。</p><h4 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h4><h5 id="遍历枚举常量"><a href="#遍历枚举常量" class="headerlink" title="遍历枚举常量"></a>遍历枚举常量</h5><p>可以使用 <code>values()</code> 方法获取枚举类的所有枚举常量，并进行遍历。</p><pre><code class="java">enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        // 遍历枚举常量        for (Season season : Season.values()) &#123;            System.out.println(season);        &#125;    &#125;&#125;</code></pre><h5 id="根据名称获取枚举常量"><a href="#根据名称获取枚举常量" class="headerlink" title="根据名称获取枚举常量"></a>根据名称获取枚举常量</h5><p>可以使用 <code>valueOf()</code> 方法根据枚举常量的名称获取对应的枚举实例。</p><pre><code class="java">enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        Season season = Season.valueOf(&quot;SPRING&quot;);        System.out.println(season);    &#125;&#125;</code></pre><h4 id="枚举类的特性"><a href="#枚举类的特性" class="headerlink" title="枚举类的特性"></a>枚举类的特性</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>枚举类可以有构造函数，但构造函数必须是私有的，以确保枚举常量的唯一性。可以为枚举常量添加属性和方法。</p><pre><code class="java">enum Season &#123;    SPRING(&quot;春天&quot;), SUMMER(&quot;夏天&quot;), AUTUMN(&quot;秋天&quot;), WINTER(&quot;冬天&quot;);    private String description;    // 私有构造函数    private Season(String description) &#123;        this.description = description;    &#125;    public String getDescription() &#123;        return description;    &#125;&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        for (Season season : Season.values()) &#123;            System.out.println(season + &quot;: &quot; + season.getDescription());        &#125;    &#125;&#125;</code></pre><h5 id="实现接口-1"><a href="#实现接口-1" class="headerlink" title="实现接口"></a>实现接口</h5><p>枚举类可以实现接口，为每个枚举常量提供不同的实现。</p><pre><code class="java">interface SeasonActivity &#123;    void activity();&#125;enum Season implements SeasonActivity &#123;    SPRING &#123;        @Override        public void activity() &#123;            System.out.println(&quot;春天适合踏青&quot;);        &#125;    &#125;,    SUMMER &#123;        @Override        public void activity() &#123;            System.out.println(&quot;夏天适合游泳&quot;);        &#125;    &#125;,    AUTUMN &#123;        @Override        public void activity() &#123;            System.out.println(&quot;秋天适合赏菊&quot;);        &#125;    &#125;,    WINTER &#123;        @Override        public void activity() &#123;            System.out.println(&quot;冬天适合滑雪&quot;);        &#125;    &#125;;&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        for (Season season : Season.values()) &#123;            season.activity();        &#125;    &#125;&#125;</code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h5><p>在程序中，经常需要表示一些固定的状态，如订单状态（未支付、已支付、已发货等）、用户状态（正常、冻结、注销等），使用枚举类可以使代码更加清晰。</p><pre><code class="java">enum OrderStatus &#123;    UNPAID, PAID, SHIPPED, DELIVERED&#125;public class Order &#123;    private OrderStatus status;    public Order(OrderStatus status) &#123;        this.status = status;    &#125;    public OrderStatus getStatus() &#123;        return status;    &#125;    public static void main(String[] args) &#123;        Order order = new Order(OrderStatus.PAID);        System.out.println(&quot;订单状态: &quot; + order.getStatus());    &#125;&#125;</code></pre><h5 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h5><p>当需要定义一组固定的配置选项时，枚举类也是一个很好的选择，如颜色选项、文件格式等。</p><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>枚举常量默认是 <code>public static final</code> 的，并且是单例的，在整个程序中只有一个实例。</li><li>枚举类不能被继承，但可以实现接口。</li><li>枚举类的 <code>values()</code>、<code>valueOf()</code> 等方法是编译器自动添加的，它们是 <code>java.lang.Enum</code> 类的子类的方法。</li></ul><h4 id="枚举类的相关方法"><a href="#枚举类的相关方法" class="headerlink" title="枚举类的相关方法"></a>枚举类的相关方法</h4><p><img src="/../images/java/1741513183213.png" alt="1741513183213"></p><ol start="2"><li>values()&#96;方法</li></ol><ul><li><strong>作用</strong>：这是编译器为枚举类自动生成的方法，它返回一个包含该枚举类所有枚举常量的数组，数组中元素的顺序就是枚举常量在枚举类中声明的顺序。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        Color[] colors = Color.values();        for (Color color : colors) &#123;            System.out.println(color);        &#125;    &#125;&#125;</code></pre><ol start="3"><li><code>valueOf()</code>方法</li></ol><ul><li><strong>作用</strong>：根据给定的字符串名称返回对应的枚举常量。字符串必须与枚举常量的名称完全匹配（包括大小写），否则会抛出<code>IllegalArgumentException</code>异常。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        Color color = Color.valueOf(&quot;RED&quot;);        System.out.println(color);    &#125;&#125;</code></pre><ol start="4"><li><code>ordinal()</code>方法</li></ol><ul><li><strong>作用</strong>：返回枚举常量在枚举类中的声明顺序，从 0 开始计数。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(Color.RED.ordinal());         System.out.println(Color.GREEN.ordinal());         System.out.println(Color.BLUE.ordinal());     &#125;&#125;</code></pre><ol start="6"><li><code>compareTo()</code>方法</li></ol><ul><li><strong>作用</strong>：用于比较两个枚举常量的顺序。它基于枚举常量的<code>ordinal</code>值进行比较，如果当前枚举常量的<code>ordinal</code>值小于参数枚举常量的<code>ordinal</code>值，则返回负整数；如果相等，则返回 0；如果大于，则返回正整数。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(Color.RED.compareTo(Color.GREEN));         System.out.println(Color.GREEN.compareTo(Color.GREEN));         System.out.println(Color.BLUE.compareTo(Color.GREEN));     &#125;&#125;</code></pre><ol start="7"><li><code>name()</code>方法</li></ol><ul><li><strong>作用</strong>：返回枚举常量的名称，与在枚举类中声明的名称一致。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(Color.RED.name());     &#125;&#125;</code></pre><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><img src="/../images/java/1741513669438.png" alt="1741513669438"></p><h4 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h4><p>使用 <code>@interface</code> 关键字来定义注解，注解的定义类似于接口的定义。示例如下：</p><pre><code class="java">// 定义一个简单的注解public @interface MyAnnotation &#123;    // 定义注解的属性    String value() default &quot;&quot;;    int count() default 0;&#125;</code></pre><p>在上述代码中，<code>MyAnnotation</code> 是一个自定义注解，它包含两个属性：<code>value</code> 和 <code>count</code>，并分别为它们设置了默认值。</p><h4 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h4><p>Java 提供了一些内置注解，用于在不同场景下提供特定的元数据信息。</p><ul><li>**<code>@Override</code>**：用于标记一个方法是重写父类的方法。编译器会检查该方法是否真的重写了父类的方法，如果没有则会报错。</li></ul><pre><code class="java">class Parent &#123;    public void display() &#123;        System.out.println(&quot;父类的方法&quot;);    &#125;&#125;class Child extends Parent &#123;    @Override    public void display() &#123;        System.out.println(&quot;子类重写的方法&quot;);    &#125;&#125;</code></pre><ul><li>**<code>@Deprecated</code>**：用于标记一个类、方法或字段已经过时，不建议再使用。编译器会在使用这些元素时给出警告。</li></ul><pre><code class="java">class MyClass &#123;    @Deprecated    public void oldMethod() &#123;        System.out.println(&quot;这是一个过时的方法&quot;);    &#125;&#125;</code></pre><ul><li>**<code>@SuppressWarnings</code>**：用于抑制编译器的警告信息。可以指定要抑制的警告类型，如 <code>unchecked</code>、<code>deprecation</code> 等。</li></ul><pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)public void test() &#123;    java.util.List list = new java.util.ArrayList();    // 这里不会出现未检查类型转换的警告&#125;</code></pre><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>自定义注解可以根据具体需求定义属性和使用规则。</p><pre><code class="java">// 定义一个自定义注解public @interface MyAnnotation &#123;    String value() default &quot;&quot;;    int count() default 0;&#125;// 使用自定义注解@MyAnnotation(value = &quot;测试注解&quot;, count = 5)public class MyClass &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;使用自定义注解的类&quot;);    &#125;&#125;</code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="/../images/java/1741515069168.png" alt="1741515069168"></p><p><img src="/../images/java/1741515612811.png" alt="1741515612811"></p><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a><code>try-catch-finally</code></h4><p><img src="/../images/java/1741515823233.png" alt="1741515823233"></p><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p><code>try-catch</code> 语句块的基本语法如下：</p><pre><code class="java">try &#123;    // 可能会抛出异常的代码&#125; catch (ExceptionType1 e1) &#123;    // 处理 ExceptionType1 类型异常的代码&#125; catch (ExceptionType2 e2) &#123;    // 处理 ExceptionType2 类型异常的代码&#125; </code></pre><p>其中，<code>try</code> 块中放置可能会抛出异常的代码，<code>catch</code> 块用于捕获并处理特定类型的异常。每个 <code>catch</code> 块可以捕获一种特定类型的异常，当 <code>try</code> 块中的代码抛出异常时，会依次检查各个 <code>catch</code> 块，找到匹配的异常类型并执行相应的处理代码。</p><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><p>下面通过一个简单的示例来展示 <code>try-catch</code> 语句块的执行流程：</p><pre><code class="java">public class TryCatchExample &#123;    public static void main(String[] args) &#123;        try &#123;            int result = 10 / 0; // 这行代码会抛出 ArithmeticException 异常            System.out.println(&quot;结果: &quot; + result);        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;捕获到算术异常: &quot; + e.getMessage());        &#125;        System.out.println(&quot;程序继续执行&quot;);    &#125;&#125;</code></pre><p>在上述代码中，<code>try</code> 块中的 <code>10 / 0</code> 会抛出 <code>ArithmeticException</code> 异常，此时程序会立即跳转到对应的 <code>catch</code> 块中执行异常处理代码，输出异常信息。然后程序会继续执行 <code>catch</code> 块之后的代码，输出 “程序继续执行”。</p><h5 id="多-catch-块"><a href="#多-catch-块" class="headerlink" title="多 catch 块"></a>多 <code>catch</code> 块</h5><p>可以使用多个 <code>catch</code> 块来捕获不同类型的异常，按照异常类型的顺序依次进行匹配。需要注意的是，子类异常的 <code>catch</code> 块要放在父类异常的 <code>catch</code> 块之前，否则子类异常将无法被捕获。</p><pre><code class="java">public class MultipleCatchExample &#123;    public static void main(String[] args) &#123;        try &#123;            int[] arr = new int[5];            System.out.println(arr[10]); // 这行代码会抛出 ArrayIndexOutOfBoundsException 异常            int result = 10 / 0; // 这行代码不会执行，因为前面已经抛出异常        &#125; catch (ArrayIndexOutOfBoundsException e) &#123;            System.out.println(&quot;捕获到数组越界异常: &quot; + e.getMessage());        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;捕获到算术异常: &quot; + e.getMessage());        &#125; catch (Exception e) &#123;            System.out.println(&quot;捕获到其他异常: &quot; + e.getMessage());        &#125;        System.out.println(&quot;程序继续执行&quot;);    &#125;&#125;</code></pre><p>在上述代码中，<code>try</code> 块中的 <code>arr[10]</code> 会抛出 <code>ArrayIndexOutOfBoundsException</code> 异常，程序会跳转到对应的 <code>catch</code> 块中执行异常处理代码。由于异常已经被捕获，后面的 <code>10 / 0</code> 代码不会执行。</p><h5 id="finally-块"><a href="#finally-块" class="headerlink" title="finally 块"></a><code>finally</code> 块</h5><p><code>finally</code> 块是可选的，它通常跟在 <code>try-catch</code> 语句块之后，无论 <code>try</code> 块中的代码是否抛出异常，<code>finally</code> 块中的代码都会被执行。</p><pre><code class="java">public class FinallyExample &#123;    public static void main(String[] args) &#123;        try &#123;            int result = 10 / 0; // 这行代码会抛出 ArithmeticException 异常            System.out.println(&quot;结果: &quot; + result);        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;捕获到算术异常: &quot; + e.getMessage());        &#125; finally &#123;            System.out.println(&quot;finally 块中的代码一定会执行&quot;);        &#125;        System.out.println(&quot;程序继续执行&quot;);    &#125;&#125;</code></pre><p>在上述代码中，<code>try</code> 块中的 <code>10 / 0</code> 会抛出 <code>ArithmeticException</code> 异常，程序会跳转到 <code>catch</code> 块中执行异常处理代码，然后执行 <code>finally</code> 块中的代码，最后继续执行 <code>finally</code> 块之后的代码。</p><h5 id="异常处理的注意事项"><a href="#异常处理的注意事项" class="headerlink" title="异常处理的注意事项"></a>异常处理的注意事项</h5><ul><li><strong>异常类型匹配</strong>：<code>catch</code> 块中的异常类型要与 <code>try</code> 块中可能抛出的异常类型相匹配，确保能够捕获到相应的异常。</li><li><strong>子类异常在前</strong>：在使用多个 <code>catch</code> 块时，子类异常的 <code>catch</code> 块要放在父类异常的 <code>catch</code> 块之前，避免子类异常被父类异常的 <code>catch</code> 块捕获。</li><li><strong><code>finally</code> 块的使用</strong>：<code>finally</code> 块通常用于释放资源，如关闭文件、数据库连接等，确保资源在任何情况下都能被正确释放。</li></ul><h4 id="throws-与-throw"><a href="#throws-与-throw" class="headerlink" title="throws 与 throw"></a><code>throws</code> 与 <code>throw</code></h4><p><img src="/../images/java/1741516755212.png" alt="1741516755212"></p><h5 id="throws-关键字"><a href="#throws-关键字" class="headerlink" title="throws 关键字"></a>throws 关键字</h5><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><p><code>throws</code> 关键字用于方法声明处，用于声明该方法可能会抛出的异常类型。它告知调用者，这个方法在执行过程中可能会产生某些异常，调用者需要对这些异常进行处理或者继续向上抛出。</p><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><pre><code class="java">修饰符 返回值类型 方法名(参数列表) throws 异常类型1, 异常类型2, ... &#123;    // 方法体&#125;</code></pre><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><pre><code class="java">import java.io.FileInputStream;import java.io.FileNotFoundException;public class ThrowsExample &#123;    // 声明该方法可能会抛出 FileNotFoundException 异常    public void readFile() throws FileNotFoundException &#123;        // 尝试打开一个文件，如果文件不存在会抛出 FileNotFoundException 异常        FileInputStream fis = new FileInputStream(&quot;nonexistentfile.txt&quot;);    &#125;    public static void main(String[] args) &#123;        ThrowsExample example = new ThrowsExample();        try &#123;            example.readFile();        &#125; catch (FileNotFoundException e) &#123;            System.out.println(&quot;文件未找到: &quot; + e.getMessage());        &#125;    &#125;&#125;</code></pre><p>在上述示例中，<code>readFile</code> 方法使用 <code>throws</code> 关键字声明可能会抛出 <code>FileNotFoundException</code> 异常。在 <code>main</code> 方法中调用 <code>readFile</code> 方法时，需要使用 <code>try-catch</code> 语句块来捕获并处理该异常。</p><h6 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li><code>throws</code> 后面可以跟多个异常类型，多个异常类型之间用逗号分隔。</li><li>如果一个方法声明了可能会抛出某个异常，但实际上该方法内部并没有抛出该异常，也是合法的。</li><li>子类重写父类的方法时，如果父类方法声明了某些异常，子类方法可以不声明这些异常，也可以声明父类方法声明的异常的子类异常，但不能声明比父类方法声明的异常范围更大的异常。</li></ul><h5 id="throw-关键字"><a href="#throw-关键字" class="headerlink" title="throw 关键字"></a>throw 关键字</h5><h6 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h6><p><code>throw</code> 关键字用于在方法内部手动抛出一个异常对象。当程序执行到 <code>throw</code> 语句时，会立即停止当前方法的执行，并将异常对象抛出给调用者。</p><h6 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h6><pre><code class="java">throw 异常对象;</code></pre><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><pre><code class="java">public class ThrowExample &#123;    public void checkAge(int age) &#123;        if (age &lt; 0) &#123;            // 手动抛出 IllegalArgumentException 异常            throw new IllegalArgumentException(&quot;年龄不能为负数&quot;);        &#125;        System.out.println(&quot;年龄合法: &quot; + age);    &#125;    public static void main(String[] args) &#123;        ThrowExample example = new ThrowExample();        try &#123;            example.checkAge(-5);        &#125; catch (IllegalArgumentException e) &#123;            System.out.println(&quot;捕获到异常: &quot; + e.getMessage());        &#125;    &#125;&#125;</code></pre><p>在上述示例中，<code>checkAge</code> 方法内部检查传入的 <code>age</code> 参数，如果 <code>age</code> 小于 0，则使用 <code>throw</code> 关键字手动抛出一个 <code>IllegalArgumentException</code> 异常。在 <code>main</code> 方法中调用 <code>checkAge</code> 方法时，使用 <code>try-catch</code> 语句块来捕获并处理该异常。</p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>Java 提供了 8 种基本数据类型，对应有 8 个包装类，具体如下：</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>Byte</code></td></tr><tr><td><code>short</code></td><td><code>Short</code></td></tr><tr><td><code>int</code></td><td><code>Integer</code></td></tr><tr><td><code>long</code></td><td><code>Long</code></td></tr><tr><td><code>float</code></td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td><code>Double</code></td></tr><tr><td><code>char</code></td><td><code>Character</code></td></tr><tr><td><code>boolean</code></td><td><code>Boolean</code></td></tr></tbody></table><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><ul><li><strong>自动装箱</strong>：将基本数据类型自动转换为对应的包装类对象。例如，将 <code>int</code> 类型的值赋给 <code>Integer</code> 类型的变量时，会自动进行装箱操作。</li></ul><pre><code class="java">int num = 10;Integer integerObj = num; // 自动装箱</code></pre><ul><li><strong>自动拆箱</strong>：将包装类对象自动转换为对应的基本数据类型。例如，将 <code>Integer</code> 类型的对象赋给 <code>int</code> 类型的变量时，会自动进行拆箱操作。</li></ul><pre><code class="java">Integer integerObj = 20;int num = integerObj; // 自动拆箱</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>不同的包装类提供了一些常用的方法，以下以 <code>Integer</code> 类为例进行介绍：</p><ul><li><strong><code>valueOf()</code> 方法</strong>：用于将基本数据类型或字符串转换为包装类对象。</li></ul><pre><code class="java">Integer intObj1 = Integer.valueOf(30);Integer intObj2 = Integer.valueOf(&quot;40&quot;);</code></pre><ul><li><strong><code>parseInt()</code> 方法</strong>：用于将字符串转换为 <code>int</code> 类型。</li></ul><pre><code class="java">int num = Integer.parseInt(&quot;50&quot;);</code></pre><ul><li><strong><code>toString()</code> 方法</strong>：用于将包装类对象转换为字符串。</li></ul><pre><code class="java">Integer intObj = 60;String str = intObj.toString();</code></pre><ul><li><strong><code>compareTo()</code> 方法</strong>：用于比较两个包装类对象的大小。</li></ul><pre><code class="java">Integer intObj1 = 70;Integer intObj2 = 80;int result = intObj1.compareTo(intObj2);if (result &lt; 0) &#123;    System.out.println(&quot;intObj1 小于 intObj2&quot;);&#125; else if (result == 0) &#123;    System.out.println(&quot;intObj1 等于 intObj2&quot;);&#125; else &#123;    System.out.println(&quot;intObj1 大于 intObj2&quot;);&#125;</code></pre><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>部分包装类（如 <code>Integer</code>、<code>Byte</code>、<code>Short</code>、<code>Long</code>、<code>Character</code>）存在缓存机制，对于一些常用的值，会将其对应的包装类对象缓存起来，当再次使用相同的值时，会直接从缓存中获取对象，而不是重新创建。</p><pre><code class="java">Integer a = 10;Integer b = 10;System.out.println(a == b); // 输出 true，因为使用了缓存Integer c = 128;Integer d = 128;System.out.println(c == d); // 输出 false，超出了缓存范围</code></pre><p><code>Integer</code> 类的缓存范围是 -128 到 127，不同的包装类缓存范围可能不同。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><img src="/../images/java/1741527233539.png" alt="1741527233539"></p><h4 id="1-String-类的创建"><a href="#1-String-类的创建" class="headerlink" title="1. String 类的创建"></a>1. <code>String</code> 类的创建</h4><p>在 Java 中创建 <code>String</code> 对象有多种方式，常见的如下：</p><h5 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h5><pre><code class="java">String str1 = &quot;Hello&quot;;</code></pre><p>这种方式会先检查字符串常量池中是否已经存在 <code>&quot;Hello&quot;</code> 这个字符串，如果存在则直接引用该字符串，若不存在则在常量池中创建该字符串对象。</p><h5 id="使用-new-关键字"><a href="#使用-new-关键字" class="headerlink" title="使用 new 关键字"></a>使用 <code>new</code> 关键字</h5><pre><code class="java">String str2 = new String(&quot;World&quot;);</code></pre><p>使用 <code>new</code> 关键字会在堆内存中创建一个新的 <code>String</code> 对象，即使字符串常量池中已经存在相同内容的字符串。</p><h4 id="2-String-类的不可变性"><a href="#2-String-类的不可变性" class="headerlink" title="2. String 类的不可变性"></a>2. <code>String</code> 类的不可变性</h4><p><code>String</code> 类的对象是不可变的，这意味着一旦一个 <code>String</code> 对象被创建，它的内容就不能被修改。例如：</p><pre><code class="java">String str = &quot;Java&quot;;str = str + &quot; Programming&quot;;</code></pre><p>这里看似 <code>str</code> 的内容发生了改变，但实际上是创建了一个新的 <code>String</code> 对象 <code>&quot;Java Programming&quot;</code>，并让 <code>str</code> 引用这个新对象，原来的 <code>&quot;Java&quot;</code> 对象依然存在于内存中。</p><p><code>String</code> 类不可变的好处主要有安全性、线程安全、可以作为哈希表的键等。</p><h4 id="3-String-类的常用方法"><a href="#3-String-类的常用方法" class="headerlink" title="3. String 类的常用方法"></a>3. <code>String</code> 类的常用方法</h4><h5 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h5><pre><code class="java">String str = &quot;Example&quot;;int length = str.length(); // 返回 7</code></pre><h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h5><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = &quot; World&quot;;String result = str1.concat(str2); // 结果为 &quot;Hello World&quot;</code></pre><h5 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h5><pre><code class="java">String str = &quot;Java Programming&quot;;int index = str.indexOf(&quot;Programming&quot;); // 返回 5</code></pre><h5 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h5><pre><code class="java">String str = &quot;Java Programming&quot;;String subStr = str.substring(5); // 结果为 &quot;Programming&quot;String subStr2 = str.substring(5, 10); // 结果为 &quot;Progr&quot;</code></pre><h5 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h5><pre><code class="java">String str = &quot;Java Programming&quot;;String newStr = str.replace(&quot;Java&quot;, &quot;Python&quot;); // 结果为 &quot;Python Programming&quot;</code></pre><h5 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h5><pre><code class="java">String str = &quot;Hello&quot;;String upperCase = str.toUpperCase(); // 结果为 &quot;HELLO&quot;String lowerCase = str.toLowerCase(); // 结果为 &quot;hello&quot;</code></pre><h5 id="去除字符串首尾空格"><a href="#去除字符串首尾空格" class="headerlink" title="去除字符串首尾空格"></a>去除字符串首尾空格</h5><pre><code class="java">String str = &quot;  Hello  &quot;;String trimmedStr = str.trim(); // 结果为 &quot;Hello&quot;</code></pre><h5 id="getBytes-方法"><a href="#getBytes-方法" class="headerlink" title="getBytes() 方法"></a><code>getBytes()</code> 方法</h5><h6 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h6><p><code>getBytes()</code> 方法有两个重载形式：</p><ul><li><code>public byte[] getBytes()</code>：使用平台的默认字符编码将字符串编码为字节序列，并将结果存储到一个新的字节数组中。</li><li><code>public byte[] getBytes(String charsetName)</code>：使用指定的字符编码将字符串编码为字节序列，并将结果存储到一个新的字节数组中。如果指定的字符编码不支持，会抛出 <code>UnsupportedEncodingException</code> 异常。</li></ul><h6 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h6><pre><code class="java">import java.io.UnsupportedEncodingException;public class GetBytesExample &#123;    public static void main(String[] args) &#123;        String str = &quot;Hello, 世界!&quot;;        // 使用平台默认编码        byte[] defaultBytes = str.getBytes();        System.out.println(&quot;默认编码后的字节数组长度: &quot; + defaultBytes.length);        try &#123;            // 使用 UTF-8 编码            byte[] utf8Bytes = str.getBytes(&quot;UTF-8&quot;);            System.out.println(&quot;UTF-8 编码后的字节数组长度: &quot; + utf8Bytes.length);            // 使用 GBK 编码            byte[] gbkBytes = str.getBytes(&quot;GBK&quot;);            System.out.println(&quot;GBK 编码后的字节数组长度: &quot; + gbkBytes.length);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h6 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h6><ul><li><code>str.getBytes()</code>：使用平台的默认字符编码对字符串 <code>str</code> 进行编码，返回一个字节数组。</li><li><code>str.getBytes(&quot;UTF-8&quot;)</code>：使用 UTF - 8 字符编码对字符串 <code>str</code> 进行编码，返回一个字节数组。</li><li><code>str.getBytes(&quot;GBK&quot;)</code>：使用 GBK 字符编码对字符串 <code>str</code> 进行编码，返回一个字节数组。</li></ul><h5 id="String-byte-bytes-String-charsetName-构造函数"><a href="#String-byte-bytes-String-charsetName-构造函数" class="headerlink" title="String(byte[] bytes, String charsetName) 构造函数"></a><code>String(byte[] bytes, String charsetName)</code> 构造函数</h5><h6 id="构造函数概述"><a href="#构造函数概述" class="headerlink" title="构造函数概述"></a>构造函数概述</h6><p>该构造函数用于通过指定的字符编码将字节数组解码为字符串。如果指定的字符编码不支持，会抛出 <code>UnsupportedEncodingException</code> 异常。</p><h6 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h6><pre><code class="java">import java.io.UnsupportedEncodingException;public class StringConstructorExample &#123;    public static void main(String[] args) &#123;        String originalStr = &quot;Hello, 世界!&quot;;        try &#123;            // 使用 UTF-8 编码将字符串转换为字节数组            byte[] utf8Bytes = originalStr.getBytes(&quot;UTF-8&quot;);            // 使用 UTF-8 编码将字节数组解码为字符串            String decodedStr = new String(utf8Bytes, &quot;UTF-8&quot;);            System.out.println(&quot;解码后的字符串: &quot; + decodedStr);            // 使用错误的编码进行解码（会导致乱码）            String wrongDecodedStr = new String(utf8Bytes, &quot;GBK&quot;);            System.out.println(&quot;使用错误编码解码后的字符串: &quot; + wrongDecodedStr);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h6 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h6><ul><li><code>new String(utf8Bytes, &quot;UTF-8&quot;)</code>：使用 UTF - 8 字符编码将字节数组 <code>utf8Bytes</code> 解码为字符串。由于编码和解码使用的是相同的字符编码，所以解码后的字符串与原始字符串相同。</li><li><code>new String(utf8Bytes, &quot;GBK&quot;)</code>：使用 GBK 字符编码将字节数组 <code>utf8Bytes</code> 解码为字符串。由于编码使用的是 UTF - 8，解码使用的是 GBK，编码和解码使用的字符编码不一致，所以解码后的字符串会出现乱码。</li></ul><h4 id="4-字符串拼接"><a href="#4-字符串拼接" class="headerlink" title="4. 字符串拼接"></a>4. 字符串拼接</h4><p>除了使用 <code>concat</code> 方法进行字符串拼接外，还可以使用 <code>+</code> 运算符：</p><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = &quot; World&quot;;String result = str1 + str2; // 结果为 &quot;Hello World&quot;</code></pre><p>在 Java 中，当使用 <code>+</code> 运算符进行字符串拼接时，如果其中一个操作数是字符串，那么其他操作数会自动转换为字符串类型。不过在大量拼接字符串时，使用 <code>+</code> 运算符会产生较多临时对象，性能较低，此时建议使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 类。</p><h4 id="5-字符串比较"><a href="#5-字符串比较" class="headerlink" title="5. 字符串比较"></a>5. 字符串比较</h4><h5 id="使用-比较"><a href="#使用-比较" class="headerlink" title="使用 == 比较"></a>使用 <code>==</code> 比较</h5><p><code>==</code> 比较的是两个字符串对象的引用是否相等，即是否指向同一个内存地址。</p><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = &quot;Hello&quot;;String str3 = new String(&quot;Hello&quot;);System.out.println(str1 == str2); // 输出 true，因为它们引用常量池中的同一个对象System.out.println(str1 == str3); // 输出 false，因为 str3 在堆内存中是新对象</code></pre><h5 id="使用-equals-方法比较"><a href="#使用-equals-方法比较" class="headerlink" title="使用 equals 方法比较"></a>使用 <code>equals</code> 方法比较</h5><p><code>equals</code> 方法比较的是两个字符串的内容是否相等。</p><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = new String(&quot;Hello&quot;);System.out.println(str1.equals(str2)); // 输出 true，因为内容相同</code></pre><h4 id="6-字符串分割"><a href="#6-字符串分割" class="headerlink" title="6. 字符串分割"></a>6. 字符串分割</h4><pre><code class="java">String str = &quot;Java,Python,C++&quot;;String[] parts = str.split(&quot;,&quot;);for (String part : parts) &#123;    System.out.println(part);&#125;</code></pre><p>上述代码将字符串按逗号进行分割，结果存储在字符串数组中。</p><h4 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h4><p><img src="/../images/java/1741698218188.png" alt="1741698218188"></p><h5 id="1-Java-字符串的内部表示"><a href="#1-Java-字符串的内部表示" class="headerlink" title="1. Java 字符串的内部表示"></a>1. Java 字符串的内部表示</h5><p>在 Java 中，<code>String</code> 类的对象在内存中是以 Unicode 编码形式存储的，Unicode 是一种字符编码标准，它为世界上几乎所有的字符都分配了一个唯一的数字代码，这使得 Java 能够处理各种语言的文本。</p><h5 id="2-编码与解码操作"><a href="#2-编码与解码操作" class="headerlink" title="2. 编码与解码操作"></a>2. 编码与解码操作</h5><h6 id="编码（将字符串转换为字节数组）"><a href="#编码（将字符串转换为字节数组）" class="headerlink" title="编码（将字符串转换为字节数组）"></a>编码（将字符串转换为字节数组）</h6><p>使用 <code>String</code> 类的 <code>getBytes()</code> 方法可以将字符串按照指定的字符编码转换为字节数组。如果不指定编码，默认使用平台的默认字符编码。</p><pre><code class="java">import java.io.UnsupportedEncodingException;public class StringEncodingExample &#123;    public static void main(String[] args) &#123;        String str = &quot;你好，世界！&quot;;        try &#123;            // 使用 UTF-8 编码将字符串转换为字节数组            byte[] utf8Bytes = str.getBytes(&quot;UTF-8&quot;);            System.out.println(&quot;UTF-8 编码后的字节数组长度: &quot; + utf8Bytes.length);            // 使用 GBK 编码将字符串转换为字节数组            byte[] gbkBytes = str.getBytes(&quot;GBK&quot;);            System.out.println(&quot;GBK 编码后的字节数组长度: &quot; + gbkBytes.length);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>在上述代码中，我们将字符串 <code>&quot;你好，世界！&quot;</code> 分别使用 UTF - 8 和 GBK 编码转换为字节数组，并输出字节数组的长度。由于不同的编码方案对字符的编码方式不同，所以得到的字节数组长度可能不同。</p><h6 id="解码（将字节数组转换为字符串）"><a href="#解码（将字节数组转换为字符串）" class="headerlink" title="解码（将字节数组转换为字符串）"></a>解码（将字节数组转换为字符串）</h6><p>使用 <code>String</code> 类的构造函数可以将字节数组按照指定的字符编码转换为字符串。</p><pre><code class="java">import java.io.UnsupportedEncodingException;public class StringDecodingExample &#123;    public static void main(String[] args) &#123;        String str = &quot;你好，世界！&quot;;        try &#123;            // 使用 UTF-8 编码将字符串转换为字节数组            byte[] utf8Bytes = str.getBytes(&quot;UTF-8&quot;);            // 使用 UTF-8 编码将字节数组解码为字符串            String decodedStr = new String(utf8Bytes, &quot;UTF-8&quot;);            System.out.println(&quot;解码后的字符串: &quot; + decodedStr);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>在上述代码中，我们先将字符串使用 UTF - 8 编码转换为字节数组，然后再使用相同的编码将字节数组解码为字符串，并输出解码后的字符串。</p><h5 id="3-常见的字符编码"><a href="#3-常见的字符编码" class="headerlink" title="3. 常见的字符编码"></a>3. 常见的字符编码</h5><h6 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF - 8"></a>UTF - 8</h6><p>UTF - 8 是一种可变长度的 Unicode 编码，它使用 1 到 4 个字节来表示一个字符。对于 ASCII 字符（即 Unicode 编码范围在 0 - 127 之间的字符），UTF - 8 只使用 1 个字节，与 ASCII 编码兼容。对于大多数常用的汉字，UTF - 8 使用 3 个字节表示。UTF - 8 是互联网上最常用的字符编码，因为它能够处理各种语言的文本，并且对于英文文本的存储效率较高。</p><h6 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h6><p>GBK 是中国国家标准的中文字符编码，它是对 GB2312 编码的扩展，能够表示 21003 个汉字和图形符号。GBK 使用 2 个字节来表示一个汉字，对于 ASCII 字符，GBK 同样只使用 1 个字节。GBK 主要用于中文操作系统和中文文本处理。</p><h6 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO - 8859 - 1"></a>ISO - 8859 - 1</h6><p>ISO - 8859 - 1 是一种单字节编码，它只能表示 256 个字符，主要用于西欧语言。ISO - 8859 - 1 是 Java 中默认的字符编码之一，但它不能表示中文等非西欧语言的字符。</p><h5 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h5><ul><li><strong>编码一致性</strong>：在进行编码和解码操作时，必须确保使用相同的字符编码，否则会导致乱码问题。例如，如果使用 UTF - 8 编码将字符串转换为字节数组，那么在解码时也必须使用 UTF - 8 编码。</li><li><strong>异常处理</strong>：在使用 <code>getBytes()</code> 方法和 <code>String</code> 构造函数时，可能会抛出 <code>UnsupportedEncodingException</code> 异常，因此需要进行异常处理。</li></ul><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p><img src="/../images/java/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-11%20214218.png"></p><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><code>StringBuffer</code> 是一个线程安全的可变字符序列。它继承自 <code>AbstractStringBuilder</code> 类，与 <code>String</code> 不同，<code>StringBuffer</code> 对象的内容可以被动态修改，不会像 <code>String</code> 那样每次修改都创建新的对象，从而避免了频繁创建对象带来的性能开销。</p><h5 id="创建-StringBuffer-对象"><a href="#创建-StringBuffer-对象" class="headerlink" title="创建 StringBuffer 对象"></a>创建 <code>StringBuffer</code> 对象</h5><p>可以通过以下几种方式创建 <code>StringBuffer</code> 对象：</p><pre><code class="java">// 1. 创建一个空的 StringBuffer 对象StringBuffer sb1 = new StringBuffer();// 2. 创建一个初始容量为 20 的 StringBuffer 对象StringBuffer sb2 = new StringBuffer(20);// 3. 使用指定的字符串初始化 StringBuffer 对象StringBuffer sb3 = new StringBuffer(&quot;Hello&quot;);</code></pre><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="1-append-方法"><a href="#1-append-方法" class="headerlink" title="1. append() 方法"></a>1. <code>append()</code> 方法</h6><p>用于将各种类型的数据追加到 <code>StringBuffer</code> 的末尾。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.append(&quot; World&quot;); // 追加字符串sb.append(123); // 追加整数System.out.println(sb); // 输出: Hello World123</code></pre><h6 id="2-insert-方法"><a href="#2-insert-方法" class="headerlink" title="2. insert() 方法"></a>2. <code>insert()</code> 方法</h6><p>用于在指定位置插入各种类型的数据。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.insert(2, &quot;abc&quot;); // 在索引为 2 的位置插入字符串System.out.println(sb); // 输出: Heabcllo</code></pre><h6 id="3-delete-方法"><a href="#3-delete-方法" class="headerlink" title="3. delete() 方法"></a>3. <code>delete()</code> 方法</h6><p>用于删除指定范围内的字符。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello World&quot;);sb.delete(6, 11); // 删除索引从 6 到 10 的字符System.out.println(sb); // 输出: Hello</code></pre><h6 id="4-replace-方法"><a href="#4-replace-方法" class="headerlink" title="4. replace() 方法"></a>4. <code>replace()</code> 方法</h6><p>用于替换指定范围内的字符。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.replace(1, 4, &quot;abc&quot;); // 替换索引从 1 到 3 的字符System.out.println(sb); // 输出: Habco</code></pre><h6 id="5-reverse-方法"><a href="#5-reverse-方法" class="headerlink" title="5. reverse() 方法"></a>5. <code>reverse()</code> 方法</h6><p>用于反转 <code>StringBuffer</code> 中的字符序列。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.reverse();System.out.println(sb); // 输出: olleH</code></pre><h6 id="6-toString-方法"><a href="#6-toString-方法" class="headerlink" title="6. toString() 方法"></a>6. <code>toString()</code> 方法</h6><p>将 <code>StringBuffer</code> 对象转换为 <code>String</code> 对象。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);String str = sb.toString();System.out.println(str); // 输出: Hello</code></pre><h5 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h5><p><code>StringBuffer</code> 是线程安全的，这意味着在多线程环境下可以安全地使用它。它的大部分方法都使用了 <code>synchronized</code> 关键字进行同步，确保在同一时间只有一个线程可以修改 <code>StringBuffer</code> 的内容。</p><h5 id="与-StringBuilder-的比较"><a href="#与-StringBuilder-的比较" class="headerlink" title="与 StringBuilder 的比较"></a>与 <code>StringBuilder</code> 的比较</h5><p><code>StringBuilder</code> 也是一个可变的字符序列类，它与 <code>StringBuffer</code> 的功能非常相似，但 <code>StringBuilder</code> 是非线程安全的。在单线程环境下，由于不需要进行同步操作，<code>StringBuilder</code> 的性能通常比 <code>StringBuffer</code> 要好。因此，如果是在单线程环境中进行字符串的频繁修改，建议使用 <code>StringBuilder</code>；如果是在多线程环境中，为了保证线程安全，应该使用 <code>StringBuffer</code>。</p><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p><img src="/../images/java/1741702404265.png" alt="1741702404265"></p><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p><img src="/../images/java/1741702461774.png" alt="1741702461774"></p><h4 id="1-对基本数据类型数组排序"><a href="#1-对基本数据类型数组排序" class="headerlink" title="1. 对基本数据类型数组排序"></a>1. 对基本数据类型数组排序</h4><p><code>Arrays.sort()</code> 可以对基本数据类型的数组进行排序，如 <code>int</code>、<code>double</code>、<code>char</code> 等。排序是按照升序进行的，使用的是双轴快速排序（Dual-Pivot Quicksort）算法，对于小规模数组会使用插入排序。</p><p><strong>示例代码</strong></p><pre><code class="java">import java.util.Arrays;public class BasicArraySorting &#123;    public static void main(String[] args) &#123;        // 对 int 数组排序        int[] intArray = &#123;5, 3, 8, 1, 2&#125;;        Arrays.sort(intArray);        System.out.println(&quot;排序后的 int 数组: &quot; + Arrays.toString(intArray));        // 对 char 数组排序        char[] charArray = &#123;&#39;d&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;&#125;;        Arrays.sort(charArray);        System.out.println(&quot;排序后的 char 数组: &quot; + Arrays.toString(charArray));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li>对于 <code>int</code> 数组 <code>intArray</code>，调用 <code>Arrays.sort(intArray)</code> 后，数组元素会按升序排列。</li><li>对于 <code>char</code> 数组 <code>charArray</code>，同样调用 <code>Arrays.sort(charArray)</code> 进行升序排序。</li></ul><h4 id="2-对对象数组排序"><a href="#2-对对象数组排序" class="headerlink" title="2. 对对象数组排序"></a>2. 对对象数组排序</h4><p>当对对象数组进行排序时，数组中的元素类型必须实现 <code>java.lang.Comparable</code> 接口，或者在调用 <code>Arrays.sort()</code> 方法时传入一个 <code>java.util.Comparator</code> 对象来指定排序规则。</p><h5 id="2-1-实现-Comparable-接口"><a href="#2-1-实现-Comparable-接口" class="headerlink" title="2.1 实现 Comparable 接口"></a>2.1 实现 <code>Comparable</code> 接口</h5><p><code>Comparable</code> 接口有一个抽象方法 <code>compareTo()</code>，用于定义对象之间的比较规则。</p><pre><code class="java">import java.util.Arrays;class Student implements Comparable&lt;Student&gt; &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public int compareTo(Student other) &#123;        return Integer.compare(this.age, other.age);    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;name=&#39;&quot; + name + &quot;&#39;, age=&quot; + age + &quot;&#125;&quot;;    &#125;&#125;public class ObjectArraySortingComparable &#123;    public static void main(String[] args) &#123;        Student[] students = &#123;                new Student(&quot;Alice&quot;, 20),                new Student(&quot;Bob&quot;, 18),                new Student(&quot;Charlie&quot;, 22)        &#125;;        Arrays.sort(students);        System.out.println(&quot;按年龄排序后的学生数组: &quot; + Arrays.toString(students));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><code>Student</code> 类实现了 <code>Comparable</code> 接口，并重写了 <code>compareTo()</code> 方法，按照学生的年龄进行比较。</li><li>调用 <code>Arrays.sort(students)</code> 时，会根据 <code>compareTo()</code> 方法定义的规则对学生数组进行排序。</li></ul><h5 id="2-2-使用-Comparator-接口"><a href="#2-2-使用-Comparator-接口" class="headerlink" title="2.2 使用 Comparator 接口"></a>2.2 使用 <code>Comparator</code> 接口</h5><p>如果不想修改类的定义，或者需要临时定义不同的排序规则，可以使用 <code>Comparator</code> 接口。</p><pre><code class="java">import java.util.Arrays;import java.util.Comparator;class Person &#123;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;name=&#39;&quot; + name + &quot;&#39;, age=&quot; + age + &quot;&#125;&quot;;    &#125;&#125;public class ObjectArraySortingComparator &#123;    public static void main(String[] args) &#123;        Person[] persons = &#123;                new Person(&quot;Alice&quot;, 20),                new Person(&quot;Bob&quot;, 18),                new Person(&quot;Charlie&quot;, 22)        &#125;;        // 按年龄降序排序        Arrays.sort(persons, new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person p1, Person p2) &#123;                return Integer.compare(p2.age, p1.age);            &#125;        &#125;);        System.out.println(&quot;按年龄降序排序后的人员数组: &quot; + Arrays.toString(persons));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><code>Person</code> 类没有实现 <code>Comparable</code> 接口，在调用 <code>Arrays.sort()</code> 时传入了一个匿名的 <code>Comparator</code> 对象，重写了 <code>compare()</code> 方法，实现了按年龄降序排序。</li></ul><h4 id="3-对部分数组元素排序"><a href="#3-对部分数组元素排序" class="headerlink" title="3. 对部分数组元素排序"></a>3. 对部分数组元素排序</h4><p><code>Arrays.sort()</code> 还提供了对数组部分元素进行排序的重载方法，通过指定起始索引和结束索引来确定排序的范围。</p><pre><code class="java">import java.util.Arrays;public class PartialArraySorting &#123;    public static void main(String[] args) &#123;        int[] array = &#123;5, 3, 8, 1, 2, 7, 4, 6&#125;;        // 对索引从 1 到 4（不包括 4）的元素进行排序        Arrays.sort(array, 1, 4);        System.out.println(&quot;部分排序后的数组: &quot; + Arrays.toString(array));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><code>Arrays.sort(array, 1, 4)</code> 只对数组 <code>array</code> 中索引从 1 到 3 的元素进行排序，其他元素保持不变。</li></ul><h4 id="4-二分查找方法"><a href="#4-二分查找方法" class="headerlink" title="4. 二分查找方法"></a>4. 二分查找方法</h4><ul><li><code>binarySearch()</code>：在已排序的数组中使用二分查找算法查找指定元素，返回元素的索引，如果未找到则返回负数。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysBinarySearchExample &#123;    public static void main(String[] args) &#123;        int[] intArray = &#123;1, 2, 3, 5, 8&#125;;        int index = Arrays.binarySearch(intArray, 5);        System.out.println(&quot;元素 5 的索引是: &quot; + index);         // 输出: 元素 5 的索引是: 3    &#125;&#125;</code></pre><h4 id="5-数组填充方法"><a href="#5-数组填充方法" class="headerlink" title="5. 数组填充方法"></a>5. 数组填充方法</h4><ul><li><code>fill()</code>：用指定的值填充数组的所有元素或指定范围的元素。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysFillExample &#123;    public static void main(String[] args) &#123;        int[] intArray = new int[5];        Arrays.fill(intArray, 10);        System.out.println(Arrays.toString(intArray));         // 输出: [10, 10, 10, 10, 10]    &#125;&#125;</code></pre><h4 id="6-数组比较方法"><a href="#6-数组比较方法" class="headerlink" title="6. 数组比较方法"></a>6. 数组比较方法</h4><ul><li><code>equals()</code>：比较两个数组是否相等，会比较数组的长度和对应位置的元素。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysEqualsExample &#123;    public static void main(String[] args) &#123;        int[] array1 = &#123;1, 2, 3&#125;;        int[] array2 = &#123;1, 2, 3&#125;;        boolean isEqual = Arrays.equals(array1, array2);        System.out.println(&quot;两个数组是否相等: &quot; + isEqual);         // 输出: 两个数组是否相等: true    &#125;&#125;</code></pre><h4 id="7-数组转字符串方法"><a href="#7-数组转字符串方法" class="headerlink" title="7. 数组转字符串方法"></a>7. 数组转字符串方法</h4><ul><li><code>toString()</code>：返回数组的字符串表示形式，方便调试和输出。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysToStringExample &#123;    public static void main(String[] args) &#123;        int[] intArray = &#123;1, 2, 3&#125;;        String arrayString = Arrays.toString(intArray);        System.out.println(arrayString);         // 输出: [1, 2, 3]    &#125;&#125;</code></pre><h4 id="8-数组复制方法"><a href="#8-数组复制方法" class="headerlink" title="8.数组复制方法"></a>8.数组复制方法</h4><p><code>Arrays.copyOf</code> 有多个重载版本，常见的方法签名如下：</p><pre><code class="java">// 复制指定数组的指定长度部分到一个新数组中，元素类型为基本数据类型（以 int 为例）public static int[] copyOf(int[] original, int newLength)// 复制指定数组的指定长度部分到一个新数组中，元素类型为对象类型（以 String 为例）public static &lt;T&gt; T[] copyOf(T[] original, int newLength)</code></pre><ul><li><code>original</code>：要复制的原始数组。</li><li><code>newLength</code>：新数组的长度。</li><li>若 <code>newLength</code> 小于原始数组的长度，新数组将只包含原始数组的前 <code>newLength</code> 个元素；若 <code>newLength</code> 大于原始数组的长度，新数组中超出原始数组长度的部分会用对应类型的默认值填充（对于基本数据类型，如 <code>int</code> 是 0，<code>boolean</code> 是 <code>false</code>；对于对象类型是 <code>null</code>）。</li></ul><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p><img src="/../images/java/1741702473807.png" alt="1741702473807"></p><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><h5 id="1-System-in"><a href="#1-System-in" class="headerlink" title="1. System.in"></a>1. <code>System.in</code></h5><p>这是一个 <code>InputStream</code> 类型的静态属性，代表标准输入流，通常关联到键盘输入。在控制台程序中，可利用它从用户那里获取输入信息。</p><pre><code class="java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class SystemInExample &#123;    public static void main(String[] args) &#123;        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) &#123;            System.out.print(&quot;请输入一些内容: &quot;);            String input = reader.readLine();            System.out.println(&quot;你输入的内容是: &quot; + input);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h5 id="2-System-out"><a href="#2-System-out" class="headerlink" title="2. System.out"></a>2. <code>System.out</code></h5><p>它是一个 <code>PrintStream</code> 类型的静态属性，代表标准输出流，通常关联到控制台输出。借助它可以将信息输出到控制台。</p><pre><code class="java">public class SystemOutExample &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;这是一个输出示例。&quot;);    &#125;&#125;</code></pre><h5 id="3-System-err"><a href="#3-System-err" class="headerlink" title="3. System.err"></a>3. <code>System.err</code></h5><p>同样是 <code>PrintStream</code> 类型的静态属性，代表标准错误输出流，也关联到控制台。一般用于输出错误信息，与 <code>System.out</code> 不同的是，它输出的内容通常会以不同颜色显示（取决于控制台设置）。</p><pre><code class="java">public class SystemErrExample &#123;    public static void main(String[] args) &#123;        try &#123;            int result = 1 / 0;        &#125; catch (ArithmeticException e) &#123;            System.err.println(&quot;发生错误: &quot; + e.getMessage());        &#125;    &#125;&#125;</code></pre><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-System-currentTimeMillis"><a href="#1-System-currentTimeMillis" class="headerlink" title="1. System.currentTimeMillis()"></a>1. <code>System.currentTimeMillis()</code></h5><p>返回当前时间（从 1970 年 1 月 1 日 00:00:00 UTC 到现在的毫秒数），常用来计算代码的执行时间。</p><pre><code class="java">public class CurrentTimeMillisExample &#123;    public static void main(String[] args) &#123;        long startTime = System.currentTimeMillis();        // 模拟一段耗时操作        for (int i = 0; i &lt; 1000000; i++) &#123;            // 空循环        &#125;        long endTime = System.currentTimeMillis();        System.out.println(&quot;操作耗时: &quot; + (endTime - startTime) + &quot; 毫秒&quot;);    &#125;&#125;</code></pre><h5 id="2-System-arraycopy"><a href="#2-System-arraycopy" class="headerlink" title="2. System.arraycopy()"></a>2. <code>System.arraycopy()</code></h5><p>用于将一个数组的指定部分复制到另一个数组中，是一个高效的数组复制方法。</p><pre><code class="java">public class ArrayCopyExample &#123;    public static void main(String[] args) &#123;        int[] source = &#123;1, 2, 3, 4, 5&#125;;        int[] destination = new int[5];        System.arraycopy(source, 0, destination, 0, 5);        for (int num : destination) &#123;            System.out.print(num + &quot; &quot;);        &#125;    &#125;&#125;</code></pre><h5 id="3-System-getProperties"><a href="#3-System-getProperties" class="headerlink" title="3. System.getProperties()"></a>3. <code>System.getProperties()</code></h5><p>返回一个 <code>Properties</code> 对象，包含了当前系统的所有属性，如操作系统名称、Java 版本等。</p><pre><code class="java">import java.util.Properties;public class GetPropertiesExample &#123;    public static void main(String[] args) &#123;        Properties properties = System.getProperties();        properties.list(System.out);    &#125;&#125;</code></pre><h5 id="4-System-setProperty-String-key-String-value"><a href="#4-System-setProperty-String-key-String-value" class="headerlink" title="4. System.setProperty(String key, String value)"></a>4. <code>System.setProperty(String key, String value)</code></h5><p>用于设置系统属性，可在程序运行时动态修改系统属性。</p><pre><code class="java">public class SetPropertyExample &#123;    public static void main(String[] args) &#123;        System.setProperty(&quot;my.property&quot;, &quot;my value&quot;);        String value = System.getProperty(&quot;my.property&quot;);        System.out.println(&quot;自定义属性的值: &quot; + value);    &#125;&#125;</code></pre><h5 id="5-System-exit-int-status"><a href="#5-System-exit-int-status" class="headerlink" title="5. System.exit(int status)"></a>5. <code>System.exit(int status)</code></h5><p>用于终止当前正在运行的 Java 虚拟机。参数 <code>status</code> 为 0 表示正常退出，非 0 表示异常退出。</p><pre><code class="java">public class ExitExample &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;程序即将退出...&quot;);        System.exit(0);        System.out.println(&quot;这行代码不会执行。&quot;);    &#125;&#125;</code></pre><h3 id="BigInteger-BigDecimal的方法和它差不多）"><a href="#BigInteger-BigDecimal的方法和它差不多）" class="headerlink" title="BigInteger(BigDecimal的方法和它差不多）"></a>BigInteger(BigDecimal的方法和它差不多）</h3><p><img src="/../images/java-notes/1741785405658.png" alt="1741785405658"></p><h4 id="创建-BigInteger-对象"><a href="#创建-BigInteger-对象" class="headerlink" title="创建 BigInteger 对象"></a>创建 <code>BigInteger</code> 对象</h4><p><code>BigInteger</code> 提供了多种创建对象的方式：</p><ul><li><strong>使用字符串构造</strong>：可以将一个表示整数的字符串作为参数传递给 <code>BigInteger</code> 的构造函数。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerCreation &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;12345678901234567890&quot;);        System.out.println(&quot;num1: &quot; + num1);    &#125;&#125;</code></pre><ul><li><strong>使用基本数据类型转换</strong>：可以将 <code>int</code>、<code>long</code> 等基本数据类型转换为 <code>BigInteger</code> 对象。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerCreationFromPrimitive &#123;    public static void main(String[] args) &#123;        int intValue = 123;        BigInteger num2 = BigInteger.valueOf(intValue);        System.out.println(&quot;num2: &quot; + num2);    &#125;&#125;</code></pre><h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-基本运算方法"><a href="#1-基本运算方法" class="headerlink" title="1. 基本运算方法"></a>1. 基本运算方法</h5><ul><li><strong>加法</strong>：使用 <code>add()</code> 方法进行加法运算。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerAddition &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;10&quot;);        BigInteger num2 = new BigInteger(&quot;20&quot;);        BigInteger sum = num1.add(num2);        System.out.println(&quot;两数之和: &quot; + sum);    &#125;&#125;</code></pre><ul><li><strong>减法</strong>：使用 <code>subtract()</code> 方法进行减法运算。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerSubtraction &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;20&quot;);        BigInteger num2 = new BigInteger(&quot;10&quot;);        BigInteger difference = num1.subtract(num2);        System.out.println(&quot;两数之差: &quot; + difference);    &#125;&#125;</code></pre><ul><li><strong>乘法</strong>：使用 <code>multiply()</code> 方法进行乘法运算。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerMultiplication &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;5&quot;);        BigInteger num2 = new BigInteger(&quot;3&quot;);        BigInteger product = num1.multiply(num2);        System.out.println(&quot;两数之积: &quot; + product);    &#125;&#125;</code></pre><ul><li><strong>除法</strong>：使用 <code>divide()</code> 方法进行除法运算，只返回商。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerDivision &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;10&quot;);        BigInteger num2 = new BigInteger(&quot;3&quot;);        BigInteger quotient = num1.divide(num2);        System.out.println(&quot;两数之商: &quot; + quotient);    &#125;&#125;</code></pre><ul><li><strong>取模</strong>：使用 <code>mod()</code> 方法进行取模运算。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerModulus &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;10&quot;);        BigInteger num2 = new BigInteger(&quot;3&quot;);        BigInteger remainder = num1.mod(num2);        System.out.println(&quot;两数取模结果: &quot; + remainder);    &#125;&#125;</code></pre><h5 id="2-比较方法"><a href="#2-比较方法" class="headerlink" title="2. 比较方法"></a>2. 比较方法</h5><ul><li><strong><code>compareTo()</code> 方法</strong>：用于比较两个 <code>BigInteger</code> 对象的大小。如果当前对象小于参数对象，返回 -1；如果相等，返回 0；如果当前对象大于参数对象，返回 1。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerComparison &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;10&quot;);        BigInteger num2 = new BigInteger(&quot;20&quot;);        int result = num1.compareTo(num2);        if (result &lt; 0) &#123;            System.out.println(&quot;num1 小于 num2&quot;);        &#125; else if (result == 0) &#123;            System.out.println(&quot;num1 等于 num2&quot;);        &#125; else &#123;            System.out.println(&quot;num1 大于 num2&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="3-转换方法"><a href="#3-转换方法" class="headerlink" title="3. 转换方法"></a>3. 转换方法</h5><ul><li><strong><code>intValue()</code>、<code>longValue()</code> 等</strong>：可以将 <code>BigInteger</code> 对象转换为基本数据类型，但要注意可能会丢失精度。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerConversion &#123;    public static void main(String[] args) &#123;        BigInteger num = new BigInteger(&quot;123&quot;);        int intValue = num.intValue();        System.out.println(&quot;转换为 int 类型的值: &quot; + intValue);    &#125;&#125;</code></pre><h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>性能问题</strong>：由于 <code>BigInteger</code> 要处理任意精度的整数，其运算性能通常比基本数据类型的运算要低，因此在能使用基本数据类型的情况下，优先使用基本数据类型。</li><li><strong>精度丢失</strong>：在将 <code>BigInteger</code> 转换为基本数据类型时，如果 <code>BigInteger</code> 的值超出了基本数据类型的取值范围，会发生精度丢失。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/../images/java-notes/1741786653399.png" alt="1741786653399"></p><h3 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h3><p><strong>单列集合</strong></p><p><img src="/../images/java-notes/1741786573112.png" alt="1741786573112"></p><p><strong>双列集合</strong></p><p><img src="/../images/java-notes/1741786639451.png" alt="1741786639451"></p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="/../images/java-notes/1741787440825.png" alt="1741787440825"></p><p><code>Collection</code> 是 Java 集合框架中的根接口，它位于 <code>java.util</code> 包下，为各种集合类提供了通用的操作规范。以下将从概述、常用方法、子接口及实现类等方面详细介绍 <code>Collection</code>。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>Collection</code> 接口代表一组对象，这些对象被称为集合的元素。它是 Java 集合框架的基础，许多具体的集合类都实现了这个接口，不同的实现类有不同的数据存储和操作特性，但都遵循 <code>Collection</code> 接口定义的基本操作规则。</p><h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-元素添加方法"><a href="#1-元素添加方法" class="headerlink" title="1. 元素添加方法"></a>1. 元素添加方法</h5><ul><li><code>boolean add(E e)</code>：将指定的元素添加到集合中。如果集合因为此调用而发生改变，则返回 <code>true</code>；如果集合不允许重复元素且已经包含该元素，则返回 <code>false</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class AddExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        boolean result = collection.add(&quot;apple&quot;);        System.out.println(&quot;添加结果: &quot; + result);     &#125;&#125;</code></pre><ul><li><code>boolean addAll(Collection c)</code>：将指定集合中的所有元素添加到当前集合中。如果集合因为此调用而发生改变，则返回 <code>true</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class AddAllExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection1 = new ArrayList&lt;&gt;();        collection1.add(&quot;apple&quot;);        collection1.add(&quot;banana&quot;);        Collection&lt;String&gt; collection2 = new ArrayList&lt;&gt;();        collection2.add(&quot;cherry&quot;);        boolean result = collection1.addAll(collection2);        System.out.println(&quot;添加结果: &quot; + result);         System.out.println(collection1);     &#125;&#125;</code></pre><h5 id="2-元素删除方法"><a href="#2-元素删除方法" class="headerlink" title="2. 元素删除方法"></a>2. 元素删除方法</h5><ul><li><code>boolean remove(Object o)</code>：从集合中移除指定元素的单个实例（如果存在）。如果集合因为此调用而发生改变，则返回 <code>true</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class RemoveExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        collection.add(&quot;apple&quot;);        boolean result = collection.remove(&quot;apple&quot;);        System.out.println(&quot;删除结果: &quot; + result);     &#125;&#125;</code></pre><ul><li><code>boolean removeAll(Collection c)</code>：从当前集合中移除包含在指定集合中的所有元素。如果集合因为此调用而发生改变，则返回 <code>true</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class RemoveAllExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection1 = new ArrayList&lt;&gt;();        collection1.add(&quot;apple&quot;);        collection1.add(&quot;banana&quot;);        Collection&lt;String&gt; collection2 = new ArrayList&lt;&gt;();        collection2.add(&quot;apple&quot;);        boolean result = collection1.removeAll(collection2);        System.out.println(&quot;删除结果: &quot; + result);         System.out.println(collection1);     &#125;&#125;</code></pre><h5 id="3-元素查询方法"><a href="#3-元素查询方法" class="headerlink" title="3. 元素查询方法"></a>3. 元素查询方法</h5><ul><li><code>boolean contains(Object o)</code>：判断集合中是否包含指定元素。如果包含，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class ContainsExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        collection.add(&quot;apple&quot;);        boolean result = collection.contains(&quot;apple&quot;);        System.out.println(&quot;是否包含: &quot; + result);     &#125;&#125;</code></pre><ul><li><code>boolean containsAll(Collection c)</code>：判断当前集合是否包含指定集合中的所有元素。如果包含，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class ContainsAllExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection1 = new ArrayList&lt;&gt;();        collection1.add(&quot;apple&quot;);        collection1.add(&quot;banana&quot;);        Collection&lt;String&gt; collection2 = new ArrayList&lt;&gt;();        collection2.add(&quot;apple&quot;);        boolean result = collection1.containsAll(collection2);        System.out.println(&quot;是否包含所有: &quot; + result);     &#125;&#125;</code></pre><h5 id="4-其他常用方法"><a href="#4-其他常用方法" class="headerlink" title="4. 其他常用方法"></a>4. 其他常用方法</h5><ul><li><code>int size()</code>：返回集合中的元素个数。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class SizeExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        collection.add(&quot;apple&quot;);        int size = collection.size();        System.out.println(&quot;集合大小: &quot; + size);     &#125;&#125;</code></pre><ul><li><code>boolean isEmpty()</code>：判断集合是否为空。如果集合不包含任何元素，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class IsEmptyExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        boolean isEmpty = collection.isEmpty();        System.out.println(&quot;集合是否为空: &quot; + isEmpty);     &#125;&#125;</code></pre><ul><li><code>void clear()</code>：移除集合中的所有元素。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class ClearExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        collection.add(&quot;apple&quot;);        collection.clear();        System.out.println(&quot;集合大小: &quot; + collection.size());     &#125;&#125;</code></pre><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><img src="/../images/java-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-12%20220014.png"></p><p><img src="/../images/java-notes/1741788798038.png" alt="1741788798038"></p><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>List</code> 接口定义了一系列用于操作有序集合的方法，它继承自 <code>Collection</code> 接口，因此也拥有 <code>Collection</code> 接口提供的通用方法，如添加元素、删除元素、检查元素是否存在等。同时，<code>List</code> 接口还提供了基于索引的操作方法，使得可以方便地对集合中的元素进行定位和操作。</p><h4 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-元素添加方法-1"><a href="#1-元素添加方法-1" class="headerlink" title="1. 元素添加方法"></a>1. 元素添加方法</h5><ul><li><code>void add(int index, E element)</code>：在指定索引位置插入指定元素。</li><li><code>boolean add(E e)</code>：将指定元素添加到列表的末尾。</li></ul><h5 id="2-元素删除方法-1"><a href="#2-元素删除方法-1" class="headerlink" title="2. 元素删除方法"></a>2. 元素删除方法</h5><ul><li><code>E remove(int index)</code>：移除列表中指定索引位置的元素，并返回该元素。</li><li><code>boolean remove(Object o)</code>：从列表中移除指定元素的第一个出现项，如果列表包含该元素，则返回 <code>true</code>。</li></ul><h5 id="3-元素获取方法"><a href="#3-元素获取方法" class="headerlink" title="3. 元素获取方法"></a>3. 元素获取方法</h5><ul><li><code>E get(int index)</code>：返回列表中指定索引位置的元素。</li></ul><h5 id="4-元素修改方法"><a href="#4-元素修改方法" class="headerlink" title="4. 元素修改方法"></a>4. 元素修改方法</h5><ul><li><code>E set(int index, E element)</code>：用指定元素替换列表中指定索引位置的元素，并返回被替换的元素。</li></ul><h5 id="5-元素查找方法"><a href="#5-元素查找方法" class="headerlink" title="5. 元素查找方法"></a>5. 元素查找方法</h5><ul><li><code>int indexOf(Object o)</code>：返回指定元素在列表中第一次出现的索引，如果列表不包含该元素，则返回 -1。</li><li><code>int lastIndexOf(Object o)</code>：返回指定元素在列表中最后一次出现的索引，如果列表不包含该元素，则返回 -1。</li></ul><h4 id="遍历-List-的方式"><a href="#遍历-List-的方式" class="headerlink" title="遍历 List 的方式"></a>遍历 <code>List</code> 的方式</h4><h5 id="1-使用-for-each-循环"><a href="#1-使用-for-each-循环" class="headerlink" title="1. 使用 for-each 循环"></a>1. 使用 <code>for-each</code> 循环</h5><pre><code class="java">import java.util.ArrayList;import java.util.List;public class ListTraversalForEach &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;apple&quot;);        list.add(&quot;banana&quot;);        list.add(&quot;cherry&quot;);        for (String element : list) &#123;            System.out.println(element);        &#125;    &#125;&#125;</code></pre><h5 id="2-使用迭代器"><a href="#2-使用迭代器" class="headerlink" title="2. 使用迭代器"></a>2. 使用迭代器</h5><pre><code class="java">import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ListTraversalIterator &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;apple&quot;);        list.add(&quot;banana&quot;);        list.add(&quot;cherry&quot;);        Iterator&lt;String&gt; iterator = list.iterator();        while (iterator.hasNext()) &#123;            String element = iterator.next();            System.out.println(element);        &#125;    &#125;&#125;</code></pre><p><strong>注意！！！</strong></p><p><strong>迭代器初始位置</strong></p><p>迭代器的初始位置是在集合第一个元素之前，它起到一个游标或者指针的作用，用于控制对集合元素的访问顺序，但本身并不直接存储集合中的元素值。<code>iterator()</code> 方法创建的迭代器就像是一个站在集合元素队列 “入口外” 的引导者，还未进入队列开始引导访问元素。</p><h5 id="3-使用普通-for-循环"><a href="#3-使用普通-for-循环" class="headerlink" title="3. 使用普通 for 循环"></a>3. 使用普通 <code>for</code> 循环</h5><pre><code class="java">import java.util.ArrayList;import java.util.List;public class ListTraversalForLoop &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;apple&quot;);        list.add(&quot;banana&quot;);        list.add(&quot;cherry&quot;);        for (int i = 0; i &lt; list.size(); i++) &#123;            String element = list.get(i);            System.out.println(element);        &#125;    &#125;&#125;</code></pre><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;安卓逆向基础&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-notes</title>
    <link href="http://example.com/2025/02/24/java/"/>
    <id>http://example.com/2025/02/24/java/</id>
    <published>2025-02-24T10:33:45.000Z</published>
    <updated>2025-03-12T13:10:25.095Z</updated>
    
    <content type="html"><![CDATA[<p>安卓逆向基础</p><span id="more"></span> <h1 id="cmd与环境变量"><a href="#cmd与环境变量" class="headerlink" title="cmd与环境变量"></a>cmd与环境变量</h1><p><img src="/../images/java/1740393417191.png" alt="1740393417191"></p><h2 id="cmd基本操作"><a href="#cmd基本操作" class="headerlink" title="cmd基本操作"></a>cmd基本操作</h2><p><strong>dir：展现当前目录</strong></p><p><strong>cd：转目录</strong></p><p><strong>cd  .. ：</strong> <strong>转上级目录</strong></p><p><strong>输入“D: ”  ：转到D盘</strong></p><p><strong>按Tab键可以补全文件命</strong></p><p><strong>右键复制粘贴</strong></p><p><strong>按上下键可以选择之前执行过的命令</strong></p><p><strong>cmd可以直接运行文件</strong></p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><ul><li><strong>定义</strong>：相对路径是相对于当前工作目录或当前文件所在位置来表示文件或目录位置的路径。它不包含从文件系统根目录开始的完整路径信息，而是基于当前位置来描述目标的位置。相对路径使用 “.”（表示当前目录）、“..”（表示上级目录）以及文件名或目录名来构建路径。</li><li><strong>示例</strong>：假设当前工作目录是<code>C:\Users\John\Documents</code>，如果要访问<code>Documents</code>目录下的<code>Projects</code>文件夹中的<code>file.txt</code>文件，相对路径可以表示为<code>Projects/file.txt</code>。如果要访问当前目录的上一级目录中的<code>Images</code>文件夹，相对路径可以写成<code>../Images</code>。</li></ul><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><ul><li><strong>定义</strong>：绝对路径是从文件系统的根目录开始，完整地指定文件或目录在整个文件系统中的位置的路径。它包含了从根目录到目标文件或目录的所有目录层次信息，具有唯一性和确定性，无论在什么环境下，绝对路径都能准确地定位到目标文件或目录。</li><li><strong>示例</strong>：在 Windows 系统中，例如<code>C:\Users\John\Documents\Projects\file.txt</code>就是一个绝对路径，它明确地指出了<code>file.txt</code>文件位于<code>C</code>盘的<code>Users</code>文件夹下的<code>John</code>文件夹中的<code>Documents</code>文件夹的<code>Projects</code>文件夹内。在 Linux 系统中，<code>/home/user/Documents/file.txt</code>也是一个绝对路径，从根目录 “&#x2F;” 开始，依次指定了各个目录层级直到目标文件。</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li><strong>用户变量</strong>：是针对特定用户设置的变量，只对当前用户的环境和应用程序起作用，不同用户的用户变量相互独立，可用于存储该用户特有的配置信息等。</li><li><strong>系统变量</strong>：是对整个系统所有用户都有效的变量，用于存储系统级的配置信息和参数，为系统和所有用户的应用程序提供通用的设置和数据。</li><li><strong>环境变量作用</strong>：在环境变量中，Path 用于指定可执行文件的搜索路径。当在命令行或程序中执行一个命令或启动一个程序时，系统会按照 Path 中指定的路径顺序去查找对应的可执行文件，以便能够找到并运行它们，而无需用户输入完整路径。</li></ul><h1 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h1><p><img src="/../images/java/1740407096683.png" alt="1740407096683"></p><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><p><img src="/../images/java/1741268784357.png" alt="1741268784357"></p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p><img src="/../images/java/1741269021214.png" alt="1741269021214"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><img src="/../images/java/1741269364034.png" alt="1741269364034"></p><p><img src="/../images/java/1741269706290.png" alt="1741269706290"></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><img src="/../images/java/1741269821892.png" alt="1741269821892"></p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p><img src="/../images/java/1741349945259.png" alt="1741349945259"></p><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>设置断点是调试的第一步，它可以让程序在指定的代码行暂停执行。</p><ul><li><strong>普通断点</strong>：在编辑器的行号旁边单击，会出现一个红色圆点，即设置了一个普通断点。当程序执行到这一行时，会暂停执行。例如，在以下代码中，在 <code>System.out.println(&quot;这是要调试的代码行&quot;);</code> 这一行的行号旁边单击设置断点：</li></ul><pre><code class="java">public class DebugExample &#123;    public static void main(String[] args) &#123;        int a = 10;        int b = 20;        int sum = a + b;        System.out.println(&quot;这是要调试的代码行&quot;);        System.out.println(&quot;两数之和为：&quot; + sum);    &#125;&#125;</code></pre><ul><li><strong>条件断点</strong>：右键单击已经设置的普通断点，选择 “Edit Breakpoint”，在弹出的对话框中可以设置条件。只有当条件满足时，程序才会在该断点处暂停。比如，在上述代码中，如果想在 <code>sum</code> 等于 30 时暂停程序，可以在条件框中输入 <code>sum == 30</code>。</li></ul><h3 id="启动调试模式"><a href="#启动调试模式" class="headerlink" title="启动调试模式"></a>启动调试模式</h3><p>设置好断点后，需要以调试模式启动程序。在 IDEA 的工具栏中，找到绿色虫子图标（Debug），点击它或者使用快捷键（通常是 Shift + F9），程序会开始执行，当遇到断点时会暂停。</p><h3 id="调试操作"><a href="#调试操作" class="headerlink" title="调试操作"></a>调试操作</h3><p>程序在断点处暂停后，可以使用以下操作来控制程序的执行和查看程序状态：</p><ul><li>单步执行<ul><li><strong>Step Over（F8）</strong>：逐行执行代码，不会进入方法内部。如果当前行调用了一个方法，会直接执行完该方法并跳到下一行。</li><li><strong>Step Into（F7）</strong>：如果当前行调用了一个方法，会进入该方法内部继续调试；如果是普通语句，则和 Step Over 效果相同。</li><li><strong>Step Out（Shift + F8）</strong>：从当前方法中跳出，继续执行该方法调用处的下一行代码。</li></ul></li><li><strong>查看变量值</strong>：在调试窗口的 “Variables” 面板中，可以查看当前作用域内的变量值。当程序暂停在断点处时，该面板会显示当前方法中所有变量的名称和值。</li><li><strong>表达式求值</strong>：在调试窗口中，有一个 “Evaluate Expression” 按钮（通常是一个带有计算器图标的按钮），点击它可以输入表达式并计算其值。例如，可以输入变量名来查看变量的值，或者输入一个复杂的表达式进行计算。</li></ul><h3 id="其他类型的断点"><a href="#其他类型的断点" class="headerlink" title="其他类型的断点"></a>其他类型的断点</h3><ul><li><strong>方法断点</strong>：在方法的声明行（方法名所在行）设置断点，当该方法被调用或者方法返回时，程序会暂停。方法断点用蓝色菱形表示。</li><li><strong>字段断点</strong>：在类的字段声明行设置断点，当该字段被读取或者写入时，程序会暂停。字段断点用黄色圆点表示。</li></ul><h3 id="管理断点"><a href="#管理断点" class="headerlink" title="管理断点"></a>管理断点</h3><ul><li><strong>禁用 &#x2F; 启用断点</strong>：右键单击断点，选择 “Disable Breakpoint” 可以禁用断点，再次右键单击选择 “Enable Breakpoint” 可以启用断点。禁用的断点不会影响程序的执行。</li><li><strong>删除断点</strong>：直接单击断点（红色圆点）即可删除断点；也可以在 “Breakpoints” 窗口（通常可以通过 “View” -&gt; “Tool Windows” -&gt; “Breakpoints” 打开）中选择要删除的断点，然后按 Delete 键删除。</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="基本调试步骤"><a href="#基本调试步骤" class="headerlink" title="基本调试步骤"></a>基本调试步骤</h3><h4 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1. 设置断点"></a>1. 设置断点</h4><p>断点是调试的关键，它能让程序在指定位置暂停执行，方便开发者查看程序状态。在 IDEA 中设置断点非常简单，只需在代码编辑器的行号旁边单击，出现红色圆点即表示成功设置断点。例如，在以下代码中，若想在 <code>sum</code> 变量计算完成后查看其值，可在 <code>System.out.println(&quot;两数之和为: &quot; + sum);</code> 这一行设置断点：</p><pre><code class="java">public class DebugExample &#123;    public static void main(String[] args) &#123;        int a = 10;        int b = 20;        int sum = a + b;        System.out.println(&quot;两数之和为: &quot; + sum);    &#125;&#125;</code></pre><h4 id="2-启动调试模式"><a href="#2-启动调试模式" class="headerlink" title="2. 启动调试模式"></a>2. 启动调试模式</h4><p>设置好断点后，有两种方式启动调试模式：</p><ul><li>点击 IDEA 工具栏上的绿色虫子图标（Debug）。</li><li>使用快捷键（通常是 <code>Shift + F9</code>）。</li></ul><p>启动调试模式后，程序会开始执行，当遇到设置的断点时会暂停。</p><h3 id="常用调试操作"><a href="#常用调试操作" class="headerlink" title="常用调试操作"></a>常用调试操作</h3><h4 id="1-单步执行"><a href="#1-单步执行" class="headerlink" title="1. 单步执行"></a>1. 单步执行</h4><ul><li><strong>StepOver（<code>F8</code>）</strong>：逐行执行代码，若当前行调用了方法，会直接执行完该方法并跳到下一行，不会进入方法内部。</li><li><strong>Step Into（<code>F7</code>）</strong>：若当前行调用了方法，会进入该方法内部继续调试；若为普通语句，则和 <code>Step Over</code> 效果相同。</li><li><strong>Step Out（<code>Shift + F8</code>）</strong>：从当前方法中跳出，继续执行该方法调用处的下一行代码。</li></ul><h4 id="2-查看变量值"><a href="#2-查看变量值" class="headerlink" title="2. 查看变量值"></a>2. 查看变量值</h4><p>程序暂停在断点处时，可在调试窗口的 “Variables” 面板中查看当前作用域内的变量值。该面板会实时显示变量的名称和值，方便开发者了解程序的运行状态。</p><h4 id="3-表达式求值"><a href="#3-表达式求值" class="headerlink" title="3. 表达式求值"></a>3. 表达式求值</h4><p>点击调窗口中带有计算器图标的 “Evaluate Expression” 按钮，可输入表达式并计算其值。例如，输入变量名查看变量值，或输入复杂表达式进行计算。</p><h3 id="断点类型"><a href="#断点类型" class="headerlink" title="断点类型"></a>断点类型</h3><h4 id="1-普通断点"><a href="#1-普通断点" class="headerlink" title="1. 普通断点"></a>1. 普通断点</h4><p>最常用的断点类型，在代码行号旁边单击即可设置，程序执行到该行时会暂停。</p><h4 id="2-条件断点"><a href="#2-条件断点" class="headerlink" title="2. 条件断点"></a>2. 条件断点</h4><p>右键单击已设置的普通断点，选择 “Edit Breakpoint”，在弹出的对话框中设置条件。只有当条件满足时，程序才会在该断点处暂停。例如，在上述代码中，若想在 <code>sum</code> 等于 30 时暂停程序，可在条件框中输入 <code>sum == 30</code>。</p><h4 id="3-方法断点"><a href="#3-方法断点" class="headerlink" title="3. 方法断点"></a>3. 方法断点</h4><p>在方法的声明行（方法名所在行）设置断点，当该方法被调用或者方法返回时，程序会暂停。方法断点用蓝色菱形表示。</p><h4 id="4-字段断点"><a href="#4-字段断点" class="headerlink" title="4. 字段断点"></a>4. 字段断点</h4><p>在类的字段声明行设置断点，当该字段被读取或者写入时，程序会暂停。字段断点用黄色圆点表示。</p><h3 id="高级调试技巧"><a href="#高级调试技巧" class="headerlink" title="高级调试技巧"></a>高级调试技巧</h3><h4 id="1-强制返回"><a href="#1-强制返回" class="headerlink" title="1. 强制返回"></a>1. 强制返回</h4><p>在调试过程中，若想提前结束当前方法的执行并返回指定值，可使用 “Force Return” 功能。在调试窗口中右键单击，选择 “Force Return”，然后输入要返回的值，程序会立即结束当前方法并返回该值。</p><h4 id="2-多线程调试"><a href="#2-多线程调试" class="headerlink" title="2. 多线程调试"></a>2. 多线程调试</h4><p>若程序包含多个线程，IDEA 支持多线程调试。在调试窗口的 “Threads” 面板中，可以查看所有线程的状态，并选择要调试的线程。</p><h4 id="3-日志断点"><a href="#3-日志断点" class="headerlink" title="3. 日志断点"></a>3. 日志断点</h4><p>在一些情况下，可能不需要暂停程序，只需在特定位置输出日志信息。可以使用日志断点，右键单击断点，在 “Log evaluated expression” 中输入要输出的日志信息，程序执行到该断点时会在控制台输出日志，但不会暂停。</p><h1 id="java-语言特点"><a href="#java-语言特点" class="headerlink" title="java 语言特点"></a>java 语言特点</h1><p><img src="/../images/java/1740458407691.png" alt="1740458407691"></p><h1 id="第一个java程序"><a href="#第一个java程序" class="headerlink" title="第一个java程序"></a>第一个java程序</h1><pre><code class="java">public class Hello &#123;    public static void main (String[] args) &#123;        System.out.println(&quot;Hello China&quot;);    &#125;&#125;</code></pre><h2 id="编译及运行"><a href="#编译及运行" class="headerlink" title="编译及运行"></a>编译及运行</h2><h3 id="编译："><a href="#编译：" class="headerlink" title="编译："></a><strong>编译：</strong></h3><p>将写好的代码保存在桌面上，且类名要与保存的文件名要一样。</p><p><strong>例：</strong> </p><p>类名 ：Hello      则文件名 ： Hello.java </p><p>然后在桌面上打开终端，输入javac + 文件名 进行编译</p><p><img src="/../images/java/1740461800775.png" alt="1740461800775"></p><p>此时桌面会得到一个编译后的文件  Hello.class </p><h3 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h3><p>在终端输入 java  +  (.class文件)文件名（不要后缀）</p><p><img src="/../images/java/1740461909477.png" alt="1740461909477"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/../images/java/1740462178975.png" alt="1740462178975"></p><h1 id="java语言基础组成"><a href="#java语言基础组成" class="headerlink" title="java语言基础组成"></a>java语言基础组成</h1><p><img src="/../images/java/1740462493599.png" alt="1740462493599"></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><img src="/../images/java/1740462613227.png" alt="1740462613227"></p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p><img src="/../images/java/1740575654215.png" alt="1740575654215"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="/../images/java/1740575933497.png" alt="1740575933497"></p><p><img src="/../images/java/1740575960520.png" alt="1740575960520"></p><p><strong>类似C</strong></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/../images/java/1740576109560.png" alt="1740576109560"></p><p><strong>与C不同点：</strong></p><p>有新的 byte</p><p>布尔型为  boolean</p><p>只有  long  没有  long long</p><p>且  char  占两个字节，并可以存中文</p><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><p><img src="/../images/java/1740576334165.png" alt="1740576334165"></p><p><strong>一字节  &#x3D;  8bit</strong></p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p><img src="/../images/java/1740576618037.png" alt="1740576618037"></p><p><strong>注意：</strong></p><p><img src="/../images/java/1740576763880.png" alt="1740576763880"></p><p><img src="/../images/java/1740576774228.png" alt="1740576774228"></p><p><strong>加入运算会影响精度</strong></p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p><img src="/../images/java/1740577000379.png" alt="1740577000379"></p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p><img src="/../images/java/1740577893027.png" alt="1740577893027"></p><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p><img src="/../images/java/1740577927233.png" alt="1740577927233"></p><p><img src="/../images/java/1740578765536.png" alt="1740578765536"></p><p><img src="/../images/java/1740578776537.png" alt="1740578776537"></p><p><strong>若运算类型含有字符串那么每个变量类型都转为字符串</strong></p><p><strong>字符串相加代表字符串连接</strong></p><p><img src="/../images/java/1740578924545.png" alt="1740578924545"></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="/../images/java/1740578980886.png" alt="1740578980886"></p><h2 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h2><ul><li><strong>关键字</strong>：是 Java 语言事先定义好的，具有特殊意义的标识符 ，用于表示一种数据类型、程序的结构等，是编译器和程序员的约定。程序员通过关键字告知编译器声明的变量类型、类、方法特性等信息。例如，<code>int</code>用于声明整数类型变量，<code>class</code>用于声明一个类，<code>if</code>用于条件语句等。关键字不能用作变量名、方法名、类名、包名和参数，并且一律用小写字母标识。Java 定义的关键字包括<code>abstract</code>、<code>assert</code>、<code>boolean</code>、<code>break</code> 等。</li><li><strong>保留字</strong>：通常指未来可能会作为关键字使用的一些单词， 目前在 Java 中没有实际的作用，但为了语言的扩展性和兼容性而保留。比如<code>goto</code>、<code>const</code> 以及<code>future</code>、<code>generic</code>、<code>operator</code>、<code>outer</code>、<code>rest</code>、<code>var</code>等，它们也不能作为标识符使用。此外，<code>null</code>、<code>true</code>、<code>false</code>虽常被认为是保留字，但更准确说是文字，包含 Java 定义的值，同样不可作为标识符 。</li></ul><h2 id="标志符"><a href="#标志符" class="headerlink" title="标志符"></a>标志符</h2><p><img src="/../images/java/1740579835980.png" alt="1740579835980"></p><p><strong>说白了就是自己取的名字</strong></p><p><strong>大驼峰（PascalCase）</strong>：</p><ul><li><strong>定义</strong>：每个单词首字母大写，无分隔符。</li><li><strong>用处</strong>：用于类名、接口名等。</li></ul><p><strong>小驼峰（camelCase）</strong>：</p><ul><li><strong>定义</strong>：首个单词首字母小写，后续单词首字母大写，无分隔符。</li><li><strong>用处</strong>：用于变量名、方法名等。</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><img src="/../images/java/1740580424234.png" alt="1740580424234"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>类似C</strong></p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="/../images/java/1740580531413.png" alt="1740580531413"></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="/../images/java/1740580829536.png" alt="1740580829536"></p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><img src="/../images/java/1740580977369.png" alt="1740580977369"></p><h3 id="三元运算符（三目运算）"><a href="#三元运算符（三目运算）" class="headerlink" title="三元运算符（三目运算）"></a>三元运算符（三目运算）</h3><p><img src="/../images/java/1740581133882.png" alt="1740581133882"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="/../images/java/1740581183917.png" alt="1740581183917"></p><h3 id="进制与位运算符"><a href="#进制与位运算符" class="headerlink" title="进制与位运算符"></a>进制与位运算符</h3><p><strong>常见的位运算符介绍：</strong></p><ol><li><strong>按位与（&amp;）</strong>：将两个数的二进制位进行比较，只有对应位都为 1 时，结果位才为 1，否则为 0。比如，5（二进制 0101）&amp; 3（二进制 0011）的结果是 1（二进制 0001）。常用于清零某些位，或者获取特定位的值。</li><li><strong>按位或（|）</strong>：对两个数的二进制位进行比较，只要对应位中有一个为 1，结果位就为 1，只有都为 0 时结果位才为 0。例如，5（二进制 0101）| 3（二进制 0011）的结果是 7（二进制 0111）。可用于设置某些位。</li><li><strong>按位异或（^）</strong>：比较两个数的二进制位，如果对应位不同，结果为 1；如果相同，结果为 0。比如，5（二进制 0101）^ 3（二进制 0011）的结果是 6（二进制 0110） 。可用于交换两个数的值等场景，无需额外变量。</li><li><strong>按位取反（~）</strong>：将一个数的每个二进制位进行反转，0 变 1，1 变 0。例如，~5（二进制 0101）的结果是 - 6（二进制 1010，补码表示）。因为 Java 中整数以补码形式存储，取反后要按补码规则转换为对应数值。</li><li><strong>左移（&lt;&lt;）</strong>：将二进制数向左移动指定的位数，空缺的位置补 0。左移 n 位相当于乘以 2 的 n 次方。比如，5（二进制 0101）&lt;&lt; 1 的结果是 10（二进制 1010） 。</li><li><strong>有符号右移（&gt;&gt;）</strong>：将二进制数向右移动指定的位数，对于负数，符号位（最高位）会被补充到空缺的位中。正数右移 n 位相当于除以 2 的 n 次方（向下取整）。比如，5（二进制 0101）&gt;&gt; 1 的结果是 2（二进制 0010） 。</li><li><strong>无符号右移（&gt;&gt;&gt;）</strong>：将二进制数向右移动指定的位数，不考虑符号位，所有空缺的位都用 0 补充。比如，5（二进制 0101）&gt;&gt;&gt; 1 的结果是 2（二进制 0010） ，常用于处理无符号数，如位图处理等场景。</li></ol><p><strong>位运算符有以下特点：</strong></p><ul><li><strong>运算高效</strong>：直接在硬件级别进行操作，比算术运算符速度更快。</li><li><strong>位移运算与乘除关系</strong>：左移一位相当于乘以 2，移动 n 位相当于乘以 2 的 n 次方；有符号右移一位相当于除以 2，移动 n 位相当于除以 2 的 n 次方（但负数右移时要注意符号位的处理） 。</li></ul><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p><img src="/../images/java/1740581486078.png" alt="1740581486078"></p><h4 id="Hex编码（十六进制编码）"><a href="#Hex编码（十六进制编码）" class="headerlink" title="Hex编码（十六进制编码）"></a>Hex编码（十六进制编码）</h4><p><strong>定义</strong></p><p>Hex 编码，即十六进制编码（Hexadecimal Encoding），是一种用十六进制数字来表示二进制数据的编码方式。在计算机领域，二进制数据是最基础的表现形式，但由于二进制数书写起来过长且不易阅读，而十六进制能更简洁、方便地表示二进制数据，所以被广泛应用。十六进制使用 0 - 9 和 A - F（或 a - f）这 16 个符号来表示数值，其中 A - F 分别对应十进制的 10 - 15。</p><p><strong>原理</strong></p><p>一个字节（Byte）由 8 位（bit）二进制数组成，其取值范围是从 00000000 到 11111111。而每 4 位二进制数可以用一个十六进制数字来表示，因为 4 位二进制数能表示的最大十进制数是 15（二进制 1111），正好对应十六进制的 F。所以一个字节的二进制数据可以用两个十六进制数字来表示。</p><p>例如，二进制数 10101100 可以拆分为 1010 和 1100 两部分，1010 对应的十进制数是 10，十六进制表示为 A；1100 对应的十进制数是 12，十六进制表示为 C。因此，二进制数 10101100 用十六进制编码后就是 AC。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p><strong>类似C</strong></p><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><img src="/../images/java/1740582597341.png" alt="1740582597341"></p><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><img src="/../images/java/1740582682860.png" alt="1740582682860"></p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><img src="/../images/java/1740582715108.png" alt="1740582715108"></p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><img src="/../images/java/1740582753580.png" alt="1740582753580"></p><h3 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h3><p><img src="/../images/java/1740582794617.png" alt="1740582794617"></p><p><img src="/../images/java/1740583059079.png" alt="1740583059079"></p><p><strong>给循环起名字b</strong></p><p>在<strong>嵌套循环</strong>中， break 和 continue 的作用如下：</p><p><strong>break</strong></p><p> break 语句用于跳出当前所在的循环体，即仅跳出包含该 break 的最内层循环，而不是整个嵌套循环结构。示例代码如下：</p><pre><code class="python">for i in range(3):    for j in range(3):        if j == 1:            break        print(i, j)</code></pre><p>上述代码中，当 j 等于1时， break 会使程序跳出内层 for 循环，继续执行外层 for 循环的下一次迭代，因此不会输出 (0, 1) 、 (1, 1) 、 (2, 1) 。</p><p><strong>continue</strong></p><p> continue 语句用于跳过当前循环的剩余语句，直接开始下一次循环迭代，同样只作用于当前所在的循环层。示例代码如下：</p><pre><code class="python">for i in range(3):    for j in range(3):        if j == 1:            continue        print(i, j)</code></pre><p>在这段代码中，当 j 等于1时， continue 会跳过当前内层循环中 print(i, j) 这一语句，直接进入下一次内层循环，即不会输出 (0, 1) 、 (1, 1) 、 (2, 1) ，但会继续执行其他情况。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>java 数组并不方便，因此后续使用集合</strong></p><p><img src="/../images/java/1740583194527.png" alt="1740583194527"></p><p><img src="/../images/java/1740583249256.png" alt="1740583249256"></p><p><strong>这样也可</strong></p><p><img src="/../images/java/1740583361466.png" alt="1740583361466"></p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p><img src="/../images/java/1740583501523.png" alt="1740583501523"></p><p><img src="/../images/java/1740583564661.png" alt="1740583564661"></p><h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><p><img src="/../images/java/1740661241136.png" alt="1740661241136"></p><p><img src="/../images/java/1740661272806.png" alt="1740661272806"></p><p><strong>将 ints1 赋值给 ints2 是引用传递（c中指针传递，传递首地址）</strong></p><p><img src="/../images/java/1740661334644.png" alt="1740661334644"></p><p><img src="/../images/java/1740661407623.png" alt="1740661407623"></p><p><strong>int[] ints1 是在栈中开辟内存</strong></p><p><strong>ints1 &#x3D; new int[5]  是在堆开辟5个空间再将首地址赋值给ints1</strong></p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p><img src="/../images/java/1740661996604.png" alt="1740661996604"></p><p><img src="/../images/java/1740663595068.png" alt="1740663595068"></p><p><img src="/../images/java/1740663631786.png" alt="1740663631786"></p><p>加入元素</p><p><img src="/../images/java/1740663703428.png" alt="1740663703428"></p><p>反转元素</p><p><img src="/../images/java/1740663950519.png" alt="1740663950519"></p><p><img src="/../images/java/1740663967066.png" alt="1740663967066"></p><p><img src="/../images/java/1740663997184.png" alt="1740663997184"></p><h2 id="java帮助文档的查阅"><a href="#java帮助文档的查阅" class="headerlink" title="java帮助文档的查阅"></a>java帮助文档的查阅</h2><p><img src="/../images/java/1740662612177.png" alt="1740662612177"></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><img src="/../images/java/1740664064218.png" alt="1740664064218"></p><p><strong>新建文件来定义类，因为一个文件只能有一个共有类（其他方面类似C++）</strong></p><p><strong>定义变量也和C++不同</strong></p><p><img src="/../images/java/1740664988967.png" alt="1740664988967"></p><p><img src="/../images/java/1740665144280.png" alt="1740665144280"></p><p><strong>右键类可以并点击Constructor可以让idea自动帮助构建构造函数</strong></p><p><img src="/../images/java/1740665298800.png" alt="1740665298800"></p><p><img src="/../images/java/1740665385855.png" alt="1740665385855"></p><h3 id="方法的定义和调用"><a href="#方法的定义和调用" class="headerlink" title="方法的定义和调用"></a>方法的定义和调用</h3><p><img src="/../images/java/1740665811671.png" alt="1740665811671"></p><p><strong>类内定义函数</strong></p><p><img src="/../images/java/1740666090677.png" alt="1740666090677"></p><p><strong>类外只能调用非静态（非static）的函数</strong></p><h3 id="方法的返回值和参数"><a href="#方法的返回值和参数" class="headerlink" title="方法的返回值和参数"></a>方法的返回值和参数</h3><p><img src="/../images/java/1740666644568.png" alt="1740666644568"></p><h3 id="方法传参机制"><a href="#方法传参机制" class="headerlink" title="方法传参机制"></a>方法传参机制</h3><p><img src="/../images/java/1740722611662.png" alt="1740722611662"></p><p> <strong>Java 的参数传递机制</strong></p><p>Java 采用的是值传递（Pass - by - Value）机制。这意味着当你将一个变量作为参数传递给一个函数时，实际上传递的是该变量的值的副本，而不是变量本身。对于基本数据类型，传递的是其值的副本；对于引用数据类型，传递的是引用（内存地址）的副本。</p><p>String 传递时，在函数中赋值一个新字符串时，是在堆区另外开出空间来存储新字符串，并将字符串地址赋值给 String 变量，当函数结束后释放出新字符串的空间，String 变量获得原字符串地址。</p><p><strong>java代码示例</strong></p><pre><code class="java">public class StringPassingExample &#123;    public static void main(String[] args) &#123;        String original = &quot;Hello&quot;;        System.out.println(&quot;调用 changeString 方法前: &quot; + original);        changeString(original);        System.out.println(&quot;调用 changeString 方法后: &quot; + original);    &#125;    public static void changeString(String str) &#123;        str = &quot;World&quot;;        System.out.println(&quot;方法内部修改后的 str: &quot; + str);    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><strong>调用 <code>changeString</code> 方法前</strong>：在 <code>main</code> 方法中，定义了一个 <code>String</code> 变量 <code>original</code>，其值为 <code>&quot;Hello&quot;</code>。</li><li><strong>调用 <code>changeString</code> 方法时</strong>：将 <code>original</code> 作为参数传递给 <code>changeString</code> 方法。此时，传递的是 <code>original</code> 引用的副本，即该副本指向 <code>&quot;Hello&quot;</code> 这个字符串对象在内存中的地址。</li><li>**方法内部修改 <code>str</code>**：在 <code>changeString</code> 方法内部，将 <code>str</code> 赋值为 <code>&quot;World&quot;</code>。由于 <code>String</code> 是不可变的，这实际上是让 <code>str</code> 这个引用副本指向了一个新的 <code>&quot;World&quot;</code> 字符串对象，而原来的 <code>&quot;Hello&quot;</code> 字符串对象并没有被修改，<code>original</code> 仍然指向 <code>&quot;Hello&quot;</code>。</li><li><strong>调用 <code>changeString</code> 方法后</strong>：在 <code>main</code> 方法中输出 <code>original</code>，其值仍然是 <code>&quot;Hello&quot;</code>，说明 <code>original</code> 本身没有受到 <code>changeString</code> 方法内部操作的影响。</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><img src="/../images/java/1740805529328.png" alt="1740805529328"></p><p><strong>定义</strong></p><ul><li><strong>实例属性</strong>：也称为对象属性，是属于类的每个实例（对象）的属性。每个对象都有自己独立的实例属性副本，这些属性的值可以在不同对象之间有所不同。实例属性在类中定义，但不使用 <code>static</code> 关键字修饰。</li><li><strong>类属性</strong>：也称为静态属性，是属于类本身的属性，而不是属于某个特定的对象。类属性在所有该类的实例之间共享，即无论创建多少个该类的对象，类属性都只有一个副本。类属性使用 <code>static</code> 关键字修饰。</li></ul><pre><code class="java">public class Animal &#123;    // 实例属性    private String name;    private int age;    // 类属性    private static int population;    public Animal(String name, int age) &#123;        this.name = name;        this.age = age;        // 每次创建一个新的 Animal 对象时，增加种群数量        population++;    &#125;    // 获取实例属性 name    public String getName() &#123;        return name;    &#125;    // 获取实例属性 age    public int getAge() &#123;        return age;    &#125;    // 获取类属性 population    public static int getPopulation() &#123;        return population;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><strong>实例属性</strong>：在上述代码中，<code>name</code> 和 <code>age</code> 是实例属性，因为它们没有使用 <code>static</code> 关键字修饰。每个 <code>Animal</code> 对象都有自己的 <code>name</code> 和 <code>age</code> 值，这些值可以在创建对象时通过构造函数进行初始化，并且可以在不同对象之间不同。</li><li><strong>类属性</strong>：<code>population</code> 是类属性，因为它使用了 <code>static</code> 关键字修饰。<code>population</code> 记录了创建的 <code>Animal</code> 对象的总数，所有 <code>Animal</code> 对象共享这个属性。每当创建一个新的 <code>Animal</code> 对象时，<code>population</code> 的值就会增加 1。</li></ul><p><strong>定义</strong></p><ul><li><strong>对象方法（实例方法）</strong>：是属于类的每个实例（对象）的方法，不使用 <code>static</code> 关键字修饰。每个对象都有自己独立的方法调用副本，这些方法可以访问和操作对象的实例属性。</li><li><strong>类方法（静态方法）</strong>：是属于类本身的方法，使用 <code>static</code> 关键字修饰。类方法不依赖于类的任何实例，它可以在不创建对象的情况下直接通过类名调用。</li></ul><pre><code class="java">public class Calculator &#123;    // 实例属性    private int num;    // 构造函数，用于初始化实例属性    public Calculator(int num) &#123;        this.num = num;    &#125;    // 对象方法（实例方法）    public int add(int other) &#123;        return this.num + other;    &#125;    // 类方法（静态方法）    public static int multiply(int a, int b) &#123;        return a * b;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><strong>对象方法</strong>：在上述代码中，<code>add</code> 方法是对象方法，因为它没有使用 <code>static</code> 关键字修饰。<code>add</code> 方法可以访问和操作对象的实例属性 <code>num</code>，它需要通过对象来调用。</li><li><strong>类方法</strong>：<code>multiply</code> 方法是类方法，因为它使用了 <code>static</code> 关键字修饰。<code>multiply</code> 方法不依赖于类的任何实例，它只接受传入的参数进行计算，不需要访问对象的实例属性，可以直接通过类名调用。</li></ul><p><strong>调用方式</strong></p><ul><li><strong>对象方法</strong>：必须通过类的实例（对象）来调用。例如，<code>calculator.add(3)</code> 是通过 <code>calculator</code> 对象来调用 <code>add</code> 方法。</li><li><strong>类方法</strong>：可以直接通过类名调用，也可以通过对象调用（但不推荐，因为这可能会引起混淆）。例如，<code>Calculator.multiply(4, 6)</code> 是通过类名 <code>Calculator</code> 直接调用 <code>multiply</code> 方法。</li></ul><p><strong>访问权限</strong></p><ul><li><p><strong>对象方法</strong>：可以访问和修改对象的实例属性，也可以调用其他对象方法和类方法。</p></li><li><p><strong>类方法</strong>：不能直接访问对象的实例属性和调用对象方法，因为类方法不依赖于任何对象。但类方法可以访问和修改类属性，也可以调用其他类方法。</p></li></ul><p>引用类型比较一般用equals</p><p><img src="/../images/java/1740807781357.png" alt="1740807781357"></p><p>比较存放内容</p><p><img src="/../images/java/1740808183985.png" alt="1740808183985"></p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p><img src="/../images/java/1740808501147.png" alt="1740808501147"></p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p><img src="/../images/java/1740809043333.png" alt="1740809043333"></p><p><img src="/../images/java/1740809320928.png" alt="1740809320928"></p><p><img src="/../images/java/1740809256927.png" alt="1740809256927"></p><p>可变参数只能有一个并且必须放在最后一个参数位置</p><p>或者可以直接传入数组</p><p><img src="/../images/java/1740809393666.png" alt="1740809393666"></p><h3 id="构造器（构造函数）"><a href="#构造器（构造函数）" class="headerlink" title="构造器（构造函数）"></a>构造器（构造函数）</h3><p><img src="/../images/java/1740809605223.png" alt="1740809605223"></p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p><img src="/../images/java/1740828827015.png" alt="1740828827015"></p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><img src="/../images/java/1740829859933.png" alt="1740829859933"></p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p><img src="/../images/java/1740830885877.png" alt="1740830885877"></p><p> 在 Java 中，包（package）是一种对类和接口等进行组织和管理的机制，它有助于避免命名冲突、便于代码的维护和共享。 </p><p><strong>作用</strong></p><ul><li><strong>避免命名冲突</strong>：在大型项目中，可能会有很多类，如果都放在同一个命名空间下，很容易出现类名冲突的情况。通过将类放在不同的包中，可以确保不同包中的类即使名称相同也不会产生冲突。</li><li><strong>便于代码组织和管理</strong>：将相关的类和接口放在同一个包中，能够使代码结构更加清晰，易于理解和维护。比如，所有与数据库操作相关的类可以放在一个名为<code>db</code>的包中，所有与用户界面相关的类可以放在<code>ui</code>包中。</li><li><strong>控制访问权限</strong>：包可以控制类、方法和变量等的访问权限。在 Java 中，默认情况下，如果没有使用<code>public</code>、<code>private</code>或<code>protected</code>修饰符，那么类、方法和变量在同一个包内是可以访问的，而在包外则不能访问。</li></ul><p><strong>定义包</strong></p><p>在 Java 源文件的开头使用<code>package</code>关键字来定义包。例如：</p><pre><code class="java">package com.example.myapp;public class MyClass &#123;    // 类的内容&#125;</code></pre><p>这表示<code>MyClass</code>类属于<code>com.example.myapp</code>包。需要注意的是，包名一般采用小写字母，且通常遵循域名倒置的规则，以确保唯一性。比如，如果你的网站域名是<code>example.com</code>，那么你的包名可以是<code>com.example</code>开头。</p><p><strong>导入包</strong></p><p>当需要使用其他包中的类时，需要使用<code>import</code>关键字导入包。例如：</p><pre><code class="java">package com.example.main;import com.example.myapp.MyClass;public class Main &#123;    public static void main(String[] args) &#123;        MyClass myClass = new MyClass();    &#125;&#125;</code></pre><p>也可以使用通配符<code>*</code>来导入整个包中的所有类：</p><pre><code class="java">package com.example.main;import com.example.myapp.*;public class Main &#123;    public static void main(String[] args) &#123;        MyClass myClass = new MyClass();    &#125;&#125;</code></pre><p>也可以不用import直接用包中的类（包内类与包外类重名时也只能这么用）：</p><p><img src="/../images/java/1740832099375.png" alt="1740832099375"></p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p><img src="/../images/java/1740842682147.png" alt="1740842682147"></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><img src="/../images/java/1740922314336.png" alt="1740922314336"></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>按 <code>Ctrl + h</code>可以在idea中看到类的继承关系</strong></p><p><img src="/../images/java/1740922861761.png" alt="1740922861761"></p><p><strong>继承的基本语法</strong></p><p>在 Java 中，使用 <code>extends</code> 关键字来实现继承。以下是一个简单的示例：</p><pre><code class="java">// 定义父类class Animal &#123;    String name;    public void eat() &#123;        System.out.println(name + &quot; 正在吃东西&quot;);    &#125;&#125;// 定义子类，继承自 Animal 类class Dog extends Animal &#123;    public void bark() &#123;        System.out.println(name + &quot; 正在汪汪叫&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.name = &quot;旺财&quot;;        dog.eat();        dog.bark();    &#125;&#125;</code></pre><p>在上述代码中，<code>Dog</code> 类继承了 <code>Animal</code> 类，因此 <code>Dog</code> 类可以使用 <code>Animal</code> 类中定义的 <code>name</code> 属性和 <code>eat()</code> 方法，同时还可以有自己特有的方法 <code>bark()</code>。</p><p><strong>继承的特点</strong></p><ol><li><strong>单继承</strong>：Java 只支持单继承，即一个子类只能有一个直接父类。这有助于避免多继承带来的复杂问题，如菱形继承问题。不过，Java 支持多层继承，即一个子类可以有父类，父类还可以有自己的父类。</li><li><strong>传递性</strong>：如果 <code>C</code> 类继承自 <code>B</code> 类，<code>B</code> 类继承自 <code>A</code> 类，那么 <code>C</code> 类就拥有 <code>B</code> 类和 <code>A</code> 类的所有可继承的属性和方法。</li></ol><p><strong>访问父类成员</strong></p><p>在子类中，可以使用 <code>super</code> 关键字来访问父类的成员，包括属性和方法。例如：</p><pre><code class="java">class Animal &#123;    String name = &quot;动物&quot;;    public void eat() &#123;        System.out.println(&quot;动物正在吃东西&quot;);    &#125;&#125;class Dog extends Animal &#123;    String name = &quot;旺财&quot;;    public void showInfo() &#123;        // 访问父类的属性        System.out.println(super.name);        // 调用父类的方法        super.eat();    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.showInfo();    &#125;&#125;</code></pre><p>在 <code>Dog</code> 类的 <code>showInfo()</code> 方法中，使用 <code>super.name</code> 访问了父类的 <code>name</code> 属性，使用 <code>super.eat()</code> 调用了父类的 <code>eat()</code> 方法。</p><p><strong>方法重写（Override）</strong></p><p>子类可以重写父类的方法，即子类提供与父类方法具有相同名称、参数列表和返回类型的方法实现。重写方法时，需要使用 <code>@Override</code> 注解来确保重写的正确性。例如：</p><pre><code class="java">class Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;class Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.makeSound();    &#125;&#125;</code></pre><p>在上述代码中，<code>Dog</code> 类重写了 <code>Animal</code> 类的 <code>makeSound()</code> 方法，当调用 <code>dog.makeSound()</code> 时，会执行 <code>Dog</code> 类中重写后的方法。</p><p><strong>构造方法的继承</strong></p><p>子类不会继承父类的构造方法，但子类的构造方法中会默认调用父类的无参构造方法。如果父类没有无参构造方法，子类的构造方法中必须使用 <code>super()</code> 显式调用父类的有参构造方法。例如：</p><pre><code class="java">class Animal &#123;    String name;    public Animal(String name) &#123;        this.name = name;    &#125;&#125;class Dog extends Animal &#123;    public Dog(String name) &#123;        // 显式调用父类的构造方法        super(name);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog(&quot;旺财&quot;);        System.out.println(dog.name);    &#125;&#125;</code></pre><p>在 <code>Dog</code> 类的构造方法中，使用 <code>super(name)</code> 调用了父类 <code>Animal</code> 的构造方法，以初始化从父类继承的 <code>name</code> 属性。</p><h4 id="父类构造器"><a href="#父类构造器" class="headerlink" title="父类构造器"></a>父类构造器</h4><p><img src="/../images/java/1740923961213.png" alt="1740923961213"></p><h4 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h4><p><img src="/../images/java/1740924652916.png" alt="1740924652916"></p><p> 需注意的是，<code>super()</code> 调用父类构造方法的语句必须是子类构造方法中的第一条语句。 </p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p><img src="/../images/java/1741005932153.png" alt="1741005932153"></p><h5 id="定义和基本语法"><a href="#定义和基本语法" class="headerlink" title="定义和基本语法"></a>定义和基本语法</h5><p>方法重写是指在子类中定义一个与父类中具有相同名称、参数列表和返回类型的方法。子类通过重写父类的方法，可以提供自己的实现逻辑。其基本语法如下：</p><pre><code class="java">// 父类class Parent &#123;    public void display() &#123;        System.out.println(&quot;这是父类的 display 方法&quot;);    &#125;&#125;// 子类class Child extends Parent &#123;    @Override    public void display() &#123;        System.out.println(&quot;这是子类重写后的 display 方法&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Child child = new Child();        child.display();     &#125;&#125;</code></pre><p>在上述代码中，<code>Child</code> 类重写了 <code>Parent</code> 类的 <code>display</code> 方法。当调用 <code>child.display()</code> 时，会执行子类中重写后的方法。</p><h5 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h5><ol><li><strong>方法签名必须相同</strong>：方法名、参数列表必须与父类中被重写的方法完全一致。</li><li><strong>返回类型必须兼容</strong>：子类重写方法的返回类型必须与父类被重写方法的返回类型相同，或者是其子类型（从 Java 5 开始支持协变返回类型）。 </li><li><strong>访问修饰符限制</strong>：子类重写方法的访问修饰符不能比父类被重写方法的访问修饰符更严格。例如，如果父类方法是 <code>public</code> 的，子类重写方法不能是 <code>protected</code> 或 <code>private</code> 的。 </li><li><strong>异常抛出限制</strong>：子类重写方法抛出的异常不能比父类被重写方法抛出的异常更宽泛。即子类重写方法可以不抛出异常，或者抛出与父类相同的异常，或者抛出父类异常的子类异常。</li></ol><h5 id="Override-注解"><a href="#Override-注解" class="headerlink" title="@Override 注解"></a><code>@Override</code> 注解</h5><p><code>@Override</code> 是 Java 中的一个注解，用于显式地表明一个方法是重写父类的方法。虽然这个注解不是必需的，但使用它可以让编译器进行检查，如果方法不符合重写规则，编译器会报错，有助于避免一些潜在的错误。例如：</p><pre><code class="java">class Parent &#123;    public void test() &#123;        System.out.println(&quot;父类的 test 方法&quot;);    &#125;&#125;class Child extends Parent &#123;    // 若此处方法名拼写错误，使用 @Override 注解编译器会报错    @Override    public void test() &#123;        System.out.println(&quot;子类重写的 test 方法&quot;);    &#125;&#125;</code></pre><h5 id="调用父类被重写的方法"><a href="#调用父类被重写的方法" class="headerlink" title="调用父类被重写的方法"></a>调用父类被重写的方法</h5><p>在子类的重写方法中，可以使用 <code>super</code> 关键字来调用父类被重写的方法。例如：</p><pre><code class="java">class Parent &#123;    public void show() &#123;        System.out.println(&quot;父类的 show 方法&quot;);    &#125;&#125;class Child extends Parent &#123;    @Override    public void show() &#123;        super.show();         System.out.println(&quot;子类重写的 show 方法&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Child child = new Child();        child.show();    &#125;&#125;</code></pre><p>在 <code>Child</code> 类的 <code>show</code> 方法中，使用 <code>super.show()</code> 调用了父类的 <code>show</code> 方法，然后再执行子类自己的逻辑。</p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p><img src="/../images/java/1741006598498.png" alt="1741006598498"></p><p><img src="/../images/java/1741007322051.png" alt="1741007322051"></p><h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><p><strong>定义</strong></p><p>静态代码块是用花括号 <code>&#123;&#125;</code> 括起来的一段代码，但它使用 <code>static</code> 关键字修饰，并且直接定义在类中。示例如下：</p><pre><code class="java">public class StaticBlockExample &#123;    // 静态代码块    static &#123;        System.out.println(&quot;这是静态代码块&quot;);    &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;这是 main 方法&quot;);    &#125;&#125;</code></pre><p><strong>执行时机</strong></p><p>静态代码块在类被加载时执行，并且只执行一次。类的加载是在程序运行过程中，当第一次使用该类时（如创建对象、调用静态方法、访问静态属性等）由 Java 虚拟机（JVM）进行的操作。</p><h5 id="普通代码块（实例代码块）"><a href="#普通代码块（实例代码块）" class="headerlink" title="普通代码块（实例代码块）"></a>普通代码块（实例代码块）</h5><p><strong>定义</strong></p><p>普通代码块是用花括号 <code>&#123;&#125;</code> 括起来的一段代码，它没有任何修饰符，并且直接定义在类中，但不在任何方法内部。示例如下：</p><pre><code class="java">public class InstanceBlockExample &#123;    // 普通代码块    &#123;        System.out.println(&quot;这是普通代码块&quot;);    &#125;    public InstanceBlockExample() &#123;        System.out.println(&quot;这是构造方法&quot;);    &#125;    public static void main(String[] args) &#123;        InstanceBlockExample obj = new InstanceBlockExample();    &#125;&#125;</code></pre><p><strong>执行时机</strong></p><p>普通代码块会在创建对象时执行，并且在构造方法之前执行。如果创建多个对象，普通代码块会在每次创建对象时都执行一次。</p><p><strong>使用场景</strong></p><p>普通代码块常用于在创建对象时进行一些通用的初始化操作，这些操作可能在多个构造方法中都需要执行，将其放在普通代码块中可以避免代码重复。例如：</p><pre><code class="java">public class Person &#123;    private String name;    private int age;    &#123;        // 初始化日志记录等操作        System.out.println(&quot;开始创建 Person 对象&quot;);    &#125;    public Person() &#123;        this.name = &quot;Unknown&quot;;        this.age = 0;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;</code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><img src="/../images/java/1741180690729.png" alt="1741180690729"></p><p><strong><code>instanceOf</code> 判断</strong></p><p><img src="/../images/java/1741181812077.png" alt="1741181812077"></p><p><strong>多态的概念</strong></p><p>多态意味着一个对象可以有多种形态。具体来说，在程序运行时，同一个方法调用可以根据实际对象的类型产生不同的行为。多态通过将父类类型的引用指向子类对象，在调用方法时根据实际对象的类型来确定执行哪个子类的方法。</p><p><strong>实现多态的条件</strong></p><ol><li><strong>继承关系</strong>：需要有父类和子类之间的继承关系。</li><li><strong>方法重写</strong>：子类需要重写父类的方法，以实现不同的行为。</li><li><strong>父类引用指向子类对象</strong>：使用父类类型的引用指向子类的对象，通过该引用调用重写的方法。</li></ol><p><strong>多态的实现方式</strong></p><p><strong>1.基于继承的多态</strong></p><p>通过子类继承父类，并重写父类的方法，然后使用父类引用指向子类对象来实现多态。</p><pre><code class="java">// 定义父类 Animalclass Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;// 定义子类 Dog，继承自 Animalclass Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;// 定义子类 Cat，继承自 Animalclass Cat extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;public class PolymorphismExample &#123;    public static void main(String[] args) &#123;        // 父类引用指向子类对象        Animal dog = new Dog();        Animal cat = new Cat();        // 调用重写的方法，实现多态        dog.makeSound();         cat.makeSound();     &#125;&#125;</code></pre><p><strong>代码解释</strong>：</p><ul><li><code>Animal</code> 是父类，包含一个 <code>makeSound</code> 方法。</li><li><code>Dog</code> 和 <code>Cat</code> 是 <code>Animal</code> 的子类，分别重写了 <code>makeSound</code> 方法。</li><li>在 <code>main</code> 方法中，使用 <code>Animal</code> 类型的引用指向 <code>Dog</code> 和 <code>Cat</code> 对象，调用 <code>makeSound</code> 方法时，根据实际对象的类型执行相应的方法。</li></ul><p><strong>2. 基于接口的多态</strong></p><p>通过实现接口，不同的类可以实现相同的接口方法，然后使用接口类型的引用指向实现类的对象来实现多态。</p><pre><code class="java">// 定义接口 Shapeinterface Shape &#123;    double area();&#125;// 定义实现类 Circle，实现 Shape 接口class Circle implements Shape &#123;    private double radius;    public Circle(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double area() &#123;        return Math.PI * radius * radius;    &#125;&#125;// 定义实现类 Rectangle，实现 Shape 接口class Rectangle implements Shape &#123;    private double length;    private double width;    public Rectangle(double length, double width) &#123;        this.length = length;        this.width = width;    &#125;    @Override    public double area() &#123;        return length * width;    &#125;&#125;public class InterfacePolymorphismExample &#123;    public static void main(String[] args) &#123;        // 接口引用指向实现类对象        Shape circle = new Circle(5);        Shape rectangle = new Rectangle(4, 6);        // 调用接口方法，实现多态        System.out.println(&quot;圆的面积: &quot; + circle.area());        System.out.println(&quot;矩形的面积: &quot; + rectangle.area());    &#125;&#125;</code></pre><p><strong>代码解释</strong>：</p><ul><li><code>Shape</code> 是一个接口，定义了一个抽象方法 <code>area</code>。</li><li><code>Circle</code> 和 <code>Rectangle</code> 是实现 <code>Shape</code> 接口的类，分别实现了 <code>area</code> 方法。</li><li>在 <code>main</code> 方法中，使用 <code>Shape</code> 类型的引用指向 <code>Circle</code> 和 <code>Rectangle</code> 对象，调用 <code>area</code> 方法时，根据实际对象的类型执行相应的方法。</li></ul><p><strong>强制向下转型</strong></p><p>可以调用子类属性和子类特有方法。</p><p><img src="/../images/java/1741181653325.png" alt="1741181653325"></p><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a><strong>多态数组</strong></h4><p><img src="/../images/java/1741181900887.png" alt="1741181900887"></p><h5 id="基于继承的多态数组"><a href="#基于继承的多态数组" class="headerlink" title="基于继承的多态数组"></a>基于继承的多态数组</h5><p>示例代码</p><pre><code class="java">// 定义父类 Animalclass Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;// 定义子类 Dog，继承自 Animalclass Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;// 定义子类 Cat，继承自 Animalclass Cat extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;public class InheritancePolymorphicArray &#123;    public static void main(String[] args) &#123;        // 创建一个 Animal 类型的数组，该数组可以存储 Animal 及其子类的对象        Animal[] animals = new Animal[2];        animals[0] = new Dog();        animals[1] = new Cat();        // 遍历数组，调用 makeSound 方法，实现多态        for (Animal animal : animals) &#123;            animal.makeSound();        &#125;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ol><li><strong>定义父类和子类</strong>：定义了一个父类 <code>Animal</code>，其中包含 <code>makeSound</code> 方法。<code>Dog</code> 和 <code>Cat</code> 类继承自 <code>Animal</code> 类，并重写了 <code>makeSound</code> 方法，以实现不同的行为。</li><li><strong>创建多态数组</strong>：创建了一个 <code>Animal</code> 类型的数组 <code>animals</code>，该数组可以存储 <code>Animal</code> 类及其子类的对象。</li><li><strong>存储不同子类对象</strong>：将 <code>Dog</code> 和 <code>Cat</code> 类的对象分别存储到数组的不同位置。</li><li><strong>遍历数组并调用方法</strong>：使用增强 <code>for</code> 循环遍历数组，调用 <code>makeSound</code> 方法。由于数组元素是 <code>Animal</code> 类型的引用，但实际指向的是 <code>Dog</code> 和 <code>Cat</code> 对象，因此会根据实际对象的类型调用相应的 <code>makeSound</code> 方法，实现多态。</li></ol><h5 id="基于接口的多态数组"><a href="#基于接口的多态数组" class="headerlink" title="基于接口的多态数组"></a>基于接口的多态数组</h5><p>示例代码</p><pre><code class="java">// 定义接口 Shapeinterface Shape &#123;    double area();&#125;// 定义实现类 Circle，实现 Shape 接口class Circle implements Shape &#123;    private double radius;    public Circle(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double area() &#123;        return Math.PI * radius * radius;    &#125;&#125;// 定义实现类 Rectangle，实现 Shape 接口class Rectangle implements Shape &#123;    private double length;    private double width;    public Rectangle(double length, double width) &#123;        this.length = length;        this.width = width;    &#125;    @Override    public double area() &#123;        return length * width;    &#125;&#125;public class InterfacePolymorphicArray &#123;    public static void main(String[] args) &#123;        // 创建一个 Shape 类型的数组，该数组可以存储实现 Shape 接口的类的对象        Shape[] shapes = new Shape[2];        shapes[0] = new Circle(5);        shapes[1] = new Rectangle(4, 6);        // 遍历数组，调用 area 方法，实现多态        for (Shape shape : shapes) &#123;            System.out.println(&quot;该图形的面积是: &quot; + shape.area());        &#125;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ol><li><strong>定义接口和实现类</strong>：定义了一个接口 <code>Shape</code>，其中包含抽象方法 <code>area</code>。<code>Circle</code> 和 <code>Rectangle</code> 类实现了 <code>Shape</code> 接口，并实现了 <code>area</code> 方法，以计算不同形状的面积。</li><li><strong>创建多态数组</strong>：创建了一个 <code>Shape</code> 类型的数组 <code>shapes</code>，该数组可以存储实现 <code>Shape</code> 接口的类的对象。</li><li><strong>存储不同实现类对象</strong>：将 <code>Circle</code> 和 <code>Rectangle</code> 类的对象分别存储到数组的不同位置。</li><li><strong>遍历数组并调用方法</strong>：使用增强 <code>for</code> 循环遍历数组，调用 <code>area</code> 方法。由于数组元素是 <code>Shape</code> 类型的引用，但实际指向的是 <code>Circle</code> 和 <code>Rectangle</code> 对象，因此会根据实际对象的类型调用相应的 <code>area</code> 方法，实现多态。</li></ol><h4 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h4><p><img src="/../images/java/1741182900629.png" alt="1741182900629"></p><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>在 Java 中，当通过父类引用调用一个被重写的方法时，编译阶段编译器会根据引用的类型（即父类类型）来检查方法是否存在，但在运行阶段，Java 虚拟机（JVM）会根据引用实际指向的对象类型（即子类类型）来决定调用哪个类的方法。这种在运行时确定调用方法的机制就是动态绑定。</p><h5 id="实现动态绑定的条件"><a href="#实现动态绑定的条件" class="headerlink" title="实现动态绑定的条件"></a>实现动态绑定的条件</h5><ol><li><strong>继承关系</strong>：存在父类和子类的继承关系，子类继承自父类。</li><li><strong>方法重写</strong>：子类重写了父类的方法，即子类定义了与父类中具有相同签名（方法名、参数列表和返回类型）的方法。</li><li><strong>父类引用指向子类对象</strong>：使用父类类型的引用变量来引用子类的对象。</li></ol><p>示例代码</p><pre><code class="java">// 定义父类 Animalclass Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;// 定义子类 Dog，继承自 Animalclass Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;// 定义子类 Cat，继承自 Animalclass Cat extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;public class DynamicBindingExample &#123;    public static void main(String[] args) &#123;        // 父类引用指向子类对象        Animal dog = new Dog();        Animal cat = new Cat();        // 调用 makeSound 方法，发生动态绑定        dog.makeSound();        cat.makeSound();    &#125;&#125;</code></pre><p>代码解释</p><ol><li><strong>定义父类和子类</strong>：定义了一个父类 <code>Animal</code>，其中包含 <code>makeSound</code> 方法。<code>Dog</code> 和 <code>Cat</code> 类继承自 <code>Animal</code> 类，并重写了 <code>makeSound</code> 方法，以实现不同的行为。</li><li><strong>父类引用指向子类对象</strong>：在 <code>main</code> 方法中，创建了 <code>Animal</code> 类型的引用变量 <code>dog</code> 和 <code>cat</code>，分别指向 <code>Dog</code> 和 <code>Cat</code> 类的对象。</li><li><strong>动态绑定过程</strong>：<ul><li>编译阶段：编译器根据引用类型 <code>Animal</code> 检查 <code>makeSound</code> 方法是否存在，由于 <code>Animal</code> 类中定义了该方法，编译通过。</li><li>运行阶段：JVM 根据引用实际指向的对象类型（<code>Dog</code> 或 <code>Cat</code>）来决定调用哪个类的 <code>makeSound</code> 方法。因此，<code>dog.makeSound()</code> 会调用 <code>Dog</code> 类的 <code>makeSound</code> 方法，输出 “汪汪汪”；<code>cat.makeSound()</code> 会调用 <code>Cat</code> 类的 <code>makeSound</code> 方法，输出 “喵喵喵”。</li></ul></li></ol><p><strong>注意事项</strong></p><ul><li><strong>静态方法和私有方法不参与动态绑定</strong>：静态方法属于类，而不是对象，它们在编译时就已经确定了调用关系，不依赖于对象的实际类型。私有方法不能被重写，因此也不会发生动态绑定。例如：</li></ul><pre><code class="java">class Parent &#123;    public static void staticMethod() &#123;        System.out.println(&quot;父类的静态方法&quot;);    &#125;    private void privateMethod() &#123;        System.out.println(&quot;父类的私有方法&quot;);    &#125;&#125;class Child extends Parent &#123;    public static void staticMethod() &#123;        System.out.println(&quot;子类的静态方法&quot;);    &#125;    // 这里并不是重写父类的私有方法，因为私有方法不能被重写    private void privateMethod() &#123;        System.out.println(&quot;子类的私有方法&quot;);    &#125;&#125;public class StaticAndPrivateMethodExample &#123;    public static void main(String[] args) &#123;        Parent parent = new Child();        parent.staticMethod(); // 调用父类的静态方法        // parent.privateMethod(); // 编译错误，私有方法不能被外部访问    &#125;&#125;</code></pre><p>在上述代码中，<code>staticMethod</code> 是静态方法，<code>parent.staticMethod()</code> 调用的是父类的静态方法，而不是子类的静态方法；<code>privateMethod</code> 是私有方法，不参与动态绑定。</p><h5 id="静态属性和方法的-“继承”-与实例属性和方法继承的区别"><a href="#静态属性和方法的-“继承”-与实例属性和方法继承的区别" class="headerlink" title="静态属性和方法的 “继承” 与实例属性和方法继承的区别"></a>静态属性和方法的 “继承” 与实例属性和方法继承的区别</h5><p><strong>方法重写方面</strong></p><p>普通的实例方法可以在子类中被重写（override），实现多态；而静态方法不能被重写，当子类中定义了和父类相同签名的静态方法时，这被称为方法隐藏（method hiding），而不是方法重写。</p><p><strong>调用时的绑定机制</strong></p><p>实例方法的调用是动态绑定的，在运行时根据对象的实际类型来确定调用哪个类的方法；而静态方法的调用是静态绑定的，在编译时就根据引用类型确定要调用的方法。</p><h3 id="默认父类方法"><a href="#默认父类方法" class="headerlink" title="默认父类方法"></a>默认父类方法</h3><p><img src="/../images/java/1741185187271.png" alt="1741185187271"></p><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p><img src="/../images/java/1741185171198.png" alt="1741185171198"></p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p><img src="/../images/java/1741185982777.png" alt="1741185982777"></p><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p><img src="/../images/java/1741185995421.png" alt="1741185995421"></p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><img src="/../images/java/1741254352036.png" alt="1741254352036"></p><h4 id="定义抽象类"><a href="#定义抽象类" class="headerlink" title="定义抽象类"></a>定义抽象类</h4><p>在 Java 中，使用 <code>abstract</code> 关键字来定义抽象类。抽象类不能被实例化，也就是不能使用 <code>new</code> 关键字来创建抽象类的对象，它主要用于被其他类继承。</p><pre><code class="java">// 定义一个抽象类 Animalabstract class Animal &#123;    // 成员变量    protected String name;    // 构造方法    public Animal(String name) &#123;        this.name = name;    &#125;    // 普通方法    public void eat() &#123;        System.out.println(name + &quot; 正在吃东西&quot;);    &#125;    // 抽象方法，没有方法体    public abstract void makeSound();&#125;</code></pre><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>抽象类中可以包含抽象方法，抽象方法使用 <code>abstract</code> 关键字修饰，并且没有方法体。抽象方法的作用是定义一个规范，要求子类必须实现这个方法。</p><pre><code class="java">// 抽象方法示例public abstract void makeSound();</code></pre><h4 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h4><p>子类继承抽象类时，必须实现抽象类中的所有抽象方法，否则子类也必须被声明为抽象类。</p><pre><code class="java">// 定义 Dog 类继承自 Animal 抽象类class Dog extends Animal &#123;    public Dog(String name) &#123;        super(name);    &#125;    // 实现抽象方法 makeSound    @Override    public void makeSound() &#123;        System.out.println(name + &quot; 汪汪叫&quot;);    &#125;&#125;// 定义 Cat 类继承自 Animal 抽象类class Cat extends Animal &#123;    public Cat(String name) &#123;        super(name);    &#125;    // 实现抽象方法 makeSound    @Override    public void makeSound() &#123;        System.out.println(name + &quot; 喵喵叫&quot;);    &#125;&#125;</code></pre><h4 id="使用抽象类"><a href="#使用抽象类" class="headerlink" title="使用抽象类"></a>使用抽象类</h4><p>虽然抽象类不能被实例化，但可以使用抽象类的引用指向子类的对象，从而实现多态。</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        // 抽象类的引用指向子类对象        Animal dog = new Dog(&quot;旺财&quot;);        Animal cat = new Cat(&quot;咪咪&quot;);        // 调用普通方法        dog.eat();        cat.eat();        // 调用抽象方法（多态）        dog.makeSound();        cat.makeSound();    &#125;&#125;</code></pre><h4 id="抽象类的特点和使用场景"><a href="#抽象类的特点和使用场景" class="headerlink" title="抽象类的特点和使用场景"></a>抽象类的特点和使用场景</h4><ul><li><strong>特点</strong><ul><li><strong>不能实例化</strong>：抽象类不能使用 <code>new</code> 关键字创建对象，只能作为父类被继承。</li><li><strong>可以包含抽象方法和普通方法</strong>：抽象类中既可以有抽象方法，也可以有普通方法，这样可以提供一些通用的实现，同时要求子类实现特定的行为。</li><li><strong>构造方法</strong>：抽象类可以有构造方法，用于初始化成员变量，但不能通过构造方法直接创建抽象类的对象，构造方法主要用于子类调用。</li></ul></li><li><strong>使用场景</strong><ul><li><strong>定义通用行为和规范</strong>：当多个类有一些共同的行为和属性时，可以将这些共同的部分提取到抽象类中，同时定义一些抽象方法，要求子类根据自身的特点去实现这些方法。</li><li><strong>实现多态</strong>：通过抽象类的引用指向子类的对象，可以实现多态，提高代码的灵活性和可扩展性。</li></ul></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="/../images/java/1741265807966.png" alt="1741265807966"></p><p><img src="/../images/java/1741266765499.png" alt="1741266765499"></p><h4 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h4><p>在 Java 中，使用 <code>interface</code> 关键字来定义接口，接口中的方法默认是 <code>public abstract</code> 类型（即抽象方法），字段默认是 <code>public static final</code> 类型（即常量）。</p><pre><code class="java">// 定义一个接口 Animalinterface Animal &#123;    // 常量    int LEGS = 4;    // 抽象方法    void eat();    void makeSound();&#125;</code></pre><ul><li><strong>不能实例化</strong>：接口不能使用 <code>new</code> 关键字创建对象，它主要用于被类实现或者被其他接口继承。</li><li><strong>抽象方法</strong>：接口中的方法默认是抽象方法，不需要使用 <code>abstract</code> 关键字修饰，而且这些方法必须由实现类来实现。</li><li><strong>常量</strong>：接口中的字段默认是常量，即 <code>public static final</code> 类型，必须在定义时进行初始化，且初始化后不能再修改。</li><li><strong>多实现</strong>：一个类可以实现多个接口，从而实现多重继承的效果，这弥补了 Java 类只能单继承的局限性。</li></ul><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><p>类通过 <code>implements</code> 关键字来实现接口，实现接口的类必须实现接口中定义的所有抽象方法。</p><pre><code class="java">// 定义 Dog 类实现 Animal 接口class Dog implements Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;狗在吃东西&quot;);    &#125;    @Override    public void makeSound() &#123;        System.out.println(&quot;狗汪汪叫&quot;);    &#125;&#125;// 定义 Cat 类实现 Animal 接口class Cat implements Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;猫在吃东西&quot;);    &#125;    @Override    public void makeSound() &#123;        System.out.println(&quot;猫喵喵叫&quot;);    &#125;&#125;</code></pre><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>接口可以继承其他接口，使用 <code>extends</code> 关键字，一个接口可以继承多个接口。</p><pre><code class="java">// 定义一个新的接口 Pet，继承自 Animal 接口interface Pet extends Animal &#123;    void play();&#125;// 定义 Dog 类实现 Pet 接口class Dog implements Pet &#123;    @Override    public void eat() &#123;        System.out.println(&quot;狗在吃东西&quot;);    &#125;    @Override    public void makeSound() &#123;        System.out.println(&quot;狗汪汪叫&quot;);    &#125;    @Override    public void play() &#123;        System.out.println(&quot;狗在玩耍&quot;);    &#125;&#125;</code></pre><h4 id="接口的使用场景"><a href="#接口的使用场景" class="headerlink" title="接口的使用场景"></a>接口的使用场景</h4><ul><li><strong>定义规范</strong>：接口可以定义一组规范，让不同的类去实现这些规范，从而保证这些类具有相同的行为。例如，Java 中的 <code>Runnable</code> 接口，任何实现该接口的类都必须实现 <code>run</code> 方法，这样就可以将这些类的对象作为线程任务来执行。</li><li><strong>实现多态</strong>：通过接口的引用指向实现类的对象，可以实现多态，提高代码的灵活性和可扩展性。</li></ul><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        // 接口的引用指向实现类对象        Animal dog = new Dog();        Animal cat = new Cat();        // 调用接口方法（多态）        dog.eat();        dog.makeSound();        cat.eat();        cat.makeSound();    &#125;&#125;</code></pre><h4 id="Java-8-及以后接口的新特性"><a href="#Java-8-及以后接口的新特性" class="headerlink" title="Java 8 及以后接口的新特性"></a>Java 8 及以后接口的新特性</h4><ul><li><strong>默认方法</strong>：Java 8 引入了默认方法，使用 <code>default</code> 关键字修饰，默认方法可以有方法体，实现类可以选择是否重写默认方法。</li></ul><pre><code class="java">interface Animal &#123;    void eat();    void makeSound();    // 默认方法    default void sleep() &#123;        System.out.println(&quot;动物在睡觉&quot;);    &#125;&#125;</code></pre><ul><li><strong>静态方法</strong>：Java 8 还允许接口中定义静态方法，静态方法使用 <code>static</code> 关键字修饰，通过接口名直接调用。</li></ul><pre><code class="java">interface Animal &#123;    void eat();    void makeSound();    // 静态方法    static void info() &#123;        System.out.println(&quot;这是一个动物接口&quot;);    &#125;&#125;</code></pre><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><img src="/../images/java/1741351878282.png" alt="1741351878282"></p><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p><img src="/../images/java/1741352159174.png" alt="1741352159174"></p><h5 id="定义成员内部类"><a href="#定义成员内部类" class="headerlink" title="定义成员内部类"></a>定义成员内部类</h5><p>成员内部类的定义语法很简单，在外部类的内部直接定义一个新的类即</p><pre><code class="java">// 外部类class Outer &#123;    // 成员内部类    class Inner &#123;        // 内部类的方法        public void innerMethod() &#123;            System.out.println(&quot;这是成员内部类的方法&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="创建成员内部类的对象"><a href="#创建成员内部类的对象" class="headerlink" title="创建成员内部类的对象"></a>创建成员内部类的对象</h5><p>要创建成员内部类的对象，必须先创建外部类的对象，因为成员内部类依赖于外部类的实例存在。创建成员内部类对象的语法如下：</p><pre><code class="java">// 创建外部类对象Outer outer = new Outer();// 通过外部类对象创建成员内部类对象Outer.Inner inner = outer.new Inner();</code></pre><h5 id="成员内部类访问外部类成员"><a href="#成员内部类访问外部类成员" class="headerlink" title="成员内部类访问外部类成员"></a>成员内部类访问外部类成员</h5><p>成员内部类可以访问外部类的所有成员，包括私有成员。</p><pre><code class="java">// 外部类class Outer &#123;    private int outerVariable = 10;    // 成员内部类    class Inner &#123;        public void accessOuterVariable() &#123;            // 访问外部类的私有成员            System.out.println(&quot;外部类的私有变量值: &quot; + outerVariable);        &#125;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        Outer.Inner inner = outer.new Inner();        inner.accessOuterVariable();    &#125;&#125;</code></pre><h5 id="外部类访问成员内部类成员"><a href="#外部类访问成员内部类成员" class="headerlink" title="外部类访问成员内部类成员"></a>外部类访问成员内部类成员</h5><p>外部类也可以访问成员内部类的成员，但需要先创建成员内部类的对象。</p><pre><code class="java">// 外部类class Outer &#123;    // 成员内部类    class Inner &#123;        private int innerVariable = 20;        public void innerMethod() &#123;            System.out.println(&quot;这是成员内部类的方法&quot;);        &#125;    &#125;    public void accessInnerMembers() &#123;        Inner inner = new Inner();        // 访问成员内部类的私有变量        System.out.println(&quot;成员内部类的私有变量值: &quot; + inner.innerVariable);        // 调用成员内部类的方法        inner.innerMethod();    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        outer.accessInnerMembers();    &#125;&#125;</code></pre><h5 id="成员内部类的特点"><a href="#成员内部类的特点" class="headerlink" title="成员内部类的特点"></a>成员内部类的特点</h5><ol><li><strong>依赖外部类实例</strong>：成员内部类的对象必须依赖于外部类的对象才能创建，因为它隐式地持有一个对外部类对象的引用。</li><li><strong>访问外部类成员</strong>：可以访问外部类的所有成员，包括私有成员和静态成员。</li><li><strong>编译后生成独立的.class 文件</strong>：成员内部类编译后会生成独立的 <code>.class</code> 文件，文件名格式为 <code>外部类名$内部类名.class</code>。</li></ol><h5 id="成员内部类的使用场景"><a href="#成员内部类的使用场景" class="headerlink" title="成员内部类的使用场景"></a>成员内部类的使用场景</h5><ol><li><strong>实现多继承效果</strong>：由于 Java 不支持类的多重继承，但通过成员内部类可以在一定程度上实现类似多重继承的效果，一个类可以通过成员内部类继承其他类。</li><li><strong>封装细节</strong>：当一个类的某些功能只与该类的其他成员密切相关，并且不希望被外部直接访问时，可以将这些功能封装在成员内部类中。</li><li><strong>事件处理</strong>：在 GUI 编程中，成员内部类常被用于处理事件，例如按钮点击事件等。</li></ol><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p><img src="/../images/java/1741501103771.png" alt="1741501103771"></p><h5 id="定义静态内部类"><a href="#定义静态内部类" class="headerlink" title="定义静态内部类"></a>定义静态内部类</h5><p>静态内部类的定义和普通内部类类似，只是在类定义前加上 <code>static</code> 关键字。示例代码如下：</p><pre><code class="java">// 外部类class OuterClass &#123;    // 静态内部类    static class StaticInnerClass &#123;        public void display() &#123;            System.out.println(&quot;这是静态内部类的方法&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="创建静态内部类的对象"><a href="#创建静态内部类的对象" class="headerlink" title="创建静态内部类的对象"></a>创建静态内部类的对象</h5><p>静态内部类不依赖于外部类的实例，因此可以直接创建静态内部类的对象，不需要先创建外部类的对象。创建对象的语法如下：</p><pre><code class="java">OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();</code></pre><p>完整示例代码如下：</p><pre><code class="java">class OuterClass &#123;    static class StaticInnerClass &#123;        public void display() &#123;            System.out.println(&quot;这是静态内部类的方法&quot;);        &#125;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();        inner.display();    &#125;&#125;</code></pre><h5 id="静态内部类的访问规则"><a href="#静态内部类的访问规则" class="headerlink" title="静态内部类的访问规则"></a>静态内部类的访问规则</h5><h6 id="访问外部类成员"><a href="#访问外部类成员" class="headerlink" title="访问外部类成员"></a>访问外部类成员</h6><p>静态内部类只能直接访问外部类的静态成员（静态变量和静态方法），不能直接访问外部类的非静态成员。如果要访问外部类的非静态成员，需要先创建外部类的对象。示例代码如下：</p><pre><code class="java">class OuterClass &#123;    private static int staticVariable = 10;    private int nonStaticVariable = 20;    static class StaticInnerClass &#123;        public void accessOuterMembers() &#123;            // 可以直接访问外部类的静态成员            System.out.println(&quot;外部类的静态变量: &quot; + staticVariable);            // 不能直接访问外部类的非静态成员，需要创建外部类对象            OuterClass outer = new OuterClass();            System.out.println(&quot;外部类的非静态变量: &quot; + outer.nonStaticVariable);        &#125;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();        inner.accessOuterMembers();    &#125;&#125;</code></pre><h6 id="外部类访问静态内部类成员"><a href="#外部类访问静态内部类成员" class="headerlink" title="外部类访问静态内部类成员"></a>外部类访问静态内部类成员</h6><p>外部类可以直接访问静态内部类的静态成员，如果要访问静态内部类的非静态成员，需要创建静态内部类的对象。示例代码如下：</p><pre><code class="java">class OuterClass &#123;    static class StaticInnerClass &#123;        private static int staticInnerVariable = 30;        private int nonStaticInnerVariable = 40;        public static void staticInnerMethod() &#123;            System.out.println(&quot;静态内部类的静态方法&quot;);        &#125;        public void nonStaticInnerMethod() &#123;            System.out.println(&quot;静态内部类的非静态方法&quot;);        &#125;    &#125;    public void accessInnerMembers() &#123;        // 直接访问静态内部类的静态成员        System.out.println(&quot;静态内部类的静态变量: &quot; + StaticInnerClass.staticInnerVariable);        StaticInnerClass.staticInnerMethod();        // 创建静态内部类对象访问其非静态成员        StaticInnerClass inner = new StaticInnerClass();        System.out.println(&quot;静态内部类的非静态变量: &quot; + inner.nonStaticInnerVariable);        inner.nonStaticInnerMethod();    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        OuterClass outer = new OuterClass();        outer.accessInnerMembers();    &#125;&#125;</code></pre><h5 id="静态内部类的特点"><a href="#静态内部类的特点" class="headerlink" title="静态内部类的特点"></a>静态内部类的特点</h5><ol><li><strong>不依赖外部类实例</strong>：静态内部类不持有外部类对象的引用，它的创建不依赖于外部类的实例，这使得它在内存使用和独立性上有一定优势。</li><li><strong>只能访问外部类静态成员</strong>：由于静态内部类不依赖外部类实例，所以只能直接访问外部类的静态成员。</li><li><strong>编译后生成独立的.class 文件</strong>：静态内部类编译后会生成独立的 <code>.class</code> 文件，文件名格式为 <code>外部类名$静态内部类名.class</code>。</li></ol><h5 id="静态内部类的使用场景"><a href="#静态内部类的使用场景" class="headerlink" title="静态内部类的使用场景"></a>静态内部类的使用场景</h5><ol><li><strong>封装相关功能</strong>：当一组功能与某个外部类相关，但又不需要访问外部类的非静态成员时，可以将这些功能封装在静态内部类中，提高代码的模块化程度。</li><li><strong>数据结构嵌套</strong>：在实现一些复杂的数据结构时，如树、图等，静态内部类可以用来表示节点等嵌套结构，使代码结构更清晰。</li></ol><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p><img src="/../images/java/1741501971643.png" alt="1741501971643"></p><h5 id="定义局部内部类"><a href="#定义局部内部类" class="headerlink" title="定义局部内部类"></a>定义局部内部类</h5><p>局部内部类定义在方法、构造函数或者代码块内部，其定义语法和普通类类似，但只能在定义它的作用域内使用。以下是在方法内部定义局部内部类的示例：</p><pre><code class="java">public class OuterClass &#123;    public void outerMethod() &#123;        // 局部内部类        class LocalInnerClass &#123;            public void display() &#123;                System.out.println(&quot;这是局部内部类的方法&quot;);            &#125;        &#125;        // 在方法内部创建局部内部类的对象并调用方法        LocalInnerClass inner = new LocalInnerClass();        inner.display();    &#125;&#125;</code></pre><p>在上述代码中，<code>LocalInnerClass</code> 是定义在 <code>outerMethod</code> 方法内部的局部内部类，只能在 <code>outerMethod</code> 方法内部使用。</p><h5 id="局部内部类的特点"><a href="#局部内部类的特点" class="headerlink" title="局部内部类的特点"></a>局部内部类的特点</h5><ol><li><strong>作用域受限</strong>：局部内部类只能在定义它的方法、构造函数或代码块内部使用，出了这个作用域就无法访问。</li><li><strong>访问外部类成员</strong>：局部内部类可以访问外部类的所有成员，包括私有成员。</li><li><strong>访问局部变量</strong>：局部内部类可以访问定义它的方法中的 <code>final</code> 或 <code>effectively final</code>（Java 8 及以后，若变量值在初始化后未被修改，可视为 <code>effectively final</code>）局部变量。</li><li><strong>编译后生成独立的.class 文件</strong>：局部内部类编译后会生成独立的 <code>.class</code> 文件，文件名格式为 <code>外部类名$数字局部内部类名.class</code>，其中数字用于区分不同位置的局部内部类。</li></ol><h5 id="访问规则"><a href="#访问规则" class="headerlink" title="访问规则"></a>访问规则</h5><h6 id="访问外部类成员-1"><a href="#访问外部类成员-1" class="headerlink" title="访问外部类成员"></a>访问外部类成员</h6><p>局部内部类可以直接访问外部类的所有成员，包括私有成员。示例代码如下：</p><pre><code class="java">public class OuterClass &#123;    private int outerVariable = 10;    public void outerMethod() &#123;        class LocalInnerClass &#123;            public void accessOuterVariable() &#123;                // 访问外部类的私有成员                System.out.println(&quot;外部类的私有变量: &quot; + outerVariable);            &#125;        &#125;        LocalInnerClass inner = new LocalInnerClass();        inner.accessOuterVariable();    &#125;&#125;</code></pre><h6 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h6><p>局部内部类可以访问定义它的方法中的 <code>final</code> 或 <code>effectively final</code> 局部变量。示例代码如下：</p><pre><code class="java">public class OuterClass &#123;    public void outerMethod() &#123;        // effectively final 局部变量        int localVar = 20;        class LocalInnerClass &#123;            public void accessLocalVariable() &#123;                // 访问局部变量                System.out.println(&quot;局部变量的值: &quot; + localVar);            &#125;        &#125;        LocalInnerClass inner = new LocalInnerClass();        inner.accessLocalVariable();    &#125;&#125;</code></pre><p>需要注意的是，如果尝试修改 <code>localVar</code> 的值，就会破坏其 <code>effectively final</code> 的特性，局部内部类将无法再访问该变量。</p><h5 id="局部内部类的使用场景"><a href="#局部内部类的使用场景" class="headerlink" title="局部内部类的使用场景"></a>局部内部类的使用场景</h5><ol><li><strong>封装特定逻辑</strong>：当某个功能只在方法内部使用，且该功能有一定的复杂性，需要封装成类时，可以使用局部内部类。</li><li><strong>实现临时接口或抽象类</strong>：在方法内部需要实现某个接口或继承某个抽象类，并且这个实现只在该方法内部使用时，使用局部内部类可以避免创建过多的外部类，使代码更加简洁。</li></ol><h5 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h5><pre><code class="java">public class OuterClass &#123;    private int outerVariable = 10;    public void outerMethod() &#123;        // effectively final 局部变量        int localVar = 20;        // 局部内部类        class LocalInnerClass &#123;            public void accessOuterVariable() &#123;                // 访问外部类的私有成员                System.out.println(&quot;外部类的私有变量: &quot; + outerVariable);            &#125;            public void accessLocalVariable() &#123;                // 访问局部变量                System.out.println(&quot;局部变量的值: &quot; + localVar);            &#125;        &#125;        // 创建局部内部类的对象并调用方法        LocalInnerClass inner = new LocalInnerClass();        inner.accessOuterVariable();        inner.accessLocalVariable();    &#125;    public static void main(String[] args) &#123;        OuterClass outer = new OuterClass();        outer.outerMethod();    &#125;&#125;</code></pre><p>在上述完整示例中，我们展示了局部内部类如何访问外部类的私有成员和方法内的局部变量，同时演示了如何在方法内部创建局部内部类的对象并调用其方法。</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p><img src="/../images/java/1741507808267.png" alt="1741507808267"></p><h5 id="定义与基本语法"><a href="#定义与基本语法" class="headerlink" title="定义与基本语法"></a>定义与基本语法</h5><p>匿名内部类通常用于创建一个实现某个接口或者继承某个类的对象，并且在创建对象的同时实现接口的抽象方法或者重写父类的方法。基本语法如下：</p><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><pre><code class="java">interface MyInterface &#123;    void doSomething();&#125;public class AnonymousInnerClassExample &#123;    public static void main(String[] args) &#123;        // 匿名内部类实现接口        MyInterface myInterface = new MyInterface() &#123;            @Override            public void doSomething() &#123;                System.out.println(&quot;执行接口的方法&quot;);            &#125;        &#125;;        myInterface.doSomething();    &#125;&#125;</code></pre><h5 id="继承类"><a href="#继承类" class="headerlink" title="继承类"></a>继承类</h5><pre><code class="java">class MyClass &#123;    public void display() &#123;        System.out.println(&quot;父类的方法&quot;);    &#125;&#125;public class AnonymousInnerClassExample2 &#123;    public static void main(String[] args) &#123;        // 匿名内部类继承类        MyClass myClass = new MyClass() &#123;            @Override            public void display() &#123;                System.out.println(&quot;重写父类的方法&quot;);            &#125;        &#125;;        myClass.display();    &#125;&#125;</code></pre><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li><strong>没有类名</strong>：匿名内部类没有显式的类名，它的定义和对象的创建是同时进行的。</li><li><strong>一次性使用</strong>：通常用于创建一次性的对象，只在当前使用的地方有效，不会被其他地方复用。</li><li><strong>隐式继承或实现</strong>：匿名内部类必须继承一个类或者实现一个接口，并且只能继承一个类或者实现一个接口。</li><li><strong>访问外部变量</strong>：可以访问外部类的成员变量和方法，对于方法中的局部变量，要求该变量是 <code>final</code> 或 <code>effectively final</code>（Java 8 及以后，若变量值在初始化后未被修改，可视为 <code>effectively final</code>）。</li></ol><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li><strong>事件处理</strong>：在 GUI 编程中，经常使用匿名内部类来处理事件，例如按钮点击事件、鼠标事件等。</li></ol><pre><code class="java">import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class EventHandlingExample &#123;    public static void main(String[] args) &#123;        JFrame frame = new JFrame(&quot;匿名内部类事件处理&quot;);        JButton button = new JButton(&quot;点击我&quot;);        // 匿名内部类处理按钮点击事件        button.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                JOptionPane.showMessageDialog(frame, &quot;按钮被点击了&quot;);            &#125;        &#125;);        frame.add(button);        frame.setSize(300, 200);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        frame.setVisible(true);    &#125;&#125;</code></pre><ol><li><strong>回调机制</strong>：当需要传递一个实现了特定接口的对象作为回调时，可以使用匿名内部类简化代码。</li><li><strong>简化代码</strong>：当某个类只需要使用一次，且实现逻辑比较简单时，使用匿名内部类可以避免创建过多的类文件，使代码更加简洁。</li></ol><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li><strong>构造函数</strong>：由于匿名内部类没有类名，所以不能有显式的构造函数。如果需要进行初始化操作，可以使用实例初始化块。</li></ol><pre><code class="java">abstract class MyAbstractClass &#123;    abstract void display();&#125;public class InitializationExample &#123;    public static void main(String[] args) &#123;        MyAbstractClass myAbstractClass = new MyAbstractClass() &#123;            int value;            // 实例初始化块            &#123;                value = 10;            &#125;            @Override            public void display() &#123;                System.out.println(&quot;值为: &quot; + value);            &#125;        &#125;;        myAbstractClass.display();    &#125;&#125;</code></pre><ol start="2"><li><strong>方法重写</strong>：如果实现接口，必须实现接口中的所有抽象方法；如果继承类，通常需要重写父类的方法来实现特定的逻辑。</li></ol><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p><img src="/../images/java/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-09%20161258.png"></p><h4 id="自定义枚举"><a href="#自定义枚举" class="headerlink" title="自定义枚举"></a>自定义枚举</h4><p><img src="/../images/java/1741509009547.png" alt="1741509009547"></p><h4 id="enum枚举类"><a href="#enum枚举类" class="headerlink" title="enum枚举类"></a>enum枚举类</h4><p><img src="/../images/java/1741509045726.png" alt="1741509045726"></p><h4 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h4><p>使用 <code>enum</code> 关键字来定义枚举类，语法如下：</p><pre><code class="java">enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;</code></pre><p>在上述代码中，<code>Season</code> 是一个枚举类，它包含四个枚举常量：<code>SPRING</code>、<code>SUMMER</code>、<code>AUTUMN</code> 和 <code>WINTER</code>。每个枚举常量都是 <code>Season</code> 类的一个实例。</p><h4 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h4><h5 id="遍历枚举常量"><a href="#遍历枚举常量" class="headerlink" title="遍历枚举常量"></a>遍历枚举常量</h5><p>可以使用 <code>values()</code> 方法获取枚举类的所有枚举常量，并进行遍历。</p><pre><code class="java">enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        // 遍历枚举常量        for (Season season : Season.values()) &#123;            System.out.println(season);        &#125;    &#125;&#125;</code></pre><h5 id="根据名称获取枚举常量"><a href="#根据名称获取枚举常量" class="headerlink" title="根据名称获取枚举常量"></a>根据名称获取枚举常量</h5><p>可以使用 <code>valueOf()</code> 方法根据枚举常量的名称获取对应的枚举实例。</p><pre><code class="java">enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        Season season = Season.valueOf(&quot;SPRING&quot;);        System.out.println(season);    &#125;&#125;</code></pre><h4 id="枚举类的特性"><a href="#枚举类的特性" class="headerlink" title="枚举类的特性"></a>枚举类的特性</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>枚举类可以有构造函数，但构造函数必须是私有的，以确保枚举常量的唯一性。可以为枚举常量添加属性和方法。</p><pre><code class="java">enum Season &#123;    SPRING(&quot;春天&quot;), SUMMER(&quot;夏天&quot;), AUTUMN(&quot;秋天&quot;), WINTER(&quot;冬天&quot;);    private String description;    // 私有构造函数    private Season(String description) &#123;        this.description = description;    &#125;    public String getDescription() &#123;        return description;    &#125;&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        for (Season season : Season.values()) &#123;            System.out.println(season + &quot;: &quot; + season.getDescription());        &#125;    &#125;&#125;</code></pre><h5 id="实现接口-1"><a href="#实现接口-1" class="headerlink" title="实现接口"></a>实现接口</h5><p>枚举类可以实现接口，为每个枚举常量提供不同的实现。</p><pre><code class="java">interface SeasonActivity &#123;    void activity();&#125;enum Season implements SeasonActivity &#123;    SPRING &#123;        @Override        public void activity() &#123;            System.out.println(&quot;春天适合踏青&quot;);        &#125;    &#125;,    SUMMER &#123;        @Override        public void activity() &#123;            System.out.println(&quot;夏天适合游泳&quot;);        &#125;    &#125;,    AUTUMN &#123;        @Override        public void activity() &#123;            System.out.println(&quot;秋天适合赏菊&quot;);        &#125;    &#125;,    WINTER &#123;        @Override        public void activity() &#123;            System.out.println(&quot;冬天适合滑雪&quot;);        &#125;    &#125;;&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        for (Season season : Season.values()) &#123;            season.activity();        &#125;    &#125;&#125;</code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h5><p>在程序中，经常需要表示一些固定的状态，如订单状态（未支付、已支付、已发货等）、用户状态（正常、冻结、注销等），使用枚举类可以使代码更加清晰。</p><pre><code class="java">enum OrderStatus &#123;    UNPAID, PAID, SHIPPED, DELIVERED&#125;public class Order &#123;    private OrderStatus status;    public Order(OrderStatus status) &#123;        this.status = status;    &#125;    public OrderStatus getStatus() &#123;        return status;    &#125;    public static void main(String[] args) &#123;        Order order = new Order(OrderStatus.PAID);        System.out.println(&quot;订单状态: &quot; + order.getStatus());    &#125;&#125;</code></pre><h5 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h5><p>当需要定义一组固定的配置选项时，枚举类也是一个很好的选择，如颜色选项、文件格式等。</p><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>枚举常量默认是 <code>public static final</code> 的，并且是单例的，在整个程序中只有一个实例。</li><li>枚举类不能被继承，但可以实现接口。</li><li>枚举类的 <code>values()</code>、<code>valueOf()</code> 等方法是编译器自动添加的，它们是 <code>java.lang.Enum</code> 类的子类的方法。</li></ul><h4 id="枚举类的相关方法"><a href="#枚举类的相关方法" class="headerlink" title="枚举类的相关方法"></a>枚举类的相关方法</h4><p><img src="/../images/java/1741513183213.png" alt="1741513183213"></p><ol start="2"><li>values()&#96;方法</li></ol><ul><li><strong>作用</strong>：这是编译器为枚举类自动生成的方法，它返回一个包含该枚举类所有枚举常量的数组，数组中元素的顺序就是枚举常量在枚举类中声明的顺序。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        Color[] colors = Color.values();        for (Color color : colors) &#123;            System.out.println(color);        &#125;    &#125;&#125;</code></pre><ol start="3"><li><code>valueOf()</code>方法</li></ol><ul><li><strong>作用</strong>：根据给定的字符串名称返回对应的枚举常量。字符串必须与枚举常量的名称完全匹配（包括大小写），否则会抛出<code>IllegalArgumentException</code>异常。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        Color color = Color.valueOf(&quot;RED&quot;);        System.out.println(color);    &#125;&#125;</code></pre><ol start="4"><li><code>ordinal()</code>方法</li></ol><ul><li><strong>作用</strong>：返回枚举常量在枚举类中的声明顺序，从 0 开始计数。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(Color.RED.ordinal());         System.out.println(Color.GREEN.ordinal());         System.out.println(Color.BLUE.ordinal());     &#125;&#125;</code></pre><ol start="6"><li><code>compareTo()</code>方法</li></ol><ul><li><strong>作用</strong>：用于比较两个枚举常量的顺序。它基于枚举常量的<code>ordinal</code>值进行比较，如果当前枚举常量的<code>ordinal</code>值小于参数枚举常量的<code>ordinal</code>值，则返回负整数；如果相等，则返回 0；如果大于，则返回正整数。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(Color.RED.compareTo(Color.GREEN));         System.out.println(Color.GREEN.compareTo(Color.GREEN));         System.out.println(Color.BLUE.compareTo(Color.GREEN));     &#125;&#125;</code></pre><ol start="7"><li><code>name()</code>方法</li></ol><ul><li><strong>作用</strong>：返回枚举常量的名称，与在枚举类中声明的名称一致。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(Color.RED.name());     &#125;&#125;</code></pre><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><img src="/../images/java/1741513669438.png" alt="1741513669438"></p><h4 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h4><p>使用 <code>@interface</code> 关键字来定义注解，注解的定义类似于接口的定义。示例如下：</p><pre><code class="java">// 定义一个简单的注解public @interface MyAnnotation &#123;    // 定义注解的属性    String value() default &quot;&quot;;    int count() default 0;&#125;</code></pre><p>在上述代码中，<code>MyAnnotation</code> 是一个自定义注解，它包含两个属性：<code>value</code> 和 <code>count</code>，并分别为它们设置了默认值。</p><h4 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h4><p>Java 提供了一些内置注解，用于在不同场景下提供特定的元数据信息。</p><ul><li>**<code>@Override</code>**：用于标记一个方法是重写父类的方法。编译器会检查该方法是否真的重写了父类的方法，如果没有则会报错。</li></ul><pre><code class="java">class Parent &#123;    public void display() &#123;        System.out.println(&quot;父类的方法&quot;);    &#125;&#125;class Child extends Parent &#123;    @Override    public void display() &#123;        System.out.println(&quot;子类重写的方法&quot;);    &#125;&#125;</code></pre><ul><li>**<code>@Deprecated</code>**：用于标记一个类、方法或字段已经过时，不建议再使用。编译器会在使用这些元素时给出警告。</li></ul><pre><code class="java">class MyClass &#123;    @Deprecated    public void oldMethod() &#123;        System.out.println(&quot;这是一个过时的方法&quot;);    &#125;&#125;</code></pre><ul><li>**<code>@SuppressWarnings</code>**：用于抑制编译器的警告信息。可以指定要抑制的警告类型，如 <code>unchecked</code>、<code>deprecation</code> 等。</li></ul><pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)public void test() &#123;    java.util.List list = new java.util.ArrayList();    // 这里不会出现未检查类型转换的警告&#125;</code></pre><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>自定义注解可以根据具体需求定义属性和使用规则。</p><pre><code class="java">// 定义一个自定义注解public @interface MyAnnotation &#123;    String value() default &quot;&quot;;    int count() default 0;&#125;// 使用自定义注解@MyAnnotation(value = &quot;测试注解&quot;, count = 5)public class MyClass &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;使用自定义注解的类&quot;);    &#125;&#125;</code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="/../images/java/1741515069168.png" alt="1741515069168"></p><p><img src="/../images/java/1741515612811.png" alt="1741515612811"></p><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a><code>try-catch-finally</code></h4><p><img src="/../images/java/1741515823233.png" alt="1741515823233"></p><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p><code>try-catch</code> 语句块的基本语法如下：</p><pre><code class="java">try &#123;    // 可能会抛出异常的代码&#125; catch (ExceptionType1 e1) &#123;    // 处理 ExceptionType1 类型异常的代码&#125; catch (ExceptionType2 e2) &#123;    // 处理 ExceptionType2 类型异常的代码&#125; </code></pre><p>其中，<code>try</code> 块中放置可能会抛出异常的代码，<code>catch</code> 块用于捕获并处理特定类型的异常。每个 <code>catch</code> 块可以捕获一种特定类型的异常，当 <code>try</code> 块中的代码抛出异常时，会依次检查各个 <code>catch</code> 块，找到匹配的异常类型并执行相应的处理代码。</p><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><p>下面通过一个简单的示例来展示 <code>try-catch</code> 语句块的执行流程：</p><pre><code class="java">public class TryCatchExample &#123;    public static void main(String[] args) &#123;        try &#123;            int result = 10 / 0; // 这行代码会抛出 ArithmeticException 异常            System.out.println(&quot;结果: &quot; + result);        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;捕获到算术异常: &quot; + e.getMessage());        &#125;        System.out.println(&quot;程序继续执行&quot;);    &#125;&#125;</code></pre><p>在上述代码中，<code>try</code> 块中的 <code>10 / 0</code> 会抛出 <code>ArithmeticException</code> 异常，此时程序会立即跳转到对应的 <code>catch</code> 块中执行异常处理代码，输出异常信息。然后程序会继续执行 <code>catch</code> 块之后的代码，输出 “程序继续执行”。</p><h5 id="多-catch-块"><a href="#多-catch-块" class="headerlink" title="多 catch 块"></a>多 <code>catch</code> 块</h5><p>可以使用多个 <code>catch</code> 块来捕获不同类型的异常，按照异常类型的顺序依次进行匹配。需要注意的是，子类异常的 <code>catch</code> 块要放在父类异常的 <code>catch</code> 块之前，否则子类异常将无法被捕获。</p><pre><code class="java">public class MultipleCatchExample &#123;    public static void main(String[] args) &#123;        try &#123;            int[] arr = new int[5];            System.out.println(arr[10]); // 这行代码会抛出 ArrayIndexOutOfBoundsException 异常            int result = 10 / 0; // 这行代码不会执行，因为前面已经抛出异常        &#125; catch (ArrayIndexOutOfBoundsException e) &#123;            System.out.println(&quot;捕获到数组越界异常: &quot; + e.getMessage());        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;捕获到算术异常: &quot; + e.getMessage());        &#125; catch (Exception e) &#123;            System.out.println(&quot;捕获到其他异常: &quot; + e.getMessage());        &#125;        System.out.println(&quot;程序继续执行&quot;);    &#125;&#125;</code></pre><p>在上述代码中，<code>try</code> 块中的 <code>arr[10]</code> 会抛出 <code>ArrayIndexOutOfBoundsException</code> 异常，程序会跳转到对应的 <code>catch</code> 块中执行异常处理代码。由于异常已经被捕获，后面的 <code>10 / 0</code> 代码不会执行。</p><h5 id="finally-块"><a href="#finally-块" class="headerlink" title="finally 块"></a><code>finally</code> 块</h5><p><code>finally</code> 块是可选的，它通常跟在 <code>try-catch</code> 语句块之后，无论 <code>try</code> 块中的代码是否抛出异常，<code>finally</code> 块中的代码都会被执行。</p><pre><code class="java">public class FinallyExample &#123;    public static void main(String[] args) &#123;        try &#123;            int result = 10 / 0; // 这行代码会抛出 ArithmeticException 异常            System.out.println(&quot;结果: &quot; + result);        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;捕获到算术异常: &quot; + e.getMessage());        &#125; finally &#123;            System.out.println(&quot;finally 块中的代码一定会执行&quot;);        &#125;        System.out.println(&quot;程序继续执行&quot;);    &#125;&#125;</code></pre><p>在上述代码中，<code>try</code> 块中的 <code>10 / 0</code> 会抛出 <code>ArithmeticException</code> 异常，程序会跳转到 <code>catch</code> 块中执行异常处理代码，然后执行 <code>finally</code> 块中的代码，最后继续执行 <code>finally</code> 块之后的代码。</p><h5 id="异常处理的注意事项"><a href="#异常处理的注意事项" class="headerlink" title="异常处理的注意事项"></a>异常处理的注意事项</h5><ul><li><strong>异常类型匹配</strong>：<code>catch</code> 块中的异常类型要与 <code>try</code> 块中可能抛出的异常类型相匹配，确保能够捕获到相应的异常。</li><li><strong>子类异常在前</strong>：在使用多个 <code>catch</code> 块时，子类异常的 <code>catch</code> 块要放在父类异常的 <code>catch</code> 块之前，避免子类异常被父类异常的 <code>catch</code> 块捕获。</li><li><strong><code>finally</code> 块的使用</strong>：<code>finally</code> 块通常用于释放资源，如关闭文件、数据库连接等，确保资源在任何情况下都能被正确释放。</li></ul><h4 id="throws-与-throw"><a href="#throws-与-throw" class="headerlink" title="throws 与 throw"></a><code>throws</code> 与 <code>throw</code></h4><p><img src="/../images/java/1741516755212.png" alt="1741516755212"></p><h5 id="throws-关键字"><a href="#throws-关键字" class="headerlink" title="throws 关键字"></a>throws 关键字</h5><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><p><code>throws</code> 关键字用于方法声明处，用于声明该方法可能会抛出的异常类型。它告知调用者，这个方法在执行过程中可能会产生某些异常，调用者需要对这些异常进行处理或者继续向上抛出。</p><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><pre><code class="java">修饰符 返回值类型 方法名(参数列表) throws 异常类型1, 异常类型2, ... &#123;    // 方法体&#125;</code></pre><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><pre><code class="java">import java.io.FileInputStream;import java.io.FileNotFoundException;public class ThrowsExample &#123;    // 声明该方法可能会抛出 FileNotFoundException 异常    public void readFile() throws FileNotFoundException &#123;        // 尝试打开一个文件，如果文件不存在会抛出 FileNotFoundException 异常        FileInputStream fis = new FileInputStream(&quot;nonexistentfile.txt&quot;);    &#125;    public static void main(String[] args) &#123;        ThrowsExample example = new ThrowsExample();        try &#123;            example.readFile();        &#125; catch (FileNotFoundException e) &#123;            System.out.println(&quot;文件未找到: &quot; + e.getMessage());        &#125;    &#125;&#125;</code></pre><p>在上述示例中，<code>readFile</code> 方法使用 <code>throws</code> 关键字声明可能会抛出 <code>FileNotFoundException</code> 异常。在 <code>main</code> 方法中调用 <code>readFile</code> 方法时，需要使用 <code>try-catch</code> 语句块来捕获并处理该异常。</p><h6 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li><code>throws</code> 后面可以跟多个异常类型，多个异常类型之间用逗号分隔。</li><li>如果一个方法声明了可能会抛出某个异常，但实际上该方法内部并没有抛出该异常，也是合法的。</li><li>子类重写父类的方法时，如果父类方法声明了某些异常，子类方法可以不声明这些异常，也可以声明父类方法声明的异常的子类异常，但不能声明比父类方法声明的异常范围更大的异常。</li></ul><h5 id="throw-关键字"><a href="#throw-关键字" class="headerlink" title="throw 关键字"></a>throw 关键字</h5><h6 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h6><p><code>throw</code> 关键字用于在方法内部手动抛出一个异常对象。当程序执行到 <code>throw</code> 语句时，会立即停止当前方法的执行，并将异常对象抛出给调用者。</p><h6 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h6><pre><code class="java">throw 异常对象;</code></pre><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><pre><code class="java">public class ThrowExample &#123;    public void checkAge(int age) &#123;        if (age &lt; 0) &#123;            // 手动抛出 IllegalArgumentException 异常            throw new IllegalArgumentException(&quot;年龄不能为负数&quot;);        &#125;        System.out.println(&quot;年龄合法: &quot; + age);    &#125;    public static void main(String[] args) &#123;        ThrowExample example = new ThrowExample();        try &#123;            example.checkAge(-5);        &#125; catch (IllegalArgumentException e) &#123;            System.out.println(&quot;捕获到异常: &quot; + e.getMessage());        &#125;    &#125;&#125;</code></pre><p>在上述示例中，<code>checkAge</code> 方法内部检查传入的 <code>age</code> 参数，如果 <code>age</code> 小于 0，则使用 <code>throw</code> 关键字手动抛出一个 <code>IllegalArgumentException</code> 异常。在 <code>main</code> 方法中调用 <code>checkAge</code> 方法时，使用 <code>try-catch</code> 语句块来捕获并处理该异常。</p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>Java 提供了 8 种基本数据类型，对应有 8 个包装类，具体如下：</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>Byte</code></td></tr><tr><td><code>short</code></td><td><code>Short</code></td></tr><tr><td><code>int</code></td><td><code>Integer</code></td></tr><tr><td><code>long</code></td><td><code>Long</code></td></tr><tr><td><code>float</code></td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td><code>Double</code></td></tr><tr><td><code>char</code></td><td><code>Character</code></td></tr><tr><td><code>boolean</code></td><td><code>Boolean</code></td></tr></tbody></table><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><ul><li><strong>自动装箱</strong>：将基本数据类型自动转换为对应的包装类对象。例如，将 <code>int</code> 类型的值赋给 <code>Integer</code> 类型的变量时，会自动进行装箱操作。</li></ul><pre><code class="java">int num = 10;Integer integerObj = num; // 自动装箱</code></pre><ul><li><strong>自动拆箱</strong>：将包装类对象自动转换为对应的基本数据类型。例如，将 <code>Integer</code> 类型的对象赋给 <code>int</code> 类型的变量时，会自动进行拆箱操作。</li></ul><pre><code class="java">Integer integerObj = 20;int num = integerObj; // 自动拆箱</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>不同的包装类提供了一些常用的方法，以下以 <code>Integer</code> 类为例进行介绍：</p><ul><li><strong><code>valueOf()</code> 方法</strong>：用于将基本数据类型或字符串转换为包装类对象。</li></ul><pre><code class="java">Integer intObj1 = Integer.valueOf(30);Integer intObj2 = Integer.valueOf(&quot;40&quot;);</code></pre><ul><li><strong><code>parseInt()</code> 方法</strong>：用于将字符串转换为 <code>int</code> 类型。</li></ul><pre><code class="java">int num = Integer.parseInt(&quot;50&quot;);</code></pre><ul><li><strong><code>toString()</code> 方法</strong>：用于将包装类对象转换为字符串。</li></ul><pre><code class="java">Integer intObj = 60;String str = intObj.toString();</code></pre><ul><li><strong><code>compareTo()</code> 方法</strong>：用于比较两个包装类对象的大小。</li></ul><pre><code class="java">Integer intObj1 = 70;Integer intObj2 = 80;int result = intObj1.compareTo(intObj2);if (result &lt; 0) &#123;    System.out.println(&quot;intObj1 小于 intObj2&quot;);&#125; else if (result == 0) &#123;    System.out.println(&quot;intObj1 等于 intObj2&quot;);&#125; else &#123;    System.out.println(&quot;intObj1 大于 intObj2&quot;);&#125;</code></pre><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>部分包装类（如 <code>Integer</code>、<code>Byte</code>、<code>Short</code>、<code>Long</code>、<code>Character</code>）存在缓存机制，对于一些常用的值，会将其对应的包装类对象缓存起来，当再次使用相同的值时，会直接从缓存中获取对象，而不是重新创建。</p><pre><code class="java">Integer a = 10;Integer b = 10;System.out.println(a == b); // 输出 true，因为使用了缓存Integer c = 128;Integer d = 128;System.out.println(c == d); // 输出 false，超出了缓存范围</code></pre><p><code>Integer</code> 类的缓存范围是 -128 到 127，不同的包装类缓存范围可能不同。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><img src="/../images/java/1741527233539.png" alt="1741527233539"></p><h4 id="1-String-类的创建"><a href="#1-String-类的创建" class="headerlink" title="1. String 类的创建"></a>1. <code>String</code> 类的创建</h4><p>在 Java 中创建 <code>String</code> 对象有多种方式，常见的如下：</p><h5 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h5><pre><code class="java">String str1 = &quot;Hello&quot;;</code></pre><p>这种方式会先检查字符串常量池中是否已经存在 <code>&quot;Hello&quot;</code> 这个字符串，如果存在则直接引用该字符串，若不存在则在常量池中创建该字符串对象。</p><h5 id="使用-new-关键字"><a href="#使用-new-关键字" class="headerlink" title="使用 new 关键字"></a>使用 <code>new</code> 关键字</h5><pre><code class="java">String str2 = new String(&quot;World&quot;);</code></pre><p>使用 <code>new</code> 关键字会在堆内存中创建一个新的 <code>String</code> 对象，即使字符串常量池中已经存在相同内容的字符串。</p><h4 id="2-String-类的不可变性"><a href="#2-String-类的不可变性" class="headerlink" title="2. String 类的不可变性"></a>2. <code>String</code> 类的不可变性</h4><p><code>String</code> 类的对象是不可变的，这意味着一旦一个 <code>String</code> 对象被创建，它的内容就不能被修改。例如：</p><pre><code class="java">String str = &quot;Java&quot;;str = str + &quot; Programming&quot;;</code></pre><p>这里看似 <code>str</code> 的内容发生了改变，但实际上是创建了一个新的 <code>String</code> 对象 <code>&quot;Java Programming&quot;</code>，并让 <code>str</code> 引用这个新对象，原来的 <code>&quot;Java&quot;</code> 对象依然存在于内存中。</p><p><code>String</code> 类不可变的好处主要有安全性、线程安全、可以作为哈希表的键等。</p><h4 id="3-String-类的常用方法"><a href="#3-String-类的常用方法" class="headerlink" title="3. String 类的常用方法"></a>3. <code>String</code> 类的常用方法</h4><h5 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h5><pre><code class="java">String str = &quot;Example&quot;;int length = str.length(); // 返回 7</code></pre><h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h5><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = &quot; World&quot;;String result = str1.concat(str2); // 结果为 &quot;Hello World&quot;</code></pre><h5 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h5><pre><code class="java">String str = &quot;Java Programming&quot;;int index = str.indexOf(&quot;Programming&quot;); // 返回 5</code></pre><h5 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h5><pre><code class="java">String str = &quot;Java Programming&quot;;String subStr = str.substring(5); // 结果为 &quot;Programming&quot;String subStr2 = str.substring(5, 10); // 结果为 &quot;Progr&quot;</code></pre><h5 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h5><pre><code class="java">String str = &quot;Java Programming&quot;;String newStr = str.replace(&quot;Java&quot;, &quot;Python&quot;); // 结果为 &quot;Python Programming&quot;</code></pre><h5 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h5><pre><code class="java">String str = &quot;Hello&quot;;String upperCase = str.toUpperCase(); // 结果为 &quot;HELLO&quot;String lowerCase = str.toLowerCase(); // 结果为 &quot;hello&quot;</code></pre><h5 id="去除字符串首尾空格"><a href="#去除字符串首尾空格" class="headerlink" title="去除字符串首尾空格"></a>去除字符串首尾空格</h5><pre><code class="java">String str = &quot;  Hello  &quot;;String trimmedStr = str.trim(); // 结果为 &quot;Hello&quot;</code></pre><h5 id="getBytes-方法"><a href="#getBytes-方法" class="headerlink" title="getBytes() 方法"></a><code>getBytes()</code> 方法</h5><h6 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h6><p><code>getBytes()</code> 方法有两个重载形式：</p><ul><li><code>public byte[] getBytes()</code>：使用平台的默认字符编码将字符串编码为字节序列，并将结果存储到一个新的字节数组中。</li><li><code>public byte[] getBytes(String charsetName)</code>：使用指定的字符编码将字符串编码为字节序列，并将结果存储到一个新的字节数组中。如果指定的字符编码不支持，会抛出 <code>UnsupportedEncodingException</code> 异常。</li></ul><h6 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h6><pre><code class="java">import java.io.UnsupportedEncodingException;public class GetBytesExample &#123;    public static void main(String[] args) &#123;        String str = &quot;Hello, 世界!&quot;;        // 使用平台默认编码        byte[] defaultBytes = str.getBytes();        System.out.println(&quot;默认编码后的字节数组长度: &quot; + defaultBytes.length);        try &#123;            // 使用 UTF-8 编码            byte[] utf8Bytes = str.getBytes(&quot;UTF-8&quot;);            System.out.println(&quot;UTF-8 编码后的字节数组长度: &quot; + utf8Bytes.length);            // 使用 GBK 编码            byte[] gbkBytes = str.getBytes(&quot;GBK&quot;);            System.out.println(&quot;GBK 编码后的字节数组长度: &quot; + gbkBytes.length);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h6 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h6><ul><li><code>str.getBytes()</code>：使用平台的默认字符编码对字符串 <code>str</code> 进行编码，返回一个字节数组。</li><li><code>str.getBytes(&quot;UTF-8&quot;)</code>：使用 UTF - 8 字符编码对字符串 <code>str</code> 进行编码，返回一个字节数组。</li><li><code>str.getBytes(&quot;GBK&quot;)</code>：使用 GBK 字符编码对字符串 <code>str</code> 进行编码，返回一个字节数组。</li></ul><h5 id="String-byte-bytes-String-charsetName-构造函数"><a href="#String-byte-bytes-String-charsetName-构造函数" class="headerlink" title="String(byte[] bytes, String charsetName) 构造函数"></a><code>String(byte[] bytes, String charsetName)</code> 构造函数</h5><h6 id="构造函数概述"><a href="#构造函数概述" class="headerlink" title="构造函数概述"></a>构造函数概述</h6><p>该构造函数用于通过指定的字符编码将字节数组解码为字符串。如果指定的字符编码不支持，会抛出 <code>UnsupportedEncodingException</code> 异常。</p><h6 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h6><pre><code class="java">import java.io.UnsupportedEncodingException;public class StringConstructorExample &#123;    public static void main(String[] args) &#123;        String originalStr = &quot;Hello, 世界!&quot;;        try &#123;            // 使用 UTF-8 编码将字符串转换为字节数组            byte[] utf8Bytes = originalStr.getBytes(&quot;UTF-8&quot;);            // 使用 UTF-8 编码将字节数组解码为字符串            String decodedStr = new String(utf8Bytes, &quot;UTF-8&quot;);            System.out.println(&quot;解码后的字符串: &quot; + decodedStr);            // 使用错误的编码进行解码（会导致乱码）            String wrongDecodedStr = new String(utf8Bytes, &quot;GBK&quot;);            System.out.println(&quot;使用错误编码解码后的字符串: &quot; + wrongDecodedStr);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h6 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h6><ul><li><code>new String(utf8Bytes, &quot;UTF-8&quot;)</code>：使用 UTF - 8 字符编码将字节数组 <code>utf8Bytes</code> 解码为字符串。由于编码和解码使用的是相同的字符编码，所以解码后的字符串与原始字符串相同。</li><li><code>new String(utf8Bytes, &quot;GBK&quot;)</code>：使用 GBK 字符编码将字节数组 <code>utf8Bytes</code> 解码为字符串。由于编码使用的是 UTF - 8，解码使用的是 GBK，编码和解码使用的字符编码不一致，所以解码后的字符串会出现乱码。</li></ul><h4 id="4-字符串拼接"><a href="#4-字符串拼接" class="headerlink" title="4. 字符串拼接"></a>4. 字符串拼接</h4><p>除了使用 <code>concat</code> 方法进行字符串拼接外，还可以使用 <code>+</code> 运算符：</p><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = &quot; World&quot;;String result = str1 + str2; // 结果为 &quot;Hello World&quot;</code></pre><p>在 Java 中，当使用 <code>+</code> 运算符进行字符串拼接时，如果其中一个操作数是字符串，那么其他操作数会自动转换为字符串类型。不过在大量拼接字符串时，使用 <code>+</code> 运算符会产生较多临时对象，性能较低，此时建议使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 类。</p><h4 id="5-字符串比较"><a href="#5-字符串比较" class="headerlink" title="5. 字符串比较"></a>5. 字符串比较</h4><h5 id="使用-比较"><a href="#使用-比较" class="headerlink" title="使用 == 比较"></a>使用 <code>==</code> 比较</h5><p><code>==</code> 比较的是两个字符串对象的引用是否相等，即是否指向同一个内存地址。</p><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = &quot;Hello&quot;;String str3 = new String(&quot;Hello&quot;);System.out.println(str1 == str2); // 输出 true，因为它们引用常量池中的同一个对象System.out.println(str1 == str3); // 输出 false，因为 str3 在堆内存中是新对象</code></pre><h5 id="使用-equals-方法比较"><a href="#使用-equals-方法比较" class="headerlink" title="使用 equals 方法比较"></a>使用 <code>equals</code> 方法比较</h5><p><code>equals</code> 方法比较的是两个字符串的内容是否相等。</p><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = new String(&quot;Hello&quot;);System.out.println(str1.equals(str2)); // 输出 true，因为内容相同</code></pre><h4 id="6-字符串分割"><a href="#6-字符串分割" class="headerlink" title="6. 字符串分割"></a>6. 字符串分割</h4><pre><code class="java">String str = &quot;Java,Python,C++&quot;;String[] parts = str.split(&quot;,&quot;);for (String part : parts) &#123;    System.out.println(part);&#125;</code></pre><p>上述代码将字符串按逗号进行分割，结果存储在字符串数组中。</p><h4 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h4><p><img src="/../images/java/1741698218188.png" alt="1741698218188"></p><h5 id="1-Java-字符串的内部表示"><a href="#1-Java-字符串的内部表示" class="headerlink" title="1. Java 字符串的内部表示"></a>1. Java 字符串的内部表示</h5><p>在 Java 中，<code>String</code> 类的对象在内存中是以 Unicode 编码形式存储的，Unicode 是一种字符编码标准，它为世界上几乎所有的字符都分配了一个唯一的数字代码，这使得 Java 能够处理各种语言的文本。</p><h5 id="2-编码与解码操作"><a href="#2-编码与解码操作" class="headerlink" title="2. 编码与解码操作"></a>2. 编码与解码操作</h5><h6 id="编码（将字符串转换为字节数组）"><a href="#编码（将字符串转换为字节数组）" class="headerlink" title="编码（将字符串转换为字节数组）"></a>编码（将字符串转换为字节数组）</h6><p>使用 <code>String</code> 类的 <code>getBytes()</code> 方法可以将字符串按照指定的字符编码转换为字节数组。如果不指定编码，默认使用平台的默认字符编码。</p><pre><code class="java">import java.io.UnsupportedEncodingException;public class StringEncodingExample &#123;    public static void main(String[] args) &#123;        String str = &quot;你好，世界！&quot;;        try &#123;            // 使用 UTF-8 编码将字符串转换为字节数组            byte[] utf8Bytes = str.getBytes(&quot;UTF-8&quot;);            System.out.println(&quot;UTF-8 编码后的字节数组长度: &quot; + utf8Bytes.length);            // 使用 GBK 编码将字符串转换为字节数组            byte[] gbkBytes = str.getBytes(&quot;GBK&quot;);            System.out.println(&quot;GBK 编码后的字节数组长度: &quot; + gbkBytes.length);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>在上述代码中，我们将字符串 <code>&quot;你好，世界！&quot;</code> 分别使用 UTF - 8 和 GBK 编码转换为字节数组，并输出字节数组的长度。由于不同的编码方案对字符的编码方式不同，所以得到的字节数组长度可能不同。</p><h6 id="解码（将字节数组转换为字符串）"><a href="#解码（将字节数组转换为字符串）" class="headerlink" title="解码（将字节数组转换为字符串）"></a>解码（将字节数组转换为字符串）</h6><p>使用 <code>String</code> 类的构造函数可以将字节数组按照指定的字符编码转换为字符串。</p><pre><code class="java">import java.io.UnsupportedEncodingException;public class StringDecodingExample &#123;    public static void main(String[] args) &#123;        String str = &quot;你好，世界！&quot;;        try &#123;            // 使用 UTF-8 编码将字符串转换为字节数组            byte[] utf8Bytes = str.getBytes(&quot;UTF-8&quot;);            // 使用 UTF-8 编码将字节数组解码为字符串            String decodedStr = new String(utf8Bytes, &quot;UTF-8&quot;);            System.out.println(&quot;解码后的字符串: &quot; + decodedStr);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>在上述代码中，我们先将字符串使用 UTF - 8 编码转换为字节数组，然后再使用相同的编码将字节数组解码为字符串，并输出解码后的字符串。</p><h5 id="3-常见的字符编码"><a href="#3-常见的字符编码" class="headerlink" title="3. 常见的字符编码"></a>3. 常见的字符编码</h5><h6 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF - 8"></a>UTF - 8</h6><p>UTF - 8 是一种可变长度的 Unicode 编码，它使用 1 到 4 个字节来表示一个字符。对于 ASCII 字符（即 Unicode 编码范围在 0 - 127 之间的字符），UTF - 8 只使用 1 个字节，与 ASCII 编码兼容。对于大多数常用的汉字，UTF - 8 使用 3 个字节表示。UTF - 8 是互联网上最常用的字符编码，因为它能够处理各种语言的文本，并且对于英文文本的存储效率较高。</p><h6 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h6><p>GBK 是中国国家标准的中文字符编码，它是对 GB2312 编码的扩展，能够表示 21003 个汉字和图形符号。GBK 使用 2 个字节来表示一个汉字，对于 ASCII 字符，GBK 同样只使用 1 个字节。GBK 主要用于中文操作系统和中文文本处理。</p><h6 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO - 8859 - 1"></a>ISO - 8859 - 1</h6><p>ISO - 8859 - 1 是一种单字节编码，它只能表示 256 个字符，主要用于西欧语言。ISO - 8859 - 1 是 Java 中默认的字符编码之一，但它不能表示中文等非西欧语言的字符。</p><h5 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h5><ul><li><strong>编码一致性</strong>：在进行编码和解码操作时，必须确保使用相同的字符编码，否则会导致乱码问题。例如，如果使用 UTF - 8 编码将字符串转换为字节数组，那么在解码时也必须使用 UTF - 8 编码。</li><li><strong>异常处理</strong>：在使用 <code>getBytes()</code> 方法和 <code>String</code> 构造函数时，可能会抛出 <code>UnsupportedEncodingException</code> 异常，因此需要进行异常处理。</li></ul><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p><img src="/../images/java/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-11%20214218.png"></p><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><code>StringBuffer</code> 是一个线程安全的可变字符序列。它继承自 <code>AbstractStringBuilder</code> 类，与 <code>String</code> 不同，<code>StringBuffer</code> 对象的内容可以被动态修改，不会像 <code>String</code> 那样每次修改都创建新的对象，从而避免了频繁创建对象带来的性能开销。</p><h5 id="创建-StringBuffer-对象"><a href="#创建-StringBuffer-对象" class="headerlink" title="创建 StringBuffer 对象"></a>创建 <code>StringBuffer</code> 对象</h5><p>可以通过以下几种方式创建 <code>StringBuffer</code> 对象：</p><pre><code class="java">// 1. 创建一个空的 StringBuffer 对象StringBuffer sb1 = new StringBuffer();// 2. 创建一个初始容量为 20 的 StringBuffer 对象StringBuffer sb2 = new StringBuffer(20);// 3. 使用指定的字符串初始化 StringBuffer 对象StringBuffer sb3 = new StringBuffer(&quot;Hello&quot;);</code></pre><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="1-append-方法"><a href="#1-append-方法" class="headerlink" title="1. append() 方法"></a>1. <code>append()</code> 方法</h6><p>用于将各种类型的数据追加到 <code>StringBuffer</code> 的末尾。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.append(&quot; World&quot;); // 追加字符串sb.append(123); // 追加整数System.out.println(sb); // 输出: Hello World123</code></pre><h6 id="2-insert-方法"><a href="#2-insert-方法" class="headerlink" title="2. insert() 方法"></a>2. <code>insert()</code> 方法</h6><p>用于在指定位置插入各种类型的数据。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.insert(2, &quot;abc&quot;); // 在索引为 2 的位置插入字符串System.out.println(sb); // 输出: Heabcllo</code></pre><h6 id="3-delete-方法"><a href="#3-delete-方法" class="headerlink" title="3. delete() 方法"></a>3. <code>delete()</code> 方法</h6><p>用于删除指定范围内的字符。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello World&quot;);sb.delete(6, 11); // 删除索引从 6 到 10 的字符System.out.println(sb); // 输出: Hello</code></pre><h6 id="4-replace-方法"><a href="#4-replace-方法" class="headerlink" title="4. replace() 方法"></a>4. <code>replace()</code> 方法</h6><p>用于替换指定范围内的字符。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.replace(1, 4, &quot;abc&quot;); // 替换索引从 1 到 3 的字符System.out.println(sb); // 输出: Habco</code></pre><h6 id="5-reverse-方法"><a href="#5-reverse-方法" class="headerlink" title="5. reverse() 方法"></a>5. <code>reverse()</code> 方法</h6><p>用于反转 <code>StringBuffer</code> 中的字符序列。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.reverse();System.out.println(sb); // 输出: olleH</code></pre><h6 id="6-toString-方法"><a href="#6-toString-方法" class="headerlink" title="6. toString() 方法"></a>6. <code>toString()</code> 方法</h6><p>将 <code>StringBuffer</code> 对象转换为 <code>String</code> 对象。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);String str = sb.toString();System.out.println(str); // 输出: Hello</code></pre><h5 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h5><p><code>StringBuffer</code> 是线程安全的，这意味着在多线程环境下可以安全地使用它。它的大部分方法都使用了 <code>synchronized</code> 关键字进行同步，确保在同一时间只有一个线程可以修改 <code>StringBuffer</code> 的内容。</p><h5 id="与-StringBuilder-的比较"><a href="#与-StringBuilder-的比较" class="headerlink" title="与 StringBuilder 的比较"></a>与 <code>StringBuilder</code> 的比较</h5><p><code>StringBuilder</code> 也是一个可变的字符序列类，它与 <code>StringBuffer</code> 的功能非常相似，但 <code>StringBuilder</code> 是非线程安全的。在单线程环境下，由于不需要进行同步操作，<code>StringBuilder</code> 的性能通常比 <code>StringBuffer</code> 要好。因此，如果是在单线程环境中进行字符串的频繁修改，建议使用 <code>StringBuilder</code>；如果是在多线程环境中，为了保证线程安全，应该使用 <code>StringBuffer</code>。</p><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p><img src="/../images/java/1741702404265.png" alt="1741702404265"></p><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p><img src="/../images/java/1741702461774.png" alt="1741702461774"></p><h4 id="1-对基本数据类型数组排序"><a href="#1-对基本数据类型数组排序" class="headerlink" title="1. 对基本数据类型数组排序"></a>1. 对基本数据类型数组排序</h4><p><code>Arrays.sort()</code> 可以对基本数据类型的数组进行排序，如 <code>int</code>、<code>double</code>、<code>char</code> 等。排序是按照升序进行的，使用的是双轴快速排序（Dual-Pivot Quicksort）算法，对于小规模数组会使用插入排序。</p><p><strong>示例代码</strong></p><pre><code class="java">import java.util.Arrays;public class BasicArraySorting &#123;    public static void main(String[] args) &#123;        // 对 int 数组排序        int[] intArray = &#123;5, 3, 8, 1, 2&#125;;        Arrays.sort(intArray);        System.out.println(&quot;排序后的 int 数组: &quot; + Arrays.toString(intArray));        // 对 char 数组排序        char[] charArray = &#123;&#39;d&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;&#125;;        Arrays.sort(charArray);        System.out.println(&quot;排序后的 char 数组: &quot; + Arrays.toString(charArray));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li>对于 <code>int</code> 数组 <code>intArray</code>，调用 <code>Arrays.sort(intArray)</code> 后，数组元素会按升序排列。</li><li>对于 <code>char</code> 数组 <code>charArray</code>，同样调用 <code>Arrays.sort(charArray)</code> 进行升序排序。</li></ul><h4 id="2-对对象数组排序"><a href="#2-对对象数组排序" class="headerlink" title="2. 对对象数组排序"></a>2. 对对象数组排序</h4><p>当对对象数组进行排序时，数组中的元素类型必须实现 <code>java.lang.Comparable</code> 接口，或者在调用 <code>Arrays.sort()</code> 方法时传入一个 <code>java.util.Comparator</code> 对象来指定排序规则。</p><h5 id="2-1-实现-Comparable-接口"><a href="#2-1-实现-Comparable-接口" class="headerlink" title="2.1 实现 Comparable 接口"></a>2.1 实现 <code>Comparable</code> 接口</h5><p><code>Comparable</code> 接口有一个抽象方法 <code>compareTo()</code>，用于定义对象之间的比较规则。</p><pre><code class="java">import java.util.Arrays;class Student implements Comparable&lt;Student&gt; &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public int compareTo(Student other) &#123;        return Integer.compare(this.age, other.age);    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;name=&#39;&quot; + name + &quot;&#39;, age=&quot; + age + &quot;&#125;&quot;;    &#125;&#125;public class ObjectArraySortingComparable &#123;    public static void main(String[] args) &#123;        Student[] students = &#123;                new Student(&quot;Alice&quot;, 20),                new Student(&quot;Bob&quot;, 18),                new Student(&quot;Charlie&quot;, 22)        &#125;;        Arrays.sort(students);        System.out.println(&quot;按年龄排序后的学生数组: &quot; + Arrays.toString(students));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><code>Student</code> 类实现了 <code>Comparable</code> 接口，并重写了 <code>compareTo()</code> 方法，按照学生的年龄进行比较。</li><li>调用 <code>Arrays.sort(students)</code> 时，会根据 <code>compareTo()</code> 方法定义的规则对学生数组进行排序。</li></ul><h5 id="2-2-使用-Comparator-接口"><a href="#2-2-使用-Comparator-接口" class="headerlink" title="2.2 使用 Comparator 接口"></a>2.2 使用 <code>Comparator</code> 接口</h5><p>如果不想修改类的定义，或者需要临时定义不同的排序规则，可以使用 <code>Comparator</code> 接口。</p><pre><code class="java">import java.util.Arrays;import java.util.Comparator;class Person &#123;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;name=&#39;&quot; + name + &quot;&#39;, age=&quot; + age + &quot;&#125;&quot;;    &#125;&#125;public class ObjectArraySortingComparator &#123;    public static void main(String[] args) &#123;        Person[] persons = &#123;                new Person(&quot;Alice&quot;, 20),                new Person(&quot;Bob&quot;, 18),                new Person(&quot;Charlie&quot;, 22)        &#125;;        // 按年龄降序排序        Arrays.sort(persons, new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person p1, Person p2) &#123;                return Integer.compare(p2.age, p1.age);            &#125;        &#125;);        System.out.println(&quot;按年龄降序排序后的人员数组: &quot; + Arrays.toString(persons));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><code>Person</code> 类没有实现 <code>Comparable</code> 接口，在调用 <code>Arrays.sort()</code> 时传入了一个匿名的 <code>Comparator</code> 对象，重写了 <code>compare()</code> 方法，实现了按年龄降序排序。</li></ul><h4 id="3-对部分数组元素排序"><a href="#3-对部分数组元素排序" class="headerlink" title="3. 对部分数组元素排序"></a>3. 对部分数组元素排序</h4><p><code>Arrays.sort()</code> 还提供了对数组部分元素进行排序的重载方法，通过指定起始索引和结束索引来确定排序的范围。</p><pre><code class="java">import java.util.Arrays;public class PartialArraySorting &#123;    public static void main(String[] args) &#123;        int[] array = &#123;5, 3, 8, 1, 2, 7, 4, 6&#125;;        // 对索引从 1 到 4（不包括 4）的元素进行排序        Arrays.sort(array, 1, 4);        System.out.println(&quot;部分排序后的数组: &quot; + Arrays.toString(array));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><code>Arrays.sort(array, 1, 4)</code> 只对数组 <code>array</code> 中索引从 1 到 3 的元素进行排序，其他元素保持不变。</li></ul><h4 id="4-二分查找方法"><a href="#4-二分查找方法" class="headerlink" title="4. 二分查找方法"></a>4. 二分查找方法</h4><ul><li><code>binarySearch()</code>：在已排序的数组中使用二分查找算法查找指定元素，返回元素的索引，如果未找到则返回负数。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysBinarySearchExample &#123;    public static void main(String[] args) &#123;        int[] intArray = &#123;1, 2, 3, 5, 8&#125;;        int index = Arrays.binarySearch(intArray, 5);        System.out.println(&quot;元素 5 的索引是: &quot; + index);         // 输出: 元素 5 的索引是: 3    &#125;&#125;</code></pre><h4 id="5-数组填充方法"><a href="#5-数组填充方法" class="headerlink" title="5. 数组填充方法"></a>5. 数组填充方法</h4><ul><li><code>fill()</code>：用指定的值填充数组的所有元素或指定范围的元素。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysFillExample &#123;    public static void main(String[] args) &#123;        int[] intArray = new int[5];        Arrays.fill(intArray, 10);        System.out.println(Arrays.toString(intArray));         // 输出: [10, 10, 10, 10, 10]    &#125;&#125;</code></pre><h4 id="6-数组比较方法"><a href="#6-数组比较方法" class="headerlink" title="6. 数组比较方法"></a>6. 数组比较方法</h4><ul><li><code>equals()</code>：比较两个数组是否相等，会比较数组的长度和对应位置的元素。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysEqualsExample &#123;    public static void main(String[] args) &#123;        int[] array1 = &#123;1, 2, 3&#125;;        int[] array2 = &#123;1, 2, 3&#125;;        boolean isEqual = Arrays.equals(array1, array2);        System.out.println(&quot;两个数组是否相等: &quot; + isEqual);         // 输出: 两个数组是否相等: true    &#125;&#125;</code></pre><h4 id="7-数组转字符串方法"><a href="#7-数组转字符串方法" class="headerlink" title="7. 数组转字符串方法"></a>7. 数组转字符串方法</h4><ul><li><code>toString()</code>：返回数组的字符串表示形式，方便调试和输出。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysToStringExample &#123;    public static void main(String[] args) &#123;        int[] intArray = &#123;1, 2, 3&#125;;        String arrayString = Arrays.toString(intArray);        System.out.println(arrayString);         // 输出: [1, 2, 3]    &#125;&#125;</code></pre><h4 id="8-数组复制方法"><a href="#8-数组复制方法" class="headerlink" title="8.数组复制方法"></a>8.数组复制方法</h4><p><code>Arrays.copyOf</code> 有多个重载版本，常见的方法签名如下：</p><pre><code class="java">// 复制指定数组的指定长度部分到一个新数组中，元素类型为基本数据类型（以 int 为例）public static int[] copyOf(int[] original, int newLength)// 复制指定数组的指定长度部分到一个新数组中，元素类型为对象类型（以 String 为例）public static &lt;T&gt; T[] copyOf(T[] original, int newLength)</code></pre><ul><li><code>original</code>：要复制的原始数组。</li><li><code>newLength</code>：新数组的长度。</li><li>若 <code>newLength</code> 小于原始数组的长度，新数组将只包含原始数组的前 <code>newLength</code> 个元素；若 <code>newLength</code> 大于原始数组的长度，新数组中超出原始数组长度的部分会用对应类型的默认值填充（对于基本数据类型，如 <code>int</code> 是 0，<code>boolean</code> 是 <code>false</code>；对于对象类型是 <code>null</code>）。</li></ul><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p><img src="/../images/java/1741702473807.png" alt="1741702473807"></p><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><h5 id="1-System-in"><a href="#1-System-in" class="headerlink" title="1. System.in"></a>1. <code>System.in</code></h5><p>这是一个 <code>InputStream</code> 类型的静态属性，代表标准输入流，通常关联到键盘输入。在控制台程序中，可利用它从用户那里获取输入信息。</p><pre><code class="java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class SystemInExample &#123;    public static void main(String[] args) &#123;        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) &#123;            System.out.print(&quot;请输入一些内容: &quot;);            String input = reader.readLine();            System.out.println(&quot;你输入的内容是: &quot; + input);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h5 id="2-System-out"><a href="#2-System-out" class="headerlink" title="2. System.out"></a>2. <code>System.out</code></h5><p>它是一个 <code>PrintStream</code> 类型的静态属性，代表标准输出流，通常关联到控制台输出。借助它可以将信息输出到控制台。</p><pre><code class="java">public class SystemOutExample &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;这是一个输出示例。&quot;);    &#125;&#125;</code></pre><h5 id="3-System-err"><a href="#3-System-err" class="headerlink" title="3. System.err"></a>3. <code>System.err</code></h5><p>同样是 <code>PrintStream</code> 类型的静态属性，代表标准错误输出流，也关联到控制台。一般用于输出错误信息，与 <code>System.out</code> 不同的是，它输出的内容通常会以不同颜色显示（取决于控制台设置）。</p><pre><code class="java">public class SystemErrExample &#123;    public static void main(String[] args) &#123;        try &#123;            int result = 1 / 0;        &#125; catch (ArithmeticException e) &#123;            System.err.println(&quot;发生错误: &quot; + e.getMessage());        &#125;    &#125;&#125;</code></pre><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-System-currentTimeMillis"><a href="#1-System-currentTimeMillis" class="headerlink" title="1. System.currentTimeMillis()"></a>1. <code>System.currentTimeMillis()</code></h5><p>返回当前时间（从 1970 年 1 月 1 日 00:00:00 UTC 到现在的毫秒数），常用来计算代码的执行时间。</p><pre><code class="java">public class CurrentTimeMillisExample &#123;    public static void main(String[] args) &#123;        long startTime = System.currentTimeMillis();        // 模拟一段耗时操作        for (int i = 0; i &lt; 1000000; i++) &#123;            // 空循环        &#125;        long endTime = System.currentTimeMillis();        System.out.println(&quot;操作耗时: &quot; + (endTime - startTime) + &quot; 毫秒&quot;);    &#125;&#125;</code></pre><h5 id="2-System-arraycopy"><a href="#2-System-arraycopy" class="headerlink" title="2. System.arraycopy()"></a>2. <code>System.arraycopy()</code></h5><p>用于将一个数组的指定部分复制到另一个数组中，是一个高效的数组复制方法。</p><pre><code class="java">public class ArrayCopyExample &#123;    public static void main(String[] args) &#123;        int[] source = &#123;1, 2, 3, 4, 5&#125;;        int[] destination = new int[5];        System.arraycopy(source, 0, destination, 0, 5);        for (int num : destination) &#123;            System.out.print(num + &quot; &quot;);        &#125;    &#125;&#125;</code></pre><h5 id="3-System-getProperties"><a href="#3-System-getProperties" class="headerlink" title="3. System.getProperties()"></a>3. <code>System.getProperties()</code></h5><p>返回一个 <code>Properties</code> 对象，包含了当前系统的所有属性，如操作系统名称、Java 版本等。</p><pre><code class="java">import java.util.Properties;public class GetPropertiesExample &#123;    public static void main(String[] args) &#123;        Properties properties = System.getProperties();        properties.list(System.out);    &#125;&#125;</code></pre><h5 id="4-System-setProperty-String-key-String-value"><a href="#4-System-setProperty-String-key-String-value" class="headerlink" title="4. System.setProperty(String key, String value)"></a>4. <code>System.setProperty(String key, String value)</code></h5><p>用于设置系统属性，可在程序运行时动态修改系统属性。</p><pre><code class="java">public class SetPropertyExample &#123;    public static void main(String[] args) &#123;        System.setProperty(&quot;my.property&quot;, &quot;my value&quot;);        String value = System.getProperty(&quot;my.property&quot;);        System.out.println(&quot;自定义属性的值: &quot; + value);    &#125;&#125;</code></pre><h5 id="5-System-exit-int-status"><a href="#5-System-exit-int-status" class="headerlink" title="5. System.exit(int status)"></a>5. <code>System.exit(int status)</code></h5><p>用于终止当前正在运行的 Java 虚拟机。参数 <code>status</code> 为 0 表示正常退出，非 0 表示异常退出。</p><pre><code class="java">public class ExitExample &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;程序即将退出...&quot;);        System.exit(0);        System.out.println(&quot;这行代码不会执行。&quot;);    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;安卓逆向基础&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>I_chun_qiu</title>
    <link href="http://example.com/2025/02/23/I-chun-qiu/"/>
    <id>http://example.com/2025/02/23/I-chun-qiu/</id>
    <published>2025-02-22T16:00:00.000Z</published>
    <updated>2025-03-02T13:43:32.481Z</updated>
    
    <content type="html"><![CDATA[<p> 跟I春秋学逆向</p><span id="more"></span> <h1 id="IDA基础操作"><a href="#IDA基础操作" class="headerlink" title="IDA基础操作"></a>IDA基础操作</h1><h2 id="IDA插件安装"><a href="#IDA插件安装" class="headerlink" title="IDA插件安装"></a>IDA插件安装</h2><p><img src="/../images/I-chun-qiu/1738665569455.png" alt="1738665569455"></p><h2 id="IDA打开方式"><a href="#IDA打开方式" class="headerlink" title="IDA打开方式"></a>IDA打开方式</h2><p><img src="/../images/I-chun-qiu/1738665679539.png" alt="1738665679539"></p><p><strong>可以先用32打开文件，如果报错，再用64打开文件</strong></p><h2 id="IDA常用窗口"><a href="#IDA常用窗口" class="headerlink" title="IDA常用窗口"></a>IDA常用窗口</h2><p><img src="/../images/I-chun-qiu/1738665790119.png" alt="1738665790119"></p><h3 id="函数列表窗口"><a href="#函数列表窗口" class="headerlink" title="函数列表窗口"></a>函数列表窗口</h3><p><img src="/../images/I-chun-qiu/1738666061089.png" alt="1738666061089"></p><p><strong>在函数列表中可按 Ctrl + F 来调出函数搜索窗口，双击函数名可在主视图跳转到对应函数的代码</strong></p><h3 id="IDA-View窗口"><a href="#IDA-View窗口" class="headerlink" title="IDA-View窗口"></a>IDA-View窗口</h3><p><strong>可按G键，或在jump功能中点击jump to address来进行地址导航</strong></p><h3 id="伪代码窗口"><a href="#伪代码窗口" class="headerlink" title="伪代码窗口"></a>伪代码窗口</h3><p><strong>按反斜杠键进行注释，按x键查看交叉引用</strong></p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><strong>程序引用的其他第三方函数</strong></p><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p><strong>程序动态数据导出的函数，默认start为最初始的执行函数</strong></p><h2 id="IDA操作实例"><a href="#IDA操作实例" class="headerlink" title="IDA操作实例"></a>IDA操作实例</h2><p><strong>在终端启动PowerShell，将执行文件托入可避免程序在我们未阅读完回显时就自动关闭</strong></p><p><img src="/../images/I-chun-qiu/1738667322612.png" alt="1738667322612"></p><p><strong>可在伪代码页面中选中函数并按N键为其重命名</strong></p><h3 id="定位main函数"><a href="#定位main函数" class="headerlink" title="定位main函数"></a>定位main函数</h3><p><img src="/../images/I-chun-qiu/1738667427818.png" alt="1738667427818"></p><p><strong>在IDA-View窗口中可选中字符串，再按U键来解除字符串，也可按A键来重新组成字符串</strong></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="/../images/I-chun-qiu/1738667810659.png" alt="1738667810659"></p><h1 id="RC4加密算法"><a href="#RC4加密算法" class="headerlink" title="RC4加密算法"></a>RC4加密算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="/../images/I-chun-qiu/1738668071519.png" alt="1738668071519"></p><h2 id="加密过程概述"><a href="#加密过程概述" class="headerlink" title="加密过程概述"></a>加密过程概述</h2><p><img src="/../images/I-chun-qiu/1738668264391.png" alt="1738668264391"></p><p><img src="/../images/I-chun-qiu/1738668597694.png" alt="1738668597694"></p><p><img src="/../images/I-chun-qiu/1738668622779.png" alt="1738668622779"></p><p><strong>注：mod为取模</strong></p><h2 id="特征识别"><a href="#特征识别" class="headerlink" title="特征识别"></a>特征识别</h2><p><img src="/../images/I-chun-qiu/1738668934155.png" alt="1738668934155"></p><h2 id="常见魔改及处理方法"><a href="#常见魔改及处理方法" class="headerlink" title="常见魔改及处理方法"></a>常见魔改及处理方法</h2><p><img src="/../images/I-chun-qiu/1738668984958.png" alt="1738668984958"></p><h1 id="TEA加密算法"><a href="#TEA加密算法" class="headerlink" title="TEA加密算法"></a>TEA加密算法</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><img src="/../images/I-chun-qiu/1738670241877.png" alt="1738670241877"></p><h2 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h2><p><img src="/../images/I-chun-qiu/1738670316411.png" alt="1738670316411"></p><h2 id="特征识别-1"><a href="#特征识别-1" class="headerlink" title="特征识别"></a>特征识别</h2><p><img src="/../images/I-chun-qiu/1738670451740.png" alt="1738670451740"></p><p><strong>注：左移4等于乘16</strong></p><h2 id="常见魔改及处理方法-1"><a href="#常见魔改及处理方法-1" class="headerlink" title="常见魔改及处理方法"></a>常见魔改及处理方法</h2><p><img src="/../images/I-chun-qiu/1738670560542.png" alt="1738670560542"></p><p><img src="/../images/I-chun-qiu/1738670608311.png" alt="1738670608311"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 跟I春秋学逆向&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="逆向" scheme="http://example.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>buuctf_solutions</title>
    <link href="http://example.com/2025/02/23/buuctf-solutions/"/>
    <id>http://example.com/2025/02/23/buuctf-solutions/</id>
    <published>2025-02-22T16:00:00.000Z</published>
    <updated>2025-02-25T14:29:23.429Z</updated>
    
    <content type="html"><![CDATA[<p> buuctf 上的一些错题</p><span id="more"></span> <h1 id="SimpleRev"><a href="#SimpleRev" class="headerlink" title="SimpleRev"></a>SimpleRev</h1><p>函数看似复杂，实际分析后发现还是很复杂，代码中的字符串 src &#x3D; 357761762382LL ；v9 &#x3D; 512969957736LL 这是不能直接用的，需要选中然后右键转成字符，如图所示</p><p><img src="/../images/buuctf-solutions/1732106594993.png" alt="1732106594993"></p><p> 你以为转成这样就完了吗？这里要给大家提个醒，涉及<strong>大小端</strong>存储问题，<strong>elf文件这种通常使用小端存储</strong>，而IDA会把内存中的数据<strong>自动</strong>转成<strong>大端存储</strong>，但是有些变量双击过去，在文本视图能直接看到转好的字符串，以key3为例</p><p><img src="/../images/buuctf-solutions/1732106613363.png" alt="1732106613363"></p><p> 而有些却不能，这个时候就需要自己把字符串<strong>倒过来</strong>，比如我们在伪代码看到的 str 是 <strong>SLCDN</strong> ，可实际用这个字符串的时候应该用 <strong>NDCLS</strong> 同理，<strong>wodah</strong> 改成 <strong>hadow</strong> 然后继续分析代码<img src="/../images/buuctf-solutions/1732106686344.png" alt="1732106686344"></p><h1 id="java逆向"><a href="#java逆向" class="headerlink" title="java逆向"></a>java逆向</h1><h2 id="jadx使用教程"><a href="#jadx使用教程" class="headerlink" title="jadx使用教程"></a>jadx使用教程</h2><p>在解压jdax的目录输入cmd，再按回车键(Entry)进入Dos命令窗口 ，</p><p><img src="/../images/buuctf-solutions/1732173119194.png" alt="1732173119194"></p><p> 2、输入指令：cd lib，进入lib目录，再输入启动指令：java -jar jadx-gui-1.4.4.jar </p><p><img src="/../images/buuctf-solutions/1732173147984.png" alt="1732173147984"></p><p><img src="/../images/buuctf-solutions/1732173163869.png" alt="1732173163869"></p><p><img src="/../images/buuctf-solutions/1732173182539.png" alt="1732173182539"></p><h1 id="BJDCTF2020-JustRE"><a href="#BJDCTF2020-JustRE" class="headerlink" title="[BJDCTF2020]JustRE"></a>[BJDCTF2020]JustRE</h1><p> 遵循这个原则，有main函数找main函数，没有main函数找敏感字符串，拖入ida32之后<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E7%BC%96%E8%AF%91&spm=1001.2101.3001.7020">反编译</a>，你会得到。 </p><p><img src="/../images/buuctf-solutions/1732175940643.png" alt="1732175940643"></p><p>但是点了一圈，发现没有什么可用的地方，那么就去寻找字符串，ida的使用方法，f5</p><p>反编译，shift+f12<a href="https://so.csdn.net/so/search?q=%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">查找字符串</a>，之后你发现了一个类似于flag的东西。</p><p><img src="/../images/buuctf-solutions/1732175972276.png" alt="1732175972276"></p><p> 之后继续下一步，双击跟过去，跳转到了这个页面。 </p><p><img src="/../images/buuctf-solutions/1732176002120.png" alt="1732176002120"></p><p>  在光标在那上面的时候，ctrl + x，会进行交叉使用列表，跳转回对应在哪个汇编的位置。 </p><p><img src="/../images/buuctf-solutions/1732176023422.png" alt="1732176023422"></p><p>会跳转到所在的汇编的位置。</p><p><img src="/../images/buuctf-solutions/1732176048530.png" alt="1732176048530"></p><p>之后反编译进去 ，会发现一句话。</p><p><img src="/../images/buuctf-solutions/1732176067574.png" alt="1732176067574"></p><p>上一个语句应该是代表点击次数如果等于19999的话就输出flag。</p><h1 id="刮开有奖"><a href="#刮开有奖" class="headerlink" title="刮开有奖"></a>刮开有奖</h1><p>前言：学习笔记。(不是为了做题而做题，reverse和pwn都需要深入学习。)</p><p>常规思路： 下载 解压 查壳 </p><p><img src="/../images/buuctf-solutions/1732716250731.png" alt="1732716250731"></p><p>32bit&gt;&gt;&gt;32位 IDA Pro打开</p><p>常规：先查找字符串【东点西看】&gt;&gt;&gt;再进入main函数【这题是winmain】&gt;&gt;&gt;WIN32编程写的。</p><p>查找字符串</p><p><img src="/../images/buuctf-solutions/1732716275389.png" alt="1732716275389"></p><p>WinMain：</p><p><img src="/../images/buuctf-solutions/1732716290804.png" alt="1732716290804"></p><p>可疑参数：</p><p>跟进去看看</p><p><img src="/../images/buuctf-solutions/1732716306445.png" alt="1732716306445"></p><p>哎不想看，先直接看反。。。【截图不完。。直接和分析一起看吧。】</p><p>分析：<br>第一部分：</p><p><img src="/../images/buuctf-solutions/1732716331424.png" alt="1732716331424"></p><p>第二部分：</p><p>对于v7数组的范围：(这样看应该更简单些):【汇编中，连续的地址引用一般都是数组】</p><p><img src="/../images/buuctf-solutions/1732716374438.png" alt="1732716374438"></p><p><img src="/../images/buuctf-solutions/1732716343787.png" alt="1732716343787"></p><p>sub_4010F0(v7, 0, 10)：（如何还原:C伪代码&gt;&gt;&gt;C语言）&gt;&gt;&gt;涨经验了。<br>关键点：类型确定[是char类型&gt;&gt;&gt;【1】还是int类型【4】、数组寻址原理、C代码风格等等。。]</p><p>还原并运行：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define _DWORD charint __cdecl sub_4010F0(char * a1, int a2, int a3)&#123;    int result; // eax    int i; // esi    int v5; // ecx    int v6; // edx     result = a3;    for (i = a2; i &lt;= a3; a2 = i)    &#123;        v5 = i;        v6 = *(_DWORD *)(i + a1);        if (a2 &lt; result &amp;&amp; i &lt; result)        &#123;            do            &#123;                if (v6 &gt; *(_DWORD *)(a1 +result))                &#123;                    if (i &gt;= result)                        break;                    ++i;                    *(_DWORD *)(v5 + a1) = *(_DWORD *)(a1 + result);                    if (i &gt;= result)                        break;                    while (*(_DWORD *)(a1 + i) &lt;= v6)                    &#123;                        if (++i &gt;= result)                            goto LABEL_13;                    &#125;                    if (i &gt;= result)                        break;                    v5 = i;                    *(_DWORD *)(a1 + result) = *(_DWORD *)( i + a1);                &#125;                --result;            &#125; while (i &lt; result);        &#125;    LABEL_13:        *(_DWORD *)(a1 + result) = v6;        sub_4010F0(a1, a2, i - 1);        result = a3;        ++i;    &#125;    return result;&#125;int main()&#123;    char v7[] = &#123; 90,74,83,69,67,97,78,72,51,110,103,0&#125;;     sub_4010F0(v7, 0, 10);    printf(&quot;%s&quot;, v7);    return 0;&#125;</code></pre><p>得到：</p><p><img src="/../images/buuctf-solutions/1732716471728.png" alt="1732716471728"></p><p>说明&gt;&gt;&gt;</p><p>①sub_4010F0对v7进行了重新排序。</p><p>②v7 &#x3D; “3CEHJNSZagn”;【变形后的值】</p><p>第三部分：</p><p><img src="/../images/buuctf-solutions/1732716496205.png" alt="1732716496205"></p><p>第四部分：</p><p><img src="/../images/buuctf-solutions/1732716516696.png" alt="1732716516696"></p><p>大意：</p><p>当它条件全部成立且String长度为8[已知] &gt;&gt;&gt;猜测 String&#x3D; flag{}       </p><p>v4 v5 加密后的值 是 ak1w 和V1Ax【在线解密就行 C实现挺困难的。。】</p><p>【猜测是base64，不知道就直接使用 随波逐流 &gt;&gt;&gt;一键解码 0.0】</p><p>眼睛看得肉疼，直接写C脚本：</p><p>对比发现，只有base64中连续含有WP&gt;&gt;&gt;说明base64加密猜测正确。</p><p>最终String结果顺序:</p><p><img src="/../images/buuctf-solutions/1732716547588.png" alt="1732716547588"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt; buuctf 上的一些错题&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="ctf" scheme="http://example.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>Pointer_Topic</title>
    <link href="http://example.com/2025/02/23/Pointer-Topic/"/>
    <id>http://example.com/2025/02/23/Pointer-Topic/</id>
    <published>2025-02-22T16:00:00.000Z</published>
    <updated>2025-03-03T13:31:31.419Z</updated>
    
    <content type="html"><![CDATA[<p> 跟滴水专门学习指针</p><span id="more"></span> <h1 id="指针基础"><a href="#指针基础" class="headerlink" title="指针基础"></a>指针基础</h1><p><img src="/../images/Pointer-Topic/1728113354254.png" alt="1728113354254"></p><p><strong>带*类型的宽度均为4</strong></p><h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h1><p><img src="/../images/Pointer-Topic/1728115779656.png" alt="1728115779656"></p><p><img src="/../images/Pointer-Topic/1728116129664.png" alt="1728116129664"></p><p><img src="/../images/Pointer-Topic/1728116392067.png" alt="1728116392067"></p><img src="../images/Pointer-Topic/1728132948425.png" alt="1728132948425"  /><p><img src="/../images/Pointer-Topic/1728133210279.png" alt="1728133210279"></p><p><img src="/../images/Pointer-Topic/1728136502045.png" alt="1728136502045"></p><pre><code class="c">typedef struct Student&#123;    int x;    int y;&#125;;void Test()&#123;    Student***** s;    s = (Student*****)100;    s++; //104    printf(&quot;%d\n&quot;, s);    s = s + 2; //112    printf(&quot;%d\n&quot;, s);    s = s - 3; //100    printf(&quot;%d\n&quot;, s);&#125;void Test2()&#123;    Student**** s1;    Student**** s2;    int x;    s1 = (Student****)200;    s2 = (Student****)100;    x = s1 - s2; //25    printf(&quot;%d\n&quot;, x);&#125;void Test3()&#123;    Student* s;    s = (Student*)100;    s++; //108    printf(&quot;%d\n&quot;, s);    s = s + 2; //124    printf(&quot;%d\n&quot;, s);    s = s - 3; //100    printf(&quot;%d\n&quot;, s);&#125;void Test4()&#123;    Student* s1;    Student* s2;    int x;    s1 = (Student*)200;    s2 = (Student*)100;    x = s1 - s2; //12.5 (12)    printf(&quot;%d\n&quot;, x);&#125;</code></pre><h1 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h1><pre><code class="c">*p == p[]*(p + 0) == p[0]*(p + 1) == p[1]*( *(p + 0) + 0) == p[0] [0]*( *(p + 1) + 2) == p[1] [2]</code></pre><p><img src="/../images/Pointer-Topic/1728389878637.png" alt="1728389878637"></p><h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><pre><code class="c">char* px[]//类似二维数组//其中&quot;*&quot;表示最后一个“ [] ”</code></pre><pre><code class="c">#include &lt;stdio.h&gt;int main()&#123;    char* a[] = &#123; &quot;hello&quot;,&quot;world&quot; &#125;;    printf(&quot;%c&quot;,*(*(a + 0) + 1));    return 0;&#125;//输出结果为e</code></pre><h3 id="指针数组-1"><a href="#指针数组-1" class="headerlink" title="指针数组"></a>指针数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>指针数组是一个数组，数组中的每个元素都是一个指针。这些指针可以指向不同类型的数据，通常用于存储多个地址。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="c">// 定义一个包含 n 个指针的数组类型 *指针数组名[n];</code></pre><p>例如：</p><pre><code class="c">int *p[5];</code></pre><p>这里 <code>p</code> 是一个包含 5 个 <code>int</code> 类型指针的数组。</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><pre><code class="c">#include &lt;stdio.h&gt;int main() &#123;    int a = 1, b = 2, c = 3, d = 4, e = 5;    int *p[5] = &#123;&amp;a, &amp;b, &amp;c, &amp;d, &amp;e&#125;;    // 访问指针数组中的元素    for (int i = 0; i &lt; 5; i++) &#123;        printf(&quot;%d &quot;, *p[i]);    &#125;    printf(&quot;\n&quot;);    return 0;&#125;</code></pre><p>在这个示例中，<code>p</code> 是一个指针数组，它包含 5 个 <code>int</code> 类型的指针，分别指向变量 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code> 和 <code>e</code>。通过 <code>*p[i]</code> 可以访问这些指针所指向的变量的值。</p><h1 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h1><pre><code class="c">char (*px) [5]*(*(px + 4) + 3) // 1 * 4 * 5 + 3 * 1 == 23int (*px) [5]*(*(px + 2) + 2) // 4 * 5 * 2 + 2 * 4 == 48</code></pre><p><strong>用int（4字节）类型指针取char（1字节）类型数组是一次取4个数 且 输出为倒序</strong></p><h3 id="数组指针-1"><a href="#数组指针-1" class="headerlink" title="数组指针"></a>数组指针</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>数组指针是一种指针，它指向一个数组。也就是说，数组指针存储的是数组的首地址，并且知道所指向数组的大小和元素类型。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code class="c">// 定义一个指向包含 n 个元素的数组的指针类型 (*指针名)[n];</code></pre><p>例如：</p><pre><code class="c">int (*p)[5];</code></pre><p>这里 <code>p</code> 是一个指针，它指向一个包含 5 个 <code>int</code> 类型元素的数组。</p><h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><pre><code class="c">#include &lt;stdio.h&gt;int main() &#123;    int arr[3][5] = &#123;        &#123;1, 2, 3, 4, 5&#125;,        &#123;6, 7, 8, 9, 10&#125;,        &#123;11, 12, 13, 14, 15&#125;    &#125;;    int (*p)[5];    p = arr;  // p 指向二维数组 arr 的第一行    // 访问二维数组元素    for (int i = 0; i &lt; 3; i++) &#123;        for (int j = 0; j &lt; 5; j++) &#123;            printf(&quot;%d &quot;, *(*(p + i) + j));        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><p>在这个示例中，<code>p</code> 是一个数组指针，它指向一个包含 5 个 <code>int</code> 类型元素的数组。通过 <code>p = arr;</code> 让 <code>p</code> 指向二维数组 <code>arr</code> 的第一行，然后可以使用 <code>*(*(p + i) + j)</code> 来访问二维数组中的元素。</p><h1 id="多维数组指针"><a href="#多维数组指针" class="headerlink" title="多维数组指针"></a>多维数组指针</h1><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><p><img src="/../images/Pointer-Topic/1728473292014.png" alt="1728473292014"></p><pre><code class="c">char (*py)[2][3]*(*(*(py + 2) + 3) + 4) //x * 1 * 2 * 3(类型字节和数组宽度【2】【3】相乘) + y * 1 * 3(类型字节和数组宽度“【3】”相乘) + z * 1(类型字节) 2 * 1 * 2 * 3 + 3 * 1 * 3 + 4 * 1 = 25</code></pre><pre><code class="c++">#include&lt;iostream&gt;using namespace std;char memory[] =&#123;    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,    0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,    0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11,    0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,    0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,    0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,    0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,    0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00,    0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,    0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00&#125;;int main() &#123;    int(*p)[2][3] = (int(*)[2][3])memory;    printf(&quot;%x&quot;, *(*(*(p + 1) + 1) + 1));    system(&quot;pause&quot;);    return 0;&#125;//*(*(*(p + 1) + 1) + 1) = 40//打印结果为10640000</code></pre><p><strong>多维的情况与二维相似</strong></p><h1 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h1><pre><code class="c">#include&lt;stdio.h&gt;int main ()&#123;    struct student &#123;        char name[50];        int age;    &#125;;    struct student Person;    strcpy(Person.name,&quot;yiyi&quot;);    Person.age = 18;    printf(&quot;%s\n&quot;,Person.name);    printf(&quot;%d\n&quot;,Person.age);        struct student* p = &amp;Person;    printf(&quot;%s\n&quot;,p-&gt;name);    printf(&quot;%d\n&quot;,p-&gt;age);    return 0;&#125;</code></pre><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p><strong>不能 ++ – 相减 可以比较大小</strong></p><p><strong>可赋函数</strong></p><img src="../images/Pointer-Topic/1728476007607.png" alt="1728476007607" style="zoom: 67%;" /><pre><code class="c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123;    int a[] = &#123; 9,8,7,6,5,4,3,2,1 &#125;;    void (*psort)(int*,int*);    psort = sort;    psort(a, a + 9);    for (int i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) &#123;        cout &lt;&lt; a[i] &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="返回类型为指针的函数"><a href="#返回类型为指针的函数" class="headerlink" title="返回类型为指针的函数"></a>返回类型为指针的函数</h1><pre><code class="c">int* pFun (int a,int b)&#123;    int ret = 0;    return ret;&#125;//返回类型为  int*</code></pre><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><pre><code class="c">#include&lt;stdio.h&gt;char memory[] =&#123;    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x07,0x09,    0x00,0x20,0x10,0x03,0x03,0x0C,0x00,0x00,0x44,0x00,    0x00,0x33,0x00,0x47,0x0C,0x0E,0x00,0x0D,0x00,0x11,    0x00,0x00,0x00,0x02,0x64,0x00,0x00,0x00,0xAA,0x00,    0x00,0x00,0x64,0x10,0x00,0x00,0x00,0x00,0x00,0x00,    0x00,0x00,0x02,0x00,0x74,0x0F,0x41,0x00,0x00,0x00,    0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x0A,0x00,    0x00,0x02,0x57,0x4F,0x57,0x00,0x06,0x08,0x00,0x00,    0x00,0x00,0x00,0x64,0x00,0x0F,0x00,0x00,0x0D,0x00,    0x00,0x00,0x23,0x00,0x00,0x64,0x00,0x00,0x64,0x00&#125;;int same(char* s1, char* s2)&#123;    char ret = 0;    for (char i = 0; i &lt; 3; i++) &#123;        if (*(s1 + i) != *(s2 + i)) &#123;            ret = 0;            break;        &#125;        if (*(s1 + i) == *(s2 + i)) &#123;            ret = 1;        &#125;    &#125;    return ret;&#125;void Find()&#123;    char index = 0;    char name[4];    name[3] = &#39;\0&#39;;    char key[4] = &quot;WOW&quot;;    char memorysize = sizeof(memory) / sizeof(memory[0]);    while (index &lt; memorysize - 2) &#123;        name[0] = *(memory + index);        name[1] = *(memory + index + 1);        name[2] = *(memory + index + 2);        if (same(name, key) == 1) &#123;            printf(&quot;%p\n&quot;, &amp;memory[index]);        &#125;        index++;    &#125;&#125;int main()&#123;    Find();    printf(&quot;%p&quot;, &amp;memory);    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt; 跟滴水专门学习指针&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c_notes</title>
    <link href="http://example.com/2025/02/23/c-notes/"/>
    <id>http://example.com/2025/02/23/c-notes/</id>
    <published>2025-02-22T16:00:00.000Z</published>
    <updated>2025-03-02T13:43:14.531Z</updated>
    
    <content type="html"><![CDATA[<p> 从0开始，向翁凯学c   ^ 0 ^</p><span id="more"></span> <h1 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h1><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;​    return 0;&#125;   //所有代码必备printf(&quot;&quot;)   //输出引号内的内容\n   //换行int   //整形(整数)%d   //代表计算结果​      例:print(&quot;%d&quot;,13+12)​           输出25</code></pre><h1 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h1><p>运算符:+(加),-(减),*(乘),&#x2F;(除),%(取余),&#x3D;</p><p>定义变量:  int(类型)  xxx(变量名称&#x2F;&#x2F; 只能由字母，数字，下划线组成，并且第一个位置只能为字母或下划线，一些C语言的关键字也不能作为变量名称)  &#x3D;(赋值运算符)  0(初始值)  </p><p>&#x2F;&#x2F;将右边的值赋给左边的变量</p><p>变量输入(scanf):</p><p>scanf(“%d,%d”,&amp;a,&amp;b);   &#x2F;&#x2F;输入a，b的值</p><p>注意!!!   scanf 中的引号内所有符号都要输入一个值</p><p>​              例:   scanf(“%d,%d”,&amp;a,&amp;b);</p><p>​                      运行输值时要输入3,4   &#x2F;&#x2F;“，”一定要输进去</p><p>定义常量:  const int xxx(常量名称) &#x3D; 100(赋值)  &#x2F;&#x2F;常量后续更改不了</p><p>int a &#x3D; 0;   &#x2F;&#x2F;赋予a初始值</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>计算时间差:</p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int hour1,minute1;    int hour2,minute2;    printf(&quot;请输入第一时间的几时几分&quot;);     scanf(&quot;%d%d&quot;,&amp;hour1,&amp;minute1);    printf(&quot;请输入第二时间的几时几分&quot;);    scanf(&quot;%d%d&quot;,&amp;hour2,&amp;minute2);    int t1 = hour1 *60 + minute1;    int t2 = hour2 *60 + minute2;    int t = t2 - t1;    printf(&quot;时差为%d时%d分&quot;,t/60,t%60);    return 0;&#125;</code></pre><h1 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h1><p>浮点型(小数):  %d改成%f,并在整数运算中加入小数</p><p>​                     例：printf(“%f”,7&#x2F;12)</p><p> 运用double(双精度)输入小数时:scanf(“%lf”,&amp;a)</p><p>float(单精度)</p><p>C语言运算具有优先级(与平常差不多)</p><h1 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h1><p>交换两个变量:a &#x3D; 4 ,b &#x3D;5</p><p>​                        t &#x3D; a</p><p>​                        a &#x3D; b</p><p>​                        b &#x3D; t</p><p>复合赋值:a +&#x3D; 1   &#x2F;&#x2F;a &#x3D; a + 1   &#x2F;&#x2F;其他运算符类推 </p><p>递增(减)运算符:a++(后置递增)   ++a(前置递增  )</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-10%20213739.png"></p><pre><code class="c">#include&lt;stdio.h&gt; int main()&#123;    int time1 = 0;    int time2 = 0;    printf(&quot;请输入四或三位数来表示时间&quot;);    scanf(&quot;%d&quot;,&amp;time1);    printf(&quot;请输入流逝的时间（分钟）&quot;);    scanf(&quot;%d&quot;,&amp;time2);    int t2 = 0,t1 = 0;    t2 = (time1/100)*60 + time1%100 + time2;    t1 = (t2/60)*100 + t2%60;    printf(&quot;%d&quot;,t1);    return 0;&#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-10%20213727.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int b = 0;    printf(&quot;请输入长度(cm)&quot;);    scanf(&quot;%d&quot;,&amp;b);    double a;    int foot,inch;    a = (b/100.0)/0.3048;    foot = (a * 12)/12;      inch = (a - foot)*12;    printf(&quot;%d英尺 %d英寸&quot;,foot,inch);    return 0; &#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-10%20213810.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    printf(&quot;请输入一个三位数&quot;);    int a = 0;    scanf(&quot;%d&quot;,&amp;a);    int b = a/100;    int c = (a%10)*100;    int d = a%100 - a%10;    printf(&quot;这三位数的逆序为:%d\n&quot;,b+c+d);    return 0;     &#125;</code></pre><p>十六进制:</p><p>printf(“%x”,x)   &#x2F;&#x2F;以十六进制的方式输出一个十进制的数</p><p>一个数前加上”0x”表示这个数为十六进制的数</p><p> <img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-10%20213757.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    printf(&quot;请输入错误输出BCD数&quot;);    int a = 0;    scanf(&quot;%d&quot;,&amp;a);    printf(&quot;%d&quot;,a/16*10+a%16);    return 0;&#125;#include&lt;stdio.h&gt;int main()&#123;    int x = 0;    scanf(&quot;%d&quot;,&amp;x);    printf(&quot;%x&quot;,x);    return 0;&#125;</code></pre><p>&#x2F;&#x2F;BCD数是用一个字节来表示的两位十进制数，一个字节有8bit，每4bit表示十进制的一位，即用八位的二进制数来表示两位的十进制数。</p><p>&#x2F;&#x2F;小明误解将BCD数当二进制输出十进制的18，又18的二进制为0001 0010，其中前四位表示十进制两位数的十，后四位表示个位，即该BCD数为12.</p><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><p>if条件语句:</p><p> if (关系条件) {</p><p>​       符合该条件的后续执行程序</p><p>} else {                        &#x2F;&#x2F;否则</p><p>​       不符合if条件后执行的程序</p><p>}</p><p>若if(else)后不加”{}”则if(else)关系条件执行到下一个分号</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-10%20224941.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20202340.png"></p><p>注意:else if后面跟的条件要不满足if后跟的条件</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-10%20213428.png">                        </p><p> 关系运算符优先级比算术运算地，比赋值运算低，其中相等和不相等的优先级比其他关系运算符更低</p><p>关系运算只有两种结果</p><p>1  表示成立        0   表示不成立 </p><h1 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch-case语句"></a>switch-case语句</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20201742.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20201756.png"></p><p>注意:case表示进入执行程序的位置</p><h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20200902.png"></p><p>注意：while语句是先判断是否符合循环条件再进入循环</p><p>do - while语句是先进入循环再判断是否符合循环条件,且do - while 结束要加”;”</p><h1 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h1><p>随机数:</p><p> 每次召唤一次rand()就得到一个随机的整数</p><p>rand()使用方式:</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20203209.png"></p><h1 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20202914.png"></p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt; int main()&#123;    srand(time(0));    int a = rand()%100 + 1;    int x;    int n = 0;    do&#123;        scanf(&quot;%d&quot;,&amp;x);        n++;        if (x &gt; a)&#123;            printf(&quot;偏大了\n&quot;);        &#125; else if (x &lt; a)&#123;            printf(&quot;偏小了\n&quot;);        &#125;    &#125;while(x != a);    printf(&quot;恭喜你答对了\n&quot;);    printf(&quot;你猜了%d次\n&quot;,n);    return 0;&#125;</code></pre><p>注意:用a%100可以每次得到一个100以内的正整数</p><p>求平均值(当输入-1时表示退出):</p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int x,b = 0;    int n = 0;    scanf(&quot;%d&quot;,&amp;x);    while (x != -1 )&#123;        b = b + x;        n++;        scanf(&quot;%d&quot;,&amp;x);    &#125;    printf(&quot;%f  %d  %d\n&quot;,1.0*b/n,b,n);    return 0;&#125;</code></pre><p>任意数的逆序:</p><pre><code class="c">#include&lt;stdio.h&gt;int main()                                                                                                                                                 &#123;    int a,b,c = 1,n = 0;    scanf(&quot;%d&quot;,&amp;a);    do&#123;         c = c * 10;    &#125;while(a % c != a);    do&#123;        b = a % 10;        a = a / 10;        c = c / 10;        n = b * c + n;    &#125;while(c != 1);`    printf(&quot;%d&quot;,n);    return 0;&#125;</code></pre><p>标答:</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20221145.png"></p><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-13%20213914.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-13%20214003.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-13%20214535.png"></p><p>注意:当满足一定条件时for循环条件可省</p><p>例:</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-13%20215618.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-13%20220415.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-13%20220542.png"></p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-13%20220703.png"></h1><h1 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h1><p>判断素合数:</p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int x,i = 2,d,a = 0;    scanf(&quot;%d&quot;,&amp;x);    for (i = 2;i &lt; x;i++)&#123;        d = x % i;        if (d == 0)&#123;            a = 1;        &#125;     &#125;    if (a == 1)&#123;        printf(&quot;是合数&quot;);    &#125; else &#123;        printf(&quot;是素数&quot;);    &#125;    return 0;&#125;</code></pre><h1 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和<strong>continue</strong>语句</h1><p>break:在循环中如果有”break”那就会跳出循环</p><p>例:</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-15%20195231.png"></p><p>continue:跳过循环这一轮剩下的语句进入下一轮(用法与break一样) </p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-15%20195641.png"></p><h1 id="嵌套的循环"><a href="#嵌套的循环" class="headerlink" title="嵌套的循环"></a><strong>嵌套的循环</strong></h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-18%20205455-1726742503702.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int x = 0,one,two,five;    scanf(&quot;%d&quot;,&amp;x);    for(one = 1;one &lt; 100 ; one++)&#123;        for(two = 1;two * 2 &lt; 100 ;two++)&#123;            for(five = 1;five * 5 &lt; 100 ;five++)&#123;                if (one + two * 2 + five * 5 == x * 10)&#123;                    printf(&quot;%d个一角，%d个两角，%d个五角可以组成%d元\n&quot;,one,two,five,x);                &#125;            &#125;        &#125;    &#125;     return 0;&#125;</code></pre><h1 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-18%20204256-1726742529608.png"></p><p>goto out跳出所有循环,break只能跳出一个循环</p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int x = 0,one,two,five;    scanf(&quot;%d&quot;,&amp;x);    for(one = 1;one &lt; 100 ; one++)&#123;        for(two = 1;two * 2 &lt; 100 ;two++)&#123;            for(five = 1;five * 5 &lt; 100 ;five++)&#123;                if (one + two * 2 + five * 5 == x * 10)&#123;                    printf(&quot;%d个一角，%d个两角，%d个五角可以组成%d元\n&quot;,one,two,five,x);                goto out;                &#125;            &#125;        &#125;    &#125;out :     return 0;&#125;# 前n项求和&amp;练习</code></pre><h1 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h1><h2 id="前n项求和"><a href="#前n项求和" class="headerlink" title="前n项求和"></a>前n项求和</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-18%20205715.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int n,i;    double s = 0;    scanf(&quot;%d&quot;,&amp;n);    for(i = 1;i &lt;= n;i++)&#123;        s = s +1.0 / i;    &#125;    printf(&quot;%f&quot;,s);    return 0;&#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-18%20205734.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int n,i,sign = 1;    double s = 0;    scanf(&quot;%d&quot;,&amp;n);    for(i = 1;i &lt;= n;i++)&#123;        s = s + sign * 1.0 / i;        sign *= -1;    &#125;    printf(&quot;%f&quot;,s);    return 0;&#125;&lt;img src=&quot;C语言笔记.assets/屏幕截图 2024-09-18 215916.png&quot; style=&quot;zoom:33%;&quot; /&gt;</code></pre><h2 id="正序分解整数"><a href="#正序分解整数" class="headerlink" title="正序分解整数"></a>正序分解整数</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-18%20215916.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int c = 1,x;    scanf(&quot;%d&quot;,&amp;x);    while(x % c != x)&#123;        c = c * 10;    &#125;    do&#123;        c /= 10;        printf(&quot;%d &quot;,x / c);        x = x % c;    &#125;while(c != 1);    return 0;&#125;错解:</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-18%20220546.png"></p><p>注意:先将数逆序再将数分解,但是如果输入700,输出的结果只为7(700逆序后为7)</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-18%20223155.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int i,a,b,n;    scanf(&quot;%d&quot;,&amp;a);    scanf(&quot;%d&quot;,&amp;b);    for(i = a ;i &gt;= 1;i--)&#123;        if(a % i == 0)&#123;            for(n = b;n &gt;= 1;n--)&#123;                if(b % n == 0)&#123;                &#125;                    if(i == n)&#123;                        printf(&quot;%d&quot;,i);                    goto out;            &#125;                &#125;            &#125;        &#125;    &#125;out :    return 0;&#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-19%20183220.png"></p><h3 id="求最大公约数方法"><a href="#求最大公约数方法" class="headerlink" title="求最大公约数方法"></a>求最大公约数方法</h3><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-19%20184408.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-19%20185129.png"></p><h1 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h1><h2 id="整数集"><a href="#整数集" class="headerlink" title="整数集"></a>整数集</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-19%20193414.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-19%20201619.png"></p><pre><code class="c">#include&lt;stdio.h&gt; int main()&#123;    int a,i,j,k;    int c = 0;     scanf(&quot;%d&quot;,&amp;a);    i = a;    while(i &lt;= a +3)&#123;        j = a;        while(j &lt;= a+3)&#123;            k = a;            while(k &lt;= a+3)&#123;                if (i != j)&#123;                    if (i != k)&#123;                        if (j != k)&#123;                            printf(&quot;%d%d%d&quot;,i,j,k);                            c++;                            if(c == 6)&#123;                                printf(&quot;\n&quot;);                                c = 0;                            &#125; else &#123;                                printf(&quot; &quot;);                            &#125;                        &#125;                    &#125;                &#125;                k++;            &#125;            j++;        &#125;        i++;    &#125;    return 0;&#125; </code></pre><h2 id="水仙花数"><a href="#水仙花数" class="headerlink" title="水仙花数"></a>水仙花数</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-19%20202004.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    int first = 1,i = 1;    while(i &lt; n)&#123;        first *= 10;        i ++;     &#125;    i = first;    while(i &lt; first * 10)&#123;        int t = i;        int s = 0;        do &#123;            int b = 1;            int a = t % 10;            int c = 1;            t /= 10;            while(b &lt;= n)&#123;            c *= a;            b ++;             &#125;        s += c;         &#125;while(t != 0);        if (s == i)&#123;            printf(&quot;%d\n&quot;,i);        &#125;        i ++;    &#125;    return 0;&#125; </code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-19%20212939.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-19%20213008.png"></p><h2 id="打印九九口诀表"><a href="#打印九九口诀表" class="headerlink" title="打印九九口诀表"></a>打印九九口诀表</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-19%20213252.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int i = 1,j = 1;    for(j = 1;j &lt;= 9;j ++)&#123;        for(i = 1;i &lt;= 9;i ++)&#123;            if (i &lt;= j)&#123;                printf(&quot;%d * %d = %d&quot;,i,j,i * j);                if (i * j &lt; 10)&#123;                    printf(&quot;   &quot;);                &#125; else &#123;                    printf(&quot;  &quot;);                &#125;                &#125;            &#125;        printf(&quot;\n&quot;);        &#125;    return 0;&#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-19%20221918.png"></p><h2 id="统计素数并求和"><a href="#统计素数并求和" class="headerlink" title="统计素数并求和"></a>统计素数并求和</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-21%20204710.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int n,m,sign = 0, s = 0,a = 0;    scanf(&quot;%d&quot;,&amp;n);    scanf(&quot;%d&quot;,&amp;m);    if (n &gt; m)&#123;        if (m = 1)&#123;            m = 2;        &#125;        int i = m ;        while (i &lt;= n)&#123;            int j = 2;            sign = 0;            while (j &lt; i)&#123;                if (i % j == 0)&#123;                    sign = 1;                &#125;                j ++;            &#125;            if (sign == 0)&#123;                s = s + i;                a ++;            &#125;            i ++;        &#125;    &#125; else if (m &gt; n)&#123;        if (n == 1)&#123;            n = 2;        &#125;        int i = n ;        while (i &lt;= m)&#123;            int j = 2;            sign = 0;            while (j &lt; i)&#123;                if (i % j == 0)&#123;                    sign = 1;                &#125;                j ++;            &#125;            if (sign == 0)&#123;                s = s + i;                a ++;            &#125;            i ++;        &#125;    &#125;     printf(&quot;%d  %d&quot;,a,s);    return 0;&#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-21%20214821.png"></p><h2 id="前N项和"><a href="#前N项和" class="headerlink" title="前N项和"></a>前N项和</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-22%20224620.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int n,i;    int a = 2, b = 1, t = 0;    double s = 0;    scanf_s(&quot;%d&quot;, &amp;n);    for (i = 1; i &lt;= n; i ++) &#123;        s = s + 1.0 * a  / b;        t = a;        a = a + b;        b = t;    &#125;    printf(&quot;%.2f&quot;, s);    return 0;&#125;</code></pre><p>注意:visual studio中”scanf”要被”scanf_s”代替,或在顶行加上#define _CRT_SECURE_NO_WARNINGS和#pragma warning(disable:6031)</p><p>int 定义类型的数有范围，超过该范围就会变成负数，应用更大范围的类型来表达如:double</p><p>%f用%.2f表示精确到小数点后两位</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-22%20230945.png"></p><h2 id="约分最简分式"><a href="#约分最简分式" class="headerlink" title="约分最简分式"></a>约分最简分式</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-22%20231112.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int a = 0, b = 0;    int i;    scanf_s(&quot;%d&quot;,&amp;a);    scanf_s(&quot;%d&quot;,&amp;b);    if (a &gt; b) &#123;        for (i = b; i &gt; 0; i--) &#123;            if (b % i == 0) &#123;                if (a % i == 0) &#123;                    printf(&quot;%d / %d = %d / %d&quot;, a, b, a / i, b / i);                    break;                &#125;            &#125;        &#125;    &#125;    else if (b &gt; a) &#123;        for (i = a; i &gt; 0; i--) &#123;            if (a % i == 0) &#123;                if (b % i == 0) &#123;                    printf(&quot;%d / %d = %d / %d&quot;, a, b, a / i, b / i);                    break;                &#125;            &#125;        &#125;    &#125;    else &#123;        printf(&quot;%d / %d = 1 / 1&quot;, a, b);    &#125;    return 0;&#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-22%20232825.png"></p><h2 id="念数字"><a href="#念数字" class="headerlink" title="念数字"></a>念数字</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-22%20233536.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int n, b = 1, a = 0, c = 0;    scanf_s(&quot;%d&quot;, &amp;n);    if (n &gt; 0) &#123;        do &#123;            b = b * 10;            a = n / b;        &#125; while (a != 0);        do &#123;            c = n / (b / 10);            n = n % (b / 10);            b = b / 10;            if (c == 0) &#123;                printf(&quot;ling&quot;);            &#125;            else if (c == 1) &#123;                printf(&quot;yi&quot;);            &#125;            else if (c == 2) &#123;                printf(&quot;er&quot;);            &#125;            else if (c == 3) &#123;                printf(&quot;san&quot;);            &#125;            else if (c == 4) &#123;                printf(&quot;si&quot;);            &#125;            else if (c == 5) &#123;                printf(&quot;wu&quot;);            &#125;            else if (&quot;c == 6&quot;) &#123;                printf(&quot;liu&quot;);            &#125;            else if (c == 7) &#123;                printf(&quot;qi&quot;);            &#125;            else if (c == 8) &#123;                printf(&quot;ba&quot;);            &#125;            else &#123;                printf(&quot;jiu&quot;);            &#125;            if (n &gt; 0)&#123;            printf(&quot; &quot;);        &#125;        &#125; while (n != 0);    &#125;    else if (n &lt; 0) &#123;        n = -n;        printf(&quot;fu &quot;);        do &#123;            b = b * 10;            a = n / b;        &#125; while (a != 0);        do &#123;            c = n / (b / 10);            n = n % (b / 10);            b = b / 10;            if (c == 0) &#123;                printf(&quot;ling&quot;);            &#125;            else if (c == 1) &#123;                printf(&quot;yi&quot;);            &#125;            else if (c == 2) &#123;                printf(&quot;er&quot;);            &#125;            else if (c == 3) &#123;                printf(&quot;san&quot;);            &#125;            else if (c == 4) &#123;                printf(&quot;si&quot;);            &#125;            else if (c == 5) &#123;                printf(&quot;wu&quot;);            &#125;            else if (&quot;c == 6&quot;) &#123;                printf(&quot;liu&quot;);            &#125;            else if (c == 7) &#123;                printf(&quot;qi&quot;);            &#125;            else if (c == 8) &#123;                printf(&quot;ba&quot;);            &#125;            else &#123;                printf(&quot;jiu&quot;);            &#125;            if (n &gt; 0)&#123;            printf(&quot; &quot;);        &#125;        &#125; while (n != 0);    &#125;    else &#123;        printf(&quot;ling&quot;);    &#125;    return 0;&#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20000019.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20000036.png"></p><h2 id="求a的连续和"><a href="#求a的连续和" class="headerlink" title="求a的连续和"></a>求a的连续和</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20001127.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int a,n,s = 0;    scanf_s(&quot;%d&quot;,&amp;a);    scanf_s(&quot;%d&quot;, &amp;n);    int t = a, i = 0;    do &#123;        s = s + a;        a = a * 10 + t;        i++;    &#125; while(i != n);    printf(&quot;%d&quot;, s);    return 0;&#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20211946.png"></p><h1 id="C语言类型"><a href="#C语言类型" class="headerlink" title="C语言类型"></a>C语言类型</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20212606.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20212656.png"></p><h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20212758.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20212845.png"></p><h1 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20213010.png"></p><h2 id="二进制的负数"><a href="#二进制的负数" class="headerlink" title="二进制的负数"></a>二进制的负数</h2><p>补码(对于一个字节):0 &#x3D; 0000 0000 , 1 &#x3D; 0000 0001</p><p>-1 &#x3D; 0 - 1&#x3D; 1 0000 0000 - 0000 0001 &#x3D; 1111 1111</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20213435.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20213553.png"></p><h2 id="整数越界"><a href="#整数越界" class="headerlink" title="整数越界"></a>整数越界</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20213819.png"></p><h2 id="整数的输入与输出"><a href="#整数的输入与输出" class="headerlink" title="整数的输入与输出"></a>整数的输入与输出</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20213929.png"></p><h3 id="八进制与十六进制"><a href="#八进制与十六进制" class="headerlink" title="八进制与十六进制"></a>八进制与十六进制</h3><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20214139.png"></p><h1 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h1><p>取消输出的补码 (没有负数)</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20213629.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20214230.png"></p><h1 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20214328.png"></p><h2 id="浮点类型的输入与输出"><a href="#浮点类型的输入与输出" class="headerlink" title="浮点类型的输入与输出"></a>浮点类型的输入与输出</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20214415.png"></p><p>%e 表示采用科学计数法</p><p>%.xf 表示精确到小数点后x位(采用四舍五入 )</p><h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h3><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-23%20214525.png"></p><h2 id="浮点运算的精度"><a href="#浮点运算的精度" class="headerlink" title="浮点运算的精度"></a>浮点运算的精度</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20215122.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20215202.png"></p><h1 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20215337.png"></p><p>赋值时带’  ‘表示赋予字符,每个字符有对应的ASCII值</p><h2 id="字符计算"><a href="#字符计算" class="headerlink" title="字符计算"></a>字符计算</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20220155.png"></p><h1 id="逃逸字符"><a href="#逃逸字符" class="headerlink" title="逃逸字符"></a>逃逸字符</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20220913.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20220925.png"></p><h2 id="b"><a href="#b" class="headerlink" title="\b"></a>\b</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20221540.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20221551.png"></p><h2 id="t"><a href="#t" class="headerlink" title="\t"></a>\t</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20221911.png"></p><p>对齐</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20222031.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20222039.png"></p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20222248.png"></p><p>如果整数和浮点在一起时，会自动转换为浮点</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20222347.png"></p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20222629.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20222753.png"></p><h1 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20222939.png"></p><p>真为1，假为0</p><h1 id="fabs"><a href="#fabs" class="headerlink" title="fabs"></a>fabs</h1><p>表示绝对值:fabs()</p><h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20223118.png"></p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20223228.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20223336.png"></p><h2 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20223524.png"></p><h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20223608.png"></p><h2 id="优先级-1"><a href="#优先级-1" class="headerlink" title="优先级"></a>优先级</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20223639.png"></p><h1 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20223741.png"></p><p>逗号优先级最低</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-24%20223902.png"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20213701.png"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20213753.png"></p><p>void返回类型表示不返回值</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20214741.png"></p><p>调用函数</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20214011.png"></p><h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h2><p>如果调用函数需要一个结果，则需要用return返回</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20214426.png"></p><p>一般单一出口(一个函数只有一个return)</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20214540.png"></p><p>返回值:</p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20214615.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20214640.png"></p><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20215008.png"></p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20215259.png"></p><h2 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20215356.png"></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20215618.png"></p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>当没有输入参数时要写成void  sum(void)</p><h1 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><img src="/../images/c-notes/1727528819224.png" alt="1727528819224"></p><h2 id="强制类型转换-1"><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p><img src="/../images/c-notes/1727528913816.png"></p><p><img src="/../images/c-notes/1727528967806.png"></p><p><img src="/../images/c-notes/1727529009704.png"></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20160935.png"></p><h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20160815.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20161046.png"></p><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20161154.png"></p><h2 id="数组的集成初始化"><a href="#数组的集成初始化" class="headerlink" title="数组的集成初始化"></a>数组的集成初始化</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20161706.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20161938.png"></p><h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20162101.png"></p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20162142.png"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意!!"></a>注意!!</h3><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20162319.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20170435.png"></p><p> 表示先将i赋给prime[count]，然后count再加1</p><h2 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20154431.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int number[100];    int x, i = 0;    scanf_s(&quot;%d&quot;, &amp;x);    while (x != -1) &#123;        number[i] = x;        scanf_s(&quot;%d&quot;, &amp;x);        i ++;    &#125;    int t = i ,sum = 0;    for (i = 0; i &lt; t; i ++) &#123;        sum += number[i];    &#125;    double pingjunshu = sum * 1.0 / t;    printf(&quot;%f\n&quot;, pingjunshu);    for (i = 0; i &lt; t; i ++) &#123;        if (number[i] &gt; pingjunshu) &#123;            printf(&quot;%d\n&quot;, number[i]);        &#125;    &#125;    return 0;&#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-25%20221753.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int count[10];    int x, i;    for (i = 0; i &lt; 10; i++) &#123;        count[i] = 0;    &#125;    scanf_s(&quot;%d&quot;, &amp;x);    while (x != -1) &#123;        for (i = 0; i &lt; 10; i++) &#123;            if (x == i) &#123;                count[i] ++;            &#125;        &#125;        scanf_s(&quot;%d&quot;, &amp;x);    &#125;    for (i = 0; i &lt; 10; i++) &#123;        printf(&quot;%d出现的次数为%d\n&quot;, i, count[i]);    &#125;    return 0;&#125;</code></pre><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20163056.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int search(int key, int a[], int length);int main ()&#123;    int a[] = &#123; 1,2,4,5,7,24,34,40 &#125;;    int x;    scanf_s(&quot;%d&quot;, &amp;x);    int length = sizeof(a) / sizeof(a[0]);    int loc = search(x,a,length);    if (loc == -1) &#123;        printf(&quot;不存在&quot;);    &#125;    else &#123;        printf(&quot;%d在数组a的第%d位上&quot;, x, loc);    &#125;    return 0;&#125;int search(int key, int a[], int length)&#123;    int i,ret;    for (i = 0; i &lt; length; i++) &#123;        if (a[i] == key) &#123;            ret = i + 1;            break;        &#125;        else &#123;            ret = -1;        &#125;    &#125;    return ret;&#125;</code></pre><h3 id="输出100以内的素数"><a href="#输出100以内的素数" class="headerlink" title="输出100以内的素数"></a>输出100以内的素数</h3><pre><code class="c">#include&lt;stdio.h&gt;int isPrime(int i, int prime[],int count);int main()&#123;    int number = 100;    int prime[100] = &#123; 2 &#125;;    int i = 3;    int count = 1;    int cnt = 0;    for (i = 3; i &lt; number; i++) &#123;        if (isPrime(i,prime,count)) &#123;            prime[count++] = i;        &#125;    &#125;    for (cnt = 0;cnt &lt; count ; cnt ++)&#123;        printf(&quot;%d&quot;,prime[cnt]);        if((cnt + 1) % 5 == 0)&#123;            printf(&quot;\n&quot;);                    &#125; else &#123;            printf(&quot; \t&quot;);        &#125;    &#125;    return 0;&#125;int isPrime(int i, int prime[],int count)&#123;    int ret = 0;    int j;    for (j = 0; j &lt; count; j++) &#123;        if (i % prime[j] == 0) &#123;            ret = 0;            break;        &#125;        else &#123;            ret = 1;        &#125;    &#125;    return ret;&#125;</code></pre><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><img src="/../images/c-notes/1728473306997.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-26%20195846.png"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;    int board[3][3];      int i, j;    int numofx = 0, numofo = 0;    int result = 0;     for (i = 0; i &lt; 3; i++) &#123;        for (j = 0; j &lt; 3; j++) &#123;            scanf_s(&quot;%d&quot;, &amp;board[i][j]);        &#125;    &#125;    for (i = 0; i &lt; 3; i++) &#123;        for (j = 0; j &lt; 3; j++) &#123;            if (board[i][j] == 1) &#123;                numofx++;            &#125;            else &#123;                numofo++;            &#125;        &#125;        if (numofx == 3) &#123;            printf(&quot;x赢&quot;);            result = 1;            break;        &#125;        else if (numofo == 3) &#123;            printf(&quot;o赢 &quot;);            result = 1;            break;        &#125;    &#125;    for (j = 0; j &lt; 3; i++) &#123;        for (i = 0; i &lt; 3; i++) &#123;            if (board[i][j] == 1) &#123;                numofx++;            &#125;            else &#123;                numofo++;            &#125;        &#125;        if (numofx == 3) &#123;            printf(&quot;x赢&quot;);            result = 1;            break;        &#125;        else if (numofo == 3) &#123;            printf(&quot;o赢 &quot;);            result = 1;            break;        &#125;    &#125;    for (i = 0, j = 0; i &lt; 3 &amp;&amp; j &lt; 3; i++, j++) &#123;        if (board[i][j] == 1) &#123;            numofx++;        &#125;        else &#123;            numofo++;        &#125;            if (numofx == 3) &#123;            printf(&quot;x赢&quot;);            result = 1;            break;        &#125;        else if (numofo == 3) &#123;            printf(&quot;o赢 &quot;);            result = 1;        break;        &#125;    &#125;    for (i = 2, j = 0; i &gt;= 0 &amp;&amp; j &lt; 3; i--, j++) &#123;        if (board[i][j] == 1) &#123;            numofx++;        &#125;        else &#123;            numofo++;        &#125;        if (numofx == 3) &#123;            printf(&quot;x赢&quot;);            result = 1;            break;        &#125;        else if (numofo == 3) &#123;            printf(&quot;o赢 &quot;);            result = 1;            break;        &#125;    &#125;    if (result = 0)&#123;        printf(&quot;平局&quot;);    &#125;    return 0;&#125;</code></pre><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="取地址运算"><a href="#取地址运算" class="headerlink" title="取地址运算"></a>取地址运算</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符&amp;"></a>运算符&amp;</h3><p><img src="/../images/c-notes/1727532035969.png"></p><p>用printf(“%p”,&amp;i);输出地址</p><p><img src="/../images/c-notes/1727532078972.png"></p><p>数组地址:</p><p>a[] &#x3D; a &#x3D; a [0]</p><p>a[1] &#x3D; a[0] + 4</p><h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h2><p><img src="/../images/c-notes/1727532944522.png"></p><p><img src="/../images/c-notes/1727533058097.png"></p><p><img src="/../images/c-notes/1727533177219-1740285397678.png"></p><p><img src="/../images/c-notes/1727533193475.png"></p><h3 id="单目运算符"><a href="#单目运算符" class="headerlink" title="单目运算符 *"></a>单目运算符 *</h3><p><img src="/../images/c-notes/1727533359681.png"></p><h3 id="找出数组中的最大值和最小值"><a href="#找出数组中的最大值和最小值" class="headerlink" title="找出数组中的最大值和最小值"></a>找出数组中的最大值和最小值</h3><pre><code class="c">#include&lt;stdio.h&gt;void minmax(int a[], int* pmin, int* pmax, int len);int main ()&#123;    int a[] = &#123;1,123,3,2,345,13,545,412,3,123,12,3123,13,45,37&#125;;    int min, max,len;    minmax(a, &amp;min, &amp;max, sizeof(a) / sizeof(a[0]));    printf(&quot;min=%d,max=%d\n&quot;, min, max);    return 0;&#125;void minmax(int a[], int* min, int* max, int len)&#123;    *min = a[0];    *max = a[0];    int i;    for (i = 1; i &lt; len; i++) &#123;        if (a[i] &lt; *min) &#123;            *min = a[i];        &#125;        if (a[i] &gt; *max) &#123;            *max = a[i];        &#125;    &#125;&#125;</code></pre><h2 id="指针的应用"><a href="#指针的应用" class="headerlink" title="指针的应用"></a>指针的应用</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20154712-1728039591656.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20154725-1728039602794.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20154753-1728039625370.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20154804-1728039643497.png"></p><h2 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20155505-1728039694168.png"></p><p><strong>数组是特殊的指针</strong></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20160252.png"></p><h2 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20190356-1728110535491.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20190551.png"></p><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20190850.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20191001.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20191032.png"></p><h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20193311.png"></h3><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20193344.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20193416.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20193736-1728110706673.png"></p><h2 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a>0地址</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20194305.png"></p><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20194559.png"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-04%20194926.png"></p><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p><img src="/../images/c-notes/1728111371013.png"></p><p><img src="/../images/c-notes/1728111349953.png" alt="1728111349953"></p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p><img src="/../images/c-notes/1728111409362.png"></p><p><img src="/../images/c-notes/1728111990160.png" alt="1728111990160"></p><pre><code class="c">free(a);</code></pre><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><img src="/../images/c-notes/1728544849886.png"></p><p><img src="/../images/c-notes/1728544870671.png" alt="1728544870671"></p><p><img src="/../images/c-notes/1728544969665.png" alt="1728544969665"></p><p><img src="/../images/c-notes/1728545010581.png" alt="1728545010581"></p><h2 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h2><p><img src="/../images/c-notes/1728544928455.png"></p><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p><img src="/../images/c-notes/1728545202996.png" alt="1728545202996"></p><p><strong>指针改不了字符串 而 数组可以更改字符串</strong></p><p><img src="/../images/c-notes/1728545346143.png"></p><p><img src="/../images/c-notes/1728545419325.png" alt="1728545419325"></p><h2 id="字符串输入与输出"><a href="#字符串输入与输出" class="headerlink" title="字符串输入与输出"></a>字符串输入与输出</h2><p><img src="/../images/c-notes/1728545804815.png" alt="1728545804815"></p><p><strong>输入输出字符串用 % s</strong></p><p><strong>输入输出单个字符用 % c</strong></p><p><img src="/../images/c-notes/1728545908776.png" alt="1728545908776"></p><p><strong>最多读7个字符</strong></p><p><img src="/../images/c-notes/1728545966709.png" alt="1728545966709"></p><p><strong>从上一个scanf未读完的字符开始</strong></p><p><img src="/../images/c-notes/1728546017939.png" alt="1728546017939"></p><p><img src="/../images/c-notes/1728546133500.png" alt="1728546133500"></p><h2 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h2><p><img src="/../images/c-notes/1728546875101.png" alt="1728546875101"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-10%20155405.png"></p><p><strong>二维数组后一个“ [] “要写宽度</strong></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-10%20155415.png"></p><p><strong>其中”*”表示最后一个“ [] ”</strong></p><p><img src="/../images/c-notes/1728546807266.png"></p><h2 id="单字符的输入与输出"><a href="#单字符的输入与输出" class="headerlink" title="单字符的输入与输出"></a>单字符的输入与输出</h2><p><img src="/../images/c-notes/1728547674526.png" alt="1728547674526"></p><p><img src="/../images/c-notes/1728547777802.png" alt="1728547777802"></p><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p><img src="/../images/c-notes/1728548310966.png"></p><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p><img src="/../images/c-notes/1728548358630.png"></p><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><p><img src="/../images/c-notes/1728548710772.png"></p><p><strong>如果s1 !&#x3D; s2则输出s1 和 s2 不想等字符的差值</strong></p><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><p><img src="/../images/c-notes/1728549426176.png" alt="1728549426176"></p><p><img src="/../images/c-notes/1728549710586.png"></p><h3 id="字符串搜索函数"><a href="#字符串搜索函数" class="headerlink" title="字符串搜索函数"></a>字符串搜索函数</h3><p><img src="/../images/c-notes/1728550121324.png"></p><p><strong>返回指针，指向那个字符的地址</strong></p><p><strong>第一个从左开始找</strong></p><p><strong>第二个从右开始找</strong></p><p><img src="/../images/c-notes/1728550410578.png"></p><p><strong>第二个函数忽略大小写</strong></p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/../images/c-notes/1728550783505.png" alt="1728550783505"></p><p><img src="/../images/c-notes/1728550904471.png" alt="1728550904471"></p><p><img src="/../images/c-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-10%20170227.png"></p><p><img src="/../images/c-notes/1728550954868.png"></p><p><img src="/../images/c-notes/1728551084963.png" alt="1728551084963"></p><p><img src="/../images/c-notes/1728551117511.png" alt="1728551117511"></p><p><strong>red &#x3D; 1,yellow &#x3D; 2,green &#x3D; 5</strong></p><p><img src="/../images/c-notes/1728551202961.png" alt="1728551202961"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 从0开始，向翁凯学c   ^ 0 ^&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="c" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>cgg_notes</title>
    <link href="http://example.com/2025/02/23/cgg-notes/"/>
    <id>http://example.com/2025/02/23/cgg-notes/</id>
    <published>2025-02-22T16:00:00.000Z</published>
    <updated>2025-03-05T13:13:07.296Z</updated>
    
    <content type="html"><![CDATA[<p>向黑马程序员学c++，目标成为黑马程序员</p> <span id="more"></span> <h1 id="c-基本要求"><a href="#c-基本要求" class="headerlink" title="c++基本要求"></a>c++基本要求</h1><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int main ()&#123;    cout &lt;&lt; &quot;hello C++&quot; &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p><strong>单行注释:&#x2F;&#x2F;</strong></p><p><strong>多行注释:&#x2F;* ……. *&#x2F;</strong></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><pre><code class="c++">int(类型) a(变量名) = 10(初始值);</code></pre><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p><strong>定义:记录程序中不可修改的数据</strong></p><h2 id="定义常量方式"><a href="#定义常量方式" class="headerlink" title="定义常量方式"></a>定义常量方式</h2><p><strong>宏常量</strong></p><pre><code class="c++">#define 常量名 常量值 #define day 7</code></pre><p><strong>const修饰的变量</strong></p><pre><code class="c++">const 类型 常量名 = 常量值;const int day = 7;cant &lt;&lt; &quot;一种一共有：&quot; &lt;&lt; day &lt;&lt; &quot;天&quot; &lt;&lt; endl;</code></pre><h1 id="c-关键字-标识符"><a href="#c-关键字-标识符" class="headerlink" title="c++关键字(标识符)"></a>c++关键字(标识符)</h1><p><img src="/../images/cgg-notes/1728648671136.png" alt="1728648671136"></p><h1 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h1><p><img src="/../images/cgg-notes/1728648768629.png" alt="1728648768629"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p><img src="/../images/cgg-notes/1728651299146.png" alt="1728651299146"></p><h2 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h2><p><img src="/../images/cgg-notes/1728651360263.png" alt="1728651360263"></p><h2 id="实型-浮点型"><a href="#实型-浮点型" class="headerlink" title="实型(浮点型)"></a>实型(浮点型)</h2><p><img src="/../images/cgg-notes/1728651436645.png" alt="1728651436645"></p><p><strong>注意：用float时赋值的数后要加f</strong></p><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p><img src="/../images/cgg-notes/1728651513153.png" alt="1728651513153"></p><p><strong>char 字符 只为单个 且 要用单引号</strong></p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p><img src="/../images/cgg-notes/1728651621531.png" alt="1728651621531"></p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><h3 id="c风格字符串"><a href="#c风格字符串" class="headerlink" title="c风格字符串"></a>c风格字符串</h3><p><img src="/../images/cgg-notes/1728651708484.png" alt="1728651708484"></p><h3 id="c-风格字符串"><a href="#c-风格字符串" class="headerlink" title="c++风格字符串"></a>c++风格字符串</h3><p><img src="/../images/cgg-notes/1728651795935.png" alt="1728651795935"></p><p><strong>注意：要包含string头文件</strong></p><p>布尔数据类型 bool</p><p><img src="/../images/cgg-notes/1728651852075.png" alt="1728651852075"></p><h1 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h1><p><img src="/../images/cgg-notes/1728651927686.png" alt="1728651927686"></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><img src="/../images/cgg-notes/1728651996340.png" alt="1728651996340"></p><p><img src="/../images/cgg-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-11%20210613.png"></p><p><img src="/../images/cgg-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-11%20210559.png"></p><p><strong>前置递增和后置递增区别</strong></p><p><img src="/../images/cgg-notes/1728652053948.png" alt="1728652053948"></p><h1 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h1><p><strong>if</strong></p><p><strong>while</strong></p><p><strong>for</strong></p><p><strong>switch</strong></p><p><strong>和C语言一样</strong></p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p> <img src="/../images/cgg-notes/1728652494423.png" alt="1728652494423"></p><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p><img src="/../images/cgg-notes/1728652569659.png" alt="1728652569659"></p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p><img src="/../images/cgg-notes/1728652630606.png" alt="1728652630606"></p><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p><img src="/../images/cgg-notes/1728652689026.png" alt="1728652689026"></p><p><img src="/../images/cgg-notes/1728652706923.png" alt="1728652706923"></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><img src="/../images/cgg-notes/1728652882896.png" alt="1728652882896"></p><p><img src="/../images/cgg-notes/1728652913002.png" alt="1728652913002"></p><p><img src="/../images/cgg-notes/1728653007620.png" alt="1728653007620"></p><p><strong>类似c语言</strong></p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><img src="/../images/cgg-notes/1728653132986.png" alt="1728653132986"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><img src="/../images/cgg-notes/1728653235312.png" alt="1728653235312"></p><p><strong>和C一样</strong></p><h2 id="函数常见样式"><a href="#函数常见样式" class="headerlink" title="函数常见样式"></a>函数常见样式</h2><p><img src="/../images/cgg-notes/1728653612848.png" alt="1728653612848"></p><h2 id="函数分文件编写"><a href="#函数分文件编写" class="headerlink" title="函数分文件编写"></a>函数分文件编写</h2><p><img src="/../images/cgg-notes/1728653738687.png" alt="1728653738687"></p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p><img src="/../images/cgg-notes/1728654241274.png" alt="1728654241274"></p><h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><p><img src="/../images/cgg-notes/1728654309593.png" alt="1728654309593"></p><h3 id="使用其他文件函数"><a href="#使用其他文件函数" class="headerlink" title="使用其他文件函数"></a>使用其他文件函数</h3><p><img src="/../images/cgg-notes/1728654369706.png" alt="1728654369706"></p><p><strong>包含头文件</strong></p><h1 id="指针-类似C"><a href="#指针-类似C" class="headerlink" title="指针(类似C)"></a>指针(类似C)</h1><p><img src="/../images/cgg-notes/1728655012510.png" alt="1728655012510"></p><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p><img src="/../images/cgg-notes/1728655085281.png" alt="1728655085281"></p><p><img src="/../images/cgg-notes/1728655098943.png" alt="1728655098943"></p><p><img src="/../images/cgg-notes/1728655270292.png" alt="1728655270292"></p><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p><img src="/../images/cgg-notes/1728655364959.png" alt="1728655364959"></p><p><strong>没向系统申请的地址</strong></p><p> <img src="/../images/cgg-notes/1728655506142.png" alt="1728655506142"></p><p><img src="/../images/cgg-notes/1728655539530.png" alt="1728655539530"></p><h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><p><img src="/../images/cgg-notes/1728655595373.png" alt="1728655595373"></p><p><img src="/../images/cgg-notes/1728656213819.png" alt="1728656213819"></p><p><img src="/../images/cgg-notes/1728656182562.png" alt="1728656182562"></p><p><img src="/../images/cgg-notes/1728656271459.png" alt="1728656271459"></p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="结构体基本概念"><a href="#结构体基本概念" class="headerlink" title="结构体基本概念"></a>结构体基本概念</h2><p><img src="/../images/cgg-notes/1728806278108.png" alt="1728806278108"></p><h2 id="结构体定义和使用"><a href="#结构体定义和使用" class="headerlink" title="结构体定义和使用"></a>结构体定义和使用</h2><p><img src="/../images/cgg-notes/1728806313919.png" alt="1728806313919"></p><p><img src="/../images/cgg-notes/1728806585081.png" alt="1728806585081"></p><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p><img src="/../images/cgg-notes/1728806928970.png" alt="1728806928970"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;struct Student&#123;    string name;    int age;    int score;&#125;;int main()&#123;    struct Student stuArray[3] =    &#123;        &#123;&quot;张三&quot;,18,100&#125;,        &#123;&quot;李四&quot;,28,99&#125;,        &#123;&quot;王五&quot;,38,66&#125;    &#125;;    stuArray[2].score = 80;    for (int i = 0; i &lt; 3; i++) &#123;        cout &lt;&lt; stuArray[i].name &lt;&lt;&quot; &quot; &lt;&lt; stuArray[i].age &lt;&lt;&quot; &quot; &lt;&lt; stuArray[i].score &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p><img src="/../images/cgg-notes/1728808286722.png" alt="1728808286722"></p><img src="../images/C++%E7%AC%94%E8%AE%B0/1728808297096.png" alt="1728808297096" style="zoom: 50%;" /><p><img src="/../images/cgg-notes/1728808311214.png" alt="1728808311214"></p><h2 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h2><p><img src="/../images/cgg-notes/1728808414154.png" alt="1728808414154"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;struct Student&#123;    string name;    int age;    int score;&#125;;struct teacher&#123;    int id;    string name;    int age;    struct Student stu;&#125;;int main()&#123;    struct Student stuArray[3] =    &#123;        &#123;&quot;张三&quot;,18,100&#125;,        &#123;&quot;李四&quot;,28,99&#125;,        &#123;&quot;王五&quot;,38,66&#125;    &#125;;    stuArray[2].score = 80;    struct teacher liming&#123;        &#123;1234&#125;,        &#123;&quot;李明&quot;&#125;,        &#123;50&#125;,        &#123;stuArray[0]&#125;    &#125;;    cout &lt;&lt; liming.name &lt;&lt;&quot; &quot;&lt;&lt; liming.stu.name &lt;&lt;&quot; &quot;&lt;&lt;liming.stu.score &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h2><p><img src="/../images/cgg-notes/1728809331855.png" alt="1728809331855"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;#include&lt;string&gt;struct Student&#123;    string name;    int age;    int score;&#125;;struct teacher&#123;    int id;    string name;    int age;    struct Student stu;&#125;;void printTeacher(struct teacher* t)&#123;    cout &lt;&lt; t-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; t-&gt;stu.name &lt;&lt; &quot; &quot; &lt;&lt; t-&gt;stu.score &lt;&lt; &quot;\n&quot; &lt;&lt; endl;&#125;int main()&#123;    struct Student stuArray[3] =    &#123;        &#123;&quot;张三&quot;,18,100&#125;,        &#123;&quot;李四&quot;,28,99&#125;,        &#123;&quot;王五&quot;,38,66&#125;    &#125;;    stuArray[2].score = 80;    struct teacher liming&#123;        &#123;1234&#125;,        &#123;&quot;李明&quot;&#125;,        &#123;50&#125;,        &#123;stuArray[0]&#125;    &#125;;    cout &lt;&lt; liming.name &lt;&lt;&quot; &quot;&lt;&lt; liming.stu.name &lt;&lt;&quot; &quot;&lt;&lt;liming.stu.score &lt;&lt;&quot;\n&quot; &lt;&lt; endl;    printTeacher(&amp;liming);    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="结构体const"><a href="#结构体const" class="headerlink" title="结构体const"></a>结构体const</h2><p><img src="/../images/cgg-notes/1728810039118.png" alt="1728810039118"></p><p><strong>函数地址传递时防止更改变量的值</strong></p><p><img src="/../images/cgg-notes/1728812099502.png" alt="1728812099502"></p><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123;    int name;    int score;&#125;;struct teacher &#123;    string name;    struct student stu[5];&#125;;void give(struct teacher* t, struct student* s)&#123;    int k = 0;    for (int i = 0; i &lt; 3; i++) &#123;        for (int j = 0; j &lt; 5; j++) &#123;                        t[i].stu[j] = s[k];            k++;        &#125;    &#125;&#125;int main()&#123;    int i;    struct student s[15];    for (i = 0; i &lt; 15; i++) &#123;        s[i].name = i + 1;        s[i].score = rand()%60 + 40;    &#125;    struct teacher t[3]&#123;        &#123;&quot;Lili&quot;&#125;,        &#123;&quot;Sam&quot;&#125;,        &#123;&quot;Dave&quot;&#125;    &#125;;    give(t, s);    for (i = 0; i &lt; 3; i++) &#123;        cout &lt;&lt; t[i].name&lt;&lt; endl;        for (int j = 0; j &lt; 5; j++) &#123;            cout &lt;&lt;&quot;student&quot; &lt;&lt; t[i].stu[j].name &lt;&lt; &quot;\t &quot; &lt;&lt; t[i].stu[j].score &lt;&lt; endl;        &#125;    &#125;        system(&quot;pause&quot;);    return 0;&#125;</code></pre><pre><code class="c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#include&lt;string&gt;struct hero &#123;    string name;    int age;    string sex;&#125;;int main()&#123;    struct hero member[5]&#123;        &#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,        &#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,        &#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,        &#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,        &#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;    &#125;;    int i;    for (i = 0; i &lt; 5; i++) &#123;        for (int j = i + 1; j &lt; 5 ;  j++) &#123;            if (member[i].age &gt; member[j].age) &#123;                struct hero temp = member[i];                member[i] = member[j];                member[j] = temp;            &#125;        &#125;    &#125;    for (i = 0; i &lt; 5; i++) &#123;        cout &lt;&lt; member[i].name &lt;&lt; &quot; &quot; &lt;&lt; member[i].age &lt;&lt; &quot; &quot; &lt;&lt; member[i].sex &lt;&lt; &quot;\n&quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="通讯管理系统"><a href="#通讯管理系统" class="headerlink" title="通讯管理系统"></a>通讯管理系统</h1><img src="../images/C++%E7%AC%94%E8%AE%B0/1728819007737.png" alt="1728819007737" style="zoom:150%;" /><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;#include&quot;add.h&quot;#include&quot;present.h&quot;#include&quot;remove.h&quot;#include&quot;find.h&quot;#include&quot;modify.h&quot;#include&quot;allremove.h&quot;using namespace std;struct person &#123;    string name;    string sex;    int age;    long long number;    string address;&#125;;int main()&#123;    cout &lt;&lt; &quot;1：添加联系人\n2：展示所有联系人\n3：删除联系人\n4：查找联系人\n5：修改联系人信息\n6:清空联系人\n0：退出系统\n&quot; &lt;&lt; endl;    int type;    cin &gt;&gt; type;    struct person Person[1000];    for (int i = 0; i &lt; 1000; i++) &#123;        Person[i].number = 0;        Person[i].name = &quot;无&quot;;        Person[i].age = 0;        Person[i].sex = &quot;无&quot;;        Person[i].address = &quot;无&quot;;    &#125;    while (type != 0) &#123;        switch (type) &#123;        case 1:            add(Person);            break;        case 2:            present(Person);            break;        case 3:            remove(Person);            break;        case 4:            find(Person);            break;        case 5:            modify(Person);            break;        case 6:            allremove(Person);            break;        &#125;        cin &gt;&gt; type;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct person &#123;    string name;    string sex;    int age;    long long number;    string address;&#125;;void add(struct person* Person)&#123;    int i;    for (i = 0; i &lt; 1000; i++) &#123;        if (Person[i].number == 0) &#123;            cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; endl;            cin &gt;&gt; Person[i].name;            cout &lt;&lt; &quot;性别：（男，女）&quot; &lt;&lt; endl;            cin &gt;&gt; Person[i].sex;            cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; endl;            cin &gt;&gt; Person[i].age;            cout &lt;&lt; &quot;号码&quot; &lt;&lt; endl;            cin &gt;&gt; Person[i].number;            cout &lt;&lt; &quot;地址&quot; &lt;&lt; endl;            cin &gt;&gt; Person[i].address;            break;        &#125;    &#125;&#125;</code></pre><h2 id="present函数"><a href="#present函数" class="headerlink" title="present函数"></a>present函数</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct person &#123;    string name;    string sex;    int age;    long long number;    string address;&#125;;void present(struct person* Person)&#123;    for (int i = 0; i &lt; 1000; i++) &#123;        if (Person[0].number == 0) &#123;            cout &lt;&lt; &quot;空&quot; &lt;&lt; endl;        &#125;        if (Person[i].number == 0) &#123;            break;        &#125;        cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; Person[i].name &lt;&lt;&quot;\t&quot; &lt;&lt; &quot;性别：&quot;            &lt;&lt; Person[i].sex &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;年龄：&quot; &lt;&lt; Person[i].age &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;号码：&quot; &lt;&lt; Person[i].number &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;地址：&quot; &lt;&lt; Person[i].address &lt;&lt; &quot;\n&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><h2 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct person &#123;    string name;    string sex;    int age;    long long number;    string address;&#125;;void remove(struct person* Person)&#123;    string name;    cout &lt;&lt; &quot;请输入要删除联系人的名字：&quot; &lt;&lt; endl;    cin &gt;&gt; name;    for (int i = 0; i &lt; 1000;  i++) &#123;        if (name == Person[i].name) &#123;            Person[i].number = 0;            Person[i].name = &quot;无&quot;;            Person[i].age = 0;            Person[i].sex = &quot;无&quot;;            Person[i].address = &quot;无&quot;;            break;        &#125;    &#125;&#125;</code></pre><h2 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a>find函数</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct person &#123;    string name;    string sex;    int age;    long long number;    string address;&#125;;void find(struct person* Person)&#123;    string name;    cout &lt;&lt; &quot;请输入要查找的联系人&quot; &lt;&lt; endl;    cin &gt;&gt; name;    int ret = 0;    for (int i = 0; i &lt; 1000; i++) &#123;                if (name == Person[i].name) &#123;            cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; Person[i].name &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;性别：&quot;                &lt;&lt; Person[i].sex &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;年龄：&quot; &lt;&lt; Person[i].age &lt;&lt; &quot;\t&quot;                 &lt;&lt; &quot;号码：&quot; &lt;&lt; Person[i].number                 &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;地址：&quot;                 &lt;&lt; Person[i].address &lt;&lt; &quot;\n&quot; &lt;&lt; endl;            ret = 1;            break;        &#125;    &#125;    if (ret == 0) &#123;        cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><h2 id="modify函数"><a href="#modify函数" class="headerlink" title="modify函数"></a>modify函数</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct person &#123;    string name;    string sex;    int age;    long long number;    string address;&#125;;void modify(struct person* Person)&#123;    string name;    cout &lt;&lt; &quot;请输入要修改信息的联系人&quot; &lt;&lt; endl;    cin &gt;&gt; name;    int ret = 0;    for (int i = 0; i &lt; 1000; i++) &#123;        if (name == Person[i].name) &#123;            cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; endl;            cin &gt;&gt; Person[i].name;            cout &lt;&lt; &quot;性别：（男，女）&quot; &lt;&lt; endl;            cin &gt;&gt; Person[i].sex;            cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; endl;            cin &gt;&gt; Person[i].age;            cout &lt;&lt; &quot;号码&quot; &lt;&lt; endl;            cin &gt;&gt; Person[i].number;            cout &lt;&lt; &quot;地址&quot; &lt;&lt; endl;            cin &gt;&gt; Person[i].address;            ret = 1;            break;        &#125;    &#125;    if (ret == 0) &#123;        cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><h2 id="allremove函数"><a href="#allremove函数" class="headerlink" title="allremove函数"></a>allremove函数</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct person &#123;    string name;    string sex;    int age;    long long number;    string address;&#125;;void allremove(struct person* Person)&#123;    for (int i = 0; i &lt; 1000; i++) &#123;        Person[i].number = 0;        Person[i].name = &quot;无&quot;;        Person[i].age = 0;        Person[i].sex = &quot;无&quot;;        Person[i].address = &quot;无&quot;;    &#125;&#125;</code></pre><h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p><img src="/../images/cgg-notes/1728990629086.png" alt="1728990629086"></p><h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p><img src="/../images/cgg-notes/1728991030036.png" alt="1728991030036"></p><h2 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h2><p><img src="/../images/cgg-notes/1728991304420.png" alt="1728991304420"></p><img src="../images/C++%E7%AC%94%E8%AE%B0/1728991644098.png" alt="1728991644098" style="zoom:50%;" /><img src="../images/C++%E7%AC%94%E8%AE%B0/1728995366466.png" alt="1728995366466" style="zoom:50%;" /><p><img src="/../images/cgg-notes/1728991857851.png" alt="1728991857851"></p><p><img src="/../images/cgg-notes/1728992274655.png" alt="1728992274655"></p><p><img src="/../images/cgg-notes/1728992299960.png" alt="1728992299960"></p><h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p><img src="/../images/cgg-notes/1728992412126.png" alt="1728992412126"></p><p><img src="/../images/cgg-notes/1728992677500.png" alt="1728992677500"></p><p><img src="/../images/cgg-notes/1728992753823.png" alt="1728992753823"></p><h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p><img src="/../images/cgg-notes/1728992877360.png" alt="1728992877360"></p><p><img src="/../images/cgg-notes/1728993134869.png" alt="1728993134869"></p><h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><p><img src="/../images/cgg-notes/1728993347167.png" alt="1728993347167"></p><p><img src="/../images/cgg-notes/1728993666859.png" alt="1728993666859"></p><p><img src="/../images/cgg-notes/1728993779763.png" alt="1728993779763"></p><p><strong>new返回的是地址</strong> </p><p><img src="/../images/cgg-notes/1728993919318.png" alt="1728993919318"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><img src="/../images/cgg-notes/1728994024878.png" alt="1728994024878"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/../images/cgg-notes/1728994311673.png" alt="1728994311673"></p><p><img src="/../images/cgg-notes/1728994439236.png" alt="1728994439236"></p><h2 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h2><p><img src="/../images/cgg-notes/1728994533078.png" alt="1728994533078"></p><p><img src="/../images/cgg-notes/1728994763744.png" alt="1728994763744"></p><h2 id="引用做函数的返回值"><a href="#引用做函数的返回值" class="headerlink" title="引用做函数的返回值"></a>引用做函数的返回值</h2><p><img src="/../images/cgg-notes/1728995023221.png" alt="1728995023221"></p><p><img src="/../images/cgg-notes/1728995733672.png" alt="1728995733672"></p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p><img src="/../images/cgg-notes/1728995824059.png" alt="1728995824059"></p><p><img src="/../images/cgg-notes/1728995950673.png" alt="1728995950673"></p><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p><img src="/../images/cgg-notes/1728996136814.png" alt="1728996136814"></p><p><img src="/../images/cgg-notes/1728996372178.png" alt="1728996372178"></p><h1 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h1><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p><img src="/../images/cgg-notes/1729424853591.png" alt="1729424853591"></p><p><img src="/../images/cgg-notes/1729424944195.png" alt="1729424944195"></p><p><img src="/../images/cgg-notes/1729424961396.png" alt="1729424961396"></p><p><strong>有默认值时可以少写参数</strong> </p><p><img src="/../images/cgg-notes/1729425051673.png" alt="1729425051673"></p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p><img src="/../images/cgg-notes/1729425253969.png" alt="1729425253969"></p><p><img src="/../images/cgg-notes/1729425309907.png" alt="1729425309907"></p><p><img src="/../images/cgg-notes/1729425450102.png" alt="1729425450102"></p><p><strong>俩个位置只能有一个默认参数</strong></p><h2 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h2><p><img src="/../images/cgg-notes/1729425898101.png" alt="1729425898101"></p><p><img src="/../images/cgg-notes/1729425915622.png" alt="1729425915622"></p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p><img src="/../images/cgg-notes/1729426433237.png" alt="1729426433237"></p><p> <img src="/../images/cgg-notes/1729426775359.png" alt="1729426775359"></p><p><strong>返回值不同不能进行函数重载</strong></p><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p><img src="/../images/cgg-notes/1729427043296.png" alt="1729427043296"></p><p><img src="/../images/cgg-notes/1729427158822.png" alt="1729427158822"></p><p><strong>变量调用int   常量调用const int</strong></p><p><img src="/../images/cgg-notes/1729427523872.png" alt="1729427523872"></p><p><strong>调用func2（10）出错</strong></p><p><img src="/../images/cgg-notes/1729427620254.png" alt="1729427620254"></p><h1 id="类和对象（重要！！）"><a href="#类和对象（重要！！）" class="headerlink" title="类和对象（重要！！）"></a>类和对象（重要！！）</h1><p><img src="/../images/cgg-notes/1729427760302.png" alt="1729427760302"></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><img src="/../images/cgg-notes/1729427801019.png" alt="1729427801019"></p><p><img src="/../images/cgg-notes/1729427892933.png" alt="1729427892933"></p><p>   <img src="/../images/cgg-notes/1729428577075.png" alt="1729428577075"></p><p> <img src="/../images/cgg-notes/1729428614394.png" alt="1729428614394"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class student&#123;public :    string m_name;    int m_id;    void showstudent() &#123;        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; m_name &lt;&lt; &quot;\n学号：&quot; &lt;&lt; m_id &lt;&lt; endl;    &#125;&#125;;int main()&#123;    student s1;    s1.m_name = &quot;张三&quot;;    s1.m_id = 123;    s1.showstudent();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class student&#123;public :    string m_name;  //属性    int m_id;        void setname(string name) &#123;  //行为        m_name = name;    &#125;    void showstudent() &#123;        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; m_name &lt;&lt; &quot;\n学号：&quot; &lt;&lt; m_id &lt;&lt; endl;    &#125;&#125;;int main()&#123;    student s1;    s1.setname(&quot;张三&quot;);    s1.m_id = 123;    s1.showstudent();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="封装访问权限"><a href="#封装访问权限" class="headerlink" title="封装访问权限"></a>封装访问权限</h2><p><img src="/../images/cgg-notes/1729604180958.png" alt="1729604180958"></p><p><img src="/../images/cgg-notes/1729604403141.png" alt="1729604403141"></p><p><strong>class的大括号内为类内</strong></p><p><img src="/../images/cgg-notes/1729604628061.png" alt="1729604628061"></p><p><img src="/../images/cgg-notes/1729604666183.png" alt="1729604666183"></p><h2 id="class和struct的区别"><a href="#class和struct的区别" class="headerlink" title="class和struct的区别"></a>class和struct的区别</h2><p><img src="/../images/cgg-notes/1729606670697.png" alt="1729606670697"></p><h2 id="私有成员属性（自己设置读写）"><a href="#私有成员属性（自己设置读写）" class="headerlink" title="私有成员属性（自己设置读写）"></a>私有成员属性（自己设置读写）</h2><p><img src="/../images/cgg-notes/1729606901511.png" alt="1729606901511"></p><p><strong>自己控制读写权限</strong></p><p><img src="/../images/cgg-notes/1729607399388.png" alt="1729607399388"></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public:    void setname(string name) &#123;        Name = name;    &#125;    string getname() &#123;        return Name;    &#125;    int getage() &#123;        return Age;    &#125;    void setidol(string idol) &#123;        Idol = idol;    &#125;private:    string Name;    int Age = 18;    string Idol;&#125;;int main ()&#123;    Person p;    p.setname(&quot;张三&quot;);    cout &lt;&lt; p.getname() &lt;&lt; endl;    cout &lt;&lt; p.getage() &lt;&lt; endl;    p.setidol(&quot;李明&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1729608316045.png" alt="1729608316045"></p><p><strong>加上限制条件</strong></p><h2 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h2><h3 id="设计立方体类"><a href="#设计立方体类" class="headerlink" title="设计立方体类"></a>设计立方体类</h3><p><img src="/../images/cgg-notes/1729608488219.png" alt="1729608488219"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Cube&#123;private:    int L;    int W;    int H;public:    int area() &#123;        return 2 * (L * W + L * H + W * H);    &#125;    int volume() &#123;        return L * W * H;    &#125;    int getL() &#123;        return L;    &#125;    int getW() &#123;        return W;    &#125;    int getH() &#123;        return H;    &#125;    void setL(int l) &#123;        L = l;    &#125;    void setW(int w) &#123;        W = w;    &#125;    void setH(int h) &#123;        H = h;    &#125;    bool isSame_1(Cube&amp; c, Cube&amp; c2) &#123;        if (c.H == c2.H &amp;&amp; c.W == c.W &amp;&amp; c.L == c2.L) &#123;            return true;        &#125;        else &#123;            return false;        &#125;    &#125;&#125;;bool isSame(Cube&amp; c, Cube&amp; c2) &#123;    if (c.getH() == c2.getH() &amp;&amp; c.getW() == c.getW() &amp;&amp; c.getL() == c2.getL()) &#123;        return true;    &#125;    else &#123;        return false;    &#125;&#125;int main() &#123;    Cube c;    c.setL(3);    c.setW(4);    c.setH(5);    cout &lt;&lt; &quot;面积：&quot; &lt;&lt; c.area() &lt;&lt; &quot; 体积：&quot; &lt;&lt; c.volume() &lt;&lt; endl;    Cube c2;    c2.setL(3);    c2.setW(4);    c2.setH(5);    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; isSame(c, c2) &lt;&lt; endl;    cout &lt;&lt; &quot;类内函数&quot; &lt;&lt; c.isSame_1(c, c2) &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1729689156084.png" alt="1729689156084"></p><pre><code class="c++"></code></pre><h1 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h1><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p><img src="/../images/cgg-notes/1729689349373.png"></p><p><img src="/../images/cgg-notes/1729689563790.png" alt="1729689563790"></p><pre><code class="c++">//构造函数和析构函数#include&lt;iostream&gt;using namespace std;class Person&#123;public:    Person() &#123;        cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;    &#125;    ~Person() &#123;        cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;    &#125;&#125;;void text() &#123;    Person p;&#125;int main()&#123;    Person p;    text();    system(&quot;pause&quot;);    return 0;&#125;//有输出结果，并且为；//1//1//2//如果析构函数写在main函数，则不会输出;</code></pre><p><img src="/../images/cgg-notes/1729690015624.png"></p><h2 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h2><p><img src="/../images/cgg-notes/1729690391656.png" alt="1729690391656"></p><p><img src="/../images/cgg-notes/1729690784325.png" alt="1729690784325"></p><p><strong>无参构造函数又称默认构造函数</strong></p><p><img src="/../images/cgg-notes/1729692939166.png" alt="1729692939166"></p><p><img src="/../images/cgg-notes/1729693248457.png" alt="1729693248457"></p><p><img src="/../images/cgg-notes/1729693360064.png" alt="1729693360064"></p><p><img src="/../images/cgg-notes/1729693426058.png" alt="1729693426058"></p><p> <img src="/../images/cgg-notes/1729693503531.png" alt="1729693503531"></p><p><img src="/../images/cgg-notes/1729693607453.png" alt="1729693607453"></p><p><img src="/../images/cgg-notes/1729693689586.png" alt="1729693689586"></p><p><img src="/../images/cgg-notes/1729693865535.png" alt="1729693865535"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Person&#123;public:    Person(int age) &#123;        m_Age = age;        cout &lt;&lt; &quot;p的年龄为：&quot; &lt;&lt; m_Age &lt;&lt; endl;    &#125;    //有参构造函数    Person(const Person &amp;p) &#123;        cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;    &#125;    //拷贝构造函数    ~Person() &#123;        cout &lt;&lt; this &lt;&lt; &quot;的析构函数的调用&quot; &lt;&lt; endl;    &#125;    int m_Age;&#125;;void text() &#123;    Person p(10);//Person p = 10    Person p = Person(10)    Person p1(p);//Person p1 = p    Person p1 = Person(p)    cout &lt;&lt; &amp;p &lt;&lt; endl;    cout &lt;&lt; &amp;p1 &lt;&lt; endl;&#125;int main()&#123;    text();        system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730122691429.png" alt="1730122691429"></p><h2 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h2><p><img src="/../images/cgg-notes/1729947335597.png" alt="1729947335597"></p><p><img src="/../images/cgg-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-26%20210755.png"></p><p><img src="/../images/cgg-notes/1729948195996.png" alt="1729948195996"></p><p><img src="/../images/cgg-notes/1729948323526.png" alt="1729948323526"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Person&#123;public:    Person(int age) &#123;        m_Age = age;        cout &lt;&lt; &quot;p的年龄为：&quot; &lt;&lt; m_Age &lt;&lt; endl;    &#125;    //有参构造函数    Person(const Person &amp;p) &#123;        cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;    &#125;    //拷贝构造函数    ~Person() &#123;        cout &lt;&lt; this &lt;&lt; &quot;的析构函数的调用&quot; &lt;&lt; endl;    &#125;    int m_Age;&#125;;Person dowork() &#123;    Person p1 = 20;    return p1;&#125;void text() &#123;    Person p(10);    dowork();    //Person p2(dowork());    cout &lt;&lt; &amp;p &lt;&lt; endl;    //cout &lt;&lt; &amp;p2 &lt;&lt; endl;&#125;int main()&#123;    text();        system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730123707305.png" alt="1730123707305"></p><h2 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h2><p><img src="/../images/cgg-notes/1729948509142.png" alt="1729948509142"></p><p><img src="/../images/cgg-notes/1729948520967.png" alt="1729948520967"></p><p><img src="/../images/cgg-notes/1729948873314.png" alt="1729948873314"></p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p><img src="/../images/cgg-notes/1729949338960.png" alt="1729949338960"></p><p><img src="/../images/cgg-notes/1729950370988.png" alt="1729950370988"></p><p><strong>new操作符返回的是指针</strong></p><p><img src="/../images/cgg-notes/1729949686275.png" alt="1729949686275"></p><p><img src="/../images/cgg-notes/1729949968020.png" alt="1729949968020"></p><p><img src="/../images/cgg-notes/1729949996903.png"></p><p><img src="/../images/cgg-notes/1729950171437.png" alt="1729950171437"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Person&#123;public:    Person(int age,int height) &#123;        m_Age = age;        m_Height = new int(height);    &#125;    //有参构造函数    Person(const Person &amp;p) &#123;        cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;        m_Age = p.m_Age;        m_Height = new int(*p.m_Height);    &#125;    //拷贝构造函数    ~Person() &#123;        if (m_Height != NULL) &#123;            delete m_Height;            m_Height = NULL;        &#125;        cout &lt;&lt; this &lt;&lt; &quot;的析构函数的调用&quot; &lt;&lt; endl;    &#125;    int m_Age;    int* m_Height;&#125;;void text() &#123;    Person p(10, 180);    Person p1(p);    Person p2(p);    cout &lt;&lt; p.m_Age &lt;&lt; &quot; &quot; &lt;&lt; *p.m_Height &lt;&lt; endl;    cout &lt;&lt; p1.m_Age &lt;&lt; &quot; &quot; &lt;&lt; *p1.m_Height &lt;&lt; endl;    cout &lt;&lt; p2.m_Age &lt;&lt; &quot; &quot; &lt;&lt; *p2.m_Height &lt;&lt; endl;&#125;int main()&#123;    text();        system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730124390295.png" alt="1730124390295"></p><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p><img src="/../images/cgg-notes/1729950489032.png" alt="1729950489032"></p><p><img src="/../images/cgg-notes/1729950717888.png" alt="1729950717888"></p><p><img src="/../images/cgg-notes/1729950803644.png" alt="1729950803644"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Person&#123;public:    Person(int age, int height) :m_Age(age), m_Height(height)    &#123;            &#125;    //有参构造函数    Person(const Person &amp;p) &#123;        cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;        m_Age = p.m_Age;        m_Height = p.m_Height;    &#125;    //拷贝构造函数    ~Person() &#123;                cout &lt;&lt; this &lt;&lt; &quot;的析构函数的调用&quot; &lt;&lt; endl;    &#125;    int m_Age;    int m_Height;&#125;;void text() &#123;    Person p(10,180);    Person p1(p);    Person p2(p);    cout &lt;&lt; p.m_Age &lt;&lt; &quot; &quot; &lt;&lt; p.m_Height &lt;&lt; endl;    cout &lt;&lt; p1.m_Age &lt;&lt; &quot; &quot; &lt;&lt; p1.m_Height &lt;&lt; endl;    cout &lt;&lt; p2.m_Age &lt;&lt; &quot; &quot; &lt;&lt; p2.m_Height &lt;&lt; endl;&#125;int main()&#123;    text();        system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730124934790.png" alt="1730124934790"></p><h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><p><img src="/../images/cgg-notes/1729950966927.png" alt="1729950966927"></p><p><img src="/../images/cgg-notes/1729950979248.png" alt="1729950979248"></p><p><img src="/../images/cgg-notes/1729951369486.png" alt="1729951369486"></p><p><img src="/../images/cgg-notes/1729951590707.png" alt="1729951590707"></p><p><img src="/../images/cgg-notes/1729951677841.png" alt="1729951677841"></p><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><p><img src="/../images/cgg-notes/1729951796931.png" alt="1729951796931"></p><p><img src="/../images/cgg-notes/1729952003288.png" alt="1729952003288"></p><p><img src="/../images/cgg-notes/1729952136564.png" alt="1729952136564"></p><p><strong>类外初始化</strong></p><p><img src="/../images/cgg-notes/1729952331851.png" alt="1729952331851"></p><p><img src="/../images/cgg-notes/1729952430056.png" alt="1729952430056"></p><p><img src="/../images/cgg-notes/1729952466207.png"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Person&#123;public:    static int m_A;&#125;;int Person::m_A = 100;void text() &#123;    Person p;    Person p1;    cout &lt;&lt; p.m_A &lt;&lt; endl;    cout &lt;&lt; p1.m_A &lt;&lt; endl;&#125;int main()&#123;    text();        system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730125138235.png" alt="1730125138235"></p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p><img src="/../images/cgg-notes/1729952605899.png" alt="1729952605899"></p><p><strong>两种访问方式</strong></p><p><img src="/../images/cgg-notes/1729952704366.png" alt="1729952704366"></p><p><img src="/../images/cgg-notes/1729952807269.png" alt="1729952807269"></p><p><img src="/../images/cgg-notes/1729952967697.png" alt="1729952967697"></p><h1 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h1><h2 id="成员变量和成员函数分开储存"><a href="#成员变量和成员函数分开储存" class="headerlink" title="成员变量和成员函数分开储存"></a>成员变量和成员函数分开储存</h2><p><img src="/../images/cgg-notes/1730119235067.png" alt="1730119235067"></p><p><img src="/../images/cgg-notes/1730119583570.png" alt="1730119583570"></p><pre><code class="c++">//此时  sizeof(p) == 4</code></pre><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p><img src="/../images/cgg-notes/1730119671480.png" alt="1730119671480"></p><p><img src="/../images/cgg-notes/1730119680579.png" alt="1730119680579"></p><p><img src="/../images/cgg-notes/1730119953444.png" alt="1730119953444"></p><p><img src="/../images/cgg-notes/1730119972144.png" alt="1730119972144"></p><p>&#96;</p><p><img src="/../images/cgg-notes/1730120347630.png" alt="1730120347630"></p><p><img src="/../images/cgg-notes/1730120378007.png" alt="1730120378007"></p><p><strong>函数返回类型要为引用类型，若没有”&amp;”返回的是一个拷贝变量</strong></p><h2 id="空指针调成员函数"><a href="#空指针调成员函数" class="headerlink" title="空指针调成员函数"></a>空指针调成员函数</h2><p><img src="/../images/cgg-notes/1730120737973.png" alt="1730120737973"></p><p><img src="/../images/cgg-notes/1730121168089.png" alt="1730121168089"></p><p><strong>在m_Age(成员变量)前总会默认加一个this-&gt;</strong></p><p><img src="/../images/cgg-notes/1730121116106.png" alt="1730121116106"></p><p><strong>调用第一个函数正常</strong></p><p><strong>调用第二个函数出错</strong></p><p><img src="/../images/cgg-notes/1730121002131.png" alt="1730121002131"></p><p><strong>改进：</strong></p><p><img src="/../images/cgg-notes/1730121045811.png" alt="1730121045811"></p><h2 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h2><p><img src="/../images/cgg-notes/1730121266649.png" alt="1730121266649"></p><h3 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h3><p><strong>this指针是一个指针常量，只能指向一个变量</strong></p><p><strong>但可以改变存储在该变量的值</strong></p><p><img src="/../images/cgg-notes/1730121389715.png" alt="1730121389715"></p><p><img src="/../images/cgg-notes/1730121585985.png"></p><p><strong>加上const之后就无法修改指针指向的值</strong></p><p><img src="/../images/cgg-notes/1730121628027.png" alt="1730121628027"></p><p><strong>特殊变量</strong></p><p><img src="/../images/cgg-notes/1730121696553.png" alt="1730121696553"></p><h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><p><img src="/../images/cgg-notes/1730121860120.png" alt="1730121860120"></p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p><img src="/../images/cgg-notes/1730291974193.png" alt="1730291974193"></p><p><img src="/../images/cgg-notes/1730291980369.png" alt="1730291980369"></p><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Building &#123;    friend void test01(Building* building);public:    Building () &#123;        m_SittingRoom = &quot;A大厅&quot;;        m_Room = &quot;201室&quot;;    &#125;public:    string m_SittingRoom;private:    string m_Room;&#125;;void test01(Building* building) &#123;    cout &lt;&lt; &quot;大厅：&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;    cout &lt;&lt; &quot;卧室：&quot; &lt;&lt; building-&gt;m_Room &lt;&lt; endl;&#125;void test() &#123;    Building building;    test01(&amp;building);&#125;int main()&#123;    test();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730292889200.png" alt="1730292889200"></p><p><img src="/../images/cgg-notes/1730292906856.png" alt="1730292906856"></p><h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><p><img src="/../images/cgg-notes/1730293165950.png" alt="1730293165950"></p><p><img src="/../images/cgg-notes/1730293477179.png" alt="1730293477179"></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Building &#123;    friend class GoodGay;public:    Building () &#123;        m_SittingRoom = &quot;A大厅&quot;;        m_Room = &quot;201室&quot;;    &#125;public:    string m_SittingRoom;private:    string m_Room;&#125;;class GoodGay&#123;public:    GoodGay();    void visit();    Building* visitBuilding;&#125;;GoodGay::GoodGay() &#123;    visitBuilding = new Building;&#125;void GoodGay::visit() &#123;    cout &lt;&lt;&quot;去大厅：&quot; &lt;&lt; visitBuilding-&gt;m_SittingRoom &lt;&lt; endl;    cout &lt;&lt; &quot;去卧室：&quot; &lt;&lt; visitBuilding-&gt;m_Room &lt;&lt; endl;&#125;void test() &#123;    GoodGay zhang;    zhang.visit();    &#125;int main()&#123;    test();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><p><img src="/../images/cgg-notes/1730295905319.png" alt="1730295905319"></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Building;class GoodGay&#123;public:    GoodGay();    void visit();    Building* visitBuilding;&#125;;class Building &#123;    public:    friend void GoodGay::visit();    Building () &#123;        m_SittingRoom = &quot;A大厅&quot;;        m_Room = &quot;201室&quot;;    &#125;public:    string m_SittingRoom;private:    string m_Room;&#125;;GoodGay::GoodGay() &#123;    visitBuilding = new Building;&#125;void GoodGay::visit() &#123;    cout &lt;&lt;&quot;去大厅：&quot; &lt;&lt;visitBuilding-&gt;m_SittingRoom &lt;&lt; endl;    cout &lt;&lt; &quot;去卧室：&quot; &lt;&lt;visitBuilding-&gt;m_Room &lt;&lt; endl;&#125;void test() &#123;    GoodGay zhang;    zhang.visit();    &#125;int main()&#123;    test();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="运算符重载（重要！！）"><a href="#运算符重载（重要！！）" class="headerlink" title="运算符重载（重要！！）"></a>运算符重载（重要！！）</h2><p><img src="/../images/cgg-notes/1730378975547.png" alt="1730378975547"></p><h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p><strong>（可以更换为其他符号（+，-，*，&#x2F;）</strong></p><p><img src="/../images/cgg-notes/1730379000731.png" alt="1730379000731"></p><p><img src="/../images/cgg-notes/1730379547066.png" alt="1730379547066"></p><p><img src="/../images/cgg-notes/1730379534449.png" alt="1730379534449"></p><p><img src="/../images/cgg-notes/1730379683189.png" alt="1730379683189"></p><p><img src="/../images/cgg-notes/1730379918247.png" alt="1730379918247"></p><p><img src="/../images/cgg-notes/1730379963630.png" alt="1730379963630"></p><p><img src="/../images/cgg-notes/1730380103971.png" alt="1730380103971"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Person &#123;public:    /*Person operator+ (Person&amp; p) &#123;        Person temp;        temp.m_A = this-&gt;m_A + p.m_A;        temp.m_B = this-&gt;m_B + p.m_B;        return temp;    &#125;*/    int m_A;    int m_B;&#125;;Person operator+ (Person p1, Person p2) &#123;    Person temp;    temp.m_A = p1.m_A + p2.m_A;    temp.m_B = p1.m_B + p2.m_B;    return temp;&#125;Person operator+ (Person p, int num) &#123;    Person temp;    temp.m_A = p.m_A + num;    temp.m_B = p.m_B + num;    return temp;&#125;void test() &#123;    Person p1;    Person p2;    p1.m_A = 10;    p1.m_B = 10;    p2.m_A = 10;    p2.m_B = 10;    Person p3 = p1 + p2;    cout &lt;&lt; p3.m_A &lt;&lt; endl;    cout &lt;&lt; p3.m_B &lt;&lt; endl;    p3 = p3 + 20;    cout &lt;&lt; p3.m_A &lt;&lt; endl;    cout &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main()&#123;    test();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730381432616.png" alt="1730381432616"></p><h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p><img src="/../images/cgg-notes/1730381661148.png" alt="1730381661148"></p><p><img src="/../images/cgg-notes/1730382040909.png" alt="1730382040909"></p><p><img src="/../images/cgg-notes/1730382319734.png" alt="1730382319734"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Person &#123;    friend ostream&amp; operator&lt;&lt; (ostream&amp; cout, Person&amp; p);public:    Person(int a, int b) &#123;        this-&gt;m_A = a;        this-&gt;m_B = b;    &#125;private:    int m_A;    int m_B;&#125;;ostream &amp; operator&lt;&lt; (ostream&amp; cout, Person&amp; p) &#123;    cout &lt;&lt; p.m_A &lt;&lt; &quot; &quot; &lt;&lt; p.m_B;    return cout;&#125;void test() &#123;    Person p(10, 10);    cout &lt;&lt; p &lt;&lt;&quot; hello world!&quot; &lt;&lt; endl;&#125;int main()&#123;    test();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><p><img src="/../images/cgg-notes/1730551116656.png" alt="1730551116656"></p><h4 id="前置递增"><a href="#前置递增" class="headerlink" title="前置递增"></a>前置递增</h4><p><img src="/../images/cgg-notes/1730551797556.png" alt="1730551797556"></p><h4 id="后置递增"><a href="#后置递增" class="headerlink" title="后置递增"></a>后置递增</h4><p><img src="/../images/cgg-notes/1730552134434.png" alt="1730552134434"></p><p><img src="/../images/cgg-notes/1730552268845.png" alt="1730552268845"></p><p><strong>后置递增要返回值，因为temp是局部函数的类，函数运行完之后会自动释放掉</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Person&#123;    friend ostream&amp; operator&lt;&lt; (ostream&amp; cout, Person&amp; p);public:    Person(int a, int b) &#123;        this-&gt;m_A = a;        this-&gt;m_B = b;    &#125;    Person&amp; operator++()    &#123;        this-&gt;m_A++;        this-&gt;m_B++;        return *this;    &#125;    Person&amp; operator++(int)    &#123;        Person temp = *this;        this-&gt;m_A++;        this-&gt;m_B++;        return temp;    &#125;    Person&amp; operator--()    &#123;        this-&gt;m_A--;        this-&gt;m_B--;        return *this;    &#125;    Person&amp; operator--(int)    &#123;        Person temp = *this;        this-&gt;m_A--;        this-&gt;m_B--;        return temp;    &#125;private:    int m_A;    int m_B;&#125;;ostream&amp; operator&lt;&lt; (ostream&amp; cout, Person&amp; p)&#123;    cout &lt;&lt; p.m_A &lt;&lt; &quot; &quot; &lt;&lt; p.m_B;    return cout;&#125;void test()&#123;    Person p(10, 10);    cout &lt;&lt; ++p &lt;&lt; &quot; hello world!&quot; &lt;&lt; endl;    cout &lt;&lt; --p &lt;&lt; &quot; hello world!&quot; &lt;&lt; endl;    cout &lt;&lt; p++ &lt;&lt; &quot; hello world!&quot; &lt;&lt; endl;    cout &lt;&lt; p-- &lt;&lt; &quot; hello world!&quot; &lt;&lt; endl;&#125;int main()&#123;    test();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730554328087.png" alt="1730554328087"></p><h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p><img src="/../images/cgg-notes/1730554024676.png" alt="1730554024676"></p><p><strong>堆区代码需要程序员手动开辟，手动释放（在类中用析构函数释放）</strong></p><p><img src="/../images/cgg-notes/1730554866664.png" alt="1730554866664"></p><p><img src="/../images/cgg-notes/1730554832585.png" alt="1730554832585"></p><p><strong>编译器默认提供的赋值运算符为浅拷贝</strong>、</p><p><img src="/../images/cgg-notes/1730555087118.png" alt="1730555087118"></p><img src="../images/C++%E7%AC%94%E8%AE%B0/1730555138118.png" alt="1730555138118" style="zoom: 50%;" /><p><img src="/../images/cgg-notes/1730555293792.png" alt="1730555293792"></p><p><img src="/../images/cgg-notes/1730555307793.png" alt="1730555307793"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Person&#123;    friend ostream&amp; operator&lt;&lt; (ostream&amp; cout, Person&amp; p);public:    Person(int a, int b) &#123;        m_A = new int(a);        m_B = new int(b);    &#125;    Person&amp; operator= (Person &amp;p) &#123;        if (m_A != NULL) &#123;            delete m_A;            m_A = NULL;        &#125;        if (m_B != NULL) &#123;            delete m_B;            m_B = NULL;        &#125;        m_A = new int(*p.m_A);        m_B = new int(*p.m_B);        return *this;    &#125;    ~Person() &#123;        if (m_A != NULL) &#123;            delete m_A;            m_A = NULL;        &#125;        if (m_B != NULL) &#123;            delete m_B;            m_B = NULL;        &#125;    &#125;private:    int* m_A;    int* m_B;&#125;;ostream&amp; operator&lt;&lt; (ostream&amp; cout, Person&amp; p)&#123;    cout &lt;&lt; *p.m_A &lt;&lt; &quot; &quot; &lt;&lt; *p.m_B;    return cout;&#125;void test()&#123;    Person p(10, 10);    Person p1(20, 20);    Person p2(30, 30);    p2 = p1 = p;    cout &lt;&lt; p2 &lt;&lt; &quot; &quot; &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; endl;&#125;int main()&#123;    test();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730556546984.png" alt="1730556546984"></p><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p><img src="/../images/cgg-notes/1730722935426.png" alt="1730722935426"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Person&#123;    friend ostream&amp; operator&lt;&lt; (ostream&amp; cout, Person&amp; p);    friend bool operator== (Person &amp;p1, Person &amp;p2);    friend bool operator!= (Person &amp;p1, Person &amp;p2);public:    Person(int a, int b) &#123;        m_A = new int(a);        m_B = new int(b);    &#125;    Person&amp; operator= (Person&amp; p) &#123;        if (m_A != NULL) &#123;            delete m_A;            m_A = NULL;        &#125;        if (m_B != NULL) &#123;            delete m_B;            m_B = NULL;        &#125;        m_A = new int(*p.m_A);        m_B = new int(*p.m_B);        return *this;    &#125;    ~Person() &#123;        if (m_A != NULL) &#123;            delete m_A;            m_A = NULL;        &#125;        if (m_B != NULL) &#123;            delete m_B;            m_B = NULL;        &#125;    &#125;private:    int* m_A;    int* m_B;&#125;;bool operator== (Person &amp;p1, Person &amp;p2) &#123;    if (*p1.m_A == *p2.m_A &amp;&amp; *p1.m_B == *p2.m_B) &#123;        return true;    &#125;    else return false;&#125;bool operator!= (Person &amp;p1,Person &amp;p2) &#123;    if (*p1.m_A == *p2.m_A &amp;&amp; *p1.m_B == *p2.m_B) &#123;        return false;    &#125;    else return true;&#125;ostream&amp; operator&lt;&lt; (ostream&amp; cout, Person&amp; p)&#123;    cout &lt;&lt; *p.m_A &lt;&lt; &quot; &quot; &lt;&lt; *p.m_B;    return cout;&#125;void test()&#123;    Person p(10, 10);    Person p1(20, 20);    Person p2(30, 30);    p2 = p1 = p;    cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; &quot; &quot; &lt;&lt; endl;    if (p1 == p2 &amp;&amp; p == p2) &#123;        cout &lt;&lt;&quot;相等&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;    &#125;&#125;int main()&#123;    test();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="函数调用运算符重载（仿函数）"><a href="#函数调用运算符重载（仿函数）" class="headerlink" title="函数调用运算符重载（仿函数）"></a>函数调用运算符重载（仿函数）</h3><p><img src="/../images/cgg-notes/1730723914749.png" alt="1730723914749"></p><p><img src="/../images/cgg-notes/1730723929110.png" alt="1730723929110"></p><p><img src="/../images/cgg-notes/1730724485494.png" alt="1730724485494"></p><p><img src="/../images/cgg-notes/1730724462284.png" alt="1730724462284"></p><p><img src="/../images/cgg-notes/1730724641559.png" alt="1730724641559"></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Myprint&#123;public:    void operator() (string test) &#123;        cout &lt;&lt; test &lt;&lt; endl;    &#125;&#125;;class Myadd&#123;public:    int operator() (int num1, int num2) &#123;        return num1 + num2;    &#125;&#125;;void test1() &#123;    Myprint myprint;    myprint(&quot;hello world&quot;);    Myadd myadd;    int ret = myadd(100, 100);    cout &lt;&lt; ret &lt;&lt; endl;    cout &lt;&lt; Myadd()(20, 12) &lt;&lt; endl;&#125;int main() &#123;    test1();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730724692666.png" alt="1730724692666"></p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><img src="/../images/cgg-notes/1730724813071.png" alt="1730724813071"></p><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><p><img src="/../images/cgg-notes/1730724894279.png" alt="1730724894279"></p><p><img src="/../images/cgg-notes/1730724908108.png" alt="1730724908108"></p><h2 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h2><p><img src="/../images/cgg-notes/1730724950015.png" alt="1730724950015"></p><p><img src="/../images/cgg-notes/1730724967229.png" alt="1730724967229"></p><p><img src="/../images/cgg-notes/1730724999922.png" alt="1730724999922"></p><p><img src="/../images/cgg-notes/1730725024664.png" alt="1730725024664"></p><h3 id="VS-开发人员命令提示符-操作方式"><a href="#VS-开发人员命令提示符-操作方式" class="headerlink" title="VS 开发人员命令提示符 操作方式"></a>VS 开发人员命令提示符 操作方式</h3><p><strong>一，</strong></p><p><strong>打开VS开发人员命令提示符</strong></p><p><img src="/../images/cgg-notes/1730725270770.png" alt="1730725270770"></p><p><strong>二，</strong></p><p><strong>打开文件所在文件夹</strong></p><p><img src="/../images/cgg-notes/1730725642826.png" alt="1730725642826"></p><p><img src="/../images/cgg-notes/1730725681204.png" alt="1730725681204"></p><p><strong>复制文件路径</strong></p><p><strong>三，</strong></p><p><strong>返回开发人员命令提示符，并转换盘符</strong></p><p><img src="/../images/cgg-notes/1730725873774.png" alt="1730725873774"></p><p><strong>打出要转的硬盘，加上冒号，最后打上回车（文件所在硬盘）</strong></p><p><strong>四，</strong></p><p><img src="/../images/cgg-notes/1730726086883.png" alt="1730726086883"></p><p><strong>输入cd表示跳转路径（打完后要加空格），之后加上之前复制的路径，并打上回车</strong></p><p><strong>五，</strong></p><p><strong>输入dir</strong></p><p><img src="/../images/cgg-notes/1730726131194.png" alt="1730726131194"></p><p><strong>六，</strong></p><p><strong>输入指令 “cl &#x2F;d1 reportSingleClassLayout<em>Son</em>(要查看的类名) “文件名称（按Tab补全）” ”</strong></p><p><img src="/../images/cgg-notes/1730726442087.png" alt="1730726442087"></p><p><img src="/../images/cgg-notes/1730726459403.png" alt="1730726459403"></p><h2 id="继承中的构造与析构"><a href="#继承中的构造与析构" class="headerlink" title="继承中的构造与析构"></a>继承中的构造与析构</h2><p><img src="/../images/cgg-notes/1730888622529.png" alt="1730888622529"></p><h2 id="继承中同名成员处理"><a href="#继承中同名成员处理" class="headerlink" title="继承中同名成员处理"></a>继承中同名成员处理</h2><h3 id="同名成员属性"><a href="#同名成员属性" class="headerlink" title="同名成员属性"></a>同名成员属性</h3><p><img src="/../images/cgg-notes/1730892898795.png" alt="1730892898795"></p><h3 id="同名成员函数"><a href="#同名成员函数" class="headerlink" title="同名成员函数"></a>同名成员函数</h3><p><img src="/../images/cgg-notes/1730893084086.png" alt="1730893084086"></p><p><img src="/../images/cgg-notes/1730893183413.png" alt="1730893183413"></p><p><strong>包括父类重载的函数</strong></p><p><img src="/../images/cgg-notes/1730893214187.png" alt="1730893214187"></p><h2 id="同名静态成员的处理方式"><a href="#同名静态成员的处理方式" class="headerlink" title="同名静态成员的处理方式"></a>同名静态成员的处理方式</h2><p><img src="/../images/cgg-notes/1730893355315.png" alt="1730893355315"></p><h3 id="变量-2"><a href="#变量-2" class="headerlink" title="变量"></a>变量</h3><p><img src="/../images/cgg-notes/1730893672879.png" alt="1730893672879"></p><h3 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h3><p><img src="/../images/cgg-notes/1730893957385.png" alt="1730893957385"></p><p><img src="/../images/cgg-notes/1730894015252.png" alt="1730894015252"></p><h2 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h2><p><img src="/../images/cgg-notes/1730894074787.png" alt="1730894074787"></p><p><img src="/../images/cgg-notes/1730894207930.png" alt="1730894207930"></p><p><img src="/../images/cgg-notes/1730894572174.png" alt="1730894572174"></p><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><p><img src="/../images/cgg-notes/1730894698655.png" alt="1730894698655"></p><p><img src="/../images/cgg-notes/1730894791631.png" alt="1730894791631"></p><p><img src="/../images/cgg-notes/1730895356552.png" alt="1730895356552"></p><img src="../images/C++%E7%AC%94%E8%AE%B0/1730895515367.png" alt="1730895515367" style="zoom: 150%;" /><p><img src="/../images/cgg-notes/1730895733571.png" alt="1730895733571"></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p><img src="/../images/cgg-notes/1730965780912.png" alt="1730965780912"></p><h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>父类的引用可以直接指向子类的对象（不需要强制类型转换）</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Animal&#123;public:    void speak()    &#123;        cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;    &#125;&#125;;class Cat :public Animal&#123;public:    void speak()    &#123;        cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;    &#125;&#125;;void doSpeak(Animal&amp; animal)&#123;    animal.speak();&#125;void test() &#123;    Cat cat;    doSpeak(cat);&#125;int main()&#123;    test();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1730968480296.png" alt="1730968480296"></p><p><img src="/../images/cgg-notes/1730968613582.png" alt="1730968613582"></p><pre><code class="c++">class  Animal&#123;public:    virtual void speak()    &#123;        cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;    &#125;&#125;;</code></pre><p><img src="/../images/cgg-notes/1730968678131.png" alt="1730968678131"></p><p><img src="/../images/cgg-notes/1730968894706.png" alt="1730968894706"></p><p><strong>子类的virtual关键字可写可不写</strong></p><p><img src="/../images/cgg-notes/1730968932015.png" alt="1730968932015"></p><p><img src="/../images/cgg-notes/1730968943233.png" alt="1730968943233"></p><pre><code class="c++">void doSpeak(Animal&amp; animal)&#123;    animal.speak();&#125;void test() &#123;    Cat cat;    doSpeak(cat);&#125;</code></pre><h2 id="多态深入剖析-多态底层原理"><a href="#多态深入剖析-多态底层原理" class="headerlink" title="多态深入剖析(多态底层原理)"></a>多态深入剖析(多态底层原理)</h2><p><img src="/../images/cgg-notes/1730969888454.png"></p><p><img src="/../images/cgg-notes/1730970013367.png" alt="1730970013367"></p><p><strong>虚函数重写前</strong></p><p><img src="/../images/cgg-notes/1730970129234.png" alt="1730970129234"></p><p><strong>虚函数重写后</strong></p><p><img src="/../images/cgg-notes/1730970152146.png" alt="1730970152146"></p><h2 id="多态案例——计算器类"><a href="#多态案例——计算器类" class="headerlink" title="多态案例——计算器类"></a>多态案例——计算器类</h2><p><img src="/../images/cgg-notes/1730970247153.png" alt="1730970247153"></p><p><img src="/../images/cgg-notes/1730970646468.png" alt="1730970646468"></p><p> <img src="/../images/cgg-notes/1730979471257.png" alt="1730979471257"></p><p><img src="/../images/cgg-notes/1730979514264.png" alt="1730979514264"></p><p><img src="/../images/cgg-notes/1730979586025.png" alt="1730979586025"></p><p><strong>new出来的数据用完都要销毁掉</strong></p><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p><img src="/../images/cgg-notes/1730979923890.png" alt="1730979923890"></p><p><img src="/../images/cgg-notes/1730979979371.png" alt="1730979979371"></p><p><img src="/../images/cgg-notes/1730979994047.png" alt="1730979994047"></p><p><img src="/../images/cgg-notes/1730980028732.png"></p><p><img src="/../images/cgg-notes/1730980123875.png" alt="1730980123875"></p><p><img src="/../images/cgg-notes/1730980252759.png" alt="1730980252759"></p><h2 id="多态案例2——制作饮品"><a href="#多态案例2——制作饮品" class="headerlink" title="多态案例2——制作饮品"></a>多态案例2——制作饮品</h2><p><img src="/../images/cgg-notes/1730980646291.png" alt="1730980646291"></p><p><img src="/../images/cgg-notes/1730980660480.png" alt="1730980660480"></p><h2 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h2><p><img src="/../images/cgg-notes/1730981378891.png" alt="1730981378891"></p><p><img src="/../images/cgg-notes/1730981387439.png" alt="1730981387439"></p><p><img src="/../images/cgg-notes/1730981876634.png" alt="1730981876634"></p><p><strong>虚析构</strong></p><p><img src="/../images/cgg-notes/1730981902209.png" alt="1730981902209"></p><p><img src="/../images/cgg-notes/1730981907256.png" alt="1730981907256"></p><p><strong>纯虚析构</strong></p><p><strong>类内</strong></p><p><img src="/../images/cgg-notes/1730981973493.png" alt="1730981973493"></p><p><strong>类外</strong></p><p><img src="/../images/cgg-notes/1730982126283.png" alt="1730982126283"></p><p><strong>析构函数需要具体的代码实现</strong></p><p><img src="/../images/cgg-notes/1730982158148.png" alt="1730982158148"></p><p><img src="/../images/cgg-notes/1730982175418.png" alt="1730982175418"></p><p><img src="/../images/cgg-notes/1730982256336.png" alt="1730982256336"></p><p><img src="/../images/cgg-notes/1730982328718.png" alt="1730982328718"></p><h2 id="多态案例3——电脑组装"><a href="#多态案例3——电脑组装" class="headerlink" title="多态案例3——电脑组装"></a>多态案例3——电脑组装</h2><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class CPU&#123;public:    virtual void calculate() = 0;&#125;;class VideoCard&#123;public:    virtual void display() = 0;&#125;;class Memmory&#123;public:    virtual void storage() = 0;&#125;;class Computer&#123;public:    Computer(CPU* cpu, VideoCard* vc, Memmory* mem) &#123;        this-&gt;m_cpu = cpu;        this-&gt;m_vc = vc;        this-&gt;m_mem = mem;    &#125;    ~Computer() &#123;        if (m_cpu != NULL) &#123;            delete m_cpu;            m_cpu = NULL;        &#125;        if (m_vc != NULL) &#123;            delete m_vc;            m_vc = NULL;        &#125;        if (m_mem != NULL) &#123;            delete m_mem;            m_mem = NULL;        &#125;    &#125;    void work() &#123;        m_cpu-&gt;calculate();        m_vc-&gt;display();        m_mem-&gt;storage();    &#125;private:    CPU* m_cpu;    VideoCard* m_vc;    Memmory* m_mem;&#125;;class intelCPU:public CPU&#123;public:    virtual void calculate() &#123;        cout &lt;&lt; &quot;intel的CPU开始计算了！&quot; &lt;&lt; endl;    &#125;&#125;;class intelVideoCard :public VideoCard&#123;public:    virtual void display() &#123;        cout &lt;&lt; &quot;intel的显卡开始显示了！&quot; &lt;&lt; endl;    &#125;&#125;;class intelMemmory :public Memmory&#123;public:    virtual void storage() &#123;        cout &lt;&lt; &quot;intel的存储条开始存储了！&quot; &lt;&lt; endl;    &#125;&#125;;class LevonoCPU :public CPU&#123;public:    virtual void calculate() &#123;        cout &lt;&lt; &quot;Levono的CPU开始计算了！&quot; &lt;&lt; endl;    &#125;&#125;;class LevonoVideoCard :public VideoCard&#123;public:    virtual void display() &#123;        cout &lt;&lt; &quot;Levono的显卡开始显示了！&quot; &lt;&lt; endl;    &#125;&#125;;class LevonoMemmory :public Memmory&#123;public:    virtual void storage() &#123;        cout &lt;&lt; &quot;Levono的存储条开始存储了！&quot; &lt;&lt; endl;    &#125;&#125;;void test()&#123;    //组装第一台电脑    Computer* computer1 = new Computer(new intelCPU, new intelVideoCard, new intelMemmory);    computer1-&gt;work();    delete computer1;    cout &lt;&lt; &quot;-------------------------------&quot; &lt;&lt; endl;    //组装第二台电脑    Computer* computer2 = new Computer(new LevonoCPU, new LevonoVideoCard, new LevonoMemmory);    computer2-&gt;work();    delete computer2;    cout &lt;&lt; &quot;-------------------------------&quot; &lt;&lt; endl;    //组装第三台电脑    Computer* computer3 = new Computer(new intelCPU, new LevonoVideoCard, new LevonoMemmory);    computer3-&gt;work();    delete computer3;&#125;int main()&#123;    test();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1731137860985.png" alt="1731137860985"></p><h1 id="c-文件操作"><a href="#c-文件操作" class="headerlink" title="c++文件操作"></a>c++文件操作</h1><p><img src="/../images/cgg-notes/1731138062401.png" alt="1731138062401"></p><p><img src="/../images/cgg-notes/1731138070940.png" alt="1731138070940"></p><p><img src="/../images/cgg-notes/1731138095473.png" alt="1731138095473"></p><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p><img src="/../images/cgg-notes/1731138269769.png" alt="1731138269769"></p><p><img src="/../images/cgg-notes/1731138449265.png" alt="1731138449265"></p><p><img src="/../images/cgg-notes/1731138546100.png" alt="1731138546100"></p><p><strong>若不写出明确文件路径，则文件会被创建在与代码同级目录中</strong></p><p><img src="/../images/cgg-notes/1731138941520.png" alt="1731138941520"></p><p><img src="/../images/cgg-notes/1731138960042.png" alt="1731138960042"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;#include&lt;fstream&gt;void test1()&#123;    ofstream ofs(&quot;text1.txt&quot;,ios::out);    ofs &lt;&lt; &quot;名字：张三&quot; &lt;&lt; endl;    ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;    ofs.close();&#125;int main()&#123;    test1();    //test2();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1731141836852.png" alt="1731141836852"></p><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p><img src="/../images/cgg-notes/1731139063282.png" alt="1731139063282"></p><p><strong>读数据</strong></p><p><img src="/../images/cgg-notes/1731140022011.png" alt="1731140022011"></p><p><img src="/../images/cgg-notes/1731140053049.png" alt="1731140053049"></p><p><img src="/../images/cgg-notes/1731140153517.png" alt="1731140153517"></p><p><img src="/../images/cgg-notes/1731140240231.png" alt="1731140240231"></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;#include&lt;fstream&gt;#include&lt;string&gt;void test1()&#123;    ofstream ofs(&quot;text1.txt&quot;,ios::out);    ofs &lt;&lt; &quot;名字：张三&quot; &lt;&lt; endl;    ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;    ofs.close();&#125;void test2() &#123;    ifstream ifs(&quot;text1.txt&quot;, ios::in);    //第一种    //char a[64] = &#123; 0 &#125;;    //while (ifs &gt;&gt; a) &#123;    //cout &lt;&lt; a &lt;&lt; endl;    //&#125;    // 第二种    //char a[64] = &#123; 0 &#125;;    //while (ifs.getline(a, sizeof(a))) &#123;    //cout &lt;&lt; a &lt;&lt; endl;    //&#125;    // 第三种    //string a;    //while (getline(ifs, a)) &#123;    //cout &lt;&lt; a &lt;&lt; endl;    //&#125;    //第四种    char a;    while ((a = ifs.get())!= EOF) &#123;        cout &lt;&lt; a;    &#125;&#125;int main()&#123;    //test1();    test2();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="/../images/cgg-notes/1731142103395.png" alt="1731142103395"></p><h2 id="二进制方式写文件"><a href="#二进制方式写文件" class="headerlink" title="二进制方式写文件"></a>二进制方式写文件</h2><p><img src="/../images/cgg-notes/1731140397069.png" alt="1731140397069"></p><p><img src="/../images/cgg-notes/1731140410298.png" alt="1731140410298"></p><p><img src="/../images/cgg-notes/1731140729136.png" alt="1731140729136"></p><p><strong>第二步和第三步可以合体</strong></p><p><img src="/../images/cgg-notes/1731140834058.png" alt="1731140834058"></p><h2 id="二进制方式读文件"><a href="#二进制方式读文件" class="headerlink" title="二进制方式读文件"></a>二进制方式读文件</h2><p><img src="/../images/cgg-notes/1731141165394.png" alt="1731141165394"></p><p><strong>读文件一般要判断文件是否打开成功</strong></p><p><strong>用is_open函数判断</strong></p><p><img src="/../images/cgg-notes/1731141348147.png" alt="1731141348147"></p><h1 id="职工管理系统"><a href="#职工管理系统" class="headerlink" title="职工管理系统"></a>职工管理系统</h1><p><img src="/../images/cgg-notes/1731219032108.png" alt="1731219032108"></p><p><img src="/c++%E7%AC%94%E8%AE%B0.assets/1731219073248.png" alt="1731219073248"></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p><img src="/../images/cgg-notes/1731929256164.png" alt="1731929256164"></p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p><img src="/../images/cgg-notes/1731929649409.png" alt="1731929649409"></p><p><img src="/../images/cgg-notes/1731929670871.png" alt="1731929670871"></p><p><img src="/../images/cgg-notes/1731930205904.png" alt="1731930205904"></p><p><img src="/../images/cgg-notes/1731930407572.png" alt="1731930407572"></p><h3 id="函数模板注意事项"><a href="#函数模板注意事项" class="headerlink" title="函数模板注意事项"></a>函数模板注意事项</h3><p><img src="/../images/cgg-notes/1731930669846.png" alt="1731930669846"></p><p><img src="/../images/cgg-notes/1731930769145.png" alt="1731930769145"></p><p><img src="/../images/cgg-notes/1731930973145.png" alt="1731930973145"></p><h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><p><img src="/../images/cgg-notes/1731931898810.png" alt="1731931898810"></p><p><img src="/../images/cgg-notes/1731932116060.png" alt="1731932116060"></p><p><strong>普通函数将c的char类型隐式转换成int类型</strong></p><p><img src="/../images/cgg-notes/1731932235718.png" alt="1731932235718"></p><p><strong>函数模板自动类型推导无法进行类型隐式转换</strong></p><p><img src="/../images/cgg-notes/1731932289013.png" alt="1731932289013"></p><p><strong>显示指定类型可以</strong></p><h3 id="普通函数与函数模板条用规则（重载）"><a href="#普通函数与函数模板条用规则（重载）" class="headerlink" title="普通函数与函数模板条用规则（重载）"></a>普通函数与函数模板条用规则（重载）</h3><p><img src="/../images/cgg-notes/1731932447568.png" alt="1731932447568"></p><p><img src="/../images/cgg-notes/1731932828284.png"></p><p><img src="/../images/cgg-notes/1731932981427.png" alt="1731932981427"></p><p><img src="/../images/cgg-notes/1731933136721.png" alt="1731933136721"></p><p><img src="/../images/cgg-notes/1731933088437.png" alt="1731933088437"></p><p><strong>直接调用模板函数，不用做类型隐式转换</strong></p><h3 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h3><p><img src="/../images/cgg-notes/1731933400429.png" alt="1731933400429"></p><p><img src="/../images/cgg-notes/1731933411395.png" alt="1731933411395"></p><p><img src="/../images/cgg-notes/1731933427670.png" alt="1731933427670"></p><h4 id="模板重载"><a href="#模板重载" class="headerlink" title="模板重载"></a>模板重载</h4><p><img src="/../images/cgg-notes/1731933997156.png" alt="1731933997156"></p><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p><img src="/../images/cgg-notes/1731934251963.png" alt="1731934251963"></p><p><img src="/../images/cgg-notes/1731934294260.png" alt="1731934294260"></p><p><img src="/../images/cgg-notes/1731934419616.png" alt="1731934419616"></p><p><img src="/../images/cgg-notes/1731934513521.png" alt="1731934513521"></p><h3 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h3><p><img src="/../images/cgg-notes/1731934792812.png" alt="1731934792812"></p><p><img src="/../images/cgg-notes/1731935000829.png" alt="1731935000829"></p><p><img src="/../images/cgg-notes/1731935016105.png" alt="1731935016105"></p><p><img src="/../images/cgg-notes/1731935053598.png" alt="1731935053598"></p><p><img src="/../images/cgg-notes/1731935135414.png" alt="1731935135414"></p><p><img src="/../images/cgg-notes/1731935190689.png" alt="1731935190689"></p><h3 id="类模板成员函数创建时机"><a href="#类模板成员函数创建时机" class="headerlink" title="类模板成员函数创建时机"></a>类模板成员函数创建时机</h3><p><img src="/../images/cgg-notes/1732448126230.png" alt="1732448126230"></p><p><img src="/../images/cgg-notes/1732448151371.png" alt="1732448151371"></p><p><img src="/../images/cgg-notes/1732448174923.png" alt="1732448174923"></p><h3 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h3><p><img src="/../images/cgg-notes/1732448237794.png" alt="1732448237794"></p><p><img src="/../images/cgg-notes/1732448495728.png" alt="1732448495728"></p><p><img src="/../images/cgg-notes/1732448636100.png" alt="1732448636100"></p><p><img src="/../images/cgg-notes/1732448935061.png" alt="1732448935061"></p><h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p><img src="/../images/cgg-notes/1732451732405.png" alt="1732451732405"></p><p><img src="/../images/cgg-notes/1732451767334.png" alt="1732451767334"></p><p><img src="/../images/cgg-notes/1732451788803.png" alt="1732451788803"></p><p><img src="/../images/cgg-notes/1732452064508.png" alt="1732452064508"></p><p><img src="/../images/cgg-notes/1732451800500.png" alt="1732451800500"></p><h3 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h3><p><img src="/../images/cgg-notes/1732452639892.png" alt="1732452639892"></p><p><img src="/../images/cgg-notes/1732452471076.png" alt="1732452471076"></p><p><img src="/../images/cgg-notes/1732452605556.png" alt="1732452605556"></p><h3 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h3><p><img src="/../images/cgg-notes/1732452751923.png" alt="1732452751923"></p><p><strong>一般不使用第一种方法直接包含源码</strong></p><p><strong>方法二是写同一在头文件</strong></p><h3 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h3><p><img src="/../images/cgg-notes/1732453602989.png" alt="1732453602989"></p><p><img src="/../images/cgg-notes/1732454337677.png" alt="1732454337677"></p><p><img src="/../images/cgg-notes/1732454405534.png" alt="1732454405534"></p><p><img src="/../images/cgg-notes/1732454574412.png" alt="1732454574412"></p><p><img src="/../images/cgg-notes/1732454618917.png" alt="1732454618917"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;向黑马程序员学c++，目标成为黑马程序员&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
</feed>
