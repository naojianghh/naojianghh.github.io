<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NaoJianghh</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-11-26T15:41:47.564Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>脑浆糊</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MeasureSpec和LayoutParams的关系</title>
    <link href="http://example.com/2025/11/26/MeasureSpec%E5%92%8CLayoutParams%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://example.com/2025/11/26/MeasureSpec%E5%92%8CLayoutParams%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2025-11-26T15:37:13.000Z</published>
    <updated>2025-11-26T15:41:47.564Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="MeasureSpec和LayoutParams的关系"><a href="#MeasureSpec和LayoutParams的关系" class="headerlink" title="MeasureSpec和LayoutParams的关系"></a>MeasureSpec和LayoutParams的关系</h2><ul><li><strong>LayoutParams（布局参数）</strong>：子 View 给父容器的「尺寸请求书」，明确 “我想要多大”；</li><li><strong>MeasureSpec（测量约束）</strong>：父容器给子 View 的「最终判决书」，明确 “结合我的情况，你最多 &#x2F; 必须多大”。</li></ul><h3 id="一、先搞懂：LayoutParams-是什么？"><a href="#一、先搞懂：LayoutParams-是什么？" class="headerlink" title="一、先搞懂：LayoutParams 是什么？"></a>一、先搞懂：LayoutParams 是什么？</h3><h4 id="1-核心定义"><a href="#1-核心定义" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h4><p><code>LayoutParams</code> 是 <strong>子 View 向父容器声明的 “尺寸与布局规则”</strong>，是子 View 主动发起的 “请求”，决定了子 View 希望自己在父容器中如何布局。</p><h4 id="2-谁来定义？"><a href="#2-谁来定义？" class="headerlink" title="2. 谁来定义？"></a>2. 谁来定义？</h4><p>由 <strong>子 View 自身（或开发者在 XML &#x2F; 代码中配置）</strong> 决定，比如：</p><ul><li>XML 中写 <code>android:layout_width=&quot;wrap_content&quot;</code> → 子 View 声明 “宽度要自适应内容”；</li><li>代码中 <code>textView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 100)</code> → 子 View 声明 “宽度填充父容器，高度固定 100px”。</li></ul><h4 id="3-核心内容（以宽高为例）"><a href="#3-核心内容（以宽高为例）" class="headerlink" title="3. 核心内容（以宽高为例）"></a>3. 核心内容（以宽高为例）</h4><p>只有三个核心选项，对应 <code>layout_width</code>&#x2F;<code>layout_height</code> 的配置：</p><ul><li><code>MATCH_PARENT</code>（<code>-1</code>）：“我要和父容器一样宽 &#x2F; 高”；</li><li><code>WRAP_CONTENT</code>（<code>-2</code>）：“我要自适应内容，宽 &#x2F; 高刚好包裹内容”；</li><li>固定尺寸（如 <code>200dp</code>&#x2F;<code>300px</code>）：“我要固定这么宽 &#x2F; 高”。</li></ul><h4 id="4-关键特点"><a href="#4-关键特点" class="headerlink" title="4. 关键特点"></a>4. 关键特点</h4><ul><li>只是 “请求”，不是 “最终结果”：子 View 想要的尺寸，能不能实现要看父容器的脸色；</li><li>依赖父容器支持：比如 <code>layout_weight</code> 是 <code>LinearLayout</code> 专属的 <code>LayoutParams</code> 属性，只有父容器是 <code>LinearLayout</code> 时才生效（其他父容器不识别）。</li></ul><h3 id="二、再搞懂：MeasureSpec-是什么？"><a href="#二、再搞懂：MeasureSpec-是什么？" class="headerlink" title="二、再搞懂：MeasureSpec 是什么？"></a>二、再搞懂：MeasureSpec 是什么？</h3><h4 id="1-核心定义-1"><a href="#1-核心定义-1" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h4><p><code>MeasureSpec</code> 是 <strong>父容器给子 View 的 “测量约束条件”</strong>，是父容器结合自身情况对 “子 View 请求” 的 “最终裁决”，决定了子 View 测量时的最大 &#x2F; 固定尺寸。</p><h4 id="2-谁来定义？-1"><a href="#2-谁来定义？-1" class="headerlink" title="2. 谁来定义？"></a>2. 谁来定义？</h4><p>由 <strong>父容器</strong> 决定，父容器会根据两个因素计算出子 View 的 <code>MeasureSpec</code>：</p><ul><li>父容器自身的 <code>MeasureSpec</code>（父容器的父容器给它的约束）；</li><li>子 View 的 <code>LayoutParams</code>（子 View 的请求）。</li></ul><h4 id="3-核心内容（模式-尺寸）"><a href="#3-核心内容（模式-尺寸）" class="headerlink" title="3. 核心内容（模式 + 尺寸）"></a>3. 核心内容（模式 + 尺寸）</h4><p>每个 <code>MeasureSpec</code> 由「模式（Mode）」和「尺寸（Size）」两部分组成（本质是一个 32 位 int，高 2 位存模式，低 30 位存尺寸）：</p><table><thead><tr><th>模式</th><th>含义（对其子 View 的约束）</th></tr></thead><tbody><tr><td><code>EXACTLY</code>（精确模式）</td><td>子 View 必须用这个固定尺寸（比如父容器给 <code>300dp</code>，子 View 就只能是 <code>300dp</code>）</td></tr><tr><td><code>AT_MOST</code>（最大模式）</td><td>子 View 尺寸不能超过这个最大值（比如父容器给 <code>300dp</code>，子 View 可以是 <code>100dp</code>&#x2F;<code>200dp</code>，但不能超 <code>300dp</code>）</td></tr><tr><td><code>UNSPECIFIED</code>（无限制）</td><td>父容器不限制子 View 尺寸（极少用，比如 <code>ScrollView</code> 的子 View 高度可以无限长）</td></tr></tbody></table><h4 id="4-关键特点-1"><a href="#4-关键特点-1" class="headerlink" title="4. 关键特点"></a>4. 关键特点</h4><ul><li>是 “约束”，不是 “最终尺寸”：子 View 测量时必须遵守这个约束，但最终尺寸是在约束范围内计算的（比如约束是 <code>AT_MOST 300dp</code>，子 View 内容只有 <code>100dp</code>，最终尺寸就是 <code>100dp</code>）；</li><li>是测量阶段的 “核心规则”：子 View 必须根据这个约束来计算自己的宽高（否则会超出父容器或尺寸异常）。</li></ul><h3 id="三、一句话对比：两者的核心区别"><a href="#三、一句话对比：两者的核心区别" class="headerlink" title="三、一句话对比：两者的核心区别"></a>三、一句话对比：两者的核心区别</h3><table><thead><tr><th>维度</th><th>LayoutParams（子 View 的请求）</th><th>MeasureSpec（父容器的约束）</th></tr></thead><tbody><tr><td>发起者</td><td>子 View（开发者配置）</td><td>父容器（自动计算）</td></tr><tr><td>核心作用</td><td>声明 “我想要多大”</td><td>规定 “你最多 &#x2F; 必须多大”</td></tr><tr><td>内容形式</td><td>MATCH_PARENT&#x2F;WRAP_CONTENT&#x2F; 固定尺寸</td><td>模式（EXACTLY&#x2F;AT_MOST&#x2F;UNSPECIFIED）+ 尺寸</td></tr><tr><td>优先级</td><td>低（只是请求）</td><td>高（最终约束）</td></tr><tr><td>依赖关系</td><td>依赖父容器识别（如 weight 只对 LinearLayout 生效）</td><td>依赖父容器自身约束 + 子 View 的 LayoutParams</td></tr></tbody></table><h3 id="举个生活例子，瞬间懂"><a href="#举个生活例子，瞬间懂" class="headerlink" title="举个生活例子，瞬间懂"></a>举个生活例子，瞬间懂</h3><p>你（子 View）去租房（找父容器要空间）：</p><ol><li>你先提需求（LayoutParams）：“我想要一个 20 平米的房间（固定尺寸）”；</li><li>房东（父容器）看了自己的房子（父容器自身约束：比如总共有 30 平米空房），给你回复（MeasureSpec）：“行，给你留 20 平米（EXACTLY 20），刚好够”；</li><li>如果你提的需求是 “我想要一个能放下沙发的房间（WRAP_CONTENT）”，房东回复（MeasureSpec）：“我这最大的空房 30 平米，你最多用 30 平米（AT_MOST 30），自己看着安排”；</li><li>如果你提的需求是 “我想要和你房子一样大的房间（MATCH_PARENT）”，房东回复（MeasureSpec）：“我房子总共 100 平米，给你整间（EXACTLY 100）”。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;MeasureSpec和LayoutParams的关系&quot;&gt;&lt;a href=&quot;#MeasureSpec和LayoutParams的关系&quot; class=&quot;headerlink&quot; title=&quot;MeasureSpec和L</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="原理" scheme="http://example.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>自定义ViewGroup流程详解</title>
    <link href="http://example.com/2025/11/26/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/11/26/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-11-26T15:18:35.000Z</published>
    <updated>2025-11-26T15:43:44.097Z</updated>
    
    <content type="html"><![CDATA[<p>流式布局自定义示例</p><span id="more"></span><h1 id="自定义ViewGroup流程详解"><a href="#自定义ViewGroup流程详解" class="headerlink" title="自定义ViewGroup流程详解"></a>自定义ViewGroup流程详解</h1><p>自定义 ViewGroup 一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自 ViewGroup 或各种 Layout 。</p><p>ViewGroup 的生命周期核心围绕「<strong>测量（Measure）→ 布局（Layout）→ 绘制（Draw）</strong>」三大阶段展开，其中 <strong>测量和布局是自定义 ViewGroup 的核心</strong>—— 测量阶段确定「自身和所有子 View 的尺寸」，布局阶段确定「所有子 View 的位置」，两者环环相扣，直接决定布局是否正常显示。</p><h2 id="一、先明确：ViewGroup-生命周期的核心流程"><a href="#一、先明确：ViewGroup-生命周期的核心流程" class="headerlink" title="一、先明确：ViewGroup 生命周期的核心流程"></a>一、先明确：ViewGroup 生命周期的核心流程</h2><p>ViewGroup 作为「容器 View」，生命周期是 <strong>「自身生命周期 + 子 View 生命周期的协调」</strong>，核心流程顺序不可逆：</p><p><img src="/../images/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup/1764171083462.png" alt="1764171083462"></p><p>其中：</p><ul><li>「测量 + 布局」是布局生效的关键，会在以下场景触发：<ol><li>首次加载布局（Activity <code>onCreate</code> 后）；</li><li>调用 <code>requestLayout()</code>（动态添加子 View、修改尺寸 &#x2F; 间距等）；</li><li>屏幕旋转、窗口尺寸变化（如软键盘弹出）；</li></ol></li><li>「绘制阶段」依赖测量和布局的结果，负责将 View 渲染到屏幕，自定义 ViewGroup 很少需要重写（除非要绘制背景、分割线等）。</li></ul><h2 id="二、核心阶段-1：测量阶段（Measure）——-解决「多大」的问题"><a href="#二、核心阶段-1：测量阶段（Measure）——-解决「多大」的问题" class="headerlink" title="二、核心阶段 1：测量阶段（Measure）—— 解决「多大」的问题"></a>二、核心阶段 1：测量阶段（Measure）—— 解决「多大」的问题</h2><p>测量阶段的核心目标：<strong>计算出 ViewGroup 自身的最终宽高，以及所有子 View 的宽高</strong></p><p>因为 ViewGroup 没有固定尺寸（依赖子 View 和父容器限制），所以测量是「自下而上 + 自上而下」的双向过程：</p><h3 id="1-测量的触发入口：measure-int-widthMeasureSpec-int-heightMeasureSpec"><a href="#1-测量的触发入口：measure-int-widthMeasureSpec-int-heightMeasureSpec" class="headerlink" title="1. 测量的触发入口：measure(int widthMeasureSpec, int heightMeasureSpec)"></a>1. 测量的触发入口：<code>measure(int widthMeasureSpec, int heightMeasureSpec)</code></h3><ul><li><p>调用者：父容器（或系统）会调用 ViewGroup 的 <code>measure</code> 方法，传入「宽高限制参数（MeasureSpec）」；</p></li><li><p>核心参数：<code>MeasureSpec</code>（由「模式 + 尺寸」组成，是父容器对当前 ViewGroup 的约束），有三种模式：</p><table><thead><tr><th>模式</th><th>含义（父容器对 ViewGroup 的限制）</th><th>对应 XML 配置</th></tr></thead><tbody><tr><td>EXACTLY（精确模式）</td><td>父容器已确定 ViewGroup 的宽高（如固定 <code>200dp</code> 或 <code>match_parent</code>）</td><td><code>layout_width=&quot;200dp&quot;</code>&#x2F;<code>match_parent</code></td></tr><tr><td>AT_MOST（最大模式）</td><td>ViewGroup 宽高不能超过父容器给定的最大值（对应 <code>wrap_content</code>）</td><td><code>layout_width=&quot;wrap_content&quot;</code></td></tr><tr><td>UNSPECIFIED（无限制）</td><td>父容器不限制宽高（如 ScrollView 子 View 的高度）</td><td>极少用（系统内部场景）</td></tr></tbody></table></li></ul><h3 id="2-测量的核心逻辑：ViewGroup-如何测量自己和子-View？"><a href="#2-测量的核心逻辑：ViewGroup-如何测量自己和子-View？" class="headerlink" title="2. 测量的核心逻辑：ViewGroup 如何测量自己和子 View？"></a>2. 测量的核心逻辑：ViewGroup 如何测量自己和子 View？</h3><p>ViewGroup 不能直接测量自己，必须先测量所有子 View，再根据子 View 的尺寸计算自身尺寸 —— 这是「自下而上」的关键：</p><h4 id="步骤-1：遍历子-View，触发子-View-测量"><a href="#步骤-1：遍历子-View，触发子-View-测量" class="headerlink" title="步骤 1：遍历子 View，触发子 View 测量"></a>步骤 1：遍历子 View，触发子 View 测量</h4><p>ViewGroup 会调用 <code>measureChild(child, widthMeasureSpec, heightMeasureSpec)</code>（或 <code>measureChildWithMargins</code>，支持 margin），本质是：</p><ul><li>根据自身的 <code>MeasureSpec</code> 和子 View 的 <code>layout_params</code>（如 <code>wrap_content</code>），计算出子 View 的 <code>MeasureSpec</code>；</li><li>调用子 View 的 <code>measure</code> 方法，让子 View 自己测量宽高（子 View 测量后，通过 <code>getMeasuredWidth()</code>&#x2F;<code>getMeasuredHeight()</code> 可获取其尺寸）。</li></ul><h4 id="步骤-2：根据子-View-尺寸，计算自身尺寸"><a href="#步骤-2：根据子-View-尺寸，计算自身尺寸" class="headerlink" title="步骤 2：根据子 View 尺寸，计算自身尺寸"></a>步骤 2：根据子 View 尺寸，计算自身尺寸</h4><p>这是自定义 ViewGroup 最需要自定义的逻辑（比如 FlowLayout 的换行计算），核心思路：</p><ul><li>记录所有子 View 的排列方式（如单行 &#x2F; 多行、水平 &#x2F; 垂直）；</li><li>累加子 View 占用的空间（宽度 &#x2F; 高度），并考虑「子 View 间距」「自身 padding」；</li><li>结合父容器的<code>MeasureSpec</code>模式，确定自身最终宽高：<ul><li>若父容器是 <code>EXACTLY</code>（如 <code>match_parent</code>&#x2F; 固定尺寸）：自身宽高直接用父容器给的尺寸；</li><li>若父容器是 <code>AT_MOST</code>（如 <code>wrap_content</code>）：自身宽高 &#x3D; 子 View 排列后的总宽高 + 自身 padding。</li></ul></li></ul><h4 id="步骤-3：保存测量结果"><a href="#步骤-3：保存测量结果" class="headerlink" title="步骤 3：保存测量结果"></a>步骤 3：保存测量结果</h4><p>必须调用 <code>setMeasuredDimension(int measuredWidth, int measuredHeight)</code>，将计算出的自身宽高保存 —— 这是测量阶段的「收尾动作」，不调用会导致 ViewGroup 尺寸为 0，布局完全不可见。</p><h3 id="3-关键原理：为什么测量是「双向」的？"><a href="#3-关键原理：为什么测量是「双向」的？" class="headerlink" title="3. 关键原理：为什么测量是「双向」的？"></a>3. 关键原理：为什么测量是「双向」的？</h3><ul><li>自上而下：父容器通过 <code>MeasureSpec</code> 给 ViewGroup 施加限制（比如 “你最多宽 300dp”）；</li><li>自下而上：ViewGroup 测量完所有子 View 后，根据子 View 的总尺寸，反过来确定自己的最终尺寸（比如 “子 View 换行后总高 200dp，所以我宽 300dp、高 200dp”）。</li></ul><h2 id="三、核心阶段-2：布局阶段（Layout）——-解决「在哪」的问题"><a href="#三、核心阶段-2：布局阶段（Layout）——-解决「在哪」的问题" class="headerlink" title="三、核心阶段 2：布局阶段（Layout）—— 解决「在哪」的问题"></a>三、核心阶段 2：布局阶段（Layout）—— 解决「在哪」的问题</h2><p>布局阶段的核心目标：<strong>根据测量阶段的结果，确定每个子 View 在 ViewGroup 中的具体位置（坐标）</strong></p><p>布局是「自上而下」的过程：ViewGroup 已经知道自己的宽高和所有子 View 的宽高，只需按排列规则分配坐标。</p><h3 id="1-布局的触发入口：layout-int-l-int-t-int-r-int-b"><a href="#1-布局的触发入口：layout-int-l-int-t-int-r-int-b" class="headerlink" title="1. 布局的触发入口：layout(int l, int t, int r, int b)"></a>1. 布局的触发入口：<code>layout(int l, int t, int r, int b)</code></h3><ul><li>调用者：父容器会调用 ViewGroup 的 <code>layout</code> 方法，传入 ViewGroup 自身在父容器中的坐标（<code>l=左，t=上，r=右，b=下</code>）；</li><li>核心动作：ViewGroup 先通过 <code>setFrame(l, t, r, b)</code> 确定自己在父容器中的位置，然后立刻调用 <code>onLayout</code> 方法，开始摆放子 View。</li></ul><h3 id="2-布局的核心逻辑：ViewGroup-如何摆放子-View？"><a href="#2-布局的核心逻辑：ViewGroup-如何摆放子-View？" class="headerlink" title="2. 布局的核心逻辑：ViewGroup 如何摆放子 View？"></a>2. 布局的核心逻辑：ViewGroup 如何摆放子 View？</h3><p>自定义 ViewGroup 必须重写 <code>onLayout(boolean changed, int l, int t, int r, int b)</code>，核心思路是「遍历子 View + 分配坐标」：</p><h4 id="步骤-1：确定自身的可用区域"><a href="#步骤-1：确定自身的可用区域" class="headerlink" title="步骤 1：确定自身的可用区域"></a>步骤 1：确定自身的可用区域</h4><p>ViewGroup 自身有 <code>padding</code>（内边距），子 View 不能超出这个范围，所以可用区域是：</p><ul><li>可用宽度 &#x3D; 自身宽度（r-l） - paddingLeft - paddingRight；</li><li>可用高度 &#x3D; 自身高度（b-t） - paddingTop - paddingBottom；</li><li>子 View 的起始坐标基准：<code>lineStartX = paddingLeft</code>，<code>lineStartY = paddingTop</code>（从内边距的左上角开始摆放）。</li></ul><h4 id="步骤-2：遍历子-View，计算子-View-的坐标"><a href="#步骤-2：遍历子-View，计算子-View-的坐标" class="headerlink" title="步骤 2：遍历子 View，计算子 View 的坐标"></a>步骤 2：遍历子 View，计算子 View 的坐标</h4><p>对每个可见的子 View（跳过 <code>GONE</code> 的），按排列规则计算其四个顶点坐标（<code>childL, childT, childR, childB</code>）：</p><ul><li>坐标规则：<code>childR = childL + 子 View 测量宽度</code>，<code>childB = childT + 子 View 测量高度</code>；</li><li>排列规则（自定义核心）：比如 FlowLayout 的换行逻辑 —— 如果当前行剩余宽度不够放子 View，就更新 <code>lineStartY</code>（换行，累加行高 + 垂直间距），重置 <code>lineStartX</code>（回到左侧起点）；</li><li>调用子 View 的 <code>layout</code> 方法：将计算好的坐标传入 <code>child.layout(childL, childT, childR, childB)</code>，子 View 会根据这个坐标确定自己的位置。</li></ul><h4 id="步骤-3：递归布局（如果子-View-也是-ViewGroup）"><a href="#步骤-3：递归布局（如果子-View-也是-ViewGroup）" class="headerlink" title="步骤 3：递归布局（如果子 View 也是 ViewGroup）"></a>步骤 3：递归布局（如果子 View 也是 ViewGroup）</h4><p>如果子 View 是 ViewGroup（比如 FlowLayout 里嵌套 LinearLayout），调用 <code>child.layout()</code> 会触发该子 View 的 <code>onLayout</code> 方法，继续摆放它的子 View—— 这就是布局的「递归特性」，从根布局一直传递到最底层的子 View。</p><h3 id="3-关键原理：布局与测量的依赖关系"><a href="#3-关键原理：布局与测量的依赖关系" class="headerlink" title="3. 关键原理：布局与测量的依赖关系"></a>3. 关键原理：布局与测量的依赖关系</h3><ul><li>测量是布局的前提：没有测量阶段的 <code>getMeasuredWidth()</code>&#x2F;<code>getMeasuredHeight()</code>，就无法计算子 View 的坐标；</li><li>布局不影响测量：布局阶段只分配位置，不会修改任何 View 的宽高（宽高已在测量阶段固定）。</li></ul><h2 id="四、测量与布局的核心关联：为什么不能乱改？"><a href="#四、测量与布局的核心关联：为什么不能乱改？" class="headerlink" title="四、测量与布局的核心关联：为什么不能乱改？"></a>四、测量与布局的核心关联：为什么不能乱改？</h2><ol><li>顺序不可逆：必须先测量（确定尺寸），再布局（确定位置）—— 没有尺寸，位置无从谈起；</li><li>触发机制联动：调用 <code>requestLayout()</code> 会同时触发「重新测量 + 重新布局」（不会触发绘制，除非尺寸变化导致视觉变化）；</li><li>子 View 状态影响父容器：子 View 的 <code>visibility</code>（<code>GONE</code> 会跳过测量布局）、<code>layout_params</code>（<code>wrap_content</code>&#x2F;<code>match_parent</code>）会直接影响 ViewGroup 的测量结果；</li><li>父容器限制影响子 View：父容器的 <code>MeasureSpec</code> 会限制子 View 的最大尺寸（比如父容器宽 300dp，子 View <code>match_parent</code> 就只能宽 300dp）。</li></ol><h2 id="五、常见误区：从生命周期角度避坑"><a href="#五、常见误区：从生命周期角度避坑" class="headerlink" title="五、常见误区：从生命周期角度避坑"></a>五、常见误区：从生命周期角度避坑</h2><ol><li>重写 <code>onMeasure</code> 不调用 <code>setMeasuredDimension</code>：测量结果不保存，ViewGroup 尺寸为 0；</li><li>布局时不考虑 <code>padding</code>&#x2F;<code>margin</code>：子 View 超出容器范围或间距异常；</li><li>跳过 <code>GONE</code> 的子 View：<code>GONE</code> 子 View 不参与测量布局，否则会导致尺寸 &#x2F; 位置计算错误；</li><li>随意重写 <code>requestLayout()</code>&#x2F;<code>measure()</code>：这两个方法是生命周期的核心触发点，重写会破坏测量 - 布局的联动逻辑；</li><li>布局时修改子 View 宽高：子 View 宽高已在测量阶段固定，布局阶段修改会导致尺寸与位置不匹配（比如子 View 宽 100dp，却按 200dp 布局，超出容器）。</li></ol><h2 id="总结：ViewGroup-生命周期的核心本质"><a href="#总结：ViewGroup-生命周期的核心本质" class="headerlink" title="总结：ViewGroup 生命周期的核心本质"></a>总结：ViewGroup 生命周期的核心本质</h2><ul><li>测量阶段：「双向协商」—— 父容器给限制，子 View 报尺寸，ViewGroup 汇总计算自身尺寸；</li><li>布局阶段：「单向分配」——ViewGroup 按规则给子 View 分配坐标，递归完成整个布局树的位置确定；</li><li>自定义 ViewGroup 的核心：<strong>在 <code>onMeasure</code> 中实现「子 View 尺寸汇总逻辑」，在 <code>onLayout</code> 中实现「子 View 坐标分配逻辑」</strong>，其余生命周期方法（如构造函数、<code>onAttachedToWindow</code>）都是辅助，无需过度修改。</li></ul><h2 id="FlowLayout自定义示例代码"><a href="#FlowLayout自定义示例代码" class="headerlink" title="FlowLayout自定义示例代码"></a>FlowLayout自定义示例代码</h2><pre><code class="kotlin">package com.naojianghh.testimport android.content.Contextimport android.util.AttributeSetimport android.view.Viewimport android.view.ViewGroupclass FlowLayout @JvmOverloads constructor(    context: Context,    attrs: AttributeSet? = null,    defStyleAttr: Int = 0) : ViewGroup(context,attrs,defStyleAttr) &#123;    var horizontalSpacing: Int = dp2px(8f)    var verticalSpacing: Int = dp2px(8f)    private fun dp2px(dp: Float): Int &#123;        return (resources.displayMetrics.density * dp + 0.5f).toInt()    &#125;    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;        // 1. 获取父容器给的宽度和高度限制        val widthMode = MeasureSpec.getMode(widthMeasureSpec)        val widthSize = MeasureSpec.getSize(widthMeasureSpec)        val heightMode = MeasureSpec.getMode(heightMeasureSpec)        val heightSize = MeasureSpec.getSize(heightMeasureSpec)        // 2. 记录当前行的宽度和高度（用于换行计算）        var lineWidth = 0        var lineHeight = 0        var measuredWidth = 0        var measuredHeight = 0        for (i in 0 until childCount)&#123;            val child = getChildAt(i)            if (child.visibility == View.GONE) continue // 跳过隐藏的子View            // 测量子View（传入父容器的限制，让子View自己计算尺寸）            measureChild(child,widthMeasureSpec,heightMeasureSpec)            // 获取子View测量后的宽高            val childWidth = child.measuredWidth            val childHeight = child.measuredHeight            // 4. 判断是否需要换行：当前行已占用宽度 + 子View宽度 + 水平间距 &gt; 父容器宽度（除了EXACTLY模式）            if (widthMode != MeasureSpec.UNSPECIFIED &amp;&amp;                lineWidth + childWidth + horizontalSpacing &gt; widthSize - paddingLeft - paddingRight            ) &#123;                // 换行：更新总宽度和总高度                measuredWidth = measuredWidth.coerceAtLeast(lineWidth) // 总宽度取所有行的最大宽度                measuredHeight += lineHeight + verticalSpacing // 总高度累加当前行高度 + 垂直间距                // 重置当前行的宽度和高度（新行从当前子View开始）                lineWidth = childWidth                lineHeight = childHeight            &#125; else &#123;                // 不换行：累加当前行宽度，更新当前行最大高度                lineWidth += childWidth + horizontalSpacing                lineHeight = lineHeight.coerceAtLeast(childHeight)            &#125;            if (i == childCount - 1) &#123;                measuredWidth = measuredWidth.coerceAtLeast(lineWidth)                measuredHeight += lineHeight            &#125;        &#125;        // 6. 加上自身的padding（左右padding影响宽度，上下padding影响高度）        measuredWidth += paddingLeft + paddingRight        measuredHeight += paddingTop + paddingBottom        // 7. 最终确定自身的尺寸（根据父容器的模式调整）        val finalWidth = if (widthMode == MeasureSpec.EXACTLY) widthSize else measuredWidth        val finalHeight = if (heightMode == MeasureSpec.EXACTLY) heightSize else measuredHeight        setMeasuredDimension(finalWidth, finalHeight)    &#125;    override fun onLayout(        changed: Boolean,        l: Int,        t: Int,        r: Int,        b: Int    ) &#123;        // 1. 获取自身的padding（子View不能超出padding范围，局部变量相较于this访问可以减少开销）        val paddingLeft = paddingLeft        val paddingTop = paddingTop        // 2. 记录当前行的起始X、Y坐标        var lineStartX = paddingLeft        var lineStartY = paddingTop        // 3. 记录当前行的最大高度（用于计算下一行的起始Y坐标）        var lineMaxHeight = 0        // 遍历所有子View，摆放位置        for (i in 0 until childCount)&#123;            val child = getChildAt(i)            if (child.visibility == View.GONE) continue            // 在onMeasure方法中已经测量了子View的测量宽高，可以直接获取            val childWidth = child.measuredWidth            val childHeight = child.measuredHeight            // 4. 判断是否需要换行（和onMeasure的换行逻辑一致）            if (lineStartX + childWidth &gt; r - l - paddingRight) &#123;                // 换行：更新下一行的起始Y坐标，重置起始X坐标和行最大高度                lineStartY += lineMaxHeight + verticalSpacing                lineStartX = paddingLeft                lineMaxHeight = 0            &#125;            // 5. 摆放子View（left, top, right, bottom）            child.layout(                lineStartX,                // 子View的左坐标                lineStartY,                // 子View的上坐标                lineStartX + childWidth,   // 子View的右坐标（左+宽）                lineStartY + childHeight   // 子View的下坐标（上+高）            )            // 6. 更新当前行的起始X坐标（累加子View宽度+水平间距）            lineStartX += childWidth + horizontalSpacing            // 7. 更新当前行的最大高度            lineMaxHeight = lineMaxHeight.coerceAtLeast(childHeight)        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;流式布局自定义示例&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="kotlin" scheme="http://example.com/tags/kotlin/"/>
    
    <category term="原理" scheme="http://example.com/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>并查集9.9_道路</title>
    <link href="http://example.com/2025/11/25/%E5%B9%B6%E6%9F%A5%E9%9B%869-9-%E9%81%93%E8%B7%AF/"/>
    <id>http://example.com/2025/11/25/%E5%B9%B6%E6%9F%A5%E9%9B%869-9-%E9%81%93%E8%B7%AF/</id>
    <published>2025-11-25T15:20:35.000Z</published>
    <updated>2025-11-26T05:12:13.418Z</updated>
    
    <content type="html"><![CDATA[<p>并查集的应用</p><span id="more"></span><h1 id="算法与数据结构实验题-9-9-道路"><a href="#算法与数据结构实验题-9-9-道路" class="headerlink" title="算法与数据结构实验题 9.9 道路"></a>算法与数据结构实验题 9.9 道路</h1><h3 id="★实验任务"><a href="#★实验任务" class="headerlink" title="★实验任务"></a>★实验任务</h3><p>某省调查城镇交通状况，得到现有城镇道路统计表，现给出每条道路连接的城镇编号，问当前的道路设计方案是否合理。</p><p>合理的方案为任意两个城镇之间可以相互到达，有且只有一条通路。</p><h3 id="★数据输入"><a href="#★数据输入" class="headerlink" title="★数据输入"></a>★数据输入</h3><p>输入a b(1&lt;&#x3D;a,b&lt;&#x3D;10,000)，表示城镇 a 和城镇 b 连通。输入包含多组数据，每组数据以 0 0 结束。</p><p>整个文件以 -1 -1 结尾</p><h3 id="★数据输出"><a href="#★数据输出" class="headerlink" title="★数据输出"></a>★数据输出</h3><p>如果方案合法，输出”Yes”,否则输出”No”。</p><h3 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h3><pre><code>6 8 5 3 5 2 6 4 5 6 0 08 1 7 3 6 2 8 9 7 5 7 4 7 8 7 6 0 03 8 6 8 6 4 5 3 5 6 5 2 0 01 2 3 4 0 0-1 -1</code></pre><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><pre><code>YesYesNoNo</code></pre><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;vector&lt;int&gt; parent;int find(int x) &#123;    if (parent[x] != x) &#123;        parent[x] = find(parent[x]);    &#125;    return parent[x];&#125;bool unite(int a, int b) &#123;    int ra = find(a);    int rb = find(b);    if (ra == rb) return false;    parent[ra] = rb;    return true;&#125;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    parent.resize(10001);    while (true) &#123;        for (int i = 1; i &lt;= 10000; i++) &#123;            parent[i] = i;        &#125;        int a, b;        bool valid = true;        set&lt;int&gt; nodes;        while (cin &gt;&gt; a &gt;&gt; b) &#123;            if (a == 0 &amp;&amp; b == 0) break;            if (a == -1 &amp;&amp; b == -1) return 0;            nodes.insert(a);            nodes.insert(b);            if (!unite(a, b)) &#123;                valid = false;            &#125;        &#125;        if (valid &amp;&amp; !nodes.empty()) &#123;            int root = find(*nodes.begin());            for (int node : nodes) &#123;                if (find(node) != root) &#123;                    valid = false;                    break;                &#125;            &#125;        &#125;        cout &lt;&lt; (valid ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &quot;\n&quot;;    &#125;    return 0;&#125;</code></pre><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><ol><li>利用并查集来判断是否有回路和判断最后道路是否能连通。</li><li>首先初始化各个城镇，然后逐个输入连通的城镇，用<code>unite</code>和并两个城镇集合。</li><li>在合并过程中，用<code>find</code>判断两个集合是否为同一集合（根相同），若为同一集合说明城镇道路有回路，用<code>valid</code>记录下不合理，直接输出答案。</li><li>如果合并完各个城镇并且没有回路，那么开始判断各个城镇是否连通，用<code>nodes</code>记录下参与连通的城镇，遍历<code>nodes</code>记录下的城镇，用find找到各个城镇的集合，判断最终是否只有一个集合（即每个城镇连通），用valid记录下结果，最后输出答案</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;并查集的应用&lt;/p&gt;</summary>
    
    
    
    <category term="算法应用" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="并查集" scheme="http://example.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Huffuman树问题</title>
    <link href="http://example.com/2025/11/20/Huffuman%E6%A0%91%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/11/20/Huffuman%E6%A0%91%E9%97%AE%E9%A2%98/</id>
    <published>2025-11-20T14:19:25.000Z</published>
    <updated>2025-11-26T05:12:20.695Z</updated>
    
    <content type="html"><![CDATA[<p>堆的简单应用</p><span id="more"></span><h2 id="Huffuman树问题"><a href="#Huffuman树问题" class="headerlink" title="Huffuman树问题"></a>Huffuman树问题</h2><h3 id="★问题描述"><a href="#★问题描述" class="headerlink" title="★问题描述"></a>★问题描述</h3><p>对于给定的一个数列，求出用该数列构造Huffman树的总费用。</p><p>给出一列数{<em>pi</em>}&#x3D;{<em>p</em>0, <em>p</em>1, …, <em>pn</em>-1}，用这列数构造Huffman树的过程如下：</p><ol><li>找到{<em>pi</em>}中<strong>最小的两个数</strong>，设为<em>pa</em>和<em>pb</em>，将<em>pa</em>和<em>pb</em>从{<em>pi</em>}中<strong>删除</strong>掉，然后<strong>将它们的和加入到{<em>pi</em>}<strong>中。</strong>这个过程的费用记为pa + pb</strong>。</li><li>重复步骤1，<strong>直到{pi}中只剩下一个数</strong>。</li></ol><p>在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。</p><p>例如，对于数列{<em>pi</em>}&#x3D;{5, 3, 8, 2, 9}，Huffman树的构造过程如下：</p><ol><li>找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{<em>pi</em>}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。</li><li>找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{<em>pi</em>}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。</li><li>找到{8, 9, 10}中最小的两个数，分别是8和9，从{<em>pi</em>}中删除它们并将和17加入，得到{10, 17}，费用为17。</li><li>找到{10, 17}中最小的两个数，分别是10和17，从{<em>pi</em>}中删除它们并将和27加入，得到{27}，费用为27。</li><li>现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27&#x3D;59。</li></ol><h3 id="★数据输入"><a href="#★数据输入" class="headerlink" title="★数据输入"></a>★数据输入</h3><p>输入的第一行包含一个正整数<em>n</em>（<em>n</em>&lt;&#x3D;100）。</p><p>接下来是<em>n</em>个正整数，表示<em>p</em>0, <em>p</em>1, …, <em>pn</em>-1，每个数不超过1000。</p><h3 id="★数据输出"><a href="#★数据输出" class="headerlink" title="★数据输出"></a>★数据输出</h3><p>用这些数构造Huffman树的总费用。</p><h3 id="★输入示例"><a href="#★输入示例" class="headerlink" title="★输入示例"></a>★输入示例</h3><pre><code>55 3 8 2 9</code></pre><h3 id="★输出示例"><a href="#★输出示例" class="headerlink" title="★输出示例"></a>★输出示例</h3><pre><code>59</code></pre><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><pre><code class="c++">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    int n;    cin &gt;&gt; n;            priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;            for (int i = 0; i &lt; n; i++) &#123;        int num;        cin &gt;&gt; num;        pq.push(num);    &#125;        int totalCost = 0;            while (pq.size() &gt; 1) &#123;                int first = pq.top(); pq.pop();        int second = pq.top(); pq.pop();        int cost = first + second;        totalCost += cost;                    pq.push(cost);    &#125;        cout &lt;&lt; totalCost &lt;&lt; endl;        return 0;&#125;</code></pre><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><ol><li>利用C++STL中的优先队列建小根堆。</li><li>此时堆顶就是该序列的最小值，连续弹出两次堆顶，用cost记录下first与second的和。</li><li>将cost累加给totalCost。</li><li>直到堆只剩1个值后退出循环，并输出最终的totalCost。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;堆的简单应用&lt;/p&gt;</summary>
    
    
    
    <category term="算法应用" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>森林冰火人</title>
    <link href="http://example.com/2025/11/20/%E6%A3%AE%E6%9E%97%E5%86%B0%E7%81%AB%E4%BA%BA/"/>
    <id>http://example.com/2025/11/20/%E6%A3%AE%E6%9E%97%E5%86%B0%E7%81%AB%E4%BA%BA/</id>
    <published>2025-11-20T14:11:56.000Z</published>
    <updated>2025-11-25T16:22:28.643Z</updated>
    
    <content type="html"><![CDATA[<p>堆的简单应用</p><span id="more"></span><h1 id="算法与数据结构实验题-8-21-森林冰火人"><a href="#算法与数据结构实验题-8-21-森林冰火人" class="headerlink" title="算法与数据结构实验题 8.21 森林冰火人"></a>算法与数据结构实验题 8.21 森林冰火人</h1><h3 id="★实验任务"><a href="#★实验任务" class="headerlink" title="★实验任务"></a>★实验任务</h3><p>火人喜欢堆雪人。</p><p>已知火人在接下来的N天中，每天早上都会堆一个大小为vi的雪人。</p><p>但是火人的温度太高了！每天晚上，所有已存在的雪人的体积都会由于融化而减少ti（若雪人体积不足ti，则雪人体积融化至0）。</p><p>问，每天融化的总体积为多少？</p><h3 id="★数据输入"><a href="#★数据输入" class="headerlink" title="★数据输入"></a>★数据输入</h3><p>输入第一行为正整数N (1&lt;&#x3D;N&lt;&#x3D;10^5)</p><p>第二行为N个正整数vi (1&lt;&#x3D;vi&lt;&#x3D;10^5)，代表每天堆的雪人的体积。</p><p>第三行为N个正整数ti (1&lt;&#x3D;ti&lt;&#x3D;10^5)，表示每天雪人融化的体积。</p><p>对于80%的数据， 1&lt;&#x3D;N&lt;&#x3D;100</p><p>对于100%的数据， 1&lt;&#x3D;N&lt;&#x3D;10^5</p><h3 id="★数据输出"><a href="#★数据输出" class="headerlink" title="★数据输出"></a>★数据输出</h3><p>输出N个整数，代表每天融化的体积。（整数间以空格分隔）</p><h3 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h3><pre><code>310 10 55 7 2</code></pre><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><pre><code>5 12 4</code></pre><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><pre><code class="c++">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    ios_base::sync_with_stdio(false);    cin.tie(NULL);    int n;    cin &gt;&gt; n;    vector&lt;long long&gt; v(n), t(n);    for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i];    for (int i = 0; i &lt; n; i++) cin &gt;&gt; t[i];        priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt;&gt; pq;    long long total_melt = 0;    for (int i = 0; i &lt; n; i++) &#123;                pq.push(v[i] + total_melt);        long long day_melt = 0;        while (!pq.empty() &amp;&amp; pq.top() &lt;= total_melt + t[i]) &#123;            day_melt += pq.top() - total_melt;            pq.pop();        &#125;        day_melt += pq.size() * t[i];        total_melt += t[i];        cout &lt;&lt; day_melt &lt;&lt; (i == n - 1 ? &quot;\n&quot; : &quot; &quot;);    &#125;    return 0;&#125;</code></pre><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a><u>核心思路</u></h2><ol><li>用<code>total_melt</code>记录下已过天数的融化累计量，例如：如何当前为第<code>i</code>天，则<code>total_melt = t[i] + ···   + t[0]</code>。</li><li>建立小根堆，遍历每一天，将每天堆的雪人的体积<code>v[i]</code>与<code>total_melt</code>之和插入小根堆中。</li><li>查看小根堆的堆顶，判断当天是否会融化完，如果会融化完，用<code>day_melt</code>累加上该雪人的剩余体积，并弹出该雪人，以此循环，直到找到下一个不会融化完的雪人为止。</li><li>用<code>dal_melt</code>再累加上不会融化完剩余雪人的数量与当天融化量之积（<code>day_melt += pq.size() * t[i];</code>），更新total_melt，输出当天的融化量。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;堆的简单应用&lt;/p&gt;</summary>
    
    
    
    <category term="算法应用" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="堆" scheme="http://example.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://example.com/2025/11/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://example.com/2025/11/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2025-11-20T14:09:26.000Z</published>
    <updated>2025-11-26T05:11:56.885Z</updated>
    
    <content type="html"><![CDATA[<p>并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。</p><span id="more"></span><h2 id="1-并查集的概念"><a href="#1-并查集的概念" class="headerlink" title="1. 并查集的概念"></a>1. 并查集的概念</h2><p>并查集支持两种核心操作：</p><ul><li><strong>查找（Find）</strong>：确定某个元素属于哪个集合。</li><li><strong>合并（Union）</strong>：将两个集合合并成一个集合。</li></ul><p>并查集的应用场景包括：</p><ul><li>连通分量问题（如判断图中两个节点是否连通）</li><li>Kruskal 算法求最小生成树</li><li>解决等价类问题</li><li>检测图中的环</li></ul><hr><h2 id="2-并查集的实现原理"><a href="#2-并查集的实现原理" class="headerlink" title="2. 并查集的实现原理"></a>2. 并查集的实现原理</h2><p>并查集的实现主要依赖于数组（或哈希表）来表示每个元素的父节点。每个集合都有一个根节点，根节点的父节点是它自己。</p><h3 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h3><p><strong>查找（Find）</strong></p><ul><li>查找元素的根节点。</li><li>如果元素的父节点不是自己，则递归或迭代查找父节点，直到找到根节点。</li></ul><p><strong>合并（Union）</strong></p><ul><li>找到两个元素的根节点。</li><li>如果根节点不同，则将其中一个根节点的父节点指向另一个根节点。</li></ul><hr><h2 id="3-优化策略"><a href="#3-优化策略" class="headerlink" title="3. 优化策略"></a>3. 优化策略</h2><h3 id="路径压缩（Path-Compression）"><a href="#路径压缩（Path-Compression）" class="headerlink" title="路径压缩（Path Compression）"></a>路径压缩（Path Compression）</h3><ul><li>在查找过程中，将路径上的每个节点直接指向根节点，从而缩短后续查找的路径。</li></ul><h3 id="按秩合并（Union-by-Rank）"><a href="#按秩合并（Union-by-Rank）" class="headerlink" title="按秩合并（Union by Rank）"></a>按秩合并（Union by Rank）</h3><ul><li>为每个根节点维护一个秩（rank），表示树的高度。</li><li>合并时，将秩较小的树合并到秩较大的树上，以保持树的平衡。</li></ul><hr><h2 id="4-C-实现"><a href="#4-C-实现" class="headerlink" title="4. C++ 实现"></a>4. C++ 实现</h2><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class DSU &#123;private:    vector&lt;int&gt; parent;  // 存储每个元素的父节点    vector&lt;int&gt; rank;    // 存储每个根节点的秩public:    // 构造函数，初始化并查集    DSU(int n) &#123;        parent.resize(n);        rank.resize(n, 0);        for (int i = 0; i &lt; n; i++) &#123;            parent[i] = i;  // 每个元素的父节点初始化为自身        &#125;    &#125;    // 查找元素 x 的根节点（带路径压缩）    int find(int x) &#123;        if (parent[x] != x) &#123;            parent[x] = find(parent[x]);  // 路径压缩        &#125;        return parent[x];    &#125;    // 合并元素 x 和 y 所在的集合（按秩合并）    void unionSet(int x, int y) &#123;        int rootX = find(x);        int rootY = find(y);        if (rootX == rootY) &#123;            return;  // 已经在同一个集合中        &#125;        // 按秩合并        if (rank[rootX] &lt; rank[rootY]) &#123;            parent[rootX] = rootY;        &#125; else if (rank[rootX] &gt; rank[rootY]) &#123;            parent[rootY] = rootX;        &#125; else &#123;            parent[rootY] = rootX;            rank[rootX]++;  // 秩相等时，合并后秩加 1        &#125;    &#125;    // 判断元素 x 和 y 是否在同一个集合中    bool isSameSet(int x, int y) &#123;        return find(x) == find(y);    &#125;&#125;;// 示例用法int main() &#123;    DSU dsu(5);  // 元素 0, 1, 2, 3, 4    dsu.unionSet(0, 1);    dsu.unionSet(1, 2);    dsu.unionSet(3, 4);    cout &lt;&lt; &quot;0 和 2 是否在同一个集合？&quot; &lt;&lt; (dsu.isSameSet(0, 2) ? &quot;是&quot; : &quot;否&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;2 和 3 是否在同一个集合？&quot; &lt;&lt; (dsu.isSameSet(2, 3) ? &quot;是&quot; : &quot;否&quot;) &lt;&lt; endl;    dsu.unionSet(2, 3);    cout &lt;&lt; &quot;2 和 3 是否在同一个集合？&quot; &lt;&lt; (dsu.isSameSet(2, 3) ? &quot;是&quot; : &quot;否&quot;) &lt;&lt; endl;    return 0;&#125;</code></pre><hr><h2 id="5-时间复杂度"><a href="#5-时间复杂度" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h2><ul><li>带路径压缩和按秩合并的并查集，每次操作的时间复杂度几乎是常数，可近似为 O (α(n))，其中 α 是阿克曼函数的反函数，增长极其缓慢。</li><li>在实际应用中，α(n) 通常小于 5，因此并查集的操作可以看作是 O (1) 的。</li></ul><hr><h2 id="6-常见应用场景"><a href="#6-常见应用场景" class="headerlink" title="6. 常见应用场景"></a>6. 常见应用场景</h2><ol><li><strong>连通分量问题</strong>：<ul><li>判断图中两个节点是否连通。</li><li>计算图中的连通分量数量。</li></ul></li><li><strong>Kruskal 算法</strong>：<ul><li>用于求最小生成树，通过并查集判断边是否会形成环。</li></ul></li><li><strong>等价类划分</strong>：<ul><li>将元素按照等价关系划分成不同的集合。</li></ul></li><li><strong>动态连通性</strong>：<ul><li>在动态变化的图中，实时维护节点的连通性。</li></ul></li></ol><hr><h2 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a>7. 注意事项</h2><ul><li>并查集的元素通常需要是整数，如果是其他类型，可以通过哈希表映射成整数。</li><li>在实现时，要注意数组的大小，确保能够容纳所有元素。</li><li>路径压缩和按秩合并是并查集高效的关键，建议同时使用这两种优化策略。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="并查集" scheme="http://example.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础</title>
    <link href="http://example.com/2025/11/19/vue%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2025/11/19/vue%E5%9F%BA%E7%A1%80/</id>
    <published>2025-11-19T14:46:38.000Z</published>
    <updated>2025-11-25T15:44:39.846Z</updated>
    
    <content type="html"><![CDATA[<p>Vue项目构建</p><span id="more"></span><h1 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h1><h2 id="Vue项目初始化"><a href="#Vue项目初始化" class="headerlink" title="Vue项目初始化"></a>Vue项目初始化</h2><pre><code class="bash">npm init vue@latest</code></pre><pre><code class="bash">cd first_vue_project</code></pre><pre><code class="bash">npm install</code></pre><h2 id="Vue项目目录结构"><a href="#Vue项目目录结构" class="headerlink" title="Vue项目目录结构"></a>Vue项目目录结构</h2><pre><code class="plaintext">vue-project/├── .vscode/                # VS Code 编辑器配置（如代码格式化、插件推荐）│   ├── extensions.json     # 推荐安装的插件│   └── settings.json       # 编辑器个性化配置（如 ESLint 自动修复）├── public/                 # 静态资源目录（不会被构建工具处理，直接复制到输出目录）│   ├── favicon.ico         # 网站图标│   ├── robots.txt          # 搜索引擎爬虫规则│   └── index.html          # 入口 HTML 文件（Vite 中为模板，Vue CLI 中为入口）├── src/                    # 源代码核心目录（所有业务逻辑、组件、资源都在这里）│   ├── api/                # 接口请求模块（统一管理 API 地址和请求逻辑）│   │   ├── index.js        # API 入口（如 axios 实例配置、请求拦截器）│   │   ├── user.js         # 用户相关接口（登录、注册、信息查询）│   │   └── goods.js        # 商品相关接口（列表、详情、下单）│   ├── assets/             # 静态资源（会被构建工具处理，支持模块化引入）│   │   ├── icons/          # 图标资源（如 SVG、Iconfont）│   │   ├── images/         # 图片资源（如 PNG、JPG、WebP，可按模块分类）│   │   ├── styles/         # 全局样式（重置样式、变量、混入、全局组件样式）│   │   │   ├── reset.css    # 浏览器样式重置（如 normalize.css）│   │   │   ├── variables.scss # 样式变量（如颜色、字体、间距）│   │   │   └── global.scss # 全局共享样式（如全局组件样式、公共布局样式）│   │   └── fonts/          # 自定义字体文件│   ├── components/         # 公共组件（全局复用、非业务强相关的组件）│   │   ├── common/         # 基础通用组件（按钮、输入框、弹窗、加载动画等）│   │   │   ├── Button/│   │   │   │   ├── Button.vue│   │   │   │   └── index.js # 组件导出（方便全局注册）│   │   │   └── Dialog/│   │   └── business/       # 业务通用组件（多个页面复用的业务组件，如商品卡片、用户信息卡片）│   │       ├── GoodsCard.vue│   │       └── UserInfo.vue│   ├── composables/        # Vue 3 组合式函数（复用逻辑抽离，替代 Vue 2 的 mixin）│   │   ├── useUser.js      # 用户相关逻辑（登录状态、用户信息管理）│   │   ├── useRequest.js   # 请求相关逻辑（封装 axios 请求、加载状态、错误处理）│   │   └── usePermission.js # 权限控制逻辑（按钮权限、路由权限）│   ├── config/             # 项目配置文件（常量、枚举、环境配置等）│   │   ├── constants.js    # 全局常量（如接口状态码、存储键名）│   │   ├── enums.js        # 枚举类型（如订单状态、用户角色）│   │   └── settings.js     # 项目设置（如页面标题、分页默认条数）│   ├── directives/         # 自定义指令（全局指令，如权限指令、防抖指令）│   │   ├── permission.js   # 权限指令（v-permission，控制元素显示隐藏）│   │   ├── debounce.js     # 防抖指令（v-debounce，防止重复点击）│   │   └── index.js        # 指令注册入口（全局注册所有指令）│   ├── hooks/              # 自定义钩子（非 Vue 专属逻辑，如浏览器相关、第三方库钩子）│   │   ├── useLocalStorage.js # 本地存储钩子（封装 localStorage 操作）│   │   └── useWindowResize.js # 窗口resize钩子（监听窗口大小变化）│   ├── layouts/            # 布局组件（页面公共布局，如顶部导航、侧边栏、底部 footer）│   │   ├── MainLayout.vue  # 主布局（大部分页面使用的布局）│   │   ├── AuthLayout.vue  # 授权布局（登录、注册页面使用的布局）│   │   └── components/     # 布局内部组件（如 Sidebar、Header、Footer）│   ├── router/             # 路由配置（Vue Router）│   │   ├── index.js        # 路由入口（路由规则、路由守卫、路由懒加载配置）│   │   ├── routes.js       # 路由规则（按模块拆分，如首页路由、用户路由）│   │   └── guards.js       # 路由守卫（全局守卫、路由独享守卫、组件内守卫）│   ├── store/              # 状态管理（Pinia 或 Vuex）│   │   ├── index.js        # 状态管理入口（Pinia 创建实例 / Vuex 创建 Store）│   │   ├── modules/        # 模块拆分（按业务模块拆分状态，如用户模块、购物车模块）│   │   │   ├── user.js     # 用户状态（登录状态、用户信息）│   │   │   └── cart.js     # 购物车状态（商品列表、数量）│   ├── styles/             # 全局样式（与 assets/styles 二选一，或按习惯拆分）│   ├── utils/              # 工具函数（通用工具，如日期格式化、字符串处理、校验函数）│   │   ├── date.js         # 日期工具（格式化日期、计算时间差）│   │   ├── string.js       # 字符串工具（防抖、节流、字符串格式化）│   │   ├── validator.js    # 校验工具（手机号校验、邮箱校验、表单校验）│   │   └── index.js        # 工具函数导出入口（统一导出，方便使用）│   ├── views/              # 页面组件（路由对应的页面，按业务模块分类）│   │   ├── Home/           # 首页模块│   │   │   ├── Home.vue    # 首页页面│   │   │   └── components/ # 首页内部组件（仅首页使用，不复用的组件）│   │   ├── User/           # 用户模块│   │   │   ├── Login.vue   # 登录页面│   │   │   ├── Register.vue # 注册页面│   │   │   ├── Profile.vue # 个人中心页面│   │   │   └── components/ # 用户模块内部组件│   │   └── Goods/          # 商品模块│   │       ├── GoodsList.vue # 商品列表页面│   │       ├── GoodsDetail.vue # 商品详情页面│   │       └── components/ # 商品模块内部组件│   ├── App.vue             # 根组件（项目入口组件，通常包含 &lt;router-view&gt;）│   ├── main.js             # 入口文件（初始化 Vue 实例、挂载根组件、导入全局资源）│   └── vite-env.d.ts       # Vite 类型声明文件（TS 项目必备，识别 Vite 特有语法）├── .env.development        # 开发环境环境变量（如接口基础地址、调试开关）├── .env.production         # 生产环境环境变量（如正式接口地址、日志开关）├── .env.test               # 测试环境环境变量├── .eslintrc.js            # ESLint 配置（代码规范检查，如语法错误、格式错误）├── .prettierrc.js          # Prettier 配置（代码格式化，如缩进、引号、分号）├── .gitignore              # Git 忽略文件（如 node_modules、dist、.env.local）├── index.html              # Vite 入口 HTML（Vue CLI 中在 public 目录下）├── package.json            # 项目依赖配置（依赖包、脚本命令如 dev/build/test）├── README.md               # 项目说明文档（安装步骤、启动命令、目录说明、注意事项）├── vite.config.js          # Vite 配置（构建配置、开发服务器、插件配置，如 Vue 插件、CSS 插件）│                           # （Vue CLI 项目为 vue.config.js）└── tsconfig.json           # TypeScript 配置（TS 项目必备，如编译选项、类型声明路径）</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vue项目构建&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="http://example.com/2025/11/19/DOM/"/>
    <id>http://example.com/2025/11/19/DOM/</id>
    <published>2025-11-19T13:11:25.000Z</published>
    <updated>2025-11-26T05:12:38.169Z</updated>
    
    <content type="html"><![CDATA[<p>DOM（Document Object Model，文档对象模型）是浏览器将 HTML&#x2F;XML 文档解析后生成的<strong>树形结构</strong>，JavaScript 通过 DOM API 可以操作文档的结构、样式和内容，是实现页面交互的核心技术。</p><span id="more"></span><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="一、DOM-核心概念"><a href="#一、DOM-核心概念" class="headerlink" title="一、DOM 核心概念"></a>一、DOM 核心概念</h2><h3 id="1-DOM-树结构"><a href="#1-DOM-树结构" class="headerlink" title="1. DOM 树结构"></a>1. DOM 树结构</h3><p>文档被解析为一个树形节点集合，每个节点对应文档中的一个部分，核心节点类型：</p><table><thead><tr><th>节点类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>Document 节点</td><td>整个文档的根节点</td><td><code>document</code> 对象</td></tr><tr><td>Element 节点</td><td>HTML 元素（标签）</td><td><code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;a&gt;</code></td></tr><tr><td>Text 节点</td><td>元素内的文本内容</td><td><code>Hello World</code></td></tr><tr><td>Attribute 节点</td><td>元素的属性</td><td><code>class=&quot;box&quot;</code>、<code>id=&quot;btn&quot;</code></td></tr><tr><td>Comment 节点</td><td>注释内容</td><td><code>&lt;!-- 这是注释 --&gt;</code></td></tr></tbody></table><p><strong>树形关系示例</strong>：</p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;DOM 示例&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;box&quot;&gt;Hello DOM&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>对应的 DOM 树：</p><pre><code class="plaintext">Document└── html (Element)    ├── head (Element)    │   └── title (Element)    │       └── &quot;DOM 示例&quot; (Text)    └── body (Element)        └── div#box (Element)            └── &quot;Hello DOM&quot; (Text)</code></pre><h3 id="2-节点关系术语"><a href="#2-节点关系术语" class="headerlink" title="2. 节点关系术语"></a>2. 节点关系术语</h3><ul><li><strong>父节点（parentNode）</strong>：直接包含当前节点的节点（如 <code>div</code> 的父节点是 <code>body</code>）</li><li><strong>子节点（childNodes）</strong>：当前节点直接包含的节点（如 <code>body</code> 的子节点是 <code>div</code>）</li><li><strong>兄弟节点（sibling）</strong>：同一父节点下的其他节点（如 <code>head</code> 和 <code>body</code> 是兄弟节点）</li><li><strong>后代节点（descendant）</strong>：当前节点包含的所有层级子节点（如 <code>html</code> 的后代包含 <code>head</code>、<code>div</code> 等）</li><li><strong>祖先节点（ancestor）</strong>：包含当前节点的所有层级父节点（如 <code>div</code> 的祖先包含 <code>body</code>、<code>html</code>、<code>document</code>）</li></ul><h2 id="二、DOM-操作核心-API"><a href="#二、DOM-操作核心-API" class="headerlink" title="二、DOM 操作核心 API"></a>二、DOM 操作核心 API</h2><p>JavaScript 通过 <code>document</code> 对象（全局可用）访问 DOM 树，核心操作分为「查找节点」「操作节点」「操作属性」「操作样式」四类。</p><h3 id="1-查找节点（获取-DOM-元素）"><a href="#1-查找节点（获取-DOM-元素）" class="headerlink" title="1. 查找节点（获取 DOM 元素）"></a>1. 查找节点（获取 DOM 元素）</h3><p>最常用的 DOM 元素查找方法，返回元素或元素集合：</p><table><thead><tr><th>方法</th><th>描述</th><th>返回值</th><th>示例</th></tr></thead><tbody><tr><td><code>getElementById(id)</code></td><td>通过 <code>id</code> 属性查找（唯一）</td><td>单个 Element 节点（找不到为 <code>null</code>）</td><td><code>document.getElementById(&quot;box&quot;)</code></td></tr><tr><td><code>getElementsByClassName(class)</code></td><td>通过 <code>class</code> 属性查找（动态集合）</td><td>HTMLCollection（类数组）</td><td><code>document.getElementsByClassName(&quot;btn&quot;)</code></td></tr><tr><td><code>getElementsByTagName(tag)</code></td><td>通过标签名查找（动态集合）</td><td>HTMLCollection（类数组）</td><td><code>document.getElementsByTagName(&quot;div&quot;)</code></td></tr><tr><td><code>querySelector(selector)</code></td><td>通过 CSS 选择器查找（第一个匹配）</td><td>单个 Element 节点（找不到为 <code>null</code>）</td><td><code>document.querySelector(&quot;#box .item&quot;)</code></td></tr><tr><td><code>querySelectorAll(selector)</code></td><td>通过 CSS 选择器查找（所有匹配）</td><td>NodeList（类数组，静态）</td><td><code>document.querySelectorAll(&quot;li&quot;)</code></td></tr><tr><td><code>document.body</code></td><td>直接获取 <code>&lt;body&gt;</code> 元素</td><td>Element 节点</td><td><code>document.body.style.color = &quot;red&quot;</code></td></tr><tr><td><code>document.head</code></td><td>直接获取 <code>&lt;head&gt;</code> 元素</td><td>Element 节点</td><td><code>document.head.appendChild(script)</code></td></tr></tbody></table><p><strong>注意</strong>：</p><ul><li>HTMLCollection 是「动态集合」（文档变化时自动更新），NodeList 是「静态集合」（不自动更新）；</li><li>类数组对象（HTMLCollection&#x2F;NodeList）需转换为数组才能使用 <code>forEach</code>&#x2F;<code>map</code> 等方法：<code>Array.from(collection)</code> 或 <code>[...collection]</code>。</li></ul><h3 id="2-操作节点（增删改查）"><a href="#2-操作节点（增删改查）" class="headerlink" title="2. 操作节点（增删改查）"></a>2. 操作节点（增删改查）</h3><h4 id="（1）创建节点"><a href="#（1）创建节点" class="headerlink" title="（1）创建节点"></a>（1）创建节点</h4><table><thead><tr><th>方法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>createElement(tag)</code></td><td>创建元素节点</td><td><code>const div = document.createElement(&quot;div&quot;)</code></td></tr><tr><td><code>createTextNode(text)</code></td><td>创建文本节点</td><td><code>const text = document.createTextNode(&quot;Hello&quot;)</code></td></tr><tr><td><code>cloneNode(deep)</code></td><td>克隆节点（<code>deep=true</code> 克隆后代）</td><td><code>const clone = div.cloneNode(true)</code></td></tr></tbody></table><h4 id="（2）插入节点"><a href="#（2）插入节点" class="headerlink" title="（2）插入节点"></a>（2）插入节点</h4><table><thead><tr><th>方法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>parent.appendChild(child)</code></td><td>向父节点末尾插入子节点</td><td><code>document.body.appendChild(div)</code></td></tr><tr><td><code>parent.insertBefore(newNode, refNode)</code></td><td>在参考节点 <code>refNode</code> 前插入新节点</td><td><code>box.insertBefore(newDiv, box.firstChild)</code></td></tr><tr><td><code>element.insertAdjacentHTML(position, html)</code></td><td>插入 HTML 字符串（无需创建节点）</td><td><code>div.insertAdjacentHTML(&quot;afterend&quot;, &quot;新段落&quot;)</code></td></tr></tbody></table><p><code>insertAdjacentHTML</code> 的 <code>position</code> 参数：</p><ul><li><code>beforebegin</code>：元素自身之前</li><li><code>afterbegin</code>：元素内部第一个子节点前</li><li><code>beforeend</code>：元素内部最后一个子节点后</li><li><code>afterend</code>：元素自身之后</li></ul><h4 id="（3）删除节点"><a href="#（3）删除节点" class="headerlink" title="（3）删除节点"></a>（3）删除节点</h4><table><thead><tr><th>方法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>parent.removeChild(child)</code></td><td>父节点删除子节点（需先获取父节点）</td><td><code>box.parentNode.removeChild(box)</code></td></tr><tr><td><code>element.remove()</code></td><td>元素自身删除（更简洁）</td><td><code>box.remove()</code>（IE 不支持）</td></tr></tbody></table><h4 id="（4）替换节点"><a href="#（4）替换节点" class="headerlink" title="（4）替换节点"></a>（4）替换节点</h4><table><thead><tr><th>方法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>parent.replaceChild(newNode, oldNode)</code></td><td>用新节点替换旧节点</td><td><code>box.parentNode.replaceChild(newDiv, box)</code></td></tr></tbody></table><h4 id="示例：完整创建-插入-删除流程"><a href="#示例：完整创建-插入-删除流程" class="headerlink" title="示例：完整创建 + 插入 + 删除流程"></a>示例：完整创建 + 插入 + 删除流程</h4><pre><code class="javascript">// 1. 创建元素和文本const div = document.createElement(&quot;div&quot;);div.textContent = &quot;新创建的 div&quot;;div.className = &quot;new-box&quot;;// 2. 插入到 body 末尾document.body.appendChild(div);// 3. 插入到 div 之后（用 insertAdjacentHTML）div.insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;p&gt;插入的段落&lt;/p&gt;&quot;);// 4. 3 秒后删除 divsetTimeout(() =&gt; &#123;  div.remove();&#125;, 3000);</code></pre><h3 id="3-操作元素属性"><a href="#3-操作元素属性" class="headerlink" title="3. 操作元素属性"></a>3. 操作元素属性</h3><p>元素属性分为「HTML 标准属性」（如 <code>id</code>、<code>class</code>、<code>src</code>）和「自定义属性」（如 <code>data-index</code>），操作方法不同。</p><h4 id="（1）标准属性操作"><a href="#（1）标准属性操作" class="headerlink" title="（1）标准属性操作"></a>（1）标准属性操作</h4><table><thead><tr><th>方式</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>点语法（<code>element.属性</code>）</td><td>简洁，适合标准属性（<code>class</code> 需用 <code>className</code>）</td><td><code>div.id = &quot;test&quot;; div.className = &quot;box&quot;; div.src = &quot;img.jpg&quot;</code></td></tr><tr><td><code>setAttribute(name, value)</code></td><td>通用，可设置任意属性（包括自定义）</td><td><code>div.setAttribute(&quot;class&quot;, &quot;box&quot;); div.setAttribute(&quot;data-id&quot;, 1)</code></td></tr><tr><td><code>getAttribute(name)</code></td><td>获取属性值</td><td><code>div.getAttribute(&quot;src&quot;); div.getAttribute(&quot;data-id&quot;)</code></td></tr><tr><td><code>removeAttribute(name)</code></td><td>删除属性</td><td><code>div.removeAttribute(&quot;class&quot;)</code></td></tr></tbody></table><p><strong>注意</strong>：</p><ul><li>点语法无法设置自定义属性（如 <code>div.data-id = 1</code> 无效，需用 <code>setAttribute</code> 或 <code>dataset</code>）；</li><li><code>class</code> 是 JavaScript 关键字，需用 <code>className</code> 或 <code>classList</code> 操作类名。</li></ul><h4 id="（2）类名操作（classList）"><a href="#（2）类名操作（classList）" class="headerlink" title="（2）类名操作（classList）"></a>（2）类名操作（<code>classList</code>）</h4><p><code>classList</code> 是元素类名的集合，提供更便捷的类操作方法（推荐使用）：</p><table><thead><tr><th>方法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>add(class1, class2)</code></td><td>添加一个 &#x2F; 多个类名</td><td><code>div.classList.add(&quot;box&quot;, &quot;active&quot;)</code></td></tr><tr><td><code>remove(class)</code></td><td>删除类名</td><td><code>div.classList.remove(&quot;active&quot;)</code></td></tr><tr><td><code>toggle(class)</code></td><td>切换类名（存在则删除，不存在则添加）</td><td><code>div.classList.toggle(&quot;active&quot;)</code></td></tr><tr><td><code>contains(class)</code></td><td>判断是否包含类名（返回布尔值）</td><td><code>div.classList.contains(&quot;box&quot;)</code></td></tr></tbody></table><h4 id="（3）自定义数据属性（dataset）"><a href="#（3）自定义数据属性（dataset）" class="headerlink" title="（3）自定义数据属性（dataset）"></a>（3）自定义数据属性（<code>dataset</code>）</h4><p>HTML5 支持 <code>data-*</code> 格式的自定义属性，通过 <code>element.dataset</code> 可便捷操作：</p><pre><code class="html">&lt;div id=&quot;user&quot; data-id=&quot;101&quot; data-user-name=&quot;张三&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">const user = document.getElementById(&quot;user&quot;);console.log(user.dataset.id); // &quot;101&quot;（自动转换为驼峰命名）console.log(user.dataset.userName); // &quot;张三&quot;（data-user-name → userName）user.dataset.age = 20; // 添加自定义属性 data-age=&quot;20&quot;delete user.dataset.userName; // 删除属性</code></pre><h3 id="4-操作样式（style-与-getComputedStyle）"><a href="#4-操作样式（style-与-getComputedStyle）" class="headerlink" title="4. 操作样式（style 与 getComputedStyle）"></a>4. 操作样式（<code>style</code> 与 <code>getComputedStyle</code>）</h3><h4 id="（1）内联样式操作（element-style）"><a href="#（1）内联样式操作（element-style）" class="headerlink" title="（1）内联样式操作（element.style）"></a>（1）内联样式操作（<code>element.style</code>）</h4><p>直接操作元素的 <code>style</code> 属性（对应 HTML 中的 <code>style</code> 属性），<strong>仅影响内联样式</strong>：</p><pre><code class="javascript">const div = document.querySelector(&quot;div&quot;);div.style.color = &quot;red&quot;; // 设置字体颜色div.style.fontSize = &quot;16px&quot;; // 注意驼峰命名（CSS 中的 font-size → fontSize）div.style.backgroundColor = &quot;#f0f0f0&quot;; // background-color → backgroundColorconsole.log(div.style.color); // &quot;red&quot;（仅能获取内联样式）</code></pre><h4 id="（2）计算样式（getComputedStyle）"><a href="#（2）计算样式（getComputedStyle）" class="headerlink" title="（2）计算样式（getComputedStyle）"></a>（2）计算样式（<code>getComputedStyle</code>）</h4><p>获取元素最终生效的样式（包括内联、内部、外部样式表），<strong>只读</strong>：</p><pre><code class="javascript">const div = document.querySelector(&quot;div&quot;);const computedStyle = window.getComputedStyle(div);console.log(computedStyle.color); // &quot;rgb(255, 0, 0)&quot;（统一转换为 rgb 格式）console.log(computedStyle.fontSize); // &quot;16px&quot;</code></pre><p><strong>注意</strong>：</p><ul><li><code>getComputedStyle</code> 返回的是实时计算的样式，值为字符串且带单位（如 <code>px</code>、<code>rgb</code>）；</li><li>IE 浏览器使用 <code>element.currentStyle</code> 替代。</li></ul><h2 id="三、DOM-节点遍历"><a href="#三、DOM-节点遍历" class="headerlink" title="三、DOM 节点遍历"></a>三、DOM 节点遍历</h2><p>遍历 DOM 树的常用属性（获取节点关系）：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>parentNode</code></td><td>获取父节点（Element&#x2F;Document）</td></tr><tr><td><code>childNodes</code></td><td>获取所有子节点（包括 Text&#x2F;Comment 节点）</td></tr><tr><td><code>children</code></td><td>获取所有子元素节点（仅 Element 节点，推荐）</td></tr><tr><td><code>firstChild</code></td><td>第一个子节点（可能是 Text&#x2F;Comment）</td></tr><tr><td><code>firstElementChild</code></td><td>第一个子元素节点（推荐）</td></tr><tr><td><code>lastChild</code></td><td>最后一个子节点</td></tr><tr><td><code>lastElementChild</code></td><td>最后一个子元素节点</td></tr><tr><td><code>previousSibling</code></td><td>前一个兄弟节点</td></tr><tr><td><code>previousElementSibling</code></td><td>前一个兄弟元素节点</td></tr><tr><td><code>nextSibling</code></td><td>后一个兄弟节点</td></tr><tr><td><code>nextElementSibling</code></td><td>后一个兄弟元素节点</td></tr></tbody></table><p><strong>示例：遍历子元素节点</strong></p><pre><code class="javascript">const box = document.getElementById(&quot;box&quot;);// 方式 1：用 children（推荐）for (let i = 0; i &lt; box.children.length; i++) &#123;  console.log(box.children[i]); // 仅输出子元素节点&#125;// 方式 2：用 firstElementChild + nextElementSiblinglet current = box.firstElementChild;while (current) &#123;  console.log(current);  current = current.nextElementSibling;&#125;</code></pre><h2 id="四、DOM-事件基础（交互核心）"><a href="#四、DOM-事件基础（交互核心）" class="headerlink" title="四、DOM 事件基础（交互核心）"></a>四、DOM 事件基础（交互核心）</h2><p>DOM 事件是用户操作（如点击、输入）或文档状态变化（如加载完成）触发的行为，通过事件监听实现页面交互。</p><h3 id="1-事件绑定方式"><a href="#1-事件绑定方式" class="headerlink" title="1. 事件绑定方式"></a>1. 事件绑定方式</h3><h4 id="（1）HTML-内联事件（不推荐）"><a href="#（1）HTML-内联事件（不推荐）" class="headerlink" title="（1）HTML 内联事件（不推荐）"></a>（1）HTML 内联事件（不推荐）</h4><pre><code class="html">&lt;button onclick=&quot;handleClick()&quot;&gt;点击&lt;/button&gt;&lt;script&gt;function handleClick() &#123;  alert(&quot;点击了按钮&quot;);&#125;&lt;/script&gt;</code></pre><h4 id="（2）DOM-属性绑定（不推荐，只能绑定一个事件）"><a href="#（2）DOM-属性绑定（不推荐，只能绑定一个事件）" class="headerlink" title="（2）DOM 属性绑定（不推荐，只能绑定一个事件）"></a>（2）DOM 属性绑定（不推荐，只能绑定一个事件）</h4><pre><code class="javascript">const btn = document.querySelector(&quot;button&quot;);btn.onclick = function() &#123;  alert(&quot;点击了按钮&quot;);&#125;;// 覆盖之前的事件btn.onclick = function() &#123;  alert(&quot;新的点击事件&quot;);&#125;;</code></pre><h4 id="（3）addEventListener（推荐，可绑定多个事件）"><a href="#（3）addEventListener（推荐，可绑定多个事件）" class="headerlink" title="（3）addEventListener（推荐，可绑定多个事件）"></a>（3）<code>addEventListener</code>（推荐，可绑定多个事件）</h4><pre><code class="javascript">const btn = document.querySelector(&quot;button&quot;);// 绑定点击事件btn.addEventListener(&quot;click&quot;, function() &#123;  alert(&quot;点击事件1&quot;);&#125;);// 绑定第二个点击事件btn.addEventListener(&quot;click&quot;, function() &#123;  alert(&quot;点击事件2&quot;);&#125;);// 移除事件（需用命名函数）function handleClick() &#123;  alert(&quot;可移除的事件&quot;);&#125;btn.addEventListener(&quot;click&quot;, handleClick);btn.removeEventListener(&quot;click&quot;, handleClick);</code></pre><h3 id="2-常用-DOM-事件"><a href="#2-常用-DOM-事件" class="headerlink" title="2. 常用 DOM 事件"></a>2. 常用 DOM 事件</h3><table><thead><tr><th>事件类型</th><th>描述</th></tr></thead><tbody><tr><td><code>click</code></td><td>鼠标点击元素</td></tr><tr><td><code>dblclick</code></td><td>鼠标双击元素</td></tr><tr><td><code>mouseover</code></td><td>鼠标移入元素</td></tr><tr><td><code>mouseout</code></td><td>鼠标移出元素</td></tr><tr><td><code>input</code></td><td>输入框内容变化（实时）</td></tr><tr><td><code>change</code></td><td>输入框内容确认变化（如失焦）</td></tr><tr><td><code>submit</code></td><td>表单提交</td></tr><tr><td><code>load</code></td><td>页面 &#x2F; 资源加载完成</td></tr><tr><td><code>DOMContentLoaded</code></td><td>DOM 解析完成（无需等待图片等资源）</td></tr><tr><td><code>resize</code></td><td>窗口大小改变</td></tr></tbody></table><h3 id="3-事件对象（event）"><a href="#3-事件对象（event）" class="headerlink" title="3. 事件对象（event）"></a>3. 事件对象（<code>event</code>）</h3><p>事件触发时，浏览器会传递一个 <code>event</code> 对象，包含事件相关信息（如触发元素、鼠标位置）：</p><pre><code class="javascript">btn.addEventListener(&quot;click&quot;, function(e) &#123;  console.log(e.target); // 触发事件的元素（按钮）  console.log(e.clientX, e.clientY); // 鼠标相对于视口的位置  e.preventDefault(); // 阻止默认行为（如表单提交、链接跳转）  e.stopPropagation(); // 阻止事件冒泡（后续讲）&#125;);</code></pre><h3 id="4-事件流（冒泡与捕获）"><a href="#4-事件流（冒泡与捕获）" class="headerlink" title="4. 事件流（冒泡与捕获）"></a>4. 事件流（冒泡与捕获）</h3><p>DOM 事件流分为三个阶段（IE 仅支持冒泡）：</p><ol><li><strong>捕获阶段</strong>：事件从 <code>document</code> 向下传播到目标元素；</li><li><strong>目标阶段</strong>：事件到达目标元素；</li><li><strong>冒泡阶段</strong>：事件从目标元素向上传播到 <code>document</code>。</li></ol><pre><code class="javascript">// 冒泡示例（点击子元素，父元素事件也会触发）const parent = document.getElementById(&quot;parent&quot;);const child = document.getElementById(&quot;child&quot;);parent.addEventListener(&quot;click&quot;, () =&gt; alert(&quot;父元素点击&quot;));child.addEventListener(&quot;click&quot;, () =&gt; alert(&quot;子元素点击&quot;));// 点击 child，先触发 &quot;子元素点击&quot;，再触发 &quot;父元素点击&quot;（冒泡）</code></pre><p>用 <code>addEventListener</code> 第三个参数控制捕获 &#x2F; 冒泡：</p><pre><code class="javascript">// 第三个参数为 true：捕获阶段触发parent.addEventListener(&quot;click&quot;, () =&gt; alert(&quot;父元素捕获&quot;), true);child.addEventListener(&quot;click&quot;, () =&gt; alert(&quot;子元素冒泡&quot;), false);// 点击 child，先触发 &quot;父元素捕获&quot;，再触发 &quot;子元素冒泡&quot;</code></pre><h2 id="五、DOM-性能优化"><a href="#五、DOM-性能优化" class="headerlink" title="五、DOM 性能优化"></a>五、DOM 性能优化</h2><p>频繁操作 DOM 会导致浏览器频繁重排（Reflow）和重绘（Repaint），影响页面性能，优化方案：</p><h3 id="1-批量操作-DOM"><a href="#1-批量操作-DOM" class="headerlink" title="1. 批量操作 DOM"></a>1. 批量操作 DOM</h3><p>用文档片段（<code>DocumentFragment</code>）临时存储节点，最后一次性插入：</p><pre><code class="javascript">const fragment = document.createDocumentFragment();for (let i = 0; i &lt; 1000; i++) &#123;  const li = document.createElement(&quot;li&quot;);  li.textContent = `列表项 $&#123;i&#125;`;  fragment.appendChild(li); // 不触发重排&#125;document.querySelector(&quot;ul&quot;).appendChild(fragment); // 仅触发一次重排</code></pre><h3 id="2-避免频繁查询-DOM"><a href="#2-避免频繁查询-DOM" class="headerlink" title="2. 避免频繁查询 DOM"></a>2. 避免频繁查询 DOM</h3><p>将查询结果缓存到变量中，避免重复查找：</p><pre><code class="javascript">// 不好的写法（重复查询）for (let i = 0; i &lt; 100; i++) &#123;  document.getElementById(&quot;box&quot;).style.left = `$&#123;i&#125;px`;&#125;// 好的写法（缓存变量）const box = document.getElementById(&quot;box&quot;);for (let i = 0; i &lt; 100; i++) &#123;  box.style.left = `$&#123;i&#125;px`;&#125;</code></pre><h3 id="3-减少重排重绘"><a href="#3-减少重排重绘" class="headerlink" title="3. 减少重排重绘"></a>3. 减少重排重绘</h3><p>避免频繁修改<code>style</code>属性，改用<code>classList</code>或<code>cssText</code>：</p><pre><code class="javascript">// 不好的写法（多次重排）div.style.width = &quot;100px&quot;;div.style.height = &quot;200px&quot;;div.style.margin = &quot;10px&quot;;// 好的写法（一次重排）div.classList.add(&quot;box-style&quot;); // 提前定义 .box-style &#123; width: 100px; ... &#125;// 或div.style.cssText = &quot;width: 100px; height: 200px; margin: 10px;&quot;;</code></pre><p>隐藏元素后操作（隐藏元素不触发重排）：</p><pre><code class="javascript">div.style.display = &quot;none&quot;;// 批量修改样式/结构div.style.width = &quot;100px&quot;;div.appendChild(child);div.style.display = &quot;block&quot;; // 仅触发一次重排</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;DOM（Document Object Model，文档对象模型）是浏览器将 HTML&amp;#x2F;XML 文档解析后生成的&lt;strong&gt;树形结构&lt;/strong&gt;，JavaScript 通过 DOM API 可以操作文档的结构、样式和内容，是实现页面交互的核心技术。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="html" scheme="http://example.com/tags/html/"/>
    
    <category term="javaScript" scheme="http://example.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS媒体查询</title>
    <link href="http://example.com/2025/11/19/CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2025/11/19/CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</id>
    <published>2025-11-19T13:10:42.000Z</published>
    <updated>2025-11-26T05:12:52.204Z</updated>
    
    <content type="html"><![CDATA[<p>媒体查询（Media Query）是 CSS3 核心特性之一，用于根据设备特性（屏幕尺寸、分辨率、方向等）或环境条件（打印、暗模式）为网页应用不同的样式规则，是实现<strong>响应式网页设计（RWD）</strong> 的核心技术。它允许开发者打破 “固定布局” 的局限，让页面在手机、平板、电脑等不同设备上自适应展示。</p><span id="more"></span><h1 id="前端开发-媒体查询"><a href="#前端开发-媒体查询" class="headerlink" title="前端开发 - 媒体查询"></a>前端开发 - 媒体查询</h1><h2 id="一、核心概念与基本语法"><a href="#一、核心概念与基本语法" class="headerlink" title="一、核心概念与基本语法"></a>一、核心概念与基本语法</h2><h3 id="1-核心作用"><a href="#1-核心作用" class="headerlink" title="1. 核心作用"></a>1. 核心作用</h3><p>判断当前浏览环境的 “媒体类型” 和 “媒体特性”，匹配成功则加载对应 CSS 样式。</p><h3 id="2-完整语法结构"><a href="#2-完整语法结构" class="headerlink" title="2. 完整语法结构"></a>2. 完整语法结构</h3><pre><code class="css">/* @media 关键字 + 媒体条件 + &#123; 样式规则 &#125; */@media [媒体类型] [逻辑运算符] ([媒体特性]) &#123;  /* 仅当条件匹配时生效的 CSS */  选择器 &#123;    属性: 值;  &#125;&#125;</code></pre><h4 id="各部分说明："><a href="#各部分说明：" class="headerlink" title="各部分说明："></a>各部分说明：</h4><table><thead><tr><th>组成部分</th><th>作用</th><th>可选值 &#x2F; 示例</th></tr></thead><tbody><tr><td><code>@media</code></td><td>声明媒体查询的关键字（必需）</td><td>-</td></tr><tr><td>媒体类型（可选）</td><td>指定目标设备类型（默认值 <code>all</code>，匹配所有设备）</td><td><code>all</code>（所有）、<code>screen</code>（屏幕设备）、<code>print</code>（打印预览）、<code>speech</code>（屏幕阅读器）</td></tr><tr><td>逻辑运算符（可选）</td><td>组合多个媒体条件（支持 <code>and</code>、<code>or</code>、<code>not</code>、<code>only</code>）</td><td><code>and</code>（同时满足）、<code>or</code>（满足其一）、<code>not</code>（排除条件）、<code>only</code>（兼容旧浏览器）</td></tr><tr><td>媒体特性（必需）</td><td>设备 &#x2F; 环境的具体属性（需用括号包裹，可带前缀 <code>min-</code>&#x2F;<code>max-</code> 表示范围）</td><td><code>width</code>（屏幕宽度）、<code>height</code>（屏幕高度）、<code>orientation</code>（方向）等</td></tr></tbody></table><h2 id="二、媒体类型（Media-Type）"><a href="#二、媒体类型（Media-Type）" class="headerlink" title="二、媒体类型（Media Type）"></a>二、媒体类型（Media Type）</h2><p>指定样式适用的设备类别，现代开发中常用 <code>screen</code>（屏幕设备）和默认的 <code>all</code>，其他类型使用场景较少：</p><table><thead><tr><th>媒体类型</th><th>适用场景</th><th>备注</th></tr></thead><tbody><tr><td><code>all</code></td><td>所有设备（默认值，可省略）</td><td>最常用，覆盖绝大多数场景</td></tr><tr><td><code>screen</code></td><td>彩色屏幕设备（手机、电脑、平板等）</td><td>响应式布局核心目标</td></tr><tr><td><code>print</code></td><td>打印预览或打印机输出</td><td>用于优化打印样式（如隐藏导航）</td></tr><tr><td><code>speech</code></td><td>屏幕阅读器等语音合成设备</td><td>无障碍开发常用</td></tr><tr><td><code>tv</code></td><td>电视设备（低分辨率、滚动受限）</td><td>极少使用</td></tr><tr><td><code>handheld</code></td><td>手持设备（早期功能机，现代已被 <code>screen</code> 替代）</td><td>不推荐使用</td></tr></tbody></table><p><strong>示例</strong>：仅在打印时隐藏导航栏</p><pre><code class="css">/* 打印预览时隐藏导航 */@media print &#123;  .navbar &#123;    display: none;  &#125;  /* 打印时文字变黑、背景变白（节省油墨） */  body &#123;    color: #000;    background: #fff;  &#125;&#125;</code></pre><h2 id="三、媒体特性（Media-Features）"><a href="#三、媒体特性（Media-Features）" class="headerlink" title="三、媒体特性（Media Features）"></a>三、媒体特性（Media Features）</h2><p>媒体查询的核心，用于描述设备 &#x2F; 环境的具体属性，支持 “精确匹配” 和 “范围匹配”（通过 <code>min-</code>&#x2F;<code>max-</code> 前缀）。</p><h3 id="1-常用核心特性（重点掌握）"><a href="#1-常用核心特性（重点掌握）" class="headerlink" title="1. 常用核心特性（重点掌握）"></a>1. 常用核心特性（重点掌握）</h3><h4 id="（1）屏幕尺寸相关（最常用）"><a href="#（1）屏幕尺寸相关（最常用）" class="headerlink" title="（1）屏幕尺寸相关（最常用）"></a>（1）屏幕尺寸相关（最常用）</h4><table><thead><tr><th>特性名</th><th>说明</th><th>单位</th><th>示例</th></tr></thead><tbody><tr><td><code>width</code></td><td>视口（viewport）宽度</td><td><code>px</code>&#x2F;<code>em</code></td><td><code>(width: 375px)</code>（精确 375px）</td></tr><tr><td><code>min-width</code></td><td>视口宽度 <strong>大于等于</strong> 指定值（移动端优先）</td><td><code>px</code>&#x2F;<code>em</code></td><td><code>(min-width: 768px)</code>（≥768px 生效）</td></tr><tr><td><code>max-width</code></td><td>视口宽度 <strong>小于等于</strong> 指定值（桌面端优先）</td><td><code>px</code>&#x2F;<code>em</code></td><td><code>(max-width: 1024px)</code>（≤1024px 生效）</td></tr><tr><td><code>height</code>&#x2F;<code>min-height</code>&#x2F;<code>max-height</code></td><td>视口高度（用法同宽度，较少用）</td><td><code>px</code>&#x2F;<code>em</code></td><td><code>(min-height: 600px)</code>（视口高度≥600px）</td></tr></tbody></table><blockquote><p>🔴 注意：<code>width</code> 指<strong>视口（viewport）宽度</strong>，而非设备物理宽度。需在 HTML 头部添加 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&gt;&quot;</code> 确保视口正确适配（否则移动端会以 “桌面宽度” 渲染）。</p></blockquote><h4 id="（2）屏幕方向"><a href="#（2）屏幕方向" class="headerlink" title="（2）屏幕方向"></a>（2）屏幕方向</h4><table><thead><tr><th>特性名</th><th>说明</th><th>取值</th><th>示例</th></tr></thead><tbody><tr><td><code>orientation</code></td><td>设备屏幕方向</td><td><code>portrait</code>（竖屏）、<code>landscape</code>（横屏）</td><td><code>(orientation: landscape)</code>（横屏生效）</td></tr></tbody></table><h4 id="（3）分辨率-像素密度"><a href="#（3）分辨率-像素密度" class="headerlink" title="（3）分辨率 &#x2F; 像素密度"></a>（3）分辨率 &#x2F; 像素密度</h4><table><thead><tr><th>特性名</th><th>说明</th><th>单位</th><th>示例</th></tr></thead><tbody><tr><td><code>resolution</code></td><td>屏幕分辨率（像素 &#x2F; 英寸）</td><td><code>dpi</code>&#x2F;<code>dpcm</code></td><td><code>(resolution: 300dpi)</code>（高清屏）</td></tr><tr><td><code>min-resolution</code></td><td>分辨率≥指定值（如 Retina 屏适配）</td><td><code>dpi</code>&#x2F;<code>dpcm</code></td><td><code>(min-resolution: 2dppx)</code>（2 倍屏）</td></tr></tbody></table><h4 id="（4）其他实用特性"><a href="#（4）其他实用特性" class="headerlink" title="（4）其他实用特性"></a>（4）其他实用特性</h4><table><thead><tr><th>特性名</th><th>说明</th><th>取值 &#x2F; 示例</th><th></th></tr></thead><tbody><tr><td><code>prefers-color-scheme</code></td><td>系统配色方案（暗 &#x2F; 亮模式）</td><td><code>light</code>（亮模式）、<code>dark</code>（暗模式）</td><td><code>(prefers-color-scheme: dark)</code></td></tr><tr><td><code>hover</code></td><td>设备是否支持鼠标悬停</td><td><code>none</code>（不支持）、<code>hover</code>（支持）</td><td><code>(hover: hover)</code>（PC 端生效）</td></tr><tr><td><code>pointer</code></td><td>主要输入设备类型</td><td><code>none</code>&#x2F;<code>coarse</code>（触屏）&#x2F;<code>fine</code>（鼠标）</td><td><code>(pointer: coarse)</code>（触屏设备）</td></tr></tbody></table><h3 id="2-范围匹配技巧"><a href="#2-范围匹配技巧" class="headerlink" title="2. 范围匹配技巧"></a>2. 范围匹配技巧</h3><ul><li>**<code>min-xxx</code>**：“大于等于”，适合「移动端优先」开发（先写移动端样式，再逐步适配大屏）。</li><li>**<code>max-xxx</code>**：“小于等于”，适合「桌面端优先」开发（先写桌面样式，再适配小屏）。</li><li>避免同时使用 <code>min-xxx</code> 和 <code>max-xxx</code> 对同一特性过度限制（如 <code>(min-width: 375px) and (max-width: 768px)</code> 是合理的 “平板区间”）。</li></ul><h2 id="四、逻辑运算符（组合条件）"><a href="#四、逻辑运算符（组合条件）" class="headerlink" title="四、逻辑运算符（组合条件）"></a>四、逻辑运算符（组合条件）</h2><p>当需要多个条件同时满足或选择满足其一，使用逻辑运算符组合媒体条件：</p><h3 id="1-and：同时满足所有条件"><a href="#1-and：同时满足所有条件" class="headerlink" title="1. and：同时满足所有条件"></a>1. <code>and</code>：同时满足所有条件</h3><p>最常用，用于组合 “媒体类型” 和 “媒体特性”，或多个 “媒体特性”。</p><pre><code class="css">/* 屏幕设备 + 视口宽度≥768px + 竖屏 → 生效 */@media screen and (min-width: 768px) and (orientation: portrait) &#123;  .container &#123;    width: 90%;    margin: 0 auto;  &#125;&#125;</code></pre><h3 id="2-or（逗号-简写）：满足任一条件"><a href="#2-or（逗号-简写）：满足任一条件" class="headerlink" title="2. or（逗号 , 简写）：满足任一条件"></a>2. <code>or</code>（逗号 <code>,</code> 简写）：满足任一条件</h3><p>逗号分隔多个条件，只要有一个匹配就生效（注意：<code>or</code> 是 CSS4 语法，部分旧浏览器不支持，推荐用逗号简写）。</p><pre><code class="css">/* 视口宽度≤375px 或 横屏模式 → 生效（逗号等价于 or） */@media (max-width: 375px), (orientation: landscape) &#123;  .btn &#123;    padding: 8px 16px;    font-size: 14px;  &#125;&#125;</code></pre><h3 id="3-not：排除匹配条件"><a href="#3-not：排除匹配条件" class="headerlink" title="3. not：排除匹配条件"></a>3. <code>not</code>：排除匹配条件</h3><p>否定整个媒体条件（仅对 “完整条件” 生效，不支持部分否定）。</p><pre><code class="css">/* 除了打印设备外，所有设备都生效 */@media not print &#123;  .header &#123;    box-shadow: 0 2px 4px rgba(0,0,0,0.1);  &#125;&#125;/* 错误用法：not 不能只否定单个特性 *//* @media (not min-width: 768px) &#123; ... &#125; → 无效 */</code></pre><h3 id="4-only：兼容旧浏览器"><a href="#4-only：兼容旧浏览器" class="headerlink" title="4. only：兼容旧浏览器"></a>4. <code>only</code>：兼容旧浏览器</h3><p>用于阻止旧浏览器（如 IE8 及以下）解析不支持的媒体查询（旧浏览器会忽略 <code>only</code> 后的条件，避免加载错误样式）。现代浏览器可省略，但建议保留兼容性。</p><pre><code class="css">/* 仅现代浏览器会解析，旧浏览器忽略 */@media only screen and (min-width: 768px) &#123;  .card &#123;    display: flex;  &#125;&#125;</code></pre><h2 id="五、媒体查询的使用方式"><a href="#五、媒体查询的使用方式" class="headerlink" title="五、媒体查询的使用方式"></a>五、媒体查询的使用方式</h2><h3 id="1-内部样式表（推荐，便于维护）"><a href="#1-内部样式表（推荐，便于维护）" class="headerlink" title="1. 内部样式表（推荐，便于维护）"></a>1. 内部样式表（推荐，便于维护）</h3><p>在 <code>&lt;style&gt;</code> 标签内直接写媒体查询，适合中小型项目。</p><pre><code class="html">&lt;head&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;style&gt;    /* 基础样式（所有设备默认生效） */    .container &#123;      padding: 16px;    &#125;    /* 平板适配（≥768px） */    @media (min-width: 768px) &#123;      .container &#123;        padding: 24px;        max-width: 900px;        margin: 0 auto;      &#125;    &#125;    /* 桌面端适配（≥1200px） */    @media (min-width: 1200px) &#123;      .container &#123;        max-width: 1140px;        padding: 32px;      &#125;    &#125;  &lt;/style&gt;&lt;/head&gt;</code></pre><h3 id="2-外部样式表（link-标签媒体属性）"><a href="#2-外部样式表（link-标签媒体属性）" class="headerlink" title="2. 外部样式表（link 标签媒体属性）"></a>2. 外部样式表（link 标签媒体属性）</h3><p>通过 <code>&lt;link&gt;</code> 标签的 <code>media</code> 属性指定样式表的适用条件，适合大型项目拆分样式文件（仅匹配时才加载该 CSS 文件，优化性能）。</p><pre><code class="html">&lt;!-- 基础样式（所有设备加载） --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;base.css&quot;&gt;&lt;!-- 平板样式（≥768px 才加载） --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;tablet.css&quot; media=&quot;(min-width: 768px)&quot;&gt;&lt;!-- 桌面端样式（≥1200px 才加载） --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;desktop.css&quot; media=&quot;(min-width: 1200px)&quot;&gt;</code></pre><h3 id="3-内联样式（不推荐）"><a href="#3-内联样式（不推荐）" class="headerlink" title="3. 内联样式（不推荐）"></a>3. 内联样式（不推荐）</h3><p>内联样式无法直接使用媒体查询（<code>style</code> 属性中不能写 <code>@media</code>），需通过 JavaScript 辅助，仅特殊场景使用。</p><h2 id="六、响应式布局实战：断点设计"><a href="#六、响应式布局实战：断点设计" class="headerlink" title="六、响应式布局实战：断点设计"></a>六、响应式布局实战：断点设计</h2><p>“断点（Breakpoint）” 是指触发样式变化的临界屏幕宽度，需根据主流设备尺寸合理设计。以下是行业通用的断点方案（移动端优先）：</p><table><thead><tr><th>设备类型</th><th>断点范围（min-width）</th><th>常见宽度</th></tr></thead><tbody><tr><td>移动端（手机）</td><td>0 - 767px</td><td>320px、375px、414px</td></tr><tr><td>平板（竖屏）</td><td>768px</td><td>768px</td></tr><tr><td>平板（横屏）&#x2F; 小桌面</td><td>992px</td><td>992px</td></tr><tr><td>桌面端（大屏）</td><td>1200px</td><td>1200px、1440px</td></tr></tbody></table><h3 id="实战示例：自适应导航栏"><a href="#实战示例：自适应导航栏" class="headerlink" title="实战示例：自适应导航栏"></a>实战示例：自适应导航栏</h3><pre><code class="css">/* 基础样式（移动端）：垂直导航 */.navbar &#123;  background: #333;  color: #fff;&#125;.navbar-list &#123;  list-style: none;  padding: 0;  margin: 0;&#125;.navbar-item &#123;  padding: 12px 16px;  border-bottom: 1px solid #444;&#125;/* 平板适配（≥768px）：水平导航 */@media (min-width: 768px) &#123;  .navbar-list &#123;    display: flex;    justify-content: space-around;  &#125;  .navbar-item &#123;    border-bottom: none;  &#125;&#125;/* 桌面端适配（≥1200px）：增加间距和 hover 效果 */@media (min-width: 1200px) &#123;  .navbar-list &#123;    width: 1140px;    margin: 0 auto;  &#125;  .navbar-item:hover &#123;    background: #555;    cursor: pointer;  &#125;&#125;</code></pre><h2 id="七、常见问题与最佳实践"><a href="#七、常见问题与最佳实践" class="headerlink" title="七、常见问题与最佳实践"></a>七、常见问题与最佳实践</h2><h3 id="1-必加-Viewport-元标签"><a href="#1-必加-Viewport-元标签" class="headerlink" title="1. 必加 Viewport 元标签"></a>1. 必加 Viewport 元标签</h3><p>移动端必须在 HTML 头部添加以下标签，否则视口宽度会默认以 “桌面端宽度”（如 980px）渲染，媒体查询失效：</p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;!-- 可选配置：禁止缩放（适合 App 类页面） --&gt;&lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt; --&gt;</code></pre><h3 id="2-避免-“像素陷阱”"><a href="#2-避免-“像素陷阱”" class="headerlink" title="2. 避免 “像素陷阱”"></a>2. 避免 “像素陷阱”</h3><ul><li>使用 <code>min-width</code>&#x2F;<code>max-width</code> 而非固定 <code>width</code>，确保样式在不同尺寸间平滑过渡。</li><li>优先使用相对单位（<code>%</code>、<code>em</code>、<code>rem</code>、<code>vw/vh</code>），避免固定像素（<code>px</code>）导致布局僵硬。</li></ul><h3 id="3-断点设计原则"><a href="#3-断点设计原则" class="headerlink" title="3. 断点设计原则"></a>3. 断点设计原则</h3><ul><li>基于 “内容适配” 而非 “设备尺寸”：当内容显示异常（如文字溢出、间距拥挤）时，再设置断点，而非盲目适配所有设备型号。</li><li>断点数量不宜过多（3-4 个即可），过多断点会增加维护成本。</li></ul><h3 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. 性能优化</h3><ul><li>避免嵌套过深的媒体查询（影响 CSS 解析速度）。</li><li>大型项目使用外部样式表拆分媒体查询（仅加载当前设备所需样式）。</li><li>避免在媒体查询中重复编写相同样式（提取公共样式到基础样式中）。</li></ul><h3 id="5-兼容旧浏览器"><a href="#5-兼容旧浏览器" class="headerlink" title="5. 兼容旧浏览器"></a>5. 兼容旧浏览器</h3><ul><li>IE8 及以下不支持媒体查询，可通过 <code>respond.js</code> 插件兼容（仅支持 <code>min-width</code>&#x2F;<code>max-width</code>）。</li><li>使用 <code>only</code> 关键字屏蔽旧浏览器对不支持媒体条件的解析。</li></ul><h2 id="八、扩展：结合-JavaScript-使用媒体查询"><a href="#八、扩展：结合-JavaScript-使用媒体查询" class="headerlink" title="八、扩展：结合 JavaScript 使用媒体查询"></a>八、扩展：结合 JavaScript 使用媒体查询</h2><p>除了 CSS，还可通过 JavaScript 监听媒体查询的匹配状态，实现更灵活的交互逻辑（如动态加载组件、修改 DOM）。</p><h3 id="示例：监听屏幕尺寸变化"><a href="#示例：监听屏幕尺寸变化" class="headerlink" title="示例：监听屏幕尺寸变化"></a>示例：监听屏幕尺寸变化</h3><pre><code class="javascript">// 1. 定义媒体查询条件const mediaQuery = window.matchMedia(&#39;(min-width: 768px)&#39;);// 2. 定义匹配状态变化时的回调函数function handleScreenChange(e) &#123;  if (e.matches) &#123;    // 满足条件（≥768px）：显示桌面端组件    console.log(&#39;当前是平板/桌面端&#39;);    document.querySelector(&#39;.desktop-component&#39;).style.display = &#39;block&#39;;  &#125; else &#123;    // 不满足条件（&lt;768px）：隐藏桌面端组件    console.log(&#39;当前是移动端&#39;);    document.querySelector(&#39;.desktop-component&#39;).style.display = &#39;none&#39;;  &#125;&#125;// 3. 初始执行一次（页面加载时）handleScreenChange(mediaQuery);// 4. 监听媒体查询状态变化（屏幕缩放/旋转时触发）mediaQuery.addEventListener(&#39;change&#39;, handleScreenChange);</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;媒体查询（Media Query）是 CSS3 核心特性之一，用于根据设备特性（屏幕尺寸、分辨率、方向等）或环境条件（打印、暗模式）为网页应用不同的样式规则，是实现&lt;strong&gt;响应式网页设计（RWD）&lt;/strong&gt; 的核心技术。它允许开发者打破 “固定布局” 的局限，让页面在手机、平板、电脑等不同设备上自适应展示。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>左式堆</title>
    <link href="http://example.com/2025/11/15/%E5%B7%A6%E5%BC%8F%E5%A0%86/"/>
    <id>http://example.com/2025/11/15/%E5%B7%A6%E5%BC%8F%E5%A0%86/</id>
    <published>2025-11-15T05:59:40.000Z</published>
    <updated>2025-11-26T05:13:01.609Z</updated>
    
    <content type="html"><![CDATA[<p>左式堆是一种<strong>可合并堆（Mergeable Heap）</strong>，核心优势是支持高效的「合并操作」（时间复杂度 O (logN)），同时保留堆的「极值优先」特性（大根堆 &#x2F; 小根堆）。它通过引入「零路径长度（NPL）」约束左子树的深度，确保合并时仅需沿 “左偏路径” 遍历，避免退化。</p><span id="more"></span><h1 id="左式堆详解"><a href="#左式堆详解" class="headerlink" title="左式堆详解"></a>左式堆详解</h1><p>左式堆（Leftist Heap）是一种<strong>可合并堆（Mergeable Heap）</strong>，核心优势是支持高效的合并操作（时间复杂度 O (log n)），同时保持堆的性质（大根堆 &#x2F; 小根堆）。它通过 “左偏性”（Leftist Property）保证合并效率，广泛应用于需要频繁合并堆的场景（如 K 路归并、任务调度等）。</p><h2 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h2><h3 id="1-左式堆的定义"><a href="#1-左式堆的定义" class="headerlink" title="1. 左式堆的定义"></a>1. 左式堆的定义</h3><p>左式堆是一棵<strong>二叉树</strong>，满足两个条件：</p><ol><li><strong>堆序性</strong>：任意节点的值 ≥ 其子节点的值（大根堆），或 ≤ 其子节点的值（小根堆）（本文以小根堆为例）；</li><li><strong>左偏性</strong>：任意节点的<strong>零路径长度（Null Path Length, NPL）</strong> 满足：左子树的 NPL ≥ 右子树的 NPL。</li></ol><h3 id="2-零路径长度（NPL）"><a href="#2-零路径长度（NPL）" class="headerlink" title="2. 零路径长度（NPL）"></a>2. 零路径长度（NPL）</h3><ul><li>定义：节点到最近的 “空节点” 的路径长度（空节点的 NPL 为 - 1，叶子节点的 NPL 为 0）；</li><li>公式：<code>NPL(node) = 1 + min(NPL(node-&gt;left), NPL(node-&gt;right))</code>；</li><li>作用：左偏性保证了树的 “左重右轻”，合并时只需优先处理右子树，避免最坏情况。</li></ul><h3 id="3-左式堆的特点"><a href="#3-左式堆的特点" class="headerlink" title="3. 左式堆的特点"></a>3. 左式堆的特点</h3><ul><li>不是完全二叉树，无需数组存储，采用链式结构；</li><li>合并是核心操作，插入、删除堆顶等操作均可基于合并实现；</li><li>平均 &#x2F; 最坏时间复杂度：合并、插入、删除堆顶均为 O (log n)。</li></ul><h2 id="二、数据结构设计"><a href="#二、数据结构设计" class="headerlink" title="二、数据结构设计"></a>二、数据结构设计</h2><h3 id="1-节点结构"><a href="#1-节点结构" class="headerlink" title="1. 节点结构"></a>1. 节点结构</h3><p>每个节点需存储：值、左子指针、右子指针、NPL 值。</p><pre><code class="cpp">template &lt;typename T&gt;struct LeftistNode &#123;    T val;                  // 节点值    LeftistNode&lt;T&gt;* left;   // 左子节点指针    LeftistNode&lt;T&gt;* right;  // 右子节点指针    int npl;                // 零路径长度    // 构造函数    LeftistNode(T value) : val(value), left(nullptr), right(nullptr), npl(0) &#123;&#125;&#125;;</code></pre><h3 id="2-左式堆类"><a href="#2-左式堆类" class="headerlink" title="2. 左式堆类"></a>2. 左式堆类</h3><p>封装节点指针、堆操作（合并、插入、删除堆顶、查询堆顶等）：</p><pre><code class="cpp">template &lt;typename T&gt;class LeftistHeap &#123;private:    LeftistNode&lt;T&gt;* root;  // 堆的根节点    // 辅助函数：合并两个左式堆（核心）    LeftistNode&lt;T&gt;* merge(LeftistNode&lt;T&gt;* a, LeftistNode&lt;T&gt;* b);    // 辅助函数：更新节点的NPL值    void updateNPL(LeftistNode&lt;T&gt;* node);    // 辅助函数：释放堆内存（递归）    void destroy(LeftistNode&lt;T&gt;* node);public:    LeftistHeap() : root(nullptr) &#123;&#125;  // 构造空堆    ~LeftistHeap() &#123; destroy(root); &#125; // 析构函数（释放内存）    bool isEmpty() const;       // 判断堆是否为空    T getMin() const;           // 获取堆顶（小根堆的最小值）    void insert(T value);       // 插入元素    void deleteMin();           // 删除堆顶元素    void merge(LeftistHeap&lt;T&gt;&amp; other);  // 合并另一个左式堆&#125;;</code></pre><h2 id="三、核心操作实现"><a href="#三、核心操作实现" class="headerlink" title="三、核心操作实现"></a>三、核心操作实现</h2><h3 id="1-合并操作（最关键）"><a href="#1-合并操作（最关键）" class="headerlink" title="1. 合并操作（最关键）"></a>1. 合并操作（最关键）</h3><p>合并两个左式堆的核心思路：</p><ol><li>递归选择较小根节点的堆，将另一堆合并到其<strong>右子树</strong>（保证堆序性）；</li><li>合并后检查左偏性，若左子树 NPL &lt; 右子树 NPL，则交换左右子树；</li><li>更新当前节点的 NPL 值（基于左右子树的最小 NPL 计算）。</li></ol><h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><pre><code class="cpp">template &lt;typename T&gt;LeftistNode&lt;T&gt;* LeftistHeap&lt;T&gt;::merge(LeftistNode&lt;T&gt;* a, LeftistNode&lt;T&gt;* b) &#123;    // 边界条件：一个堆为空，直接返回另一个堆    if (a == nullptr) return b;    if (b == nullptr) return a;    // 保证a的根节点更小（小根堆），否则交换a和b    if (a-&gt;val &gt; b-&gt;val) &#123;        swap(a, b);    &#125;    // 递归合并a的右子树和b    a-&gt;right = merge(a-&gt;right, b);    // 检查左偏性：若右子树NPL更大，交换左右子树    if (a-&gt;left == nullptr || a-&gt;left-&gt;npl &lt; a-&gt;right-&gt;npl) &#123;        swap(a-&gt;left, a-&gt;right);    &#125;    // 更新当前节点的NPL    updateNPL(a);    return a;&#125;// 更新节点的NPL：1 + min(左子NPL, 右子NPL)template &lt;typename T&gt;void LeftistHeap&lt;T&gt;::updateNPL(LeftistNode&lt;T&gt;* node) &#123;    if (node == nullptr) return;    // 空节点NPL为-1，叶子节点的左右子均为空，NPL=0    if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123;        node-&gt;npl = 0;    &#125; else if (node-&gt;right == nullptr) &#123;        // 右子为空，min为右子的-1，故NPL=0        node-&gt;npl = 0;    &#125; else &#123;        node-&gt;npl = 1 + min(node-&gt;left-&gt;npl, node-&gt;right-&gt;npl);    &#125;&#125;</code></pre><h3 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="2. 插入操作"></a>2. 插入操作</h3><p>插入本质是<strong>合并 “单个节点的堆” 和原堆</strong>，直接复用 merge 函数：</p><pre><code class="cpp">template &lt;typename T&gt;void LeftistHeap&lt;T&gt;::insert(T value) &#123;    LeftistNode&lt;T&gt;* newNode = new LeftistNode&lt;T&gt;(value);    root = merge(root, newNode);  // 合并原堆和新节点堆&#125;</code></pre><h3 id="3-删除堆顶操作"><a href="#3-删除堆顶操作" class="headerlink" title="3. 删除堆顶操作"></a>3. 删除堆顶操作</h3><p>删除堆顶（最小值）的思路：</p><ol><li>堆顶的左右子树构成两个左式堆；</li><li>合并这两个子堆，作为新的堆根；</li><li>释放原堆顶节点的内存。</li></ol><h4 id="实现代码：-1"><a href="#实现代码：-1" class="headerlink" title="实现代码："></a>实现代码：</h4><pre><code class="cpp">template &lt;typename T&gt;void LeftistHeap&lt;T&gt;::deleteMin() &#123;    if (isEmpty()) &#123;        throw runtime_error(&quot;Heap is empty, cannot delete min!&quot;);    &#125;    LeftistNode&lt;T&gt;* oldRoot = root;    // 合并左右子堆，作为新根    root = merge(root-&gt;left, root-&gt;right);    delete oldRoot;  // 释放原堆顶内存&#125;</code></pre><h3 id="4-其他辅助操作"><a href="#4-其他辅助操作" class="headerlink" title="4. 其他辅助操作"></a>4. 其他辅助操作</h3><pre><code class="cpp">// 判断堆是否为空template &lt;typename T&gt;bool LeftistHeap&lt;T&gt;::isEmpty() const &#123;    return root == nullptr;&#125;// 获取堆顶（最小值）template &lt;typename T&gt;T LeftistHeap&lt;T&gt;::getMin() const &#123;    if (isEmpty()) &#123;        throw runtime_error(&quot;Heap is empty, no min value!&quot;);    &#125;    return root-&gt;val;&#125;// 合并另一个左式堆（外部接口）template &lt;typename T&gt;void LeftistHeap&lt;T&gt;::merge(LeftistHeap&lt;T&gt;&amp; other) &#123;    root = merge(this-&gt;root, other.root);    other.root = nullptr;  // 避免对方堆重复释放内存&#125;// 递归释放堆内存template &lt;typename T&gt;void LeftistHeap&lt;T&gt;::destroy(LeftistNode&lt;T&gt;* node) &#123;    if (node == nullptr) return;    destroy(node-&gt;left);    destroy(node-&gt;right);    delete node;&#125;</code></pre><h2 id="四、测试代码"><a href="#四、测试代码" class="headerlink" title="四、测试代码"></a>四、测试代码</h2><p>验证左式堆的核心功能（插入、删除堆顶、合并）：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    // 测试1：插入和删除堆顶    LeftistHeap&lt;int&gt; heap1;    heap1.insert(5);    heap1.insert(3);    heap1.insert(7);    heap1.insert(1);    cout &lt;&lt; &quot;Heap1 min: &quot; &lt;&lt; heap1.getMin() &lt;&lt; endl;  // 输出1    heap1.deleteMin();    cout &lt;&lt; &quot;After delete min, Heap1 min: &quot; &lt;&lt; heap1.getMin() &lt;&lt; endl;  // 输出3    // 测试2：合并两个堆    LeftistHeap&lt;int&gt; heap2;    heap2.insert(2);    heap2.insert(4);    heap1.merge(heap2);    cout &lt;&lt; &quot;After merge, Heap1 min: &quot; &lt;&lt; heap1.getMin() &lt;&lt; endl;  // 输出2    heap1.deleteMin();    cout &lt;&lt; &quot;After delete min, Heap1 min: &quot; &lt;&lt; heap1.getMin() &lt;&lt; endl;  // 输出3    return 0;&#125;</code></pre><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><pre><code class="plaintext">Heap1 min: 1After delete min, Heap1 min: 3After merge, Heap1 min: 2After delete min, Heap1 min: 3</code></pre><h2 id="五、时间复杂度分析"><a href="#五、时间复杂度分析" class="headerlink" title="五、时间复杂度分析"></a>五、时间复杂度分析</h2><table><thead><tr><th>操作</th><th>时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td>合并（merge）</td><td>O(log n)</td><td>每次递归深入一层，树高为 O (log n)</td></tr><tr><td>插入（insert）</td><td>O(log n)</td><td>等价于合并单个节点，复用 merge</td></tr><tr><td>删除堆顶</td><td>O(log n)</td><td>合并两个子堆，复用 merge</td></tr><tr><td>查询堆顶</td><td>O(1)</td><td>直接访问根节点</td></tr></tbody></table><p>注：左式堆的树高最坏为 O (log n)（因左偏性限制了右子树深度），故所有操作均为对数时间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;左式堆是一种&lt;strong&gt;可合并堆（Mergeable Heap）&lt;/strong&gt;，核心优势是支持高效的「合并操作」（时间复杂度 O (logN)），同时保留堆的「极值优先」特性（大根堆 &amp;#x2F; 小根堆）。它通过引入「零路径长度（NPL）」约束左子树的深度，确保合并时仅需沿 “左偏路径” 遍历，避免退化。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="堆" scheme="http://example.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>CSS_动画</title>
    <link href="http://example.com/2025/11/11/CSS-%E5%8A%A8%E7%94%BB/"/>
    <id>http://example.com/2025/11/11/CSS-%E5%8A%A8%E7%94%BB/</id>
    <published>2025-11-11T15:10:59.000Z</published>
    <updated>2025-11-25T15:46:54.355Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 动画是通过 CSS 属性控制元素从一种样式状态平滑过渡到另一种状态的技术，无需 JavaScript 即可实现丰富的视觉效果（如渐变、旋转、缩放、位移等）。核心分为 <strong>过渡动画（<code>transition</code>）</strong> 和 <strong>关键帧动画（<code>animation</code>）</strong> 两大类，前者适合简单的 “状态切换”，后者适合复杂的 “多阶段动画”。本文将从基础概念、用法、特性、实战场景及优化全面解析。</p><span id="more"></span><h1 id="CSS-动画详解"><a href="#CSS-动画详解" class="headerlink" title="CSS 动画详解"></a>CSS 动画详解</h1><h2 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h2><h3 id="1-动画的本质"><a href="#1-动画的本质" class="headerlink" title="1. 动画的本质"></a>1. 动画的本质</h3><p>通过 CSS 定义元素的 “初始状态” 和 “目标状态”（或多阶段状态），浏览器自动计算中间帧，实现平滑过渡。核心优势：</p><ul><li>浏览器原生支持，性能优于 JS 动画（可利用 GPU 加速）；</li><li>语法简洁，无需复杂脚本；</li><li>支持暂停、延迟、循环等控制。</li></ul><h3 id="2-关键术语"><a href="#2-关键术语" class="headerlink" title="2. 关键术语"></a>2. 关键术语</h3><ul><li><strong>状态</strong>：元素的 CSS 样式集合（如 <code>width: 100px</code>、<code>opacity: 0</code>）；</li><li><strong>过渡（Transition）</strong>：从 “初始状态” 到 “目标状态” 的一次性平滑过渡；</li><li><strong>关键帧（Keyframe）</strong>：定义动画的多个关键阶段（如开始、中间、结束），<code>animation</code> 基于关键帧实现复杂动画；</li><li><strong>时间函数（Timing Function）</strong>：控制动画的速度曲线（如匀速、先慢后快）；</li><li><strong>持续时间（Duration）</strong>：动画从开始到结束的总时间；</li><li><strong>延迟时间（Delay）</strong>：动画触发后等待多久开始执行。</li></ul><h2 id="二、过渡动画（transition）：简单状态切换"><a href="#二、过渡动画（transition）：简单状态切换" class="headerlink" title="二、过渡动画（transition）：简单状态切换"></a>二、过渡动画（transition）：简单状态切换</h2><p><code>transition</code> 是最基础的 CSS 动画，用于实现 “元素状态变化时的平滑过渡”（如 hover 效果、点击切换样式），仅需定义 “过渡属性”“持续时间” 等核心参数。</p><h3 id="1-语法（简写）"><a href="#1-语法（简写）" class="headerlink" title="1. 语法（简写）"></a>1. 语法（简写）</h3><pre><code class="css">transition: [过渡属性] [持续时间] [时间函数] [延迟时间];</code></pre><ul><li>各参数可选，顺序固定（后两个可省略，默认：<code>ease</code> 时间函数、<code>0s</code> 延迟）；</li><li>多属性过渡：用逗号分隔（如 <code>transition: width 0.3s, background 0.5s</code>）；</li><li>所有属性过渡：<code>transition: all 0.3s</code>（简单但性能略差，推荐明确指定属性）。</li></ul><h3 id="2-核心参数详解"><a href="#2-核心参数详解" class="headerlink" title="2. 核心参数详解"></a>2. 核心参数详解</h3><table><thead><tr><th>参数</th><th>说明</th><th>可选值</th></tr></thead><tbody><tr><td>过渡属性</td><td>要过渡的 CSS 属性（如 <code>width</code>、<code>opacity</code>、<code>transform</code>）</td><td>具体属性名 &#x2F; <code>all</code>（所有属性） &#x2F; <code>none</code></td></tr><tr><td>持续时间</td><td>动画完成的时间（必须指定，否则无效）</td><td>单位 <code>s</code>（秒）或 <code>ms</code>（毫秒）（如 <code>0.3s</code>）</td></tr><tr><td>时间函数</td><td>动画速度曲线</td><td><code>ease</code>（默认：先慢后快）、<code>linear</code>（匀速）、<code>ease-in-out</code>（先慢后快再慢）、<code>cubic-bezier(n,n,n,n)</code>（自定义曲线）</td></tr><tr><td>延迟时间</td><td>触发后延迟多久开始动画</td><td>单位 <code>s</code>&#x2F;<code>ms</code>（如 <code>0.2s</code>，默认 <code>0s</code>）</td></tr></tbody></table><h3 id="3-基础示例：hover-平滑缩放"><a href="#3-基础示例：hover-平滑缩放" class="headerlink" title="3. 基础示例：hover 平滑缩放"></a>3. 基础示例：hover 平滑缩放</h3><pre><code class="html">&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background: blue;    /* 过渡动画：transform 属性，持续 0.3s，匀速 */    transition: transform 0.3s linear;  &#125;  .box:hover &#123;    transform: scale(1.2); /* hover 时放大 1.2 倍 */  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><ul><li>效果：鼠标悬浮时，盒子平滑放大；离开时，平滑恢复原大小。</li></ul><h3 id="4-多属性过渡示例"><a href="#4-多属性过渡示例" class="headerlink" title="4. 多属性过渡示例"></a>4. 多属性过渡示例</h3><pre><code class="css">.box &#123;  width: 100px;  height: 100px;  background: red;  /* 同时过渡 width、background、border-radius，各属性持续时间不同 */  transition: width 0.5s ease, background 0.3s, border-radius 0.8s;&#125;.box:hover &#123;  width: 200px;  background: green;  border-radius: 50%; /* 变为圆形 */&#125;</code></pre><h3 id="5-过渡动画的触发方式"><a href="#5-过渡动画的触发方式" class="headerlink" title="5. 过渡动画的触发方式"></a>5. 过渡动画的触发方式</h3><p><code>transition</code> 需通过 “状态变化” 触发，常见触发方式：</p><ul><li>伪类：<code>hover</code>（悬浮）、<code>active</code>（点击）、<code>focus</code>（聚焦）；</li><li>JS 操作：修改元素 <code>class</code>、直接修改 CSS 属性；</li><li>表单元素状态：<code>checked</code>（复选框选中）。</li></ul><p>示例：JS 触发过渡</p><pre><code class="html">&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background: yellow;    transition: all 0.3s;  &#125;  .box.active &#123;    width: 300px;    background: purple;  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;&lt;/div&gt;&lt;button onclick=&quot;document.getElementById(&#39;box&#39;).classList.toggle(&#39;active&#39;)&quot;&gt;切换状态&lt;/button&gt;</code></pre><h2 id="三、关键帧动画（animation）：复杂多阶段动画"><a href="#三、关键帧动画（animation）：复杂多阶段动画" class="headerlink" title="三、关键帧动画（animation）：复杂多阶段动画"></a>三、关键帧动画（animation）：复杂多阶段动画</h2><p><code>animation</code> 是更强大的 CSS 动画，通过 <code>@keyframes</code> 定义多个关键帧（阶段），支持循环、暂停、反向播放等，适合实现复杂动画（如加载动画、元素穿梭、多步骤变换）。</p><h3 id="1-核心语法"><a href="#1-核心语法" class="headerlink" title="1. 核心语法"></a>1. 核心语法</h3><h4 id="（1）定义关键帧（-keyframes）"><a href="#（1）定义关键帧（-keyframes）" class="headerlink" title="（1）定义关键帧（@keyframes）"></a>（1）定义关键帧（<code>@keyframes</code>）</h4><pre><code class="css">/* 方式 1：用 from（开始）和 to（结束）定义两阶段动画 */@keyframes 动画名称 &#123;  from &#123; /* 初始状态 */    transform: translateX(0);  &#125;  to &#123; /* 结束状态 */    transform: translateX(300px);  &#125;&#125;/* 方式 2：用百分比定义多阶段动画（更灵活） */@keyframes 动画名称 &#123;  0% &#123; /* 初始状态 */    opacity: 0;    transform: scale(0.5);  &#125;  50% &#123; /* 中间阶段（动画进行到一半） */    opacity: 1;    transform: scale(1.1);  &#125;  100% &#123; /* 结束状态 */    opacity: 1;    transform: scale(1);  &#125;&#125;</code></pre><h4 id="（2）应用动画（animation-简写）"><a href="#（2）应用动画（animation-简写）" class="headerlink" title="（2）应用动画（animation 简写）"></a>（2）应用动画（<code>animation</code> 简写）</h4><pre><code class="css">animation: [动画名称] [持续时间] [时间函数] [延迟时间] [循环次数] [方向] [填充模式] [播放状态];</code></pre><ul><li>各参数顺序可灵活调整（但持续时间必须在延迟时间前）；</li><li>未指定的参数取默认值。</li></ul><h3 id="2-animation-各参数详解"><a href="#2-animation-各参数详解" class="headerlink" title="2. animation 各参数详解"></a>2. <code>animation</code> 各参数详解</h3><table><thead><tr><th>参数</th><th>说明</th><th>可选值</th></tr></thead><tbody><tr><td>动画名称</td><td>对应 <code>@keyframes</code> 定义的名称（必须指定）</td><td>自定义名称（如 <code>fadeIn</code>、<code>slide</code>）</td></tr><tr><td>持续时间</td><td>动画完成一次的时间（必须指定，否则无效）</td><td><code>s</code>&#x2F;<code>ms</code>（如 <code>1s</code>）</td></tr><tr><td>时间函数</td><td>动画速度曲线</td><td>同 <code>transition</code>（<code>linear</code>、<code>ease</code> 等）</td></tr><tr><td>延迟时间</td><td>触发后延迟多久开始</td><td><code>s</code>&#x2F;<code>ms</code>（默认 <code>0s</code>）</td></tr><tr><td>循环次数</td><td>动画重复次数</td><td>数字（如 <code>3</code>） &#x2F; <code>infinite</code>（无限循环，常用）</td></tr><tr><td>方向</td><td>动画播放方向</td><td><code>normal</code>（默认：正向）、<code>reverse</code>（反向）、<code>alternate</code>（交替：正向→反向→正向…）、<code>alternate-reverse</code>（反向交替）</td></tr><tr><td>填充模式</td><td>动画结束后元素保留的状态</td><td><code>none</code>（默认：回到初始状态）、<code>forwards</code>（保留结束状态）、<code>backwards</code>（延迟期间显示第一帧）、<code>both</code>（同时应用 <code>forwards</code> 和 <code>backwards</code>）</td></tr><tr><td>播放状态</td><td>控制动画播放 &#x2F; 暂停</td><td><code>running</code>（默认：播放）、<code>paused</code>（暂停）</td></tr></tbody></table><h3 id="3-基础示例：加载动画（无限旋转）"><a href="#3-基础示例：加载动画（无限旋转）" class="headerlink" title="3. 基础示例：加载动画（无限旋转）"></a>3. 基础示例：加载动画（无限旋转）</h3><pre><code class="html">&lt;style&gt;  /* 定义关键帧：旋转 360 度 */  @keyframes spin &#123;    from &#123;      transform: rotate(0deg);    &#125;    to &#123;      transform: rotate(360deg);    &#125;  &#125;  .loader &#123;    width: 50px;    height: 50px;    border: 5px solid #eee;    border-top: 5px solid blue;    border-radius: 50%; /* 圆形 */    /* 应用动画：无限循环、匀速、1s 一圈 */    animation: spin 1s linear infinite;  &#125;&lt;/style&gt;&lt;div class=&quot;loader&quot;&gt;&lt;/div&gt;</code></pre><ul><li>效果：圆形持续旋转，实现经典加载动画。</li></ul><h3 id="4-多阶段动画示例：淡入-缩放"><a href="#4-多阶段动画示例：淡入-缩放" class="headerlink" title="4. 多阶段动画示例：淡入 + 缩放"></a>4. 多阶段动画示例：淡入 + 缩放</h3><pre><code class="html">&lt;style&gt;  /* 定义多阶段关键帧 */  @keyframes fadeInScale &#123;    0% &#123;      opacity: 0; /* 完全透明 */      transform: scale(0.5); /* 缩小 50% */    &#125;    70% &#123;      opacity: 1; /* 完全显示 */      transform: scale(1.2); /* 放大 20% */    &#125;    100% &#123;      transform: scale(1); /* 恢复原大小 */    &#125;  &#125;  .box &#123;    width: 100px;    height: 100px;    background: red;    /* 应用动画：持续 1.5s，先慢后快，保留结束状态 */    animation: fadeInScale 1.5s ease forwards;  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><ul><li>效果：元素从透明缩小状态，逐渐淡入并放大，最后恢复原大小并保持。</li></ul><h3 id="5-动画控制：暂停-播放、反向"><a href="#5-动画控制：暂停-播放、反向" class="headerlink" title="5. 动画控制：暂停 &#x2F; 播放、反向"></a>5. 动画控制：暂停 &#x2F; 播放、反向</h3><pre><code class="html">&lt;style&gt;  @keyframes move &#123;    0% &#123; transform: translateX(0); &#125;    100% &#123; transform: translateX(300px); &#125;  &#125;  .box &#123;    width: 100px;    height: 100px;    background: green;    animation: move 3s linear infinite alternate; /* 交替方向循环 */  &#125;  .box:hover &#123;    animation-play-state: paused; /* 鼠标悬浮暂停动画 */  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><ul><li>效果：盒子左右往复移动，鼠标悬浮时暂停。</li></ul><h2 id="四、常用动画属性（transform、opacity-等）"><a href="#四、常用动画属性（transform、opacity-等）" class="headerlink" title="四、常用动画属性（transform、opacity 等）"></a>四、常用动画属性（transform、opacity 等）</h2><p>CSS 动画通常配合 “可过渡的 CSS 属性” 使用，核心属性如下：</p><h3 id="1-transform：元素变换（无布局偏移）"><a href="#1-transform：元素变换（无布局偏移）" class="headerlink" title="1. transform：元素变换（无布局偏移）"></a>1. transform：元素变换（无布局偏移）</h3><p><code>transform</code> 用于对元素进行旋转、缩放、位移、倾斜等变换，<strong>不会影响其他元素布局</strong>（性能最优），是动画核心属性。</p><h4 id="常用变换函数"><a href="#常用变换函数" class="headerlink" title="常用变换函数"></a>常用变换函数</h4><table><thead><tr><th>函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>translateX(n)</code></td><td>水平位移（<code>n</code> 为 <code>px</code> 或百分比）</td><td><code>translateX(50px)</code>（向右移 50px）</td></tr><tr><td><code>translateY(n)</code></td><td>垂直位移</td><td><code>translateY(-20px)</code>（向上移 20px）</td></tr><tr><td><code>translate(n,m)</code></td><td>水平 + 垂直位移</td><td><code>translate(30px, 40px)</code></td></tr><tr><td><code>scale(n)</code></td><td>缩放（<code>n=1</code> 原大小，<code>n&gt;1</code> 放大）</td><td><code>scale(1.5)</code>（放大 1.5 倍）</td></tr><tr><td><code>scaleX(n)</code>&#x2F;<code>scaleY(n)</code></td><td>水平 &#x2F; 垂直单独缩放</td><td><code>scaleX(2)</code>（水平放大 2 倍）</td></tr><tr><td><code>rotate(ndeg)</code></td><td>旋转（<code>n</code> 为角度，正顺时针，负逆时针）</td><td><code>rotate(45deg)</code>（顺时针转 45 度）</td></tr><tr><td><code>skewX(ndeg)</code>&#x2F;<code>skewY(ndeg)</code></td><td>水平 &#x2F; 垂直倾斜</td><td><code>skewX(10deg)</code>（水平倾斜 10 度）</td></tr></tbody></table><p>示例：组合变换（位移 + 旋转 + 缩放）</p><pre><code class="css">.box &#123;  transform: translateX(50px) rotate(30deg) scale(1.2);&#125;</code></pre><h3 id="2-opacity：透明度（无布局偏移）"><a href="#2-opacity：透明度（无布局偏移）" class="headerlink" title="2. opacity：透明度（无布局偏移）"></a>2. opacity：透明度（无布局偏移）</h3><p>控制元素透明度（<code>0</code> 完全透明，<code>1</code> 完全不透明），适合淡入淡出效果，性能优异。</p><p>示例：淡入动画</p><pre><code class="css">@keyframes fadeIn &#123;  from &#123; opacity: 0; &#125;  to &#123; opacity: 1; &#125;&#125;</code></pre><h3 id="3-其他可动画属性（可能触发布局重绘）"><a href="#3-其他可动画属性（可能触发布局重绘）" class="headerlink" title="3. 其他可动画属性（可能触发布局重绘）"></a>3. 其他可动画属性（可能触发布局重绘）</h3><p>以下属性也支持动画，但会改变元素布局（触发浏览器重绘 &#x2F; 回流，性能略差），尽量少用：</p><ul><li>尺寸类：<code>width</code>、<code>height</code>、<code>padding</code>、<code>margin</code>；</li><li>位置类：<code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>（需配合定位）；</li><li>颜色类：<code>background</code>、<code>color</code>、<code>border-color</code>；</li><li>其他：<code>border-radius</code>、<code>box-shadow</code>。</li></ul><blockquote><p>性能优化建议：优先使用 <code>transform</code> + <code>opacity</code> 实现动画（浏览器可通过 GPU 加速，避免重绘回流）。</p></blockquote><h2 id="五、动画的性能优化"><a href="#五、动画的性能优化" class="headerlink" title="五、动画的性能优化"></a>五、动画的性能优化</h2><h3 id="1-优先使用-GPU-加速属性"><a href="#1-优先使用-GPU-加速属性" class="headerlink" title="1. 优先使用 GPU 加速属性"></a>1. 优先使用 GPU 加速属性</h3><ul><li>推荐：<code>transform</code>、<code>opacity</code>（这两个属性不会触发布局重绘，仅触发合成层更新）；</li><li>避免：<code>width</code>、<code>height</code>、<code>top</code>、<code>left</code> 等会改变布局的属性。</li></ul><h3 id="2-减少动画元素数量"><a href="#2-减少动画元素数量" class="headerlink" title="2. 减少动画元素数量"></a>2. 减少动画元素数量</h3><p>过多同时运行的动画会占用大量 GPU 资源，导致卡顿，尽量精简动画元素。</p><h3 id="3-避免过度使用-animation-all"><a href="#3-避免过度使用-animation-all" class="headerlink" title="3. 避免过度使用 animation: all"></a>3. 避免过度使用 <code>animation: all</code></h3><p><code>all</code> 会让所有属性参与过渡，可能包含无需动画的属性，增加浏览器计算压力，建议明确指定动画属性。</p><h3 id="4-合理设置-will-change（提前告知浏览器）"><a href="#4-合理设置-will-change（提前告知浏览器）" class="headerlink" title="4. 合理设置 will-change（提前告知浏览器）"></a>4. 合理设置 <code>will-change</code>（提前告知浏览器）</h3><p>给即将动画的元素添加 <code>will-change</code>，让浏览器提前准备优化（如分配 GPU 资源），避免动画启动时卡顿：</p><pre><code class="css">.box &#123;  will-change: transform, opacity; /* 告知浏览器即将动画这两个属性 */&#125;</code></pre><ul><li>注意：不要滥用 <code>will-change</code>（如给所有元素添加），否则会占用额外资源。</li></ul><h3 id="5-控制动画持续时间和帧率"><a href="#5-控制动画持续时间和帧率" class="headerlink" title="5. 控制动画持续时间和帧率"></a>5. 控制动画持续时间和帧率</h3><ul><li>持续时间建议在 <code>0.3s~0.6s</code> 之间（过短生硬，过长拖沓）；</li><li>浏览器默认帧率 60fps（每帧约 16.7ms），确保动画每帧计算时间不超过 16.7ms。</li></ul><h2 id="六、动画的常见问题与解决方案"><a href="#六、动画的常见问题与解决方案" class="headerlink" title="六、动画的常见问题与解决方案"></a>六、动画的常见问题与解决方案</h2><h3 id="1-动画结束后回到初始状态"><a href="#1-动画结束后回到初始状态" class="headerlink" title="1. 动画结束后回到初始状态"></a>1. 动画结束后回到初始状态</h3><p>问题：<code>animation</code>默认动画结束后回到初始状态，无法保留结束样式。解决方案：设置<code>animation-fill-mode: forwards</code></p><pre><code class="css">.box &#123;  animation: fadeIn 1s forwards; /* 保留结束状态 */&#125;</code></pre><h3 id="2-动画触发时的-“闪烁”"><a href="#2-动画触发时的-“闪烁”" class="headerlink" title="2. 动画触发时的 “闪烁”"></a>2. 动画触发时的 “闪烁”</h3><p>问题：动画开始前元素可能出现瞬间闪烁（尤其  </p><p>解决方案：</p><ul><li>给元素初始状态添加 <code>opacity: 0</code>（避免初始显示）；</li><li>配合 <code>animation-fill-mode: backwards</code>（延迟期间显示第一帧）：</li></ul><pre><code class="css">.box &#123;  opacity: 0; /* 初始透明 */  animation: fadeIn 1s forwards backwards;&#125;</code></pre><h3 id="3-transform-动画抖动"><a href="#3-transform-动画抖动" class="headerlink" title="3. transform 动画抖动"></a>3. transform 动画抖动</h3><p>问题：元素用 </p><p>解决方案：给动画元素添加  ，避免 GPU 渲染时的 “像素对齐问题”：</p><pre><code class="css">.box &#123;  backface-visibility: hidden;  perspective: 1000px;&#125;</code></pre><h3 id="4-多动画冲突"><a href="#4-多动画冲突" class="headerlink" title="4. 多动画冲突"></a>4. 多动画冲突</h3><p>问题：给同一元素添加多个 </p><p>解决方案：</p><ul><li>合并关键帧（将多个动画逻辑写在一个 <code>@keyframes</code> 中）；</li><li>用逗号分隔多个动画（确保不冲突）：</li></ul><pre><code class="css">.box &#123;  animation: fadeIn 1s, move 2s; /* 同时执行两个动画 */&#125;</code></pre><h2 id="七、过渡（transition）vs-关键帧（animation）：如何选择？"><a href="#七、过渡（transition）vs-关键帧（animation）：如何选择？" class="headerlink" title="七、过渡（transition）vs 关键帧（animation）：如何选择？"></a>七、过渡（transition）vs 关键帧（animation）：如何选择？</h2><table><thead><tr><th>特性</th><th>transition（过渡）</th><th>animation（关键帧）</th></tr></thead><tbody><tr><td>核心用途</td><td>简单状态切换（如 hover、点击）</td><td>复杂多阶段动画（如加载、循环、多步骤）</td></tr><tr><td>触发方式</td><td>需状态变化触发（被动）</td><td>自动触发（或 JS 控制），支持主动控制</td></tr><tr><td>阶段数</td><td>仅支持 “初始→目标” 两阶段</td><td>支持任意多阶段（百分比定义）</td></tr><tr><td>循环能力</td><td>不支持循环（需 JS 反复触发状态）</td><td>支持 <code>infinite</code> 无限循环、交替方向</td></tr><tr><td>控制灵活性</td><td>低（仅能控制过渡参数）</td><td>高（支持暂停、反向、填充模式等）</td></tr></tbody></table><h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ul><li>简单交互效果（如 hover 变色、缩放）→ 用 <code>transition</code>（简洁高效）；</li><li>复杂动画（如加载旋转、多步骤变换、循环动画）→ 用 <code>animation</code>（灵活强大）；</li><li>需 JS 控制播放 &#x2F; 暂停、循环次数 → 用 <code>animation</code>。</li></ul><h2 id="八、实战场景示例"><a href="#八、实战场景示例" class="headerlink" title="八、实战场景示例"></a>八、实战场景示例</h2><h3 id="1-导航栏-hover-效果（transition）"><a href="#1-导航栏-hover-效果（transition）" class="headerlink" title="1. 导航栏 hover 效果（transition）"></a>1. 导航栏 hover 效果（transition）</h3><pre><code class="css">.nav-item &#123;  color: #333;  padding: 10px 15px;  transition: color 0.3s, background 0.3s, transform 0.2s;&#125;.nav-item:hover &#123;  color: white;  background: #0066cc;  transform: translateY(-2px); /* 轻微上移，增强交互感 */&#125;</code></pre><h3 id="2-弹窗淡入弹出（animation）"><a href="#2-弹窗淡入弹出（animation）" class="headerlink" title="2. 弹窗淡入弹出（animation）"></a>2. 弹窗淡入弹出（animation）</h3><pre><code class="css">@keyframes modalFadeIn &#123;  0% &#123;    opacity: 0;    transform: scale(0.9) translateY(-20px);  &#125;  100% &#123;    opacity: 1;    transform: scale(1) translateY(0);  &#125;&#125;.modal &#123;  position: fixed;  top: 50%;  left: 50%;  transform: translate(-50%, -50%);  animation: modalFadeIn 0.4s ease forwards;  background: white;  padding: 30px;  border-radius: 8px;&#125;</code></pre><h3 id="3-滚动触发动画（JS-animation）"><a href="#3-滚动触发动画（JS-animation）" class="headerlink" title="3. 滚动触发动画（JS + animation）"></a>3. 滚动触发动画（JS + animation）</h3><pre><code class="html">&lt;style&gt;  @keyframes slideUp &#123;    from &#123;      opacity: 0;      transform: translateY(50px);    &#125;    to &#123;      opacity: 1;      transform: translateY(0);    &#125;  &#125;  .animate-on-scroll &#123;    opacity: 0; /* 初始透明 */  &#125;  .animate-on-scroll.active &#123;    animation: slideUp 0.6s ease forwards;  &#125;&lt;/style&gt;&lt;div class=&quot;animate-on-scroll&quot;&gt;滚动到此处时触发动画&lt;/div&gt;&lt;script&gt;  // 监听滚动事件  window.addEventListener(&#39;scroll&#39;, () =&gt; &#123;    const elements = document.querySelectorAll(&#39;.animate-on-scroll&#39;);    elements.forEach(el =&gt; &#123;      // 计算元素是否进入视口      const rect = el.getBoundingClientRect();      if (rect.top &lt; window.innerHeight - 100) &#123;        el.classList.add(&#39;active&#39;); // 触发动画      &#125;    &#125;);  &#125;);&lt;/script&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSS 动画是通过 CSS 属性控制元素从一种样式状态平滑过渡到另一种状态的技术，无需 JavaScript 即可实现丰富的视觉效果（如渐变、旋转、缩放、位移等）。核心分为 &lt;strong&gt;过渡动画（&lt;code&gt;transition&lt;/code&gt;）&lt;/strong&gt; 和 &lt;strong&gt;关键帧动画（&lt;code&gt;animation&lt;/code&gt;）&lt;/strong&gt; 两大类，前者适合简单的 “状态切换”，后者适合复杂的 “多阶段动画”。本文将从基础概念、用法、特性、实战场景及优化全面解析。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS_定位</title>
    <link href="http://example.com/2025/11/11/CSS-%E5%AE%9A%E4%BD%8D/"/>
    <id>http://example.com/2025/11/11/CSS-%E5%AE%9A%E4%BD%8D/</id>
    <published>2025-11-11T14:02:53.000Z</published>
    <updated>2025-11-25T15:47:07.104Z</updated>
    
    <content type="html"><![CDATA[<p>定位（<code>position</code>）是 CSS 中控制元素<strong>精确位置</strong>的核心属性，通过改变元素在页面中的布局规则（脱离标准文档流或保留文档流位置），实现浮动无法完成的复杂布局（如固定导航、弹窗、元素叠加等）。本文将从核心概念、属性值、定位规则、应用场景及常见问题全面解析。</p><span id="more"></span><h1 id="CSS-定位"><a href="#CSS-定位" class="headerlink" title="CSS 定位"></a>CSS 定位</h1><h2 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h2><h3 id="1-定位的本质"><a href="#1-定位的本质" class="headerlink" title="1. 定位的本质"></a>1. 定位的本质</h3><p>定位通过 <code>position</code> 属性定义元素的 “定位类型”，再通过 <code>top</code>&#x2F;<code>bottom</code>&#x2F;<code>left</code>&#x2F;<code>right</code>（偏移属性）控制元素的具体位置，同时可能影响元素与其他元素的层叠关系（<code>z-index</code>）。</p><h3 id="2-关键术语"><a href="#2-关键术语" class="headerlink" title="2. 关键术语"></a>2. 关键术语</h3><ul><li><strong>标准文档流</strong>：元素默认排列规则（块级独占一行、行内横向排列），定位会改变元素在文档流中的行为；</li><li><strong>包含块</strong>：定位元素的 “参考容器”，偏移属性（<code>top</code>&#x2F;<code>left</code> 等）基于包含块计算，默认是最近的已定位祖先元素，若无则为根元素（&#96;&#96;）；</li><li><strong>偏移属性</strong>：<code>top</code>（上偏移）、<code>bottom</code>（下偏移）、<code>left</code>（左偏移）、<code>right</code>（右偏移），仅对非 <code>static</code> 定位的元素有效；</li><li><strong>z-index</strong>：控制定位元素的层叠顺序（数值越大越靠上），仅对非 <code>static</code> 定位的元素有效。</li></ul><h2 id="二、position-的-5-个属性值"><a href="#二、position-的-5-个属性值" class="headerlink" title="二、position 的 5 个属性值"></a>二、position 的 5 个属性值</h2><p><code>position</code> 的取值决定了元素的定位规则，共 5 种类型，核心差异在于 “是否脱离文档流” 和 “参考容器是谁”：</p><table><thead><tr><th>定位类型</th><th>是否脱离文档流</th><th>参考容器（包含块）</th><th>核心特点</th><th>典型场景</th></tr></thead><tbody><tr><td><code>static</code>（默认）</td><td>否</td><td>无（遵循标准流）</td><td>无法使用偏移属性和 <code>z-index</code>，元素正常排列</td><td>默认布局，无需特殊定位</td></tr><tr><td><code>relative</code>（相对）</td><td>否（保留位置）</td><td>自身在标准流中的原始位置</td><td>偏移后不影响其他元素，仍占据原文档流空间</td><td>微调元素位置、作为绝对定位的父容器</td></tr><tr><td><code>absolute</code>（绝对）</td><td>是</td><td>最近的非 <code>static</code> 定位祖先元素</td><td>脱离文档流，不占据原位置，可叠加、精确布局</td><td>弹窗、下拉菜单、元素叠加</td></tr><tr><td><code>fixed</code>（固定）</td><td>是</td><td>浏览器视口（viewport）</td><td>脱离文档流，位置不随滚动条滚动</td><td>固定导航、回到顶部按钮、弹窗遮罩</td></tr><tr><td><code>sticky</code>（粘性）</td><td>半脱离（滚动时）</td><td>父元素（滚动容器）</td><td>滚动前遵循标准流，滚动到阈值后固定在视口</td><td>粘性导航、列表标题吸顶</td></tr></tbody></table><h2 id="三、逐个解析定位类型"><a href="#三、逐个解析定位类型" class="headerlink" title="三、逐个解析定位类型"></a>三、逐个解析定位类型</h2><h3 id="1-static：默认定位（无定位）"><a href="#1-static：默认定位（无定位）" class="headerlink" title="1. static：默认定位（无定位）"></a>1. static：默认定位（无定位）</h3><p><code>static</code> 是所有元素的默认定位类型，元素遵循标准文档流，**无法使用 <code>top</code>&#x2F;<code>left</code>&#x2F;<code>z-index</code>**，任何偏移设置都会被忽略。</p><pre><code class="css">.box &#123;  position: static; /* 默认值，可省略 */  left: 50px; /* 无效，元素仍在标准流位置 */&#125;</code></pre><h3 id="2-relative：相对定位"><a href="#2-relative：相对定位" class="headerlink" title="2. relative：相对定位"></a>2. relative：相对定位</h3><p>相对定位是 “相对于自身原始位置” 的定位，<strong>不脱离标准文档流</strong>，仅视觉上偏移，原位置仍被保留（其他元素不会填充）。</p><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li>偏移属性（<code>top</code>&#x2F;<code>left</code> 等）基于自身原始位置计算（例：<code>left: 20px</code> 表示向右偏移 20px）；</li><li>不影响其他元素的布局，仅自身视觉偏移；</li><li>常作为 <code>absolute</code> 定位的 “包含块”（父元素设为 <code>relative</code>，子元素设为 <code>absolute</code>）。</li></ul><h4 id="示例：微调元素位置"><a href="#示例：微调元素位置" class="headerlink" title="示例：微调元素位置"></a>示例：微调元素位置</h4><pre><code class="html">&lt;style&gt;  .box &#123;    position: relative;    left: 30px; /* 相对于原始位置向右偏移 30px */    top: -10px; /* 相对于原始位置向上偏移 10px（负值向上） */    width: 100px;    height: 100px;    background: red;  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;相对定位元素&lt;/div&gt;&lt;p&gt;其他元素不会填充.box的原始位置（因为.box仍在文档流中）&lt;/p&gt;</code></pre><h4 id="示例：作为绝对定位的父容器（关键用法）"><a href="#示例：作为绝对定位的父容器（关键用法）" class="headerlink" title="示例：作为绝对定位的父容器（关键用法）"></a>示例：作为绝对定位的父容器（关键用法）</h4><pre><code class="html">&lt;style&gt;  .parent &#123;    position: relative; /* 父元素设为 relative，成为包含块 */    width: 300px;    height: 300px;    background: #eee;  &#125;  .child &#123;    position: absolute;    top: 20px; /* 相对于父元素顶部偏移 20px */    right: 20px; /* 相对于父元素右侧偏移 20px */    width: 100px;    height: 100px;    background: blue;  &#125;&lt;/style&gt;&lt;div class=&quot;parent&quot;&gt;  父容器（relative）  &lt;div class=&quot;child&quot;&gt;绝对定位子元素&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>若父元素不设 <code>relative</code>，子元素的 <code>absolute</code> 会向上查找，最终以 &#96;&#96; 为参考容器（视口左上角）。</li></ul><h3 id="3-absolute：绝对定位"><a href="#3-absolute：绝对定位" class="headerlink" title="3. absolute：绝对定位"></a>3. absolute：绝对定位</h3><p>绝对定位是 “相对于包含块” 的定位，<strong>完全脱离标准文档流</strong>，不占据原位置（其他元素会填充其原始位置），可通过偏移属性精确控制位置。</p><h4 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li>脱离文档流，元素位置独立于其他元素；</li><li>包含块规则：优先找最近的 <code>relative</code>&#x2F;<code>absolute</code>&#x2F;<code>fixed</code>&#x2F;<code>sticky</code> 祖先元素，若无则以根元素（<code>&lt;html&gt;</code>）为参考；</li><li>行内元素设为 <code>absolute</code> 后，自动转为 “行内块级元素”（可设置宽高，不独占一行）；</li><li>若未设置偏移属性（<code>top</code>&#x2F;<code>left</code> 等），元素会默认停留在其原始文档流中的位置，但已脱离文档流（其他元素会覆盖它）。</li></ul><h4 id="示例：弹窗布局"><a href="#示例：弹窗布局" class="headerlink" title="示例：弹窗布局"></a>示例：弹窗布局</h4><pre><code class="html">&lt;style&gt;  .modal &#123;    position: absolute;    top: 50%; /* 相对于视口（无定位父元素）垂直居中 */    left: 50%; /* 水平居中 */    transform: translate(-50%, -50%); /* 修正居中（基于自身宽高） */    width: 200px;    height: 150px;    background: white;    border: 1px solid #ccc;    padding: 20px;    z-index: 100; /* 确保弹窗在最上层 */  &#125;  .overlay &#123;    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;    background: rgba(0,0,0,0.5); /* 半透明遮罩 */    z-index: 99; /* 遮罩在弹窗下方 */  &#125;&lt;/style&gt;&lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;&lt;div class=&quot;modal&quot;&gt;这是一个绝对定位的弹窗&lt;/div&gt;</code></pre><ul><li>注：<code>transform: translate(-50%, -50%)</code> 是实现绝对定位元素居中的常用技巧，无需知道元素自身宽高。</li></ul><h3 id="4-fixed：固定定位"><a href="#4-fixed：固定定位" class="headerlink" title="4. fixed：固定定位"></a>4. fixed：固定定位</h3><p>固定定位是 “相对于浏览器视口” 的定位，<strong>完全脱离文档流</strong>，位置不随滚动条滚动（始终固定在视口的某个位置）。</p><h4 id="核心特性-2"><a href="#核心特性-2" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li>参考容器是浏览器视口（无论页面如何滚动，元素位置不变）；</li><li>脱离文档流，不占据原位置；</li><li>常与 <code>top: 0</code>&#x2F;<code>bottom: 0</code>&#x2F;<code>left: 0</code>&#x2F;<code>right: 0</code> 配合实现 “全屏” 或 “固定边距” 效果。</li></ul><h4 id="示例：固定导航栏"><a href="#示例：固定导航栏" class="headerlink" title="示例：固定导航栏"></a>示例：固定导航栏</h4><pre><code class="html">&lt;style&gt;  .nav &#123;    position: fixed;    top: 0; /* 固定在视口顶部 */    left: 0;    right: 0; /* 左右贴边，宽度自适应 */    height: 60px;    background: #333;    color: white;    line-height: 60px;    padding: 0 20px;    z-index: 999; /* 确保导航在最上层，不被其他元素覆盖 */  &#125;  .content &#123;    margin-top: 80px; /* 避免内容被固定导航遮挡 */    height: 2000px; /* 模拟长页面滚动 */  &#125;&lt;/style&gt;&lt;nav class=&quot;nav&quot;&gt;固定导航栏（滚动不消失）&lt;/nav&gt;&lt;div class=&quot;content&quot;&gt;页面内容...&lt;/div&gt;</code></pre><h4 id="示例：回到顶部按钮"><a href="#示例：回到顶部按钮" class="headerlink" title="示例：回到顶部按钮"></a>示例：回到顶部按钮</h4><pre><code class="css">.back-to-top &#123;  position: fixed;  bottom: 30px; /* 距离视口底部 30px */  right: 30px; /* 距离视口右侧 30px */  width: 50px;  height: 50px;  background: #000;  color: white;  text-align: center;  line-height: 50px;  border-radius: 50%;  cursor: pointer;&#125;</code></pre><h3 id="5-sticky：粘性定位（CSS3-新增）"><a href="#5-sticky：粘性定位（CSS3-新增）" class="headerlink" title="5. sticky：粘性定位（CSS3 新增）"></a>5. sticky：粘性定位（CSS3 新增）</h3><p>粘性定位是 “相对定位 + 固定定位” 的混合体，<strong>滚动前遵循标准流，滚动到阈值后转为固定定位</strong>（相对于父滚动容器，而非视口）。</p><h4 id="核心特性-3"><a href="#核心特性-3" class="headerlink" title="核心特性"></a>核心特性</h4><ul><li>未滚动到阈值时：表现如 <code>relative</code>，保留文档流位置；</li><li>滚动到阈值时：表现如 <code>fixed</code>，固定在父容器的指定位置（不随滚动继续移动）；</li><li>必须设置 <code>top</code>&#x2F;<code>bottom</code>&#x2F;<code>left</code>&#x2F;<code>right</code> 中的一个（阈值），否则无效；</li><li>父元素不能有 <code>overflow: hidden</code>&#x2F;<code>auto</code>&#x2F;<code>scroll</code>（除非父元素是滚动容器），否则会失效。</li></ul><h4 id="示例：粘性导航（列表标题吸顶）"><a href="#示例：粘性导航（列表标题吸顶）" class="headerlink" title="示例：粘性导航（列表标题吸顶）"></a>示例：粘性导航（列表标题吸顶）</h4><pre><code class="html">&lt;style&gt;  .list &#123;    width: 300px;    height: 300px;    overflow-y: auto; /* 父元素设为滚动容器 */    border: 1px solid #ccc;  &#125;  .list-title &#123;    position: sticky;    top: 0; /* 滚动到顶部时固定 */    background: #f0f0f0;    padding: 10px;    margin: 0;    border-bottom: 1px solid #ccc;  &#125;  .list-item &#123;    padding: 10px;  &#125;&lt;/style&gt;&lt;div class=&quot;list&quot;&gt;  &lt;h3 class=&quot;list-title&quot;&gt;列表标题（粘性吸顶）&lt;/h3&gt;  &lt;div class=&quot;list-item&quot;&gt;列表项 1&lt;/div&gt;  &lt;div class=&quot;list-item&quot;&gt;列表项 2&lt;/div&gt;  &lt;div class=&quot;list-item&quot;&gt;列表项 3&lt;/div&gt;  &lt;!-- 更多列表项... --&gt;&lt;/div&gt;</code></pre><ul><li>效果：滚动列表时，标题会固定在父容器顶部，直到列表滚动到底部（标题跟随父容器消失）。</li></ul><h2 id="四、z-index：层叠顺序控制"><a href="#四、z-index：层叠顺序控制" class="headerlink" title="四、z-index：层叠顺序控制"></a>四、z-index：层叠顺序控制</h2><p>当多个定位元素（非 <code>static</code>）重叠时，<code>z-index</code> 控制它们的层叠顺序，<strong>数值越大，元素越靠上</strong>。</p><h3 id="核心规则"><a href="#核心规则" class="headerlink" title="核心规则"></a>核心规则</h3><ol><li>仅对非 <code>static</code> 定位的元素有效（<code>relative</code>&#x2F;<code>absolute</code>&#x2F;<code>fixed</code>&#x2F;<code>sticky</code>）；</li><li>默认 <code>z-index: auto</code>（等价于 <code>z-index: 0</code>）；</li><li>若元素属于同一 “层叠上下文”，直接比较 <code>z-index</code> 数值（大的在上）；</li><li>若元素属于不同层叠上下文，先比较父级层叠上下文的 <code>z-index</code>（父级大的子元素在上）。</li></ol><h3 id="示例：层叠顺序"><a href="#示例：层叠顺序" class="headerlink" title="示例：层叠顺序"></a>示例：层叠顺序</h3><pre><code class="html">&lt;style&gt;  .box1 &#123;    position: absolute;    top: 20px;    left: 20px;    width: 100px;    height: 100px;    background: red;    z-index: 1; /* 层级 1 */  &#125;  .box2 &#123;    position: absolute;    top: 40px;    left: 40px;    width: 100px;    height: 100px;    background: blue;    z-index: 2; /* 层级 2，在 box1 上方 */  &#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;z-index: 1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;z-index: 2&lt;/div&gt;</code></pre><ul><li>效果：蓝色盒子（<code>z-index: 2</code>）覆盖在红色盒子（<code>z-index: 1</code>）上方。</li></ul><h3 id="注意：层叠上下文陷阱"><a href="#注意：层叠上下文陷阱" class="headerlink" title="注意：层叠上下文陷阱"></a>注意：层叠上下文陷阱</h3><p>若父元素设置了 <code>z-index</code>（非 <code>auto</code>），则子元素的 <code>z-index</code> 仅在父元素的层叠上下文中生效，无法超越父元素的层级。</p><pre><code class="css">.parent &#123;  position: relative;  z-index: 1; /* 父元素层级 1 */&#125;.child &#123;  position: absolute;  z-index: 999; /* 子元素层级再高，也无法超越父元素的层级 */&#125;.other &#123;  position: relative;  z-index: 2; /* 该元素会覆盖 parent 及其子元素 */&#125;</code></pre><h2 id="五、定位的常见问题与解决方案"><a href="#五、定位的常见问题与解决方案" class="headerlink" title="五、定位的常见问题与解决方案"></a>五、定位的常见问题与解决方案</h2><h3 id="1-绝对定位元素居中偏差"><a href="#1-绝对定位元素居中偏差" class="headerlink" title="1. 绝对定位元素居中偏差"></a>1. 绝对定位元素居中偏差</h3><p> 问题：用 <code>top: 50%; left: 50%;</code> 居中时，元素会以左上角为基准，导致视觉偏移。 </p><p> 解决方案：添加 <code>transform: translate(-50%, -50%);</code>（基于元素自身宽高修正）： </p><pre><code class="css">.centered &#123;  position: absolute;  top: 50%;  left: 50%;  transform: translate(-50%, -50%); /* 完美居中 */&#125;</code></pre><h3 id="2-固定定位元素被遮挡"><a href="#2-固定定位元素被遮挡" class="headerlink" title="2. 固定定位元素被遮挡"></a>2. 固定定位元素被遮挡</h3><p>问题：<code>fixed</code>元素被其他元素覆盖。解决方案：提高<code>z-index</code>数值（确保父元素没有设置更低的<code>z-index</code></p><pre><code class="css">.fixed-box &#123;  position: fixed;  z-index: 9999; /* 足够大的数值，确保在最上层 */&#125;</code></pre><h3 id="3-sticky-定位失效"><a href="#3-sticky-定位失效" class="headerlink" title="3. sticky 定位失效"></a>3. sticky 定位失效</h3><p>常见原因及解决：</p><ul><li>未设置 <code>top</code>&#x2F;<code>bottom</code>&#x2F;<code>left</code>&#x2F;<code>right</code> 阈值 → 补充设置（如 <code>top: 0</code>）；</li><li>父元素有 <code>overflow: hidden</code> → 移除父元素的 <code>overflow: hidden</code>（或让父元素成为滚动容器）；</li><li>父元素高度小于粘性元素高度 → 确保父元素高度足够滚动。</li></ul><h3 id="4-绝对定位元素超出包含块"><a href="#4-绝对定位元素超出包含块" class="headerlink" title="4. 绝对定位元素超出包含块"></a>4. 绝对定位元素超出包含块</h3><p>问题：绝对定位元素内容过长，超出父容器。</p><p>解决方案：给包含块设置 （显示滚动条）或<code>overflow: hidden</code></p><pre><code class="css">.parent &#123;  position: relative;  width: 300px;  height: 300px;  overflow: auto; /* 超出部分显示滚动条 */&#125;.child &#123;  position: absolute;  width: 400px; /* 超出父容器宽度 */&#125;</code></pre><h2 id="六、定位的适用场景与最佳实践"><a href="#六、定位的适用场景与最佳实践" class="headerlink" title="六、定位的适用场景与最佳实践"></a>六、定位的适用场景与最佳实践</h2><h3 id="1-适用场景"><a href="#1-适用场景" class="headerlink" title="1. 适用场景"></a>1. 适用场景</h3><ul><li><code>relative</code>：微调元素位置、作为绝对定位的父容器；</li><li><code>absolute</code>：弹窗、下拉菜单、元素叠加、精确布局（如图标在按钮右上角）；</li><li><code>fixed</code>：固定导航、回到顶部按钮、弹窗遮罩、悬浮广告；</li><li><code>sticky</code>：粘性导航、列表标题吸顶、滚动时固定的筛选栏。</li></ul><h3 id="2-最佳实践"><a href="#2-最佳实践" class="headerlink" title="2. 最佳实践"></a>2. 最佳实践</h3><ul><li>尽量用 <code>relative</code> 作为 <code>absolute</code> 的父容器，避免绝对定位元素参考根元素（难以维护）；</li><li>固定定位元素需注意 <code>z-index</code>，避免被其他元素遮挡；</li><li>粘性定位需测试父容器的滚动行为，避免失效；</li><li>避免过度使用定位（尤其是 <code>absolute</code>），复杂布局优先用 Flex&#x2F;Grid（更简洁、易维护）。</li></ul><h2 id="七、定位与浮动、Flex-Grid-的区别"><a href="#七、定位与浮动、Flex-Grid-的区别" class="headerlink" title="七、定位与浮动、Flex&#x2F;Grid 的区别"></a>七、定位与浮动、Flex&#x2F;Grid 的区别</h2><table><thead><tr><th>布局方式</th><th>核心用途</th><th>脱离文档流</th><th>灵活性</th></tr></thead><tbody><tr><td>浮动</td><td>文字环绕、简单水平排列</td><td>是（半脱离）</td><td>低（仅水平方向）</td></tr><tr><td>定位</td><td>精确布局、元素叠加、固定</td><td>部分 &#x2F; 完全</td><td>高（任意方向控制）</td></tr><tr><td>Flex</td><td>一维布局（横向 &#x2F; 纵向）</td><td>否</td><td>中高（对齐、均分方便）</td></tr><tr><td>Grid</td><td>二维布局（行列控制）</td><td>否</td><td>最高（复杂布局高效）</td></tr></tbody></table><ul><li>简单水平排列 → 用 Flex；</li><li>复杂行列布局 → 用 Grid；</li><li>文字环绕 → 用浮动；</li><li>精确位置、固定 &#x2F; 悬浮元素 → 用定位。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;定位（&lt;code&gt;position&lt;/code&gt;）是 CSS 中控制元素&lt;strong&gt;精确位置&lt;/strong&gt;的核心属性，通过改变元素在页面中的布局规则（脱离标准文档流或保留文档流位置），实现浮动无法完成的复杂布局（如固定导航、弹窗、元素叠加等）。本文将从核心概念、属性值、定位规则、应用场景及常见问题全面解析。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS_浮动</title>
    <link href="http://example.com/2025/11/11/CSS-%E6%B5%AE%E5%8A%A8/"/>
    <id>http://example.com/2025/11/11/CSS-%E6%B5%AE%E5%8A%A8/</id>
    <published>2025-11-11T13:03:46.000Z</published>
    <updated>2025-11-25T15:47:16.138Z</updated>
    
    <content type="html"><![CDATA[<p>浮动（<code>float</code>）是 CSS 中用于<strong>实现元素水平排列、文字环绕</strong>的核心属性，曾是网页布局的基础（如多列布局），虽如今被 Flex&#x2F;Grid 替代，但在文字环绕、局部布局等场景仍广泛使用。本文将从核心概念、用法、特性、问题及解决方案全面解析。</p><span id="more"></span><h1 id="CSS-浮动（float）详解"><a href="#CSS-浮动（float）详解" class="headerlink" title="CSS 浮动（float）详解"></a>CSS 浮动（float）详解</h1><h2 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h2><p>浮动的本质是：<strong>让元素 “脱离标准文档流”，并向左 &#x2F; 向右浮动，直到碰到父元素边界或其他浮动元素</strong>。</p><ul><li>标准文档流：元素默认的排列规则（块级元素独占一行、行内元素横向排列）。</li><li>浮动后元素特性：<ol><li>脱离文档流，但<strong>不脱离文本流</strong>（文字会环绕浮动元素）；</li><li>块级元素、行内元素浮动后，都会自动转为 “行内块级元素”（可设置宽高，且不独占一行）；</li><li>浮动元素的父元素若未特殊处理，会 “塌陷”（高度为 0）。</li></ol></li></ul><h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><pre><code class="css">float: none | left | right | inherit;</code></pre><ul><li><code>none</code>：默认值，不浮动（遵循标准文档流）；</li><li><code>left</code>：元素向左浮动；</li><li><code>right</code>：元素向右浮动；</li><li><code>inherit</code>：继承父元素的 <code>float</code> 属性（极少用）。</li></ul><h3 id="2-基础示例"><a href="#2-基础示例" class="headerlink" title="2. 基础示例"></a>2. 基础示例</h3><h4 id="（1）文字环绕图片（最经典场景）"><a href="#（1）文字环绕图片（最经典场景）" class="headerlink" title="（1）文字环绕图片（最经典场景）"></a>（1）文字环绕图片（最经典场景）</h4><pre><code class="html">&lt;style&gt;  .img-float &#123;    float: left; /* 图片向左浮动 */    width: 150px;    margin-right: 15px; /* 与文字间距 */  &#125;&lt;/style&gt;&lt;div&gt;  &lt;img src=&quot;image.jpg&quot; class=&quot;img-float&quot; alt=&quot;示例图&quot;&gt;  &lt;p&gt;这是一段环绕图片的文字... 文字会自动避开浮动的图片，形成自然的环绕效果，常用于文章配图场景。&lt;/p&gt;&lt;/div&gt;</code></pre><h4 id="（2）多元素水平排列（早期布局方式）"><a href="#（2）多元素水平排列（早期布局方式）" class="headerlink" title="（2）多元素水平排列（早期布局方式）"></a>（2）多元素水平排列（早期布局方式）</h4><pre><code class="html">&lt;style&gt;  .box &#123;    float: left; /* 三个盒子均向左浮动 */    width: 30%;    height: 100px;    margin: 0 1.5%;    background: #f0f0f0;  &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;盒子3&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>效果：三个盒子横向排列（需确保总宽度 ≤ 父容器宽度，避免换行）。</li></ul><h2 id="三、浮动的关键特性"><a href="#三、浮动的关键特性" class="headerlink" title="三、浮动的关键特性"></a>三、浮动的关键特性</h2><h3 id="1-脱离标准文档流，但不脱离文本流"><a href="#1-脱离标准文档流，但不脱离文本流" class="headerlink" title="1. 脱离标准文档流，但不脱离文本流"></a>1. 脱离标准文档流，但不脱离文本流</h3><ul><li>脱离文档流：浮动元素不再占据原文档流的位置，后续的标准流元素会 “向上顶”（覆盖浮动元素的位置）；</li><li>不脱离文本流：后续的文字 &#x2F; 行内元素会自动环绕浮动元素，不会被覆盖。</li></ul><p>示例对比：</p><pre><code class="html">&lt;style&gt;  .float-box &#123;    float: left;    width: 100px;    height: 100px;    background: red;  &#125;  .normal-box &#123;    width: 200px;    height: 200px;    background: #ccc; /* 灰色盒子会向上顶，但文字会环绕红色浮动盒 */  &#125;&lt;/style&gt;&lt;div class=&quot;float-box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;normal-box&quot;&gt;我是标准流盒子的文字，会环绕浮动元素&lt;/div&gt;</code></pre><h3 id="2-浮动元素的-“包裹性”"><a href="#2-浮动元素的-“包裹性”" class="headerlink" title="2. 浮动元素的 “包裹性”"></a>2. 浮动元素的 “包裹性”</h3><p>浮动元素的宽度默认由<strong>内容决定</strong>（类似 <code>inline-block</code>），而非占满父容器（块级元素默认行为）。</p><p>示例：</p><pre><code class="css">.float-box &#123;  float: left;  background: blue;  color: white;&#125;</code></pre><pre><code class="html">&lt;div class=&quot;float-box&quot;&gt;我是浮动元素，宽度由内容决定&lt;/div&gt;</code></pre><ul><li>效果：元素宽度仅包裹内容，而非占满父容器。</li></ul><h3 id="3-浮动元素的-“堆叠”-规则"><a href="#3-浮动元素的-“堆叠”-规则" class="headerlink" title="3. 浮动元素的 “堆叠” 规则"></a>3. 浮动元素的 “堆叠” 规则</h3><p>多个浮动元素会按浮动方向依次排列，不会重叠：</p><ul><li>左浮动：元素从左到右依次排列，超出父容器则换行；</li><li>右浮动：元素从右到左依次排列。</li></ul><pre><code class="css">.box &#123;  float: left;  width: 100px;  height: 100px;  margin: 10px;  background: green;&#125;</code></pre><pre><code class="html">&lt;div class=&quot;box&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;3&lt;/div&gt;</code></pre><ul><li>效果：三个盒子从左到右排列，间距由 <code>margin</code> 控制。</li></ul><h2 id="四、浮动的核心问题：父元素塌陷"><a href="#四、浮动的核心问题：父元素塌陷" class="headerlink" title="四、浮动的核心问题：父元素塌陷"></a>四、浮动的核心问题：父元素塌陷</h2><h3 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1. 问题现象"></a>1. 问题现象</h3><p>当父元素的所有子元素都是浮动元素时，父元素会失去高度（高度为 0），导致页面布局错乱。</p><p>示例：</p><pre><code class="html">&lt;style&gt;  .parent &#123;    border: 2px solid #000; /* 父元素边框 */  &#125;  .child &#123;    float: left;    width: 100px;    height: 100px;    background: yellow;  &#125;&lt;/style&gt;&lt;div class=&quot;parent&quot;&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>效果：父元素的边框仅显示一条线（高度为 0），子元素 “溢出” 父容器。</li></ul><h3 id="2-解决方案（清除浮动）"><a href="#2-解决方案（清除浮动）" class="headerlink" title="2. 解决方案（清除浮动）"></a>2. 解决方案（清除浮动）</h3><p>清除浮动的核心是：<strong>让父元素重新感知浮动子元素的高度</strong>，常用 4 种方法：</p><h4 id="（1）额外标签法（最简单，不推荐）"><a href="#（1）额外标签法（最简单，不推荐）" class="headerlink" title="（1）额外标签法（最简单，不推荐）"></a>（1）额外标签法（最简单，不推荐）</h4><p>在父元素末尾添加一个空的块级元素，设置 <code>clear: both</code>：</p><pre><code class="html">&lt;div class=&quot;parent&quot;&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;  &lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt; &lt;!-- 额外空标签 --&gt;&lt;/div&gt;</code></pre><ul><li>原理：<code>clear: both</code> 表示该元素不允许左右两侧有浮动元素，迫使父元素拉伸高度包裹子元素；</li><li>缺点：增加无意义 DOM 元素，影响代码整洁。</li></ul><h4 id="（2）父元素设置-overflow-hidden（简单，慎用）"><a href="#（2）父元素设置-overflow-hidden（简单，慎用）" class="headerlink" title="（2）父元素设置 overflow: hidden（简单，慎用）"></a>（2）父元素设置 <code>overflow: hidden</code>（简单，慎用）</h4><p>给父元素添加 <code>overflow: hidden</code> 或 <code>overflow: auto</code>：</p><pre><code class="css">.parent &#123;  border: 2px solid #000;  overflow: hidden; /* 触发 BFC，清除浮动 */&#125;</code></pre><ul><li><p>原理：<code>overflow: hidden</code> 会触发父元素的 <strong>BFC（块级格式化上下文）</strong>，BFC 元素会包裹所有子元素（包括浮动元素）；</p></li><li><p>缺点：若子元素有溢出（如下拉菜单、弹出层），会被父元素裁剪，适用于无溢出场景。</p></li><li><p>补充：<code>overflow</code></p><p>CSS样式<code>overflow</code>用于控制元素内容溢出时的处理方式。<code>overflow</code>属性有以下常见取值：</p><p><code>visible</code>：默认值，内容会溢出到元素框之外。<br><code>hidden</code>：内容会被裁剪，并且不可见。<br><code>scroll</code>：如果内容溢出，会显示滚动条。<br><code>auto</code>：如果内容溢出，会显示滚动条，只有在需要时才显示。<br><code>inherit</code>：继承父元素的overflow属性。</p></li></ul><h4 id="（3）父元素也浮动（不推荐）"><a href="#（3）父元素也浮动（不推荐）" class="headerlink" title="（3）父元素也浮动（不推荐）"></a>（3）父元素也浮动（不推荐）</h4><p>给父元素添加 <code>float: left/right</code>：</p><pre><code class="css">.parent &#123;  border: 2px solid #000;  float: left;  width: 100%; /* 需手动设置宽度，否则由内容决定 */&#125;</code></pre><ul><li>原理：浮动的父元素会自动包裹浮动子元素；</li><li>缺点：父元素浮动后会脱离文档流，可能导致后续元素布局错乱，需嵌套更多容器解决。</li></ul><h4 id="（4）伪元素清除法（推荐，无副作用）"><a href="#（4）伪元素清除法（推荐，无副作用）" class="headerlink" title="（4）伪元素清除法（推荐，无副作用）"></a>（4）伪元素清除法（推荐，无副作用）</h4><p>利用父元素的 <code>::after</code> 伪元素模拟 “额外标签”，不增加真实 DOM：</p><pre><code class="css">/* 通用清除浮动类 */.clearfix::after &#123;  content: &quot;&quot;; /* 伪元素必须有 content */  display: block; /* 转为块级元素 */  clear: both; /* 清除左右浮动 */  visibility: hidden; /* 隐藏伪元素 */  height: 0; /* 高度为 0，不占空间 */&#125;/* 兼容 IE6/7（已淘汰，可选） */.clearfix &#123;  *zoom: 1;&#125;</code></pre><p>使用时给父元素添加 <code>clearfix</code> 类：</p><pre><code class="html">&lt;div class=&quot;parent clearfix&quot;&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>优点：无额外 DOM、无副作用，兼容所有现代浏览器，是工业界标准方案。</li></ul><h2 id="五、clear-属性详解"><a href="#五、clear-属性详解" class="headerlink" title="五、clear 属性详解"></a>五、<code>clear</code> 属性详解</h2><p><code>clear</code> 用于控制元素是否允许周围有浮动元素，仅对<strong>块级元素</strong>有效。</p><h3 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1. 语法"></a>1. 语法</h3><pre><code class="css">clear: none | left | right | both;</code></pre><ul><li><code>none</code>：默认值，允许左右两侧有浮动元素；</li><li><code>left</code>：不允许左侧有浮动元素；</li><li><code>right</code>：不允许右侧有浮动元素；</li><li><code>both</code>：不允许左右两侧有浮动元素（最常用）。</li></ul><h3 id="2-示例：清除右侧浮动"><a href="#2-示例：清除右侧浮动" class="headerlink" title="2. 示例：清除右侧浮动"></a>2. 示例：清除右侧浮动</h3><pre><code class="html">&lt;style&gt;  .float-right &#123;    float: right;    width: 100px;    height: 100px;    background: purple;  &#125;  .clear-right &#123;    clear: right; /* 不允许右侧有浮动元素 */    background: #eee;  &#125;&lt;/style&gt;&lt;div class=&quot;float-right&quot;&gt;&lt;/div&gt;&lt;p class=&quot;clear-right&quot;&gt;这段文字不允许右侧有浮动元素，会自动换行到浮动元素下方。&lt;/p&gt;</code></pre><h2 id="六、浮动的适用场景与替代方案"><a href="#六、浮动的适用场景与替代方案" class="headerlink" title="六、浮动的适用场景与替代方案"></a>六、浮动的适用场景与替代方案</h2><h3 id="1-适用场景（现代开发仍常用）"><a href="#1-适用场景（现代开发仍常用）" class="headerlink" title="1. 适用场景（现代开发仍常用）"></a>1. 适用场景（现代开发仍常用）</h3><ul><li>文字环绕图片 &#x2F; 元素；</li><li>局部小布局（如导航栏按钮横向排列）；</li><li>兼容旧浏览器的简单布局。</li></ul><h3 id="2-替代方案（现代布局首选）"><a href="#2-替代方案（现代布局首选）" class="headerlink" title="2. 替代方案（现代布局首选）"></a>2. 替代方案（现代布局首选）</h3><p>如今浮动已不再是布局首选，以下方案更简洁、强大：</p><ul><li><strong>Flex 布局</strong>：适合一维布局（横向 &#x2F; 纵向排列），替代浮动实现多列布局、居中对齐等；</li><li><strong>Grid 布局</strong>：适合二维布局（行列同时控制），替代复杂的浮动嵌套布局；</li><li><strong>inline-block</strong>：适合简单横向排列（无父元素塌陷问题，但需处理缝隙）。</li></ul><p>示例：Flex 替代浮动实现多列布局</p><pre><code class="html">&lt;style&gt;  .container &#123;    display: flex; /* 父元素设为 Flex 容器 */    gap: 20px; /* 子元素间距（替代 margin） */  &#125;  .box &#123;    flex: 1; /* 子元素等分宽度 */    height: 100px;    background: #f0f0f0;  &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;盒子3&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>优点：无需清除浮动、自动适配、易于对齐，代码更简洁。</li></ul><h2 id="七、常见误区"><a href="#七、常见误区" class="headerlink" title="七、常见误区"></a>七、常见误区</h2><ol><li><p>浮动元素会被 <code>margin: auto</code> 居中？ </p><p>不会！<code>margin: auto</code>仅对标准流的块级元素有效，浮动元素需通过父容器<code>text-align: center</code>+ 自身<code>display: inline-block</code>实现居中（或直接用 Flex）。</p></li><li><p>浮动元素可以覆盖文字？</p><p>不能！浮动元素脱离文档流但不脱离文本流，文字会自动环绕，若想覆盖需用 （绝对定位）。</p></li><li><p>清除浮动后，浮动元素会回到标准流？</p><p>不会！清除浮动仅影响 “后续元素” 和 “父元素高度”，浮动元素本身仍脱离标准流。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;浮动（&lt;code&gt;float&lt;/code&gt;）是 CSS 中用于&lt;strong&gt;实现元素水平排列、文字环绕&lt;/strong&gt;的核心属性，曾是网页布局的基础（如多列布局），虽如今被 Flex&amp;#x2F;Grid 替代，但在文字环绕、局部布局等场景仍广泛使用。本文将从核心概念、用法、特性、问题及解决方案全面解析。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="http://example.com/2025/11/11/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2025/11/11/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</id>
    <published>2025-11-11T12:35:48.000Z</published>
    <updated>2025-11-26T05:13:08.890Z</updated>
    
    <content type="html"><![CDATA[<p>优先队列是一种<strong>特殊的队列数据结构</strong>，核心区别于普通队列的 “先进先出（FIFO）” 规则 —— 它按元素的<strong>优先级</strong>排序，每次出队时，总是取出优先级最高（或最低）的元素。无论是算法优化（如最短路径、排序）还是工程场景（如任务调度），优先队列都是解决 “动态选择最优元素” 问题的核心工具。</p><span id="more"></span><h1 id="优先队列（Priority-Queue）"><a href="#优先队列（Priority-Queue）" class="headerlink" title="优先队列（Priority Queue）"></a>优先队列（Priority Queue）</h1><h2 id="一、核心概念与核心特性"><a href="#一、核心概念与核心特性" class="headerlink" title="一、核心概念与核心特性"></a>一、核心概念与核心特性</h2><h3 id="1-与普通队列的本质区别"><a href="#1-与普通队列的本质区别" class="headerlink" title="1. 与普通队列的本质区别"></a>1. 与普通队列的本质区别</h3><table><thead><tr><th>特性</th><th>普通队列（FIFO）</th><th>优先队列</th></tr></thead><tbody><tr><td>排序依据</td><td>元素入队顺序</td><td>元素的优先级（自定义规则）</td></tr><tr><td>出队元素</td><td>最早入队的元素</td><td>优先级最高 &#x2F; 最低的元素</td></tr><tr><td>核心操作效率</td><td>入队 &#x2F; 出队均 O (1)</td><td>取决于实现（最优 O (logn)）</td></tr><tr><td>典型应用</td><td>消息队列、广度优先搜索（BFS）</td><td>最短路径、任务调度、堆排序</td></tr></tbody></table><h3 id="2-优先级的两种核心约定"><a href="#2-优先级的两种核心约定" class="headerlink" title="2. 优先级的两种核心约定"></a>2. 优先级的两种核心约定</h3><p>优先队列的优先级由 “关键值” 定义，最常用两种规则：</p><ul><li><strong>大顶堆（Max-Heap）</strong>：优先级最高 &#x3D; 关键值最大（默认优先出最大元素，如 “优先级 10&gt; 优先级 5”）；</li><li><strong>小顶堆（Min-Heap）</strong>：优先级最高 &#x3D; 关键值最小（默认优先出最小元素，如 “距离 1 &lt; 距离 3”）；</li><li>扩展：可自定义优先级（如任务 “截止时间早” 优先、订单 “加急标识” 优先）。</li></ul><h3 id="3-必须支持的核心操作"><a href="#3-必须支持的核心操作" class="headerlink" title="3. 必须支持的核心操作"></a>3. 必须支持的核心操作</h3><p>优先队列的价值在于 “高效动态维护最优元素”，标准核心操作如下：</p><table><thead><tr><th>操作名称</th><th>功能描述</th><th>目标时间复杂度</th></tr></thead><tbody><tr><td><code>insert(x)</code> &#x2F; <code>push(x)</code></td><td>向队列中插入元素 x，维持优先级排序</td><td>O(logn)</td></tr><tr><td><code>extract-max()</code> &#x2F; <code>extract-min()</code></td><td>取出并删除优先级最高的元素</td><td>O(logn)</td></tr><tr><td><code>peek()</code> &#x2F; <code>top()</code></td><td>查看（不删除）优先级最高的元素</td><td>O(1)</td></tr><tr><td><code>delete(x)</code></td><td>删除队列中指定元素 x（可选，按需实现）</td><td>O(logn)</td></tr><tr><td><code>update-priority(x)</code></td><td>修改元素 x 的优先级（可选，按需实现）</td><td>O(logn)</td></tr></tbody></table><h2 id="二、优先队列的三种实现方式（对比分析）"><a href="#二、优先队列的三种实现方式（对比分析）" class="headerlink" title="二、优先队列的三种实现方式（对比分析）"></a>二、优先队列的三种实现方式（对比分析）</h2><p>优先队列的效率核心是 “如何快速找到并维护最优元素”，三种常见实现各有优劣，<strong>堆实现是工业界标准</strong>：</p><h3 id="1-数组-链表（朴素实现）"><a href="#1-数组-链表（朴素实现）" class="headerlink" title="1. 数组 &#x2F; 链表（朴素实现）"></a>1. 数组 &#x2F; 链表（朴素实现）</h3><ul><li><strong>原理</strong>：元素直接存储在数组或链表中，插入时直接尾插（O (1)），取最优元素时遍历整个集合查找（O (n)）。</li><li>时间复杂度：<ul><li>插入：O (1)（无需排序，直接追加）；</li><li>取最优元素：O (n)（遍历所有元素找最值）；</li><li>删除最优元素：O (n)（查找后需移动元素填补空位）。</li></ul></li><li><strong>适用场景</strong>：元素数量极少（n &lt; 100），或插入操作远多于查询操作（几乎不用在实际开发）。</li></ul><h3 id="2-有序数组-有序链表（改进实现）"><a href="#2-有序数组-有序链表（改进实现）" class="headerlink" title="2. 有序数组 &#x2F; 有序链表（改进实现）"></a>2. 有序数组 &#x2F; 有序链表（改进实现）</h3><ul><li><strong>原理</strong>：插入时维持数组 &#x2F; 链表有序（按优先级排序），取最优元素时直接取表头 &#x2F; 表尾（O (1)）。</li><li>时间复杂度：<ul><li>插入：O (n)（需找到插入位置，移动后续元素）；</li><li>取最优元素：O (1)（有序结构的首尾即为最值）；</li><li>删除最优元素：O (1)（链表表头删除，数组仍需移动元素 O (n)）。</li></ul></li><li><strong>适用场景</strong>：查询操作远多于插入操作（仍不推荐，效率低于堆）。</li></ul><h3 id="3-堆（Heap）（最优实现）"><a href="#3-堆（Heap）（最优实现）" class="headerlink" title="3. 堆（Heap）（最优实现）"></a>3. 堆（Heap）（最优实现）</h3><p>堆是优先队列的<strong>标准实现方式</strong>，本质是一棵满足 “堆性质” 的<strong>完全二叉树</strong>（完全二叉树：除最后一层外，每一层节点数均满，最后一层从左到右连续排列）。</p><h4 id="堆的核心性质"><a href="#堆的核心性质" class="headerlink" title="堆的核心性质"></a>堆的核心性质</h4><ul><li>大顶堆：每个父节点的关键值 ≥ 左右子节点的关键值；</li><li>小顶堆：每个父节点的关键值 ≤ 左右子节点的关键值；</li><li>存储优势：完全二叉树可通过<strong>数组</strong>高效存储（无需指针，通过索引计算父子关系），空间开销极小。</li></ul><h4 id="数组与堆的索引映射（核心！）"><a href="#数组与堆的索引映射（核心！）" class="headerlink" title="数组与堆的索引映射（核心！）"></a>数组与堆的索引映射（核心！）</h4><p>假设数组索引从 0 开始，对于任意节点 i：</p><ul><li>左子节点索引 &#x3D; <code>2i + 1</code></li><li>右子节点索引 &#x3D; <code>2i + 2</code></li><li>父节点索引 &#x3D; <code>(i - 1) // 2</code>（整数除法）</li></ul><p>例：索引 0（根节点）的左子节点是 1，右子节点是 2；索引 3 的父节点是 (3-1)&#x2F;2 &#x3D; 1。</p><h4 id="堆的高效操作原理（核心！上浮与下沉）"><a href="#堆的高效操作原理（核心！上浮与下沉）" class="headerlink" title="堆的高效操作原理（核心！上浮与下沉）"></a>堆的高效操作原理（核心！上浮与下沉）</h4><p>堆的所有操作（插入、删除）都依赖两个核心调整动作，确保操作后仍满足堆性质，时间复杂度均为 O (logn)（树的高度为 logn）。</p><h5 id="（1）插入元素（insert-push）：上浮（sift-up）"><a href="#（1）插入元素（insert-push）：上浮（sift-up）" class="headerlink" title="（1）插入元素（insert&#x2F;push）：上浮（sift up）"></a>（1）插入元素（insert&#x2F;push）：上浮（sift up）</h5><ol><li>将新元素插入数组<strong>末尾</strong>（完全二叉树的最后一个位置，保证结构完整）；</li><li>执行 “上浮”：将新元素与父节点比较，若不满足堆性质（如大顶堆中子节点 &gt; 父节点），则交换父子节点；</li><li>重复步骤 2，直到元素到达根节点或满足堆性质。</li></ol><h5 id="（2）取出最优元素（extract-max-extract-min）：下沉（sift-down）"><a href="#（2）取出最优元素（extract-max-extract-min）：下沉（sift-down）" class="headerlink" title="（2）取出最优元素（extract-max&#x2F;extract-min）：下沉（sift down）"></a>（2）取出最优元素（extract-max&#x2F;extract-min）：下沉（sift down）</h5><ol><li>取出数组<strong>第一个元素</strong>（根节点，即最值）；</li><li>将数组<strong>末尾元素</strong>移到根节点位置（维持完全二叉树结构）；</li><li>执行 “下沉”：将当前节点与左右子节点中 “符合堆性质的最值子节点”（如大顶堆找最大子节点）比较，若不满足堆性质则交换；</li><li>重复步骤 3，直到元素到达叶子节点或满足堆性质。</li></ol><h5 id="（3）查看最优元素（top-peek）"><a href="#（3）查看最优元素（top-peek）" class="headerlink" title="（3）查看最优元素（top&#x2F;peek）"></a>（3）查看最优元素（top&#x2F;peek）</h5><p>直接返回数组第一个元素（根节点），O (1) 时间。</p><h4 id="堆实现的优势"><a href="#堆实现的优势" class="headerlink" title="堆实现的优势"></a>堆实现的优势</h4><ul><li>兼顾插入和查询效率：所有核心操作均为 O (logn)，是三种实现中综合性能最优的；</li><li>空间高效：数组存储，无额外指针开销；</li><li>实现简单：仅依赖 “上浮”“下沉” 两个核心函数，易工程化。</li></ul><h2 id="三、主流语言的优先队列使用（实战重点）"><a href="#三、主流语言的优先队列使用（实战重点）" class="headerlink" title="三、主流语言的优先队列使用（实战重点）"></a>三、主流语言的优先队列使用（实战重点）</h2><h3 id="C-标准库-priority-queue"><a href="#C-标准库-priority-queue" class="headerlink" title="C++ 标准库 priority_queue"></a>C++ 标准库 <code>priority_queue</code></h3><p>C++ 中 <code>priority_queue</code> 是<strong>容器适配器</strong>（定义在 &#96;&#96; 头文件），默认基于大顶堆实现，底层依赖 <code>vector</code> 存储。</p><h4 id="基本模板定义"><a href="#基本模板定义" class="headerlink" title="基本模板定义"></a>基本模板定义</h4><pre><code class="cpp">template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;T&gt;&gt;class priority_queue;</code></pre><ul><li><code>T</code>：元素类型（如 <code>int</code>、自定义结构体）；</li><li><code>Container</code>：底层存储容器（默认 <code>vector</code>，支持 <code>deque</code>）；</li><li><code>Compare</code>：比较函数（默认 <code>less</code> 大顶堆，<code>greater</code> 小顶堆）。</li></ul><h4 id="核心用法示例"><a href="#核心用法示例" class="headerlink" title="核心用法示例"></a>核心用法示例</h4><h5 id="（1）默认大顶堆（int-类型）"><a href="#（1）默认大顶堆（int-类型）" class="headerlink" title="（1）默认大顶堆（int 类型）"></a>（1）默认大顶堆（int 类型）</h5><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123;    priority_queue&lt;int&gt; max_heap;  // 大顶堆：大元素优先出队    // 插入元素    max_heap.push(3);    max_heap.push(1);    max_heap.push(5);    max_heap.push(2);    // 查看堆顶（最大值）    cout &lt;&lt; &quot;堆顶元素：&quot; &lt;&lt; max_heap.top() &lt;&lt; endl;  // 输出 5    // 出队（删除堆顶）    max_heap.pop();    cout &lt;&lt; &quot;出队后堆顶：&quot; &lt;&lt; max_heap.top() &lt;&lt; endl;  // 输出 3    // 遍历（需出队，遍历后队列空）    cout &lt;&lt; &quot;出队顺序：&quot;;    while (!max_heap.empty()) &#123;        cout &lt;&lt; max_heap.top() &lt;&lt; &quot; &quot;;        max_heap.pop();    &#125;  // 输出 3 2 1    return 0;&#125;</code></pre><h5 id="（2）小顶堆（用-greater）"><a href="#（2）小顶堆（用-greater）" class="headerlink" title="（2）小顶堆（用 greater）"></a>（2）小顶堆（用 <code>greater</code>）</h5><p>需包含 <code>&lt;functional&gt;</code> 头文件（<code>greater</code> 定义在此）：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;functional&gt;  // 包含 greater&lt;T&gt;using namespace std;int main() &#123;    // 小顶堆：小元素优先出队    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap;    min_heap.push(3);    min_heap.push(1);    min_heap.push(5);    min_heap.push(2);    cout &lt;&lt; &quot;堆顶元素：&quot; &lt;&lt; min_heap.top() &lt;&lt; endl;  // 输出 1    cout &lt;&lt; &quot;出队顺序：&quot;;    while (!min_heap.empty()) &#123;        cout &lt;&lt; min_heap.top() &lt;&lt; &quot; &quot;;        min_heap.pop();    &#125;  // 输出 1 2 3 5    return 0;&#125;</code></pre><h5 id="（3）自定义结构体（任务调度场景）"><a href="#（3）自定义结构体（任务调度场景）" class="headerlink" title="（3）自定义结构体（任务调度场景）"></a>（3）自定义结构体（任务调度场景）</h5><p>需重载 <code>operator&lt;</code> 或自定义比较结构体，定义优先级规则：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;// 自定义任务结构体：包含名称、优先级（10最高）、IDstruct Task &#123;    string name;    int priority;    int id;    // 重载 &lt; 运算符：定义大顶堆规则（优先级高的先执行，同优先级ID小的先执行）    bool operator&lt;(const Task&amp; other) const &#123;        if (priority != other.priority) &#123;            return priority &lt; other.priority;  // 优先级大的优先        &#125; else &#123;            return id &gt; other.id;  // ID小的优先        &#125;    &#125;&#125;;int main() &#123;    priority_queue&lt;Task&gt; task_queue;    // 插入任务    task_queue.push(&#123;&quot;紧急修复&quot;, 10, 101&#125;);    task_queue.push(&#123;&quot;功能开发&quot;, 8, 102&#125;);    task_queue.push(&#123;&quot;优化测试&quot;, 8, 103&#125;);    task_queue.push(&#123;&quot;文档编写&quot;, 5, 104&#125;);    // 执行任务（按优先级排序）    cout &lt;&lt; &quot;任务执行顺序：\n&quot;;    while (!task_queue.empty()) &#123;        Task t = task_queue.top();        task_queue.pop();        cout &lt;&lt; &quot;ID:&quot; &lt;&lt; t.id &lt;&lt; &quot; | 名称:&quot; &lt;&lt; t.name &lt;&lt; &quot; | 优先级:&quot; &lt;&lt; t.priority &lt;&lt; endl;    &#125;    /* 输出：    ID:101 | 名称:紧急修复 | 优先级:10    ID:102 | 名称:功能开发 | 优先级:8    ID:103 | 名称:优化测试 | 优先级:8    ID:104 | 名称:文档编写 | 优先级:5    */    return 0;&#125;</code></pre><h2 id="五、典型应用场景"><a href="#五、典型应用场景" class="headerlink" title="五、典型应用场景"></a>五、典型应用场景</h2><p>优先队列的核心价值是 “动态获取最优元素”，以下是最经典的应用场景：</p><h3 id="1-堆排序（时间复杂度-O-nlogn-）"><a href="#1-堆排序（时间复杂度-O-nlogn-）" class="headerlink" title="1. 堆排序（时间复杂度 O (nlogn)）"></a>1. 堆排序（时间复杂度 O (nlogn)）</h3><p>利用堆的性质实现高效排序，步骤：</p><ol><li>构建大顶堆（O (n) 时间）；</li><li>反复弹出堆顶（最大值），放入结果数组末尾，同时调整堆（O (nlogn) 时间）；</li><li>最终结果数组为升序（小顶堆可实现降序）。</li></ol><h3 id="2-Dijkstra-最短路径算法（无负权图）"><a href="#2-Dijkstra-最短路径算法（无负权图）" class="headerlink" title="2. Dijkstra 最短路径算法（无负权图）"></a>2. Dijkstra 最短路径算法（无负权图）</h3><p>在带权无负边图中，需不断选择 “当前距离起点最近的节点” 扩展，优先队列（小顶堆）用于高效获取该节点：</p><ul><li>队列元素为 <code>(当前距离, 节点)</code>，按距离排序；</li><li>每次弹出距离最小的节点，更新其邻接节点的距离，若更新后更优则加入队列。</li></ul><h3 id="3-任务调度系统"><a href="#3-任务调度系统" class="headerlink" title="3. 任务调度系统"></a>3. 任务调度系统</h3><p>按任务优先级执行，例如：</p><ul><li>操作系统进程调度（高优先级进程先占用 CPU）；</li><li>外卖 &#x2F; 快递调度（加急订单优先配送）；</li><li>服务器请求处理（VIP 用户请求优先响应）。</li></ul><h3 id="4-合并-k-个有序链表（LeetCode-困难题）"><a href="#4-合并-k-个有序链表（LeetCode-困难题）" class="headerlink" title="4. 合并 k 个有序链表（LeetCode 困难题）"></a>4. 合并 k 个有序链表（LeetCode 困难题）</h3><p>需反复选择 “所有链表头中最小的节点”，优先队列（小顶堆）用于高效获取：</p><ul><li>队列元素为 <code>(节点值, 链表索引, 节点)</code>，按节点值排序；</li><li>每次弹出最小节点，将其下一个节点（若有）加入队列，直到所有链表合并完成。</li></ul><h3 id="5-Huffman-编码（数据压缩）"><a href="#5-Huffman-编码（数据压缩）" class="headerlink" title="5. Huffman 编码（数据压缩）"></a>5. Huffman 编码（数据压缩）</h3><p>构建最优前缀编码树时，需反复合并 “频率最低的两个节点”，优先队列（小顶堆）用于高效获取这两个节点，最终实现最小冗余编码。</p><h3 id="6-求-Top-K-问题（如前-K-个高频元素、第-K-大元素）"><a href="#6-求-Top-K-问题（如前-K-个高频元素、第-K-大元素）" class="headerlink" title="6. 求 Top K 问题（如前 K 个高频元素、第 K 大元素）"></a>6. 求 Top K 问题（如前 K 个高频元素、第 K 大元素）</h3><p>用小顶堆维护 K 个元素，遍历所有元素时，若元素大于堆顶则替换堆顶并调整，最终堆内即为 Top K 大元素（时间复杂度 O (nlogK)，比排序 O (nlogn) 更高效）。</p><h2 id="六、注意事项与进阶技巧"><a href="#六、注意事项与进阶技巧" class="headerlink" title="六、注意事项与进阶技巧"></a>六、注意事项与进阶技巧</h2><ol><li><strong>优先级队列的 “无序性”</strong>：底层是堆结构，存储容器中的元素并非完全有序，仅保证堆顶是最优元素，不能直接遍历获取有序序列（需通过出队实现）；</li><li>自定义优先级的两种方式：<ul><li>基本类型：C++ 用 <code>greater</code>&#x2F;<code>less</code>，Python 用负数反转；</li><li>自定义结构体：C++ 重载 <code>operator&lt;</code> 或定义比较结构体，Python 可传入自定义比较函数（需配合 <code>functools.cmp_to_key</code>）；</li></ul></li><li>效率优化：<ul><li>已知元素数量时，提前为底层容器分配空间（如 C++ <code>vector.reserve()</code>），减少扩容开销；</li><li>批量构建堆时，用 <code>heapify</code>（Python）或手动实现的批量建堆（O (n) 时间），比逐个插入（O (nlogn)）更高效；</li></ul></li><li>与其他数据结构的选择：<ul><li>若需 “动态插入 + 频繁查最值”：优先队列（堆实现）是最优选择；</li><li>若需 “静态查最值”（无插入删除）：直接遍历找最值（O (n)）更简单；</li><li>若需 “有序遍历 + 频繁插入删除”：平衡二叉搜索树（如 C++ <code>set</code>&#x2F;<code>map</code>）更合适（但优先级队列效率更高）。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;优先队列是一种&lt;strong&gt;特殊的队列数据结构&lt;/strong&gt;，核心区别于普通队列的 “先进先出（FIFO）” 规则 —— 它按元素的&lt;strong&gt;优先级&lt;/strong&gt;排序，每次出队时，总是取出优先级最高（或最低）的元素。无论是算法优化（如最短路径、排序）还是工程场景（如任务调度），优先队列都是解决 “动态选择最优元素” 问题的核心工具。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="堆" scheme="http://example.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>CSS3弹性盒子模型</title>
    <link href="http://example.com/2025/11/10/CSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2025/11/10/CSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-11-10T12:11:47.000Z</published>
    <updated>2025-11-25T15:47:49.775Z</updated>
    
    <content type="html"><![CDATA[<p>CSS3 弹性盒子模型（Flexible Box，简称 Flexbox）是一种<strong>一维布局模型</strong>，专为解决传统布局（<code>float</code>、<code>position</code>）的对齐复杂、自适应繁琐等问题设计，现已成为前端布局的首选方案。它通过「容器 - 项目」的结构，轻松实现元素的对齐、分布、伸缩和自适应，兼容性覆盖所有现代浏览器（IE11 部分支持）。</p><span id="more"></span><h1 id="CSS3-弹性盒子（Flexbox"><a href="#CSS3-弹性盒子（Flexbox" class="headerlink" title="CSS3 弹性盒子（Flexbox"></a>CSS3 弹性盒子（Flexbox</h1><h2 id="一、核心原理与概念"><a href="#一、核心原理与概念" class="headerlink" title="一、核心原理与概念"></a>一、核心原理与概念</h2><p>Flexbox 的布局逻辑围绕「主轴」和「交叉轴」展开，核心是通过控制容器和项目的属性，实现灵活的布局效果。先明确以下关键概念：</p><table><thead><tr><th>概念</th><th>定义与说明</th></tr></thead><tbody><tr><td>弹性容器（Flex Container）</td><td>父元素通过 <code>display: flex</code> 或 <code>display: inline-flex</code> 声明，其直接子元素自动成为弹性项目</td></tr><tr><td>弹性项目（Flex Item）</td><td>弹性容器的<strong>直接子元素</strong>（不包含嵌套子元素），默认沿主轴排列</td></tr><tr><td>主轴（Main Axis）</td><td>项目排列的主方向，由 <code>flex-direction</code> 控制（默认水平向左→右）</td></tr><tr><td>交叉轴（Cross Axis）</td><td>与主轴垂直的方向（默认垂直向上→下），所有交叉轴相关属性（如 <code>align-items</code>）均作用于此方向</td></tr><tr><td>主轴起点 &#x2F; 终点（Main Start&#x2F;End）</td><td>主轴的开始和结束位置（如水平主轴的左 &#x2F; 右）</td></tr><tr><td>交叉轴起点 &#x2F; 终点（Cross Start&#x2F;End）</td><td>交叉轴的开始和结束位置（如垂直交叉轴的上 &#x2F; 下）</td></tr><tr><td>基线（Baseline）</td><td>项目内文字的基准线（<code>align-items: baseline</code> 时按此对齐）</td></tr></tbody></table><h2 id="二、基础入门：创建弹性容器"><a href="#二、基础入门：创建弹性容器" class="headerlink" title="二、基础入门：创建弹性容器"></a>二、基础入门：创建弹性容器</h2><h3 id="1-声明弹性容器"><a href="#1-声明弹性容器" class="headerlink" title="1. 声明弹性容器"></a>1. 声明弹性容器</h3><p>给父元素添加 <code>display</code> 属性，即可将其变为弹性容器，两种取值区别如下：</p><pre><code class="css">/* 1. 块级弹性容器：独占一行，宽度默认 100%（常用） */.container &#123;  display: flex;&#125;/* 2. 行内弹性容器：宽度自适应内容，与其他行内元素同行排列 */.container &#123;  display: inline-flex;&#125;</code></pre><h3 id="2-项目的默认行为"><a href="#2-项目的默认行为" class="headerlink" title="2. 项目的默认行为"></a>2. 项目的默认行为</h3><p>容器声明为 <code>flex</code> 后，子项目（Flex Item）会自动呈现以下特性：</p><ul><li>沿主轴（默认水平）排列，不再独占一行（打破块级元素默认行为）</li><li>项目高度默认拉伸至与容器等高（<code>align-items: stretch</code>）</li><li>项目不会换行，空间不足时自动收缩（<code>flex-shrink: 1</code>）</li><li>忽略 <code>float</code>、<code>clear</code>、<code>vertical-align</code> 属性（失效）</li></ul><h2 id="三、容器属性（控制整体布局）"><a href="#三、容器属性（控制整体布局）" class="headerlink" title="三、容器属性（控制整体布局）"></a>三、容器属性（控制整体布局）</h2><p>弹性容器的属性用于定义项目的排列方向、换行规则、对齐方式等，共 6 个核心属性，是 Flexbox 布局的核心。</p><h3 id="1-flex-direction：控制主轴方向（项目排列方向）"><a href="#1-flex-direction：控制主轴方向（项目排列方向）" class="headerlink" title="1. flex-direction：控制主轴方向（项目排列方向）"></a>1. flex-direction：控制主轴方向（项目排列方向）</h3><p>决定主轴的方向，直接改变项目的排列顺序（水平 &#x2F; 垂直），取值如下：</p><table><thead><tr><th>取值</th><th>主轴方向</th><th>项目排列效果</th><th>适用场景</th></tr></thead><tbody><tr><td><code>row</code>（默认）</td><td>水平（左→右）</td><td>从左到右横向排列</td><td>导航栏、水平布局</td></tr><tr><td><code>row-reverse</code></td><td>水平（右→左）</td><td>从右到左横向排列</td><td>反向水平布局</td></tr><tr><td><code>column</code></td><td>垂直（上→下）</td><td>从上到下纵向排列</td><td>垂直导航、表单布局</td></tr><tr><td><code>column-reverse</code></td><td>垂直（下→上）</td><td>从下到上纵向排列</td><td>反向垂直布局</td></tr></tbody></table><p><strong>示例：垂直排列项目</strong></p><pre><code class="css">.container &#123;  display: flex;  flex-direction: column; /* 主轴垂直，项目从上到下排列 */  height: 200px; /* 容器高度决定交叉轴空间 */&#125;</code></pre><h3 id="2-flex-wrap：控制项目是否换行"><a href="#2-flex-wrap：控制项目是否换行" class="headerlink" title="2. flex-wrap：控制项目是否换行"></a>2. flex-wrap：控制项目是否换行</h3><p>默认情况下，项目会压缩在一行（<code>nowrap</code>），通过 <code>flex-wrap</code> 控制溢出时的换行规则：</p><table><thead><tr><th>取值</th><th>效果说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>nowrap</code>（默认）</td><td>不换行，项目自动收缩以适应容器宽度</td><td>少量项目的水平布局</td></tr><tr><td><code>wrap</code></td><td>换行，溢出的项目在下一行排列（从上到下）</td><td>响应式卡片、多项目布局</td></tr><tr><td><code>wrap-reverse</code></td><td>反向换行，溢出的项目在上一行排列（从下到上）</td><td>特殊反向布局</td></tr></tbody></table><p><strong>示例：自动换行布局</strong></p><pre><code class="css">.container &#123;  display: flex;  flex-wrap: wrap; /* 空间不足时自动换行 */  width: 500px; /* 容器固定宽度，触发换行 */&#125;</code></pre><h3 id="3-flex-flow：flex-direction-flex-wrap-简写"><a href="#3-flex-flow：flex-direction-flex-wrap-简写" class="headerlink" title="3. flex-flow：flex-direction + flex-wrap 简写"></a>3. flex-flow：<code>flex-direction</code> + <code>flex-wrap</code> 简写</h3><p>为简化代码，将两个属性合并为 <code>flex-flow</code>，默认值 <code>row nowrap</code>：</p><pre><code class="css">/* 水平排列 + 自动换行（常用组合） */.container &#123;  display: flex;  flex-flow: row wrap;&#125;/* 垂直排列 + 不换行 */.container &#123;  flex-flow: column nowrap;&#125;</code></pre><h3 id="4-justify-content：主轴对齐方式（核心）"><a href="#4-justify-content：主轴对齐方式（核心）" class="headerlink" title="4. justify-content：主轴对齐方式（核心）"></a>4. justify-content：主轴对齐方式（核心）</h3><p>控制项目在<strong>主轴方向</strong>的对齐和分布，是最常用的属性之一（以 <code>flex-direction: row</code> 为例，主轴为水平方向）：</p><table><thead><tr><th>取值</th><th>效果说明</th><th>视觉示意（水平主轴）</th><th>适用场景</th></tr></thead><tbody><tr><td><code>flex-start</code>（默认）</td><td>靠主轴起点对齐（左对齐）</td><td>[项目 1 项目 2 项目 3] ——</td><td>左对齐布局</td></tr><tr><td><code>flex-end</code></td><td>靠主轴终点对齐（右对齐）</td><td>—— [项目 1 项目 2 项目 3]</td><td>右对齐布局</td></tr><tr><td><code>center</code></td><td>主轴居中对齐</td><td>—— [项目 1 项目 2 项目 3] ——</td><td>水平居中（如弹窗内容）</td></tr><tr><td><code>space-between</code></td><td>两端对齐，项目间间距相等（无首尾间距）</td><td>[项目 1] —- [项目 2] —- [项目 3]</td><td>导航栏、均匀分布布局</td></tr><tr><td><code>space-around</code></td><td>项目两侧间距相等（首尾间距为项目间间距的 1&#x2F;2）</td><td>– [项目 1] – [项目 2] – [项目 3] –</td><td>均匀分布（需首尾留白）</td></tr><tr><td><code>space-evenly</code></td><td>项目间间距 + 首尾间距完全相等</td><td>– [项目 1] – [项目 2] – [项目 3] –</td><td>严格均匀分布</td></tr></tbody></table><p><strong>示例：水平居中且项目间均匀分布</strong></p><pre><code class="css">.container &#123;  display: flex;  justify-content: space-between; /* 两端对齐，中间间距相等 */&#125;</code></pre><h3 id="5-align-items：交叉轴对齐方式（核心）"><a href="#5-align-items：交叉轴对齐方式（核心）" class="headerlink" title="5. align-items：交叉轴对齐方式（核心）"></a>5. align-items：交叉轴对齐方式（核心）</h3><p>控制项目在<strong>交叉轴方向</strong>的对齐（仅适用于「单行项目」），以 <code>flex-direction: row</code> 为例（交叉轴为垂直方向）：</p><table><thead><tr><th>取值</th><th>效果说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>stretch</code>（默认）</td><td>项目高度拉伸至与容器等高（项目无固定高度时）</td><td>等高卡片布局</td></tr><tr><td><code>flex-start</code></td><td>靠交叉轴起点对齐（顶部对齐）</td><td>顶部对齐的列表</td></tr><tr><td><code>flex-end</code></td><td>靠交叉轴终点对齐（底部对齐）</td><td>底部对齐的按钮组</td></tr><tr><td><code>center</code></td><td>交叉轴居中对齐（垂直居中）</td><td>水平 + 垂直居中布局</td></tr><tr><td><code>baseline</code></td><td>按项目内文字基线对齐（文字底部对齐）</td><td>文字对齐的卡片</td></tr></tbody></table><p><strong>示例：水平垂直居中（最常用布局）</strong></p><pre><code class="css">.container &#123;  display: flex;  justify-content: center; /* 主轴（水平）居中 */  align-items: center;     /* 交叉轴（垂直）居中 */  height: 300px; /* 容器必须有高度，否则交叉轴无拉伸空间 */&#125;</code></pre><h3 id="6-align-content：多行项目的交叉轴对齐"><a href="#6-align-content：多行项目的交叉轴对齐" class="headerlink" title="6. align-content：多行项目的交叉轴对齐"></a>6. align-content：多行项目的交叉轴对齐</h3><p>仅当项目<strong>换行</strong>（<code>flex-wrap: wrap</code>）时生效，控制「多行项目整体」在交叉轴的对齐方式（区别于 <code>align-items</code> 控制单个项目）：</p><table><thead><tr><th>取值</th><th>效果说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>stretch</code>（默认）</td><td>多行拉伸至容器高度，行间距相等</td><td>多行等高布局</td></tr><tr><td><code>flex-start</code></td><td>多行靠交叉轴起点对齐（顶部对齐）</td><td>多行顶部对齐</td></tr><tr><td><code>flex-end</code></td><td>多行靠交叉轴终点对齐（底部对齐）</td><td>多行底部对齐</td></tr><tr><td><code>center</code></td><td>多行交叉轴居中对齐（整体垂直居中）</td><td>多行居中布局</td></tr><tr><td><code>space-between</code></td><td>多行两端对齐，行间距相等</td><td>多行均匀分布</td></tr><tr><td><code>space-around</code></td><td>多行两侧间距相等</td><td>多行均匀分布（需留白）</td></tr></tbody></table><p><strong>示例：多行项目整体垂直居中</strong></p><pre><code class="css">.container &#123;  display: flex;  flex-wrap: wrap; /* 必须换行才生效 */  align-content: center; /* 多行整体垂直居中 */  height: 500px; /* 容器高度足够容纳多行 */&#125;</code></pre><h2 id="四、项目属性（控制单个项目）"><a href="#四、项目属性（控制单个项目）" class="headerlink" title="四、项目属性（控制单个项目）"></a>四、项目属性（控制单个项目）</h2><p>弹性项目的属性用于单独调整某个项目的大小、对齐方式或排列顺序，覆盖容器的默认设置，共 6 个核心属性。</p><h3 id="1-flex-grow：项目的放大比例"><a href="#1-flex-grow：项目的放大比例" class="headerlink" title="1. flex-grow：项目的放大比例"></a>1. flex-grow：项目的放大比例</h3><p>控制项目在容器有<strong>剩余空间</strong>时的放大比例，默认值 <code>0</code>（不放大）：</p><ul><li>取值为非负数字（整数 &#x2F; 小数），比例越大，占有的剩余空间越多</li><li>多个项目的 <code>flex-grow</code> 按比例分配剩余空间（如 1:2 则分别占 1&#x2F;3、2&#x2F;3）</li></ul><p><strong>示例：2 个项目按 1:2 分配剩余空间</strong></p><pre><code class="css">.container &#123;  display: flex;  width: 500px;&#125;.item1 &#123; flex-grow: 1; &#125; /* 占 1/3 剩余空间 */.item2 &#123; flex-grow: 2; &#125; /* 占 2/3 剩余空间 */</code></pre><h3 id="2-flex-shrink：项目的收缩比例"><a href="#2-flex-shrink：项目的收缩比例" class="headerlink" title="2. flex-shrink：项目的收缩比例"></a>2. flex-shrink：项目的收缩比例</h3><p>控制项目在容器<strong>空间不足</strong>时的收缩比例，默认值 <code>1</code>（自动收缩）：</p><ul><li>取值为非负数字，<code>0</code> 表示不收缩（固定宽度，避免被压缩）</li><li>多个项目的 <code>flex-shrink</code> 按比例收缩（如 1:2 则 item1 收缩幅度是 item2 的 1&#x2F;2）</li></ul><p><strong>示例：禁止项目收缩（常用）</strong></p><pre><code class="css">.item &#123;  flex-shrink: 0; /* 容器空间不足时，项目不收缩 */  width: 200px; /* 固定宽度不被压缩 */&#125;</code></pre><h3 id="3-flex-basis：项目的基准宽度"><a href="#3-flex-basis：项目的基准宽度" class="headerlink" title="3. flex-basis：项目的基准宽度"></a>3. flex-basis：项目的基准宽度</h3><p>定义项目在主轴上的<strong>初始宽度</strong>（在分配剩余空间前的宽度），默认值 <code>auto</code>（项目自身宽度）：</p><ul><li>优先级：<code>flex-basis</code> &gt; 项目自身 <code>width</code>（若同时设置，<code>width</code> 失效）</li><li>可取值：<code>px</code>&#x2F;<code>%</code>&#x2F;<code>em</code> 等具体单位，或 <code>auto</code>（自动适应内容）</li></ul><p><strong>示例：设置项目初始宽度</strong></p><pre><code class="css">.item &#123;  flex-basis: 200px; /* 初始宽度 200px，剩余空间按 flex-grow 分配 */&#125;</code></pre><h3 id="4-flex：flex-grow-flex-shrink-flex-basis-简写（常用）"><a href="#4-flex：flex-grow-flex-shrink-flex-basis-简写（常用）" class="headerlink" title="4. flex：flex-grow + flex-shrink + flex-basis 简写（常用）"></a>4. flex：<code>flex-grow</code> + <code>flex-shrink</code> + <code>flex-basis</code> 简写（常用）</h3><p>为简化代码，将三个属性合并为 <code>flex</code>，默认值 <code>0 1 auto</code>，常用简写形式如下：</p><table><thead><tr><th>简写</th><th>等价于</th><th>效果说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>flex: 1</code></td><td><code>1 1 0%</code></td><td>项目自动放大 &#x2F; 收缩，基准宽度为 0（按比例分配空间）</td><td>等分布局、自适应宽度</td></tr><tr><td><code>flex: auto</code></td><td><code>1 1 auto</code></td><td>项目自动放大 &#x2F; 收缩，基准宽度为自身宽度</td><td>自适应内容宽度</td></tr><tr><td><code>flex: none</code></td><td><code>0 0 auto</code></td><td>项目不放大、不收缩，固定自身宽度</td><td>固定宽度项目（如侧边栏）</td></tr><tr><td><code>flex: 2 0 300px</code></td><td><code>2 0 300px</code></td><td>放大比例 2，不收缩，基准宽度 300px</td><td>固定基准宽度的自适应项目</td></tr></tbody></table><p><strong>示例：等分布局（最常用）</strong></p><pre><code class="css">.container &#123;  display: flex;&#125;.item &#123;  flex: 1; /* 所有项目等比例分配容器宽度 */  margin: 0 10px; /* 项目间距 */&#125;</code></pre><h3 id="5-align-self：单个项目的交叉轴对齐"><a href="#5-align-self：单个项目的交叉轴对齐" class="headerlink" title="5. align-self：单个项目的交叉轴对齐"></a>5. align-self：单个项目的交叉轴对齐</h3><p>覆盖容器的 <code>align-items</code> 属性，单独设置某个项目的交叉轴对齐方式，取值与 <code>align-items</code> 一致：</p><pre><code class="css">.container &#123;  display: flex;  align-items: flex-start; /* 所有项目顶部对齐 */&#125;.item-special &#123;  align-self: center; /* 该项目单独垂直居中 */&#125;</code></pre><h3 id="6-order：项目的排列顺序"><a href="#6-order：项目的排列顺序" class="headerlink" title="6. order：项目的排列顺序"></a>6. order：项目的排列顺序</h3><p>控制项目的显示顺序，默认值 <code>0</code>，取值为整数（负数在前，正数在后，数值越小越靠前）：</p><pre><code class="css">.item1 &#123; order: 2; &#125; /* 第 2 个显示 */.item2 &#123; order: 1; &#125; /* 第 1 个显示 */.item3 &#123; order: -1; &#125; /* 最前面显示（数值最小） */</code></pre><h2 id="五、常用应用场景（附代码）"><a href="#五、常用应用场景（附代码）" class="headerlink" title="五、常用应用场景（附代码）"></a>五、常用应用场景（附代码）</h2><p>Flexbox 几乎能解决所有前端布局问题，以下是最常用的场景示例：</p><h3 id="1-水平垂直居中（弹窗、卡片内容）"><a href="#1-水平垂直居中（弹窗、卡片内容）" class="headerlink" title="1. 水平垂直居中（弹窗、卡片内容）"></a>1. 水平垂直居中（弹窗、卡片内容）</h3><pre><code class="css">.modal-content &#123;  display: flex;  justify-content: center; /* 水平居中 */  align-items: center;     /* 垂直居中 */  height: 200px;  width: 300px;&#125;</code></pre><h3 id="2-等分布局（导航栏、选项卡）"><a href="#2-等分布局（导航栏、选项卡）" class="headerlink" title="2. 等分布局（导航栏、选项卡）"></a>2. 等分布局（导航栏、选项卡）</h3><pre><code class="css">.nav &#123;  display: flex;  list-style: none;  padding: 0;&#125;.nav-item &#123;  flex: 1; /* 等比例分配宽度 */  text-align: center;  padding: 10px 0;&#125;</code></pre><h3 id="3-两栏布局（侧边栏固定-主内容自适应）"><a href="#3-两栏布局（侧边栏固定-主内容自适应）" class="headerlink" title="3. 两栏布局（侧边栏固定 + 主内容自适应）"></a>3. 两栏布局（侧边栏固定 + 主内容自适应）</h3><pre><code class="css">.container &#123;  display: flex;  height: 100vh; /* 占满视口高度 */&#125;.sidebar &#123;  width: 200px;  flex-shrink: 0; /* 侧边栏不收缩 */  background: #f5f5f5;&#125;.main &#123;  flex: 1; /* 主内容自适应剩余宽度 */  padding: 20px;&#125;</code></pre><h3 id="4-响应式换行布局（卡片、产品列表）"><a href="#4-响应式换行布局（卡片、产品列表）" class="headerlink" title="4. 响应式换行布局（卡片、产品列表）"></a>4. 响应式换行布局（卡片、产品列表）</h3><pre><code class="css">.card-container &#123;  display: flex;  flex-wrap: wrap; /* 自动换行 */  gap: 16px; /* 项目间距（替代 margin，更简洁） */  padding: 20px;&#125;.card &#123;  flex: 1 1 250px; /* 最小宽度 250px，超出自动换行 */  background: #fff;  padding: 20px;  border-radius: 8px;&#125;</code></pre><h3 id="5-底部固定布局（内容不足时底部贴底）"><a href="#5-底部固定布局（内容不足时底部贴底）" class="headerlink" title="5. 底部固定布局（内容不足时底部贴底）"></a>5. 底部固定布局（内容不足时底部贴底）</h3><pre><code class="css">body &#123;  margin: 0;  min-height: 100vh; /* 视口高度 */  display: flex;  flex-direction: column; /* 主轴垂直 */&#125;.header &#123;  height: 60px;  background: #333;  color: #fff;&#125;.content &#123;  flex: 1; /* 内容区占满剩余空间，推底部到底部 */  padding: 20px;&#125;.footer &#123;  height: 60px;  background: #333;  color: #fff;  text-align: center;  line-height: 60px;&#125;</code></pre><h3 id="6-文字基线对齐（卡片内文字对齐）"><a href="#6-文字基线对齐（卡片内文字对齐）" class="headerlink" title="6. 文字基线对齐（卡片内文字对齐）"></a>6. 文字基线对齐（卡片内文字对齐）</h3><pre><code class="css">.card-container &#123;  display: flex;  align-items: baseline; /* 按文字基线对齐 */  gap: 20px;&#125;.card h3 &#123;  margin: 0;  font-size: 24px;&#125;.card p &#123;  margin: 0;  font-size: 16px;&#125;</code></pre><h2 id="六、关键注意事项"><a href="#六、关键注意事项" class="headerlink" title="六、关键注意事项"></a>六、关键注意事项</h2><ol><li><p><strong>容器高度与交叉轴对齐</strong>：<code>align-items: center</code>、<code>align-content: center</code> 等属性需要容器有明确高度（如 <code>height</code>、<code>min-height: 100vh</code>），否则交叉轴无空间，对齐效果失效。</p></li><li><p><strong><code>gap</code> 属性的使用</strong>：Flexbox 支持 <code>gap</code>（项目间距）和 <code>row-gap</code>&#x2F;<code>column-gap</code>（行列间距），无需用 <code>margin</code> 实现，更简洁（IE 不支持 <code>gap</code>，需兼容时用 <code>margin</code>）。</p></li><li><p>**项目的 <code>width</code> 与 <code>flex-basis</code>**：<code>flex-basis</code> 优先级高于 <code>width</code>，若同时设置，<code>width</code> 失效；若 <code>flex-basis: auto</code>，则以 <code>width</code> 为准。</p></li><li><p>兼容性处理：IE11 支持 Flexbox，但存在部分差异（如<code>flex-basis</code>需配合<code>width</code>，<code>gap</code>不支持），可通过以下兼容写法修复：</p><pre><code class="css">/* IE11 兼容 flex-basis */.item &#123;  flex-basis: 200px;  width: 200px; /* 兜底 IE11 */&#125;</code></pre></li><li><p><strong>嵌套 Flex 布局</strong>：弹性项目可以再声明为弹性容器，实现复杂的嵌套布局（如卡片内部的元素对齐）。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSS3 弹性盒子模型（Flexible Box，简称 Flexbox）是一种&lt;strong&gt;一维布局模型&lt;/strong&gt;，专为解决传统布局（&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;position&lt;/code&gt;）的对齐复杂、自适应繁琐等问题设计，现已成为前端布局的首选方案。它通过「容器 - 项目」的结构，轻松实现元素的对齐、分布、伸缩和自适应，兼容性覆盖所有现代浏览器（IE11 部分支持）。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS核心属性</title>
    <link href="http://example.com/2025/11/07/CSS%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7/"/>
    <id>http://example.com/2025/11/07/CSS%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7/</id>
    <published>2025-11-07T14:57:18.000Z</published>
    <updated>2025-11-25T15:47:58.215Z</updated>
    
    <content type="html"><![CDATA[<p>开发中最常用的 <strong>字体、背景、文本、表格</strong> 属性，包含语法、取值、示例，兼顾实用性和易理解性，直接可复制到项目中使用。</p><span id="more"></span><h1 id="CSS-核心属性详解（字体、背景、文本、表格）"><a href="#CSS-核心属性详解（字体、背景、文本、表格）" class="headerlink" title="CSS 核心属性详解（字体、背景、文本、表格）"></a>CSS 核心属性详解（字体、背景、文本、表格）</h1><h2 id="一、字体属性（控制文字样式）"><a href="#一、字体属性（控制文字样式）" class="headerlink" title="一、字体属性（控制文字样式）"></a>一、字体属性（控制文字样式）</h2><p>核心用于设置文字的 <strong>字体、大小、粗细、风格、行高</strong> 等，是页面文字排版的基础。</p><table><thead><tr><th>属性名</th><th>作用</th><th>取值 &#x2F; 说明</th><th>示例</th></tr></thead><tbody><tr><td><code>font-family</code></td><td>设置字体（优先匹配）</td><td>具体字体名（如 <code>Arial</code>）、通用字体族（如 <code>sans-serif</code> 无衬线、<code>serif</code> 衬线）；多个字体用逗号分隔（fallback 机制）</td><td><code>font-family: &quot;微软雅黑&quot;, &quot;Microsoft YaHei&quot;, sans-serif;</code></td></tr><tr><td><code>font-size</code></td><td>设置字体大小（核心）</td><td>固定值（<code>16px</code> 常用）、相对值（<code>1.2em</code> 相对于父元素、<code>120%</code> 百分比、<code>small/large</code> 关键字）</td><td><code>font-size: 16px;</code>（网页默认 16px）</td></tr><tr><td><code>font-weight</code></td><td>设置字体粗细</td><td>关键字（<code>normal</code> 正常 &#x2F;<code>bold</code> 加粗 &#x2F;<code>bolder</code> 更粗 &#x2F;<code>lighter</code> 更细）、数字（100-900，400&#x3D;normal，700&#x3D;bold）</td><td><code>font-weight: 600;</code>（半加粗，常用）</td></tr><tr><td><code>font-style</code></td><td>设置字体风格（斜体 &#x2F; 正常）</td><td><code>normal</code>（正常）、<code>italic</code>（斜体，字体自带）、<code>oblique</code>（强制斜体）</td><td><code>font-style: italic;</code>（斜体文字）</td></tr><tr><td><code>line-height</code></td><td>设置行高（文字垂直间距）</td><td>数字（如 <code>1.5</code>，相对于字体大小的倍数，推荐）、固定值（<code>24px</code>）、百分比（<code>150%</code>）</td><td><code>line-height: 1.5;</code>（行高 &#x3D; 字体大小 ×1.5，易读）</td></tr><tr><td><code>font</code></td><td>复合属性（简化写法）</td><td>顺序：<code>font-style font-weight font-size/line-height font-family</code>（必须包含 <code>font-size</code> 和 <code>font-family</code>）</td><td><code>font: italic 600 16px/1.5 &quot;微软雅黑&quot;, sans-serif;</code></td></tr><tr><td><code>color</code></td><td>设置文字颜色（关联字体）</td><td>颜色值（<code>red</code>、<code>#333</code>、<code>rgb(51,51,51)</code>、<code>rgba(51,51,51,0.8)</code> 带透明度）</td><td><code>color: #666;</code>（浅灰色文字）</td></tr></tbody></table><h3 id="字体属性常用示例"><a href="#字体属性常用示例" class="headerlink" title="字体属性常用示例"></a>字体属性常用示例</h3><pre><code class="css">.text &#123;  font-family: &quot;PingFang SC&quot;, &quot;微软雅黑&quot;, sans-serif; /* 适配 macOS/Windows */  font-size: 14px;  font-weight: normal; /* 取消加粗 */  line-height: 1.6; /* 优化可读性 */  color: rgba(33, 33, 33, 0.9); /* 深灰带轻微透明度 */&#125;</code></pre><h2 id="二、背景属性（控制元素背景）"><a href="#二、背景属性（控制元素背景）" class="headerlink" title="二、背景属性（控制元素背景）"></a>二、背景属性（控制元素背景）</h2><p>用于设置元素的 <strong>背景色、背景图、背景平铺、位置、大小</strong> 等，丰富元素视觉效果。</p><table><thead><tr><th>属性名</th><th>作用</th><th>取值 &#x2F; 说明</th><th>示例</th></tr></thead><tbody><tr><td><code>background-color</code></td><td>设置背景颜色</td><td>颜色值、<code>transparent</code>（透明，默认）</td><td><code>background-color: #f5f5f5;</code>（浅灰背景）</td></tr><tr><td><code>background-image</code></td><td>设置背景图片</td><td><code>url(&quot;图片路径&quot;)</code>（相对 &#x2F; 绝对路径）、<code>none</code>（无背景图，默认）</td><td><code>background-image: url(&quot;bg.jpg&quot;);</code></td></tr><tr><td><code>background-repeat</code></td><td>控制背景图平铺方式</td><td><code>repeat</code>（默认，全平铺）、<code>no-repeat</code>（不平铺）、<code>repeat-x</code>（水平平铺）、<code>repeat-y</code>（垂直平铺）</td><td><code>background-repeat: no-repeat;</code></td></tr><tr><td><code>background-position</code></td><td>控制背景图位置</td><td>关键字（<code>center</code> 居中、<code>left top</code> 左上）、数值（<code>50px 30px</code> 左 50px 上 30px）、百分比（<code>50% 50%</code> 居中）</td><td><code>background-position: center;</code></td></tr><tr><td><code>background-size</code></td><td>控制背景图大小</td><td><code>cover</code>（覆盖元素，可能裁剪）、<code>contain</code>（完全显示，可能留白）、数值（<code>100px 80px</code> 宽高）、百分比（<code>100% 100%</code> 拉伸填充）</td><td><code>background-size: cover;</code>（常用背景铺满）</td></tr><tr><td><code>background-attachment</code></td><td>背景图滚动行为</td><td><code>scroll</code>（随页面滚动，默认）、<code>fixed</code>（固定不动，类似视差效果）</td><td><code>background-attachment: fixed;</code></td></tr><tr><td><code>background</code></td><td>复合属性（简化写法）</td><td>顺序：<code>background-color background-image background-repeat background-position / background-size background-attachment</code>（<code>size</code> 前必须加 <code>/</code>）</td><td><code>background: #f5f5f5 url(&quot;bg.jpg&quot;) no-repeat center / cover fixed;</code></td></tr></tbody></table><h3 id="背景属性常用示例（全屏背景图）"><a href="#背景属性常用示例（全屏背景图）" class="headerlink" title="背景属性常用示例（全屏背景图）"></a>背景属性常用示例（全屏背景图）</h3><pre><code class="css">body &#123;  background: url(&quot;full-screen-bg.jpg&quot;) no-repeat center / cover;  background-color: #eee; /* 背景图加载失败时的 fallback 色 */&#125;</code></pre><h2 id="三、文本属性（控制文本排版）"><a href="#三、文本属性（控制文本排版）" class="headerlink" title="三、文本属性（控制文本排版）"></a>三、文本属性（控制文本排版）</h2><p>用于设置文本的 <strong>对齐方式、缩进、间距、装饰线</strong> 等，优化文本布局的可读性。</p><table><thead><tr><th>属性名</th><th>作用</th><th>取值 &#x2F; 说明</th><th>示例</th></tr></thead><tbody><tr><td><code>text-align</code></td><td>文本水平对齐</td><td><code>left</code>（左对齐，默认）、<code>center</code>（居中）、<code>right</code>（右对齐）、<code>justify</code>（两端对齐，仅多行有效）</td><td><code>text-align: center;</code>（标题居中）</td></tr><tr><td><code>text-indent</code></td><td>文本首行缩进</td><td>数值（<code>2em</code> 常用，对应 2 个字符宽度）、百分比（<code>10%</code>）</td><td><code>text-indent: 2em;</code>（段落首行缩进 2 字）</td></tr><tr><td><code>letter-spacing</code></td><td>字符间距（字与字之间）</td><td>数值（<code>2px</code> 加宽、<code>-1px</code> 收紧）、<code>normal</code>（默认）</td><td><code>letter-spacing: 1px;</code>（加宽字符间距）</td></tr><tr><td><code>word-spacing</code></td><td>单词间距（英文单词之间）</td><td>数值（<code>5px</code> 加宽）、<code>normal</code>（默认）；中文无效（中文无单词概念）</td><td><code>word-spacing: 3px;</code>（英文单词间距）</td></tr><tr><td><code>text-decoration</code></td><td>文本装饰线（下划线 &#x2F; 删除线等）</td><td><code>none</code>（无装饰，默认，常用於清除 <code>&lt;a&gt;</code> 标签下划线）、<code>underline</code>（下划线）、<code>line-through</code>（删除线）、<code>overline</code>（上划线）；可加颜色（如 <code>underline red</code>）</td><td><code>text-decoration: none;</code>（清除 a 标签下划线）</td></tr><tr><td><code>text-transform</code></td><td>英文文本大小写转换</td><td><code>none</code>（默认）、<code>uppercase</code>（全大写）、<code>lowercase</code>（全小写）、<code>capitalize</code>（首字母大写）</td><td><code>text-transform: uppercase;</code>（英文全大写）</td></tr><tr><td><code>white-space</code></td><td>空白字符处理（换行 &#x2F; 空格）</td><td><code>normal</code>（默认，合并空格 + 自动换行）、<code>nowrap</code>（不换行，溢出隐藏或滚动）、<code>pre</code>（保留空格和换行，类似 <code>&lt;pre&gt;</code> 标签）</td><td><code>white-space: nowrap;</code>（强制不换行）</td></tr><tr><td><code>overflow-wrap</code></td><td>长文本换行（防止溢出）</td><td><code>normal</code>（默认）、<code>break-word</code>（单词内换行，适合中文 &#x2F; 长英文单词）</td><td><code>overflow-wrap: break-word;</code>（避免长文本撑破容器）</td></tr></tbody></table><h3 id="文本属性常用示例（段落排版）"><a href="#文本属性常用示例（段落排版）" class="headerlink" title="文本属性常用示例（段落排版）"></a>文本属性常用示例（段落排版）</h3><pre><code class="css">.paragraph &#123;  text-align: justify; /* 两端对齐 */  text-indent: 2em; /* 首行缩进2字 */  letter-spacing: 0.5px; /* 字符间距轻微加宽 */  line-height: 1.8; /* 行高优化可读性 */  overflow-wrap: break-word; /* 长文本换行 */&#125;a &#123;  text-decoration: none; /* 清除下划线 */  color: #0066cc;&#125;a:hover &#123;  text-decoration: underline; /* hover 时显示下划线 */&#125;</code></pre><h2 id="四、表格属性（控制表格样式）"><a href="#四、表格属性（控制表格样式）" class="headerlink" title="四、表格属性（控制表格样式）"></a>四、表格属性（控制表格样式）</h2><p>用于设置表格的 <strong>边框、间距、对齐、单元格样式</strong> 等，默认表格样式简陋，需通过 CSS 美化。</p><table><thead><tr><th>属性名</th><th>作用</th><th>取值 &#x2F; 说明</th><th>示例</th></tr></thead><tbody><tr><td><code>border-collapse</code></td><td>表格边框合并（核心）</td><td><code>collapse</code>（边框合并，推荐）、<code>separate</code>（边框分离，默认，有间距）</td><td><code>border-collapse: collapse;</code>（消除边框间隙）</td></tr><tr><td><code>border-spacing</code></td><td>表格边框间距（仅 <code>separate</code> 时有效）</td><td>数值（<code>5px</code> 间距）、<code>0</code>（无间距）</td><td><code>border-spacing: 2px;</code></td></tr><tr><td><code>table-layout</code></td><td>表格布局算法</td><td><code>auto</code>（默认，自适应内容宽度）、<code>fixed</code>（固定列宽，性能更好，需设置 <code>width</code>）</td><td><code>table-layout: fixed;</code>（固定表格宽度）</td></tr><tr><td><code>width/height</code></td><td>表格 &#x2F; 单元格宽高</td><td>数值（<code>600px</code>）、百分比（<code>100%</code> 自适应父容器）</td><td><code>width: 100%;</code>（表格占满父容器）</td></tr><tr><td><code>text-align</code></td><td>单元格文本水平对齐</td><td>继承文本属性的 <code>left/center/right/justify</code></td><td><code>td &#123; text-align: center; &#125;</code>（单元格文本居中）</td></tr><tr><td><code>vertical-align</code></td><td>单元格文本垂直对齐（核心）</td><td><code>middle</code>（垂直居中，常用）、<code>top</code>（顶部对齐）、<code>bottom</code>（底部对齐）、<code>baseline</code>（基线对齐）</td><td><code>td &#123; vertical-align: middle; &#125;</code>（单元格垂直居中）</td></tr><tr><td><code>border</code></td><td>表格 &#x2F; 单元格边框</td><td>复合属性（<code>宽度 样式 颜色</code>），如 <code>1px solid #ddd</code>（1px 灰色实线）</td><td><code>table, td, th &#123; border: 1px solid #ddd; &#125;</code></td></tr><tr><td><code>empty-cells</code></td><td>空单元格是否显示边框</td><td><code>show</code>（显示，默认）、<code>hide</code>（隐藏空单元格边框）</td><td><code>empty-cells: hide;</code></td></tr></tbody></table><h3 id="表格属性常用示例（美化表格）"><a href="#表格属性常用示例（美化表格）" class="headerlink" title="表格属性常用示例（美化表格）"></a>表格属性常用示例（美化表格）</h3><pre><code class="html">&lt;!-- HTML 结构 --&gt;&lt;table class=&quot;beautiful-table&quot;&gt;  &lt;thead&gt;    &lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;城市&lt;/th&gt;&lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr&gt;&lt;td&gt;张三&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;北京&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td&gt;李四&lt;/td&gt;&lt;td&gt;30&lt;/td&gt;&lt;td&gt;上海&lt;/td&gt;&lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;</code></pre><pre><code class="css">/* CSS 样式 */.beautiful-table &#123;  width: 100%; /* 占满父容器 */  border-collapse: collapse; /* 边框合并 */  table-layout: fixed; /* 固定列宽 */  font-size: 14px;&#125;.beautiful-table th,.beautiful-table td &#123;  border: 1px solid #e8e8e8; /* 边框颜色 */  padding: 12px 8px; /* 单元格内边距 */  text-align: center; /* 水平居中 */  vertical-align: middle; /* 垂直居中 */&#125;.beautiful-table th &#123;  background-color: #f8f8f8; /* 表头背景色 */  font-weight: 600; /* 表头文字加粗 */  color: #333;&#125;/* 奇偶行交替颜色（斑马纹） */.beautiful-table tbody tr:nth-child(even) &#123;  background-color: #fafafa;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发中最常用的 &lt;strong&gt;字体、背景、文本、表格&lt;/strong&gt; 属性，包含语法、取值、示例，兼顾实用性和易理解性，直接可复制到项目中使用。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS简介与基础语法</title>
    <link href="http://example.com/2025/11/07/CSS%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2025/11/07/CSS%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2025-11-07T13:20:09.000Z</published>
    <updated>2025-11-25T15:43:31.174Z</updated>
    
    <content type="html"><![CDATA[<p>CSS（层叠样式表）的核心作用是为 HTML 元素设置样式，其语法规则简洁清晰，核心由「选择器」「声明块」「属性 - 值对」三部分构成，同时包含注释、引入方式等基础规范。</p><span id="more"></span><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="一、核心语法结构"><a href="#一、核心语法结构" class="headerlink" title="一、核心语法结构"></a>一、核心语法结构</h2><p>CSS 规则的基本格式如下，核心是「选中元素 + 定义样式」：</p><pre><code class="css">/* 选择器：指定要样式化的 HTML 元素 */选择器 &#123;  /* 声明块：包裹一组样式声明（属性-值对） */  属性1: 值1; /* 样式声明：属性和值用冒号分隔，结尾必须加分号（可省略最后一个，但推荐都加） */  属性2: 值2;&#125;</code></pre><h3 id="1-关键组成部分说明"><a href="#1-关键组成部分说明" class="headerlink" title="1. 关键组成部分说明"></a>1. 关键组成部分说明</h3><table><thead><tr><th>组成部分</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>选择器</td><td>定位 HTML 中需要样式化的元素（如标签、类、ID 等）</td><td><code>p</code>（选中所有 &#96;&#96; 标签）、<code>.box</code>（选中所有 <code>class=&quot;box&quot;</code> 的元素）</td></tr><tr><td>声明块</td><td>用 <code>&#123;&#125;</code> 包裹，包含一个或多个样式声明</td><td><code>&#123; color: red; font-size: 16px; &#125;</code></td></tr><tr><td>属性</td><td>CSS 预定义的样式名（如颜色、字体、宽度等）</td><td><code>color</code>（文字颜色）、<code>width</code>（宽度）、<code>background</code>（背景）</td></tr><tr><td>值</td><td>对应属性的具体设置（需符合属性的取值规范）</td><td><code>red</code>（颜色值）、<code>16px</code>（尺寸值）、<code>center</code>（对齐方式）</td></tr></tbody></table><h3 id="2-基础示例"><a href="#2-基础示例" class="headerlink" title="2. 基础示例"></a>2. 基础示例</h3><pre><code class="css">/* 选中所有 &lt;h1&gt; 标签，设置文字颜色红色、字体大小 24px */h1 &#123;  color: red;  font-size: 24px;&#125;/* 选中 class=&quot;container&quot; 的元素，设置宽度 1200px、水平居中 */.container &#123;  width: 1200px;  margin: 0 auto;&#125;</code></pre><h2 id="二、选择器：如何选中元素？"><a href="#二、选择器：如何选中元素？" class="headerlink" title="二、选择器：如何选中元素？"></a>二、选择器：如何选中元素？</h2><p>选择器是 CSS 的核心，用于精准定位 HTML 元素，以下是最常用的基础选择器：</p><table><thead><tr><th>选择器类型</th><th>语法</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>元素选择器</td><td>标签名</td><td>选中所有该标签的元素</td><td><code>div &#123; ... &#125;</code>（选中所有 <code>&lt;div&gt;</code>）</td></tr><tr><td>类选择器</td><td><code>.类名</code></td><td>选中所有 <code>class=&quot;类名&quot;</code> 的元素（可复用）</td><td><code>.active &#123; color: blue; &#125;</code>（选中 <code>&lt;p class=&quot;active&quot;&gt;</code>）</td></tr><tr><td>ID 选择器</td><td><code>#ID名</code></td><td>选中唯一 <code>id=&quot;ID名&quot;</code> 的元素（不可重复）</td><td><code>#header &#123; height: 80px; &#125;</code>（选中 <code>&lt;header id=&quot;header&quot;&gt;</code>）</td></tr><tr><td>通配符选择器</td><td><code>*</code></td><td>选中页面所有元素（慎用，性能较低）</td><td><code>* &#123; margin: 0; padding: 0; &#125;</code>（清除所有元素默认边距）</td></tr><tr><td>后代选择器</td><td>选择器 1 选择器 2</td><td>选中选择器 1 内部的所有选择器 2 元素</td><td><code>nav a &#123; text-decoration: none; &#125;</code>（选中 <code>&lt;nav&gt;</code> 内所有 <code>&lt;a&gt;</code>）</td></tr><tr><td>交集选择器</td><td>选择器 1 选择器 2</td><td>同时满足两个选择器的元素（无空格）</td><td><code>p.active &#123; font-weight: bold; &#125;</code>（选中 <code>&lt;p class=&quot;active&quot;&gt;</code>）</td></tr><tr><td>并集选择器</td><td>选择器 1, 选择器 2</td><td>同时选中多个选择器的元素（用逗号分隔）</td><td><code>h1, h2, h3 &#123; color: #333; &#125;</code>（选中所有 <code>h1/h2/h3</code>）</td></tr></tbody></table><h2 id="三、样式声明：属性与值的规则"><a href="#三、样式声明：属性与值的规则" class="headerlink" title="三、样式声明：属性与值的规则"></a>三、样式声明：属性与值的规则</h2><h3 id="1-属性值的常见类型"><a href="#1-属性值的常见类型" class="headerlink" title="1. 属性值的常见类型"></a>1. 属性值的常见类型</h3><p>CSS 属性值需符合对应属性的规范，常见类型：</p><ul><li>颜色值：<code>red</code>（英文）、<code>#ff0000</code>（十六进制）、<code>rgb(255,0,0)</code>（RGB）、<code>rgba(255,0,0,0.5)</code>（带透明度）</li><li>尺寸值：<code>10px</code>（像素，固定尺寸）、<code>2em</code>（相对当前字体大小）、<code>50%</code>（相对父元素尺寸）、<code>auto</code>（自动）</li><li>关键字：<code>center</code>（居中）、<code>block</code>（块级）、<code>none</code>（无）、<code>bold</code>（加粗）</li></ul><h3 id="2-声明的注意事项"><a href="#2-声明的注意事项" class="headerlink" title="2. 声明的注意事项"></a>2. 声明的注意事项</h3><ul><li>分号必须：每个声明结尾必须加 <code>;</code>，否则后续样式可能失效（最后一个声明可省略，但推荐统一添加，避免出错）</li><li>大小写不敏感：CSS 对大小写不敏感（如 <code>Color: Red</code> 等价于 <code>color: red</code>），但建议统一小写（规范）</li><li>空格不影响：声明中可适当加空格（如 <code>font-size: 16px</code> 等价于 <code>font-size:16px</code>），增强可读性</li></ul><h2 id="四、注释：代码说明（不生效）"><a href="#四、注释：代码说明（不生效）" class="headerlink" title="四、注释：代码说明（不生效）"></a>四、注释：代码说明（不生效）</h2><p>CSS 注释用于解释代码，浏览器会忽略注释内容，语法：</p><pre><code class="css">/* 单行注释 */p &#123;  color: #333; /* 文字颜色：深灰色（行内注释） */&#125;/*  多行注释  选中 .box 元素，设置背景色和内边距*/.box &#123;  background: #f5f5f5;  padding: 20px;&#125;</code></pre><blockquote><p>注意：CSS 没有 <code>//</code> 注释语法，<code>//</code> 会导致后续代码失效！</p></blockquote><h2 id="五、CSS-的引入方式（3-种核心）"><a href="#五、CSS-的引入方式（3-种核心）" class="headerlink" title="五、CSS 的引入方式（3 种核心）"></a>五、CSS 的引入方式（3 种核心）</h2><p>CSS 需引入 HTML 才能生效，3 种常用方式：</p><h3 id="1-内联样式（行内样式）"><a href="#1-内联样式（行内样式）" class="headerlink" title="1. 内联样式（行内样式）"></a>1. 内联样式（行内样式）</h3><p>直接写在 HTML 元素的 <code>style</code> 属性中，优先级最高（仅作用于当前元素）：</p><pre><code class="html">&lt;p style=&quot;color: green; font-size: 18px;&quot;&gt;这是内联样式的文字&lt;/p&gt;</code></pre><blockquote><p>缺点：样式与结构耦合，复用性差，仅适合临时修改单个元素。</p></blockquote><h3 id="2-内部样式表（嵌入式）"><a href="#2-内部样式表（嵌入式）" class="headerlink" title="2. 内部样式表（嵌入式）"></a>2. 内部样式表（嵌入式）</h3><p>写在 HTML 的 <code>标签中（通常放在</code> 内），作用于当前 HTML 文件：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;style&gt;    /* 内部样式表 */    h1 &#123; color: purple; &#125;    .content &#123; line-height: 1.5; &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;标题&lt;/h1&gt;  &lt;div class=&quot;content&quot;&gt;内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>优点：样式与结构分离（同一文件内），适合单页面样式。</p></blockquote><h3 id="3-外部样式表（链接式）"><a href="#3-外部样式表（链接式）" class="headerlink" title="3. 外部样式表（链接式）"></a>3. 外部样式表（链接式）</h3><p>将 CSS 写在独立的 <code>.css</code> 文件中，通过 <code>&lt;link&gt;</code> 标签引入 HTML，最推荐（复用性强、维护方便）：</p><h4 id="步骤-1：创建-CSS-文件（如-style-css）"><a href="#步骤-1：创建-CSS-文件（如-style-css）" class="headerlink" title="步骤 1：创建 CSS 文件（如 style.css）"></a>步骤 1：创建 CSS 文件（如 <code>style.css</code>）</h4><pre><code class="css">/* style.css */body &#123; background: #f9f9f9; &#125;a &#123; color: #0066cc; text-decoration: none; &#125;</code></pre><h4 id="步骤-2：HTML-中引入"><a href="#步骤-2：HTML-中引入" class="headerlink" title="步骤 2：HTML 中引入"></a>步骤 2：HTML 中引入</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;!-- 引入外部 CSS 文件 --&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;a href=&quot;#&quot;&gt;这是链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>优点：样式与结构完全分离，多个页面可共用一个 CSS 文件，便于统一维护。</p></blockquote><h2 id="六、基础语法总结"><a href="#六、基础语法总结" class="headerlink" title="六、基础语法总结"></a>六、基础语法总结</h2><ol><li>核心结构：<code>选择器 &#123; 属性: 值; &#125;</code></li><li>选择器：优先掌握「类选择器」「元素选择器」「后代选择器」（最常用）</li><li>声明：属性和值需匹配，分号不能漏，注释用 <code>/* */</code></li><li>引入方式：推荐「外部样式表」，少量样式可用「内部样式表」，避免滥用「内联样式」</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSS（层叠样式表）的核心作用是为 HTML 元素设置样式，其语法规则简洁清晰，核心由「选择器」「声明块」「属性 - 值对」三部分构成，同时包含注释、引入方式等基础规范。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://example.com/categories/web/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://example.com/2025/11/07/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://example.com/2025/11/07/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2025-11-07T10:54:19.000Z</published>
    <updated>2025-11-26T05:13:17.004Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表（Hash Table），也叫散列表，是一种<strong>基于哈希函数</strong>实现的高效数据结构，核心目标是在 <strong>O (1) 平均时间复杂度</strong> 内完成插入、查找、删除操作，是工程中最常用的数据结构之一（例如 Java 的 HashMap、Python 的 dict、C++ 的 unordered_map 等底层均基于哈希表实现）。</p><span id="more"></span><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="一、哈希表的核心思想"><a href="#一、哈希表的核心思想" class="headerlink" title="一、哈希表的核心思想"></a>一、哈希表的核心思想</h2><p>哈希表的本质是 <strong>“键（Key）→ 值（Value）” 的映射</strong>，核心解决 “如何快速通过 Key 找到 Value” 的问题：</p><ol><li>传统数组：通过<strong>索引</strong>访问元素（O (1)），但索引是连续整数，无法直接映射非整数 Key（如字符串、对象）；</li><li>链表 &#x2F; 二叉搜索树：查找需遍历（O (n) 或 O (log n)），效率较低；</li><li>哈希表的方案：<ul><li>用<strong>哈希函数</strong>将任意类型的 Key 转换为一个整数（称为 “哈希值”）；</li><li>将哈希值映射为数组的索引（通过取模等操作）；</li><li>数组的该索引位置存储对应的 Value，实现 “Key→索引→Value” 的快速映射。</li></ul></li></ol><p>简单说：<strong>哈希函数是 “翻译官”，将 Key 翻译成数组能理解的索引；数组是 “存储容器”，直接通过索引存取数据</strong>。</p><h2 id="二、哈希表的核心组成"><a href="#二、哈希表的核心组成" class="headerlink" title="二、哈希表的核心组成"></a>二、哈希表的核心组成</h2><p>哈希表由 3 个核心部分构成：</p><table><thead><tr><th>组成部分</th><th>作用</th></tr></thead><tbody><tr><td>键（Key）</td><td>唯一标识（如用户名、ID），需支持哈希函数计算（不可变类型，如整数、字符串、元组）</td></tr><tr><td>哈希函数（Hash Function）</td><td>将 Key 转换为哈希值（整数），要求：① 相同 Key 必须得到相同哈希值；② 尽量分散不同 Key 的哈希值</td></tr><tr><td>哈希桶（Hash Bucket）</td><td>存储数据的数组（“桶” 即数组的每个元素位置），通过哈希值映射到桶的索引</td></tr></tbody></table><h3 id="1-哈希函数的设计原则"><a href="#1-哈希函数的设计原则" class="headerlink" title="1. 哈希函数的设计原则"></a>1. 哈希函数的设计原则</h3><p>哈希函数的质量直接决定哈希表的效率，需满足以下要求：</p><ul><li><strong>确定性</strong>：同一 Key 多次计算，哈希值必须相同（否则无法找到对应 Value）；</li><li><strong>高效性</strong>：计算过程简单，时间复杂度 O (1)（不能比查找本身更耗时）；</li><li><strong>均匀性</strong>：不同 Key 的哈希值尽量均匀分布在哈希桶的索引范围内（减少 “哈希冲突”）；</li><li><strong>抗碰撞性</strong>：尽量避免不同 Key 计算出相同哈希值（完全避免不可能，需后续解决）。</li></ul><h4 id="常见哈希函数示例"><a href="#常见哈希函数示例" class="headerlink" title="常见哈希函数示例"></a>常见哈希函数示例</h4><ul><li>整数 Key：直接用 Key 本身（或对桶数取模）；</li><li>字符串 Key：多项式哈希（如 <code>hash = s[0]*base^(n-1) + s[1]*base^(n-2) + ... + s[n-1]</code>，base 取 31&#x2F;127 等质数）；</li><li>对象 Key：结合对象的多个属性计算哈希值（如 Java 的 <code>hashCode()</code> 方法）。</li></ul><h3 id="2-哈希冲突（Hash-Collision）"><a href="#2-哈希冲突（Hash-Collision）" class="headerlink" title="2. 哈希冲突（Hash Collision）"></a>2. 哈希冲突（Hash Collision）</h3><h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p>不同的 Key 通过哈希函数计算后，得到了<strong>相同的哈希值</strong>，进而映射到同一个哈希桶索引，这种情况称为哈希冲突。</p><p>例如：Key1 &#x3D; “abc”，Key2 &#x3D; “cba”，可能通过哈希函数计算后得到相同的哈希值，映射到同一个桶。</p><h4 id="为什么冲突无法避免？"><a href="#为什么冲突无法避免？" class="headerlink" title="为什么冲突无法避免？"></a>为什么冲突无法避免？</h4><p>根据 <strong>鸽巢原理</strong>：若哈希桶的数量为 M，待存储的 Key 数量为 N，当 N &gt; M 时，必然有至少两个 Key 映射到同一个桶。即使 N ≤ M，也可能因哈希函数的分布性不足导致冲突。</p><h3 id="3-哈希冲突的解决方法"><a href="#3-哈希冲突的解决方法" class="headerlink" title="3. 哈希冲突的解决方法"></a>3. 哈希冲突的解决方法</h3><p>工程中最常用的两种方案：<strong>链地址法（拉链法）</strong> 和 <strong>开放地址法</strong>。</p><h4 id="（1）链地址法（拉链法）——-最常用"><a href="#（1）链地址法（拉链法）——-最常用" class="headerlink" title="（1）链地址法（拉链法）—— 最常用"></a>（1）链地址法（拉链法）—— 最常用</h4><ul><li><strong>核心思路</strong>：每个哈希桶中存储一个链表（或红黑树），当冲突发生时，将冲突的 Key-Value 对加入到链表的尾部。</li><li><strong>查询过程</strong>：<ol><li>计算 Key 的哈希值 → 映射到桶索引；</li><li>遍历该桶的链表，对比每个节点的 Key（哈希值可能相同，但 Key 本身不同）；</li><li>找到匹配的 Key 则返回 Value，否则返回不存在。</li></ol></li><li><strong>优点</strong>：<ul><li>实现简单，冲突处理高效；</li><li>不会导致其他桶的占用（开放地址法可能出现 “聚集” 问题）；</li><li>负载因子（存储元素数 &#x2F; 桶数）可大于 1（链表可无限延伸，但效率会下降）。</li></ul></li><li><strong>优化</strong>：当链表长度超过阈值（如 Java HashMap 阈值为 8），会将链表转为红黑树，将查询时间复杂度从 O (k) 优化为 O (log k)（k 为链表长度）。</li></ul><h4 id="（2）开放地址法"><a href="#（2）开放地址法" class="headerlink" title="（2）开放地址法"></a>（2）开放地址法</h4><ul><li><strong>核心思路</strong>：当冲突发生时，不使用链表存储，而是在哈希桶数组中重新寻找一个 “空闲桶” 存储数据。</li><li><strong>常见探测方式</strong>：<ul><li>线性探测：冲突后依次检查下一个桶（<code>index+1, index+2, ...</code>），直到找到空闲桶；</li><li>二次探测：冲突后检查 <code>index+1², index-1², index+2², index-2², ...</code>（避免线性探测的 “聚集” 问题）；</li><li>双重哈希：使用第二个哈希函数计算探测步长（<code>step = hash2(Key)</code>），避免聚集。</li></ul></li><li><strong>优点</strong>：无需额外存储链表节点，空间利用率更高；</li><li><strong>缺点</strong>：<ul><li>会出现 “聚集现象”（多个冲突 Key 连续占用桶，导致后续插入 &#x2F; 查询需多次探测）；</li><li>负载因子不能太大（通常 ≤ 0.7），否则探测次数会急剧增加；</li><li>删除元素时不能直接置空（会破坏探测链），需标记为 “已删除”，增加复杂度。</li></ul></li></ul><h4 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h4><ul><li>再哈希法：冲突时使用另一个哈希函数重新计算哈希值，直到找到空闲桶；</li><li>公共溢出区：将所有冲突的元素统一存储到一个 “溢出桶” 中，查询时先查原桶，再查溢出桶。</li></ul><h2 id="三、哈希表的关键参数：负载因子"><a href="#三、哈希表的关键参数：负载因子" class="headerlink" title="三、哈希表的关键参数：负载因子"></a>三、哈希表的关键参数：负载因子</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>负载因子（Load Factor）&#x3D; 哈希表中存储的元素个数（N） &#x2F; 哈希桶的数量（M），即 <code>α = N/M</code>。</p><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><p>负载因子是衡量哈希表 “拥挤程度” 的核心指标：</p><ul><li>α 越小：桶的空闲率越高，冲突概率越低，查询 &#x2F; 插入效率越高，但空间利用率低；</li><li>α 越大：桶的空闲率越低，冲突概率越高，查询 &#x2F; 插入效率越低（链表变长或探测次数增多）。</li></ul><h3 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h3><p>当负载因子超过阈值（工程中通常为 0.7），哈希表会自动进行 <strong>扩容</strong>：</p><ol><li>创建一个新的、容量更大的哈希桶数组（通常是原容量的 2 倍）；</li><li>重新计算所有原有元素的哈希值（因桶数变化，映射的索引会改变）；</li><li>将原有元素迁移到新的哈希桶中（该过程称为 “rehash”）。</li></ol><p>扩容的时间复杂度是 O (N)（需迁移所有元素），但因扩容是<strong>阶段性触发</strong>（平均每个元素只参与一次扩容），所以哈希表的平均时间复杂度仍为 O (1)。</p><h2 id="四、哈希表的时间复杂度"><a href="#四、哈希表的时间复杂度" class="headerlink" title="四、哈希表的时间复杂度"></a>四、哈希表的时间复杂度</h2><table><thead><tr><th>操作</th><th>平均时间复杂度</th><th>最坏时间复杂度（链地址法）</th><th>最坏时间复杂度（开放地址法）</th></tr></thead><tbody><tr><td>插入（put）</td><td>O(1)</td><td>O (k)（k 为链表长度，红黑树 O (log k)）</td><td>O (M)（桶满，需多次探测）</td></tr><tr><td>查找（get）</td><td>O(1)</td><td>O (k)（红黑树 O (log k)）</td><td>O(M)</td></tr><tr><td>删除（remove）</td><td>O(1)</td><td>O (k)（红黑树 O (log k)）</td><td>O(M)</td></tr></tbody></table><ul><li>最坏情况仅发生在：哈希函数设计极差（所有 Key 映射到同一个桶），或负载因子极大（未及时扩容）；</li><li>实际工程中，通过合理设计哈希函数和扩容机制，哈希表的操作基本接近 O (1)。</li></ul><h2 id="五、哈希表的应用场景"><a href="#五、哈希表的应用场景" class="headerlink" title="五、哈希表的应用场景"></a>五、哈希表的应用场景</h2><p>哈希表的核心优势是 “快速查找 &#x2F; 映射”，常见应用：</p><ol><li><strong>缓存系统</strong>：如 Redis（底层用哈希表 + 跳表），Key 是缓存键，Value 是缓存数据，实现 O (1) 存取；</li><li><strong>字典 &#x2F; 映射</strong>：如 Python 的 dict、Java 的 HashMap，存储键值对（如用户名→用户信息）；</li><li><strong>去重</strong>：如统计数组中不重复元素、日志去重，通过 Key 的唯一性快速判断元素是否已存在；</li><li><strong>哈希集合（HashSet）</strong>：基于哈希表实现，仅存储 Key（Value 为占位符），用于快速判断元素是否存在（如 Java 的 HashSet）；</li><li><strong>LRU 缓存</strong>：哈希表 + 双向链表实现，哈希表负责 O (1) 查找，双向链表负责维护访问顺序；</li><li><strong>计数统计</strong>：如统计字符串中字符出现次数（Key 是字符，Value 是次数）。</li></ol><h2 id="六、哈希表的优缺点"><a href="#六、哈希表的优缺点" class="headerlink" title="六、哈希表的优缺点"></a>六、哈希表的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>平均时间复杂度 O (1)，效率极高；</li><li>支持任意类型的 Key（只要能计算哈希值）；</li><li>实现简单，工程中成熟易用（大部分语言内置哈希表类）。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>哈希函数设计不当会导致冲突频繁，效率下降；</li><li>扩容时会产生性能开销（rehash 过程）；</li><li>元素存储无序（哈希值映射是随机的，无法保证插入顺序）；</li><li>空间利用率较低（需预留空闲桶以减少冲突）。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;哈希表（Hash Table），也叫散列表，是一种&lt;strong&gt;基于哈希函数&lt;/strong&gt;实现的高效数据结构，核心目标是在 &lt;strong&gt;O (1) 平均时间复杂度&lt;/strong&gt; 内完成插入、查找、删除操作，是工程中最常用的数据结构之一（例如 Java 的 HashMap、Python 的 dict、C++ 的 unordered_map 等底层均基于哈希表实现）。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>线段树与序列树</title>
    <link href="http://example.com/2025/10/30/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%BA%8F%E5%88%97%E6%A0%91/"/>
    <id>http://example.com/2025/10/30/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%BA%8F%E5%88%97%E6%A0%91/</id>
    <published>2025-10-30T15:10:36.000Z</published>
    <updated>2025-11-26T05:13:36.349Z</updated>
    
    <content type="html"><![CDATA[<p>QAQ</p><span id="more"></span><h1 id="线段树与序列树详解"><a href="#线段树与序列树详解" class="headerlink" title="线段树与序列树详解"></a>线段树与序列树详解</h1><h2 id="线段树（Segment-Tree）"><a href="#线段树（Segment-Tree）" class="headerlink" title="线段树（Segment Tree）"></a>线段树（Segment Tree）</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p><strong>线段树</strong>是一种二叉树数据结构，主要用于解决<strong>区间查询</strong>和<strong>区间更新</strong>问题。</p><h3 id="二、核心特性"><a href="#二、核心特性" class="headerlink" title="二、核心特性"></a>二、核心特性</h3><ul><li><strong>适用场景</strong>：区间求和、区间最值、区间更新等</li><li><strong>时间复杂度</strong>：<ul><li>建树：O(n)</li><li>区间查询：O(log n)</li><li>单点更新：O(log n)</li><li>区间更新：O(log n)（使用懒惰传播）</li></ul></li><li><strong>空间复杂度</strong>：O(4n)（数组实现）</li></ul><h3 id="三、数据结构定义"><a href="#三、数据结构定义" class="headerlink" title="三、数据结构定义"></a>三、数据结构定义</h3><pre><code class="c++">class SegmentTree &#123;private:    vector&lt;int&gt; tree;  // 线段树数组    vector&lt;int&gt; arr;   // 原始数组    vector&lt;int&gt; lazy;  // 懒惰标记数组（用于区间更新）    int n;    public:    SegmentTree(vector&lt;int&gt;&amp; nums) &#123;        n = nums.size();        arr = nums;        tree.resize(4 * n);        lazy.resize(4 * n, 0);        build(0, n-1, 0);    &#125;&#125;;</code></pre><h3 id="四、建树过程"><a href="#四、建树过程" class="headerlink" title="四、建树过程"></a>四、建树过程</h3><pre><code class="c++">// 递归建树void build(int start, int end, int node) &#123;    if (start == end) &#123;        // 叶子节点，存储单个元素        tree[node] = arr[start];        return;    &#125;        int mid = (start + end) / 2;    int leftNode = 2 * node + 1;    int rightNode = 2 * node + 2;        // 递归构建左右子树    build(start, mid, leftNode);    build(mid + 1, end, rightNode);        // 合并左右子树结果（这里是求和）    tree[node] = tree[leftNode] + tree[rightNode];&#125;</code></pre><h3 id="五、区间查询"><a href="#五、区间查询" class="headerlink" title="五、区间查询"></a>五、区间查询</h3><pre><code class="c++">// 查询区间 [l, r] 的和int query(int l, int r, int start, int end, int node) &#123;    if (l &lt;= start &amp;&amp; end &lt;= r) &#123;        // 当前区间完全在查询范围内        return tree[node];    &#125;        int mid = (start + end) / 2;    int leftNode = 2 * node + 1;    int rightNode = 2 * node + 2;    int sum = 0;        if (l &lt;= mid) &#123;        sum += query(l, r, start, mid, leftNode);    &#125;    if (r &gt; mid) &#123;        sum += query(l, r, mid + 1, end, rightNode);    &#125;        return sum;&#125;// 对外接口int queryRange(int l, int r) &#123;    return query(l, r, 0, n-1, 0);&#125;</code></pre><h3 id="六、单点更新"><a href="#六、单点更新" class="headerlink" title="六、单点更新"></a>六、单点更新</h3><pre><code class="c++">// 更新单个元素void update(int index, int value, int start, int end, int node) &#123;    if (start == end) &#123;        // 找到目标叶子节点        arr[index] = value;        tree[node] = value;        return;    &#125;        int mid = (start + end) / 2;    int leftNode = 2 * node + 1;    int rightNode = 2 * node + 2;        if (index &lt;= mid) &#123;        update(index, value, start, mid, leftNode);    &#125; else &#123;        update(index, value, mid + 1, end, rightNode);    &#125;        // 更新父节点    tree[node] = tree[leftNode] + tree[rightNode];&#125;</code></pre><h3 id="七、懒惰传播（区间更新）"><a href="#七、懒惰传播（区间更新）" class="headerlink" title="七、懒惰传播（区间更新）"></a>七、懒惰传播（区间更新）</h3><pre><code class="c++">// 懒惰传播更新void updateLazy(int l, int r, int value, int start, int end, int node) &#123;    // 先处理懒惰标记    if (lazy[node] != 0) &#123;        tree[node] += (end - start + 1) * lazy[node];        if (start != end) &#123;            // 将懒惰标记传递给子节点            lazy[2*node+1] += lazy[node];            lazy[2*node+2] += lazy[node];        &#125;        lazy[node] = 0;    &#125;        if (start &gt; r || end &lt; l) return; // 完全不重叠        if (l &lt;= start &amp;&amp; end &lt;= r) &#123;        // 当前区间完全在更新范围内        tree[node] += (end - start + 1) * value;        if (start != end) &#123;            lazy[2*node+1] += value;            lazy[2*node+2] += value;        &#125;        return;    &#125;        int mid = (start + end) / 2;    updateLazy(l, r, value, start, mid, 2*node+1);    updateLazy(l, r, value, mid+1, end, 2*node+2);    tree[node] = tree[2*node+1] + tree[2*node+2];&#125;</code></pre><h2 id="序列树（树状数组）"><a href="#序列树（树状数组）" class="headerlink" title="序列树（树状数组）"></a>序列树（树状数组）</h2><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-什么是序列树？"><a href="#1-1-什么是序列树？" class="headerlink" title="1.1 什么是序列树？"></a>1.1 什么是序列树？</h3><p><strong>序列树（Fenwick Tree &#x2F; Binary Indexed Tree）</strong> 是一种用于高效处理<strong>前缀和查询</strong>和<strong>单点更新</strong>的数据结构。</p><h3 id="1-2-核心思想"><a href="#1-2-核心思想" class="headerlink" title="1.2 核心思想"></a>1.2 核心思想</h3><p>利用<strong>二进制表示</strong>的特性，将前缀和分解为多个子区间的和，从而实现：</p><ul><li><strong>前缀和查询</strong>：O(log n)</li><li><strong>单点更新</strong>：O(log n)</li></ul><h2 id="二、核心原理-Lowbit操作"><a href="#二、核心原理-Lowbit操作" class="headerlink" title="二、核心原理 - Lowbit操作"></a>二、核心原理 - Lowbit操作</h2><h3 id="2-1-Lowbit定义"><a href="#2-1-Lowbit定义" class="headerlink" title="2.1 Lowbit定义"></a>2.1 Lowbit定义</h3><p>**Lowbit(x)**：获取x的二进制表示中最低位的1所代表的数值</p><pre><code class="c++">int lowbit(int x) &#123;    return x &amp; (-x);&#125;</code></pre><h3 id="2-2-Lowbit示例"><a href="#2-2-Lowbit示例" class="headerlink" title="2.2 Lowbit示例"></a>2.2 Lowbit示例</h3><pre><code>x = 6  (二进制: 110)  → lowbit(6) = 2  (二进制: 010)x = 12 (二进制: 1100) → lowbit(12) = 4 (二进制: 0100)x = 7  (二进制: 111)  → lowbit(7) = 1  (二进制: 001)</code></pre><h2 id="三、序列树的结构原理"><a href="#三、序列树的结构原理" class="headerlink" title="三、序列树的结构原理"></a>三、序列树的结构原理</h2><h3 id="3-1-基本结构"><a href="#3-1-基本结构" class="headerlink" title="3.1 基本结构"></a>3.1 基本结构</h3><p>序列树不是一棵显式的树，而是通过数组和下标关系隐含的树形结构。</p><p><strong>数组下标从1开始</strong>（重要！）</p><ul><li><code>tree[i]</code>：存储区间<code>[i - lowbit(i) + 1, i]</code>的和</li></ul><h3 id="3-2-存储区间示意图"><a href="#3-2-存储区间示意图" class="headerlink" title="3.2 存储区间示意图"></a>3.2 存储区间示意图</h3><p>对于长度为8的数组：</p><pre><code>tree[1] = arr[1]                                          [1,1]tree[2] = arr[1] + arr[2]                                 [1,2]  tree[3] = arr[3]                                          [3,3]tree[4] = arr[1] + arr[2] + arr[3] + arr[4]               [1,4]tree[5] = arr[5]                                          [5,5]tree[6] = arr[5] + arr[6]                                 [5,6]tree[7] = arr[7]                                          [7,7]tree[8] = arr[1] + arr[2] + ... + arr[8]                  [1,8]</code></pre><h3 id="3-3-树形结构关系"><a href="#3-3-树形结构关系" class="headerlink" title="3.3 树形结构关系"></a>3.3 树形结构关系</h3><pre><code>                tree[8]               /       \          tree[4]     tree[6]   tree[7]          /     \     /          tree[2] tree[3] tree[5]      /tree[1]</code></pre><h2 id="四、关键操作原理"><a href="#四、关键操作原理" class="headerlink" title="四、关键操作原理"></a>四、关键操作原理</h2><h3 id="4-1-单点更新原理"><a href="#4-1-单点更新原理" class="headerlink" title="4.1 单点更新原理"></a>4.1 单点更新原理</h3><p><strong>目标</strong>：更新<code>arr[i]</code>时，更新所有包含<code>arr[i]</code>的<code>tree</code>节点</p><p><strong>更新路径</strong>：沿着二进制下标不断加上lowbit(i)</p><ul><li>从<code>i</code>开始</li><li><code>i = i + lowbit(i)</code></li><li>重复直到<code>i &gt; n</code></li></ul><pre><code class="C++">void update(int index, int value) &#123;    int i = index + 1;  // 序列树下标从1开始    while (i &lt;= n) &#123;        tree[i] += value;        i += lowbit(i);  // 跳到父节点    &#125;&#125;</code></pre><h4 id="更新示例：更新arr-3-（即tree-4-中的元素）"><a href="#更新示例：更新arr-3-（即tree-4-中的元素）" class="headerlink" title="更新示例：更新arr[3]（即tree[4]中的元素）"></a>更新示例：更新arr[3]（即tree[4]中的元素）</h4><p>更新路径：3 → 4 → 8</p><pre><code>更新arr[3] = 5:1. tree[3] += 5    (包含arr[3])2. tree[4] += 5    (包含arr[1]-arr[4])  3. tree[8] += 5    (包含arr[1]-arr[8])</code></pre><h3 id="4-2-前缀和查询原理"><a href="#4-2-前缀和查询原理" class="headerlink" title="4.2 前缀和查询原理"></a>4.2 前缀和查询原理</h3><p><strong>目标</strong>：计算<code>arr[1] + arr[2] + ... + arr[i]</code>的和</p><p><strong>查询路径</strong>：沿着二进制下标不断减去lowbit(i)</p><ul><li>从<code>i</code>开始</li><li><code>i = i - lowbit(i)</code></li><li>重复直到<code>i == 0</code></li></ul><pre><code>int query(int index) &#123;    int sum = 0;    int i = index + 1;  // 序列树下标从1开始    while (i &gt; 0) &#123;        sum += tree[i];        i -= lowbit(i);  // 跳到前一个区间    &#125;    return sum;&#125;</code></pre><h4 id="查询示例：查询前缀和-1-7"><a href="#查询示例：查询前缀和-1-7" class="headerlink" title="查询示例：查询前缀和[1,7]"></a>查询示例：查询前缀和[1,7]</h4><p>查询路径：7 → 6 → 4 → 结束</p><pre><code>查询前缀和[1,7]:sum = tree[7] + tree[6] + tree[4]tree[7] = arr[7]                    [7,7]tree[6] = arr[5] + arr[6]           [5,6]  tree[4] = arr[1] + arr[2] + arr[3] + arr[4]  [1,4]总和 = arr[1]到arr[7]的和</code></pre><h2 id="五、数学原理深度解析"><a href="#五、数学原理深度解析" class="headerlink" title="五、数学原理深度解析"></a>五、数学原理深度解析</h2><h3 id="5-1-二进制分解原理"><a href="#5-1-二进制分解原理" class="headerlink" title="5.1 二进制分解原理"></a>5.1 二进制分解原理</h3><p><strong>关键观察</strong>：任何数字都可以表示为2的幂次之和</p><pre><code>7 = 4 + 2 + 113 = 8 + 4 + 1</code></pre><p>序列树利用这个性质将前缀和分解：</p><pre><code>sum[1,7] = sum[1,4] + sum[5,6] + sum[7,7]         = tree[4] + tree[6] + tree[7]</code></pre><h3 id="5-2-区间覆盖证明"><a href="#5-2-区间覆盖证明" class="headerlink" title="5.2 区间覆盖证明"></a>5.2 区间覆盖证明</h3><p><strong>定理</strong>：对于任意i，区间<code>[i-lowbit(i)+1, i]</code>的长度正好是<code>lowbit(i)</code></p><p><strong>证明</strong>：</p><ul><li>设<code>i</code>的二进制为：<code>xxxx100...0</code>（最后k个0）</li><li><code>lowbit(i) = 2^k</code></li><li><code>i - lowbit(i) = xxxx000...0</code></li><li>区间长度 &#x3D; <code>i - (i - lowbit(i)) = lowbit(i)</code></li></ul><h3 id="5-3-操作正确性证明"><a href="#5-3-操作正确性证明" class="headerlink" title="5.3 操作正确性证明"></a>5.3 操作正确性证明</h3><p><strong>更新正确性</strong>：每个被更新的节点确实包含目标元素</p><ul><li>因为更新路径是不断加上lowbit，覆盖的区间越来越大</li><li>每个父节点都包含子节点的区间</li></ul><p><strong>查询正确性</strong>：所有子区间正好覆盖<code>[1, i]</code></p><ul><li>每次减去lowbit，得到不相交的区间</li><li>这些区间的并集正好是<code>[1, i]</code></li></ul><h2 id="六、完整实现与示例"><a href="#六、完整实现与示例" class="headerlink" title="六、完整实现与示例"></a>六、完整实现与示例</h2><h3 id="6-1-完整序列树实现"><a href="#6-1-完整序列树实现" class="headerlink" title="6.1 完整序列树实现"></a>6.1 完整序列树实现</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class FenwickTree &#123;private:    vector&lt;int&gt; tree;    int n;        int lowbit(int x) &#123;        return x &amp; (-x);    &#125;    public:    // 构造函数：从数组构建    FenwickTree(vector&lt;int&gt;&amp; nums) &#123;        n = nums.size();        tree.resize(n + 1, 0);        for (int i = 0; i &lt; n; i++) &#123;            update(i, nums[i]);        &#125;    &#125;        // 单点更新：在位置index增加value    void update(int index, int value) &#123;        int i = index + 1;  // 转为1-based索引        while (i &lt;= n) &#123;            tree[i] += value;            i += lowbit(i);        &#125;    &#125;        // 查询前缀和：[0, index]的和    int query(int index) &#123;        int sum = 0;        int i = index + 1;  // 转为1-based索引        while (i &gt; 0) &#123;            sum += tree[i];            i -= lowbit(i);        &#125;        return sum;    &#125;        // 查询区间和：[l, r]的和    int queryRange(int l, int r) &#123;        if (l == 0) return query(r);        return query(r) - query(l - 1);    &#125;        // 打印树结构（用于调试）    void printTree() &#123;        cout &lt;&lt; &quot;序列树结构:&quot; &lt;&lt; endl;        for (int i = 1; i &lt;= n; i++) &#123;            cout &lt;&lt; &quot;tree[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; tree[i]                  &lt;&lt; &quot; (覆盖区间: [&quot; &lt;&lt; i - lowbit(i) + 1 &lt;&lt; &quot;, &quot; &lt;&lt; i &lt;&lt; &quot;])&quot; &lt;&lt; endl;        &#125;    &#125;&#125;;</code></pre><h3 id="6-2-运行示例"><a href="#6-2-运行示例" class="headerlink" title="6.2 运行示例"></a>6.2 运行示例</h3><pre><code class="c++">int main() &#123;    vector&lt;int&gt; arr = &#123;1, 3, 5, 7, 9, 11&#125;;    FenwickTree ft(arr);        ft.printTree();        cout &lt;&lt; &quot;\n前缀和查询:&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;前缀和[0,2]: &quot; &lt;&lt; ft.query(2) &lt;&lt; &quot; (应为: 1+3+5=9)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;前缀和[0,4]: &quot; &lt;&lt; ft.query(4) &lt;&lt; &quot; (应为: 1+3+5+7+9=25)&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;\n区间和查询:&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;区间[2,4]: &quot; &lt;&lt; ft.queryRange(2, 4) &lt;&lt; &quot; (应为: 5+7+9=21)&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;\n更新测试:&quot; &lt;&lt; endl;    ft.update(3, 10);  // arr[3]从7增加到17    cout &lt;&lt; &quot;更新后区间[2,4]: &quot; &lt;&lt; ft.queryRange(2, 4) &lt;&lt; &quot; (应为: 5+17+9=31)&quot; &lt;&lt; endl;        return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;QAQ&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树与哈夫曼编码</title>
    <link href="http://example.com/2025/10/30/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <id>http://example.com/2025/10/30/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</id>
    <published>2025-10-30T14:54:11.000Z</published>
    <updated>2025-11-26T05:13:26.419Z</updated>
    
    <content type="html"><![CDATA[<p>QAQ</p><span id="more"></span><h1 id="哈夫曼树与哈夫曼编码详解"><a href="#哈夫曼树与哈夫曼编码详解" class="headerlink" title="哈夫曼树与哈夫曼编码详解"></a>哈夫曼树与哈夫曼编码详解</h1><h2 id="一、哈夫曼树构建原理"><a href="#一、哈夫曼树构建原理" class="headerlink" title="一、哈夫曼树构建原理"></a>一、哈夫曼树构建原理</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p><strong>哈夫曼树（Huffman Tree）</strong>：是一种带权路径长度最短的二叉树，也称为最优二叉树。</p><p><strong>关键术语：</strong></p><ul><li><strong>权值（Weight）</strong>：每个字符的出现频率或概率</li><li><strong>路径长度</strong>：从根节点到该节点的边数</li><li><strong>节点的带权路径长度</strong>：权值 × 路径长度</li><li><strong>树的带权路径长度（WPL）</strong>：所有叶子节点的带权路径长度之和</li></ul><h3 id="1-2-构建算法步骤"><a href="#1-2-构建算法步骤" class="headerlink" title="1.2 构建算法步骤"></a>1.2 构建算法步骤</h3><h4 id="步骤1：初始化"><a href="#步骤1：初始化" class="headerlink" title="步骤1：初始化"></a>步骤1：初始化</h4><p>将每个字符看作一个独立的二叉树，权值为该字符的频率，组成森林F。</p><p><strong>示例</strong>：假设有字符集 {A, B, C, D}，频率分别为 {5, 3, 2, 1}</p><p>初始森林：</p><pre><code>A(5)  B(3)  C(2)  D(1)</code></pre><h4 id="步骤2：选择最小权值树"><a href="#步骤2：选择最小权值树" class="headerlink" title="步骤2：选择最小权值树"></a>步骤2：选择最小权值树</h4><p>从森林F中选择<strong>权值最小的两棵树</strong>（如果有多棵树权值相同，任意选择）。</p><p>第一次选择：C(2) 和 D(1) 最小</p><h4 id="步骤3：合并树"><a href="#步骤3：合并树" class="headerlink" title="步骤3：合并树"></a>步骤3：合并树</h4><p>将选中的两棵树合并，新树的根节点权值为两棵树权值之和，原来的两棵树作为新树的左右子树。</p><p>合并C和D：</p><pre><code>新根节点(3)     /   \   C(2)  D(1)</code></pre><p>更新后的森林：</p><pre><code>A(5)  B(3)  新树(3)</code></pre><h4 id="步骤4：重复过程"><a href="#步骤4：重复过程" class="headerlink" title="步骤4：重复过程"></a>步骤4：重复过程</h4><p>重复步骤2-3，直到森林中只剩一棵树。</p><p><strong>第二次选择</strong>：B(3) 和新树(3) 最小（权值相同，任意选择）</p><pre><code>  新根节点(6)       /    \     B(3)   新树(3)              /   \            C(2)  D(1)</code></pre><p>更新后的森林：</p><pre><code>A(5)  新树(6)</code></pre><p><strong>第三次选择</strong>：A(5) 和新树(6) 合并</p><pre><code>    根节点(11)        /    \     A(5)    新树(6)              /   \            B(3)   子树(3)                    /   \                  C(2)  D(1)</code></pre><h3 id="1-3-构建过程可视化"><a href="#1-3-构建过程可视化" class="headerlink" title="1.3 构建过程可视化"></a>1.3 构建过程可视化</h3><pre><code>初始: A(5)  B(3)  C(2)  D(1)第1次合并:    C(2) + D(1) = 新树1(3)   森林: A(5)  B(3)  新树1(3)第2次合并:   B(3) + 新树1(3) = 新树2(6)   森林: A(5)  新树2(6)第3次合并:   A(5) + 新树2(6) = 根节点(11)   完成构建</code></pre><p>最终哈夫曼树：</p><pre><code>      11     /  \    5     6   A(5)  / \       3     3      B(3)  / \          2     1         C(2) D(1)</code></pre><h2 id="二、哈夫曼编码原理"><a href="#二、哈夫曼编码原理" class="headerlink" title="二、哈夫曼编码原理"></a>二、哈夫曼编码原理</h2><h3 id="2-1-编码规则"><a href="#2-1-编码规则" class="headerlink" title="2.1 编码规则"></a>2.1 编码规则</h3><p><strong>前缀编码特性</strong>：任何一个字符的编码都不是另一个字符编码的前缀，保证了解码的唯一性。</p><p><strong>编码规则：</strong></p><ol><li>从根节点开始，向左子树走编码为’0’，向右子树走编码为’1’</li><li>到达叶子节点时，路径上的0和1序列就是该字符的编码</li></ol><h3 id="2-2-编码过程"><a href="#2-2-编码过程" class="headerlink" title="2.2 编码过程"></a>2.2 编码过程</h3><p>基于上面构建的哈夫曼树：</p><pre><code>       11     0/  \1    5     6   A    0/ \1       3     3      B    0/ \1          2     1         C     D</code></pre><p><strong>编码生成：</strong></p><ul><li><strong>A</strong>：从根向左 → <code>0</code></li><li><strong>B</strong>：从根向右(1)，再向左(0) → <code>10</code></li><li><strong>C</strong>：从根向右(1)，再向右(1)，再向左(0) → <code>110</code></li><li><strong>D</strong>：从根向右(1)，再向右(1)，再向右(1) → <code>111</code></li></ul><p>编码表：</p><pre><code>A: 0B: 10  C: 110D: 111</code></pre><h3 id="2-3-编码验证"><a href="#2-3-编码验证" class="headerlink" title="2.3 编码验证"></a>2.3 编码验证</h3><p><strong>前缀编码验证：</strong></p><ul><li>A的编码<code>0</code>不是B<code>10</code>、C<code>110</code>、D<code>111</code>的前缀</li><li>B的编码<code>10</code>不是C<code>110</code>、D<code>111</code>的前缀</li><li>C的编码<code>110</code>不是D<code>111</code>的前缀</li></ul><p><strong>满足前缀编码条件，可以无歧义解码。</strong></p><h3 id="2-4-编码示例"><a href="#2-4-编码示例" class="headerlink" title="2.4 编码示例"></a>2.4 编码示例</h3><p>文本：<code>&quot;ABACABAD&quot;</code></p><p>编码过程：</p><pre><code>A: 0B: 10A: 0  C: 110A: 0B: 10A: 0D: 111</code></pre><p>编码结果：<code>0 10 0 110 0 10 0 111</code>→ <code>01001100100111</code></p><h3 id="2-5-解码过程"><a href="#2-5-解码过程" class="headerlink" title="2.5 解码过程"></a>2.5 解码过程</h3><p>编码流：<code>01001100100111</code></p><p>解码：</p><ol><li>从根开始，读入<code>0</code>→ 到达A，输出A，回到根</li><li>读入<code>1</code>→ 向右，读入<code>0</code>→ 到达B，输出B，回到根</li><li>读入<code>0</code>→ 到达A，输出A，回到根</li><li>读入<code>1</code>→ 向右，读入<code>1</code>→ 向右，读入<code>0</code>→ 到达C，输出C，回到根</li><li>继续解码…</li></ol><p>最终得到：<code>ABACABAD</code></p><h2 id="三、数学原理分析"><a href="#三、数学原理分析" class="headerlink" title="三、数学原理分析"></a>三、数学原理分析</h2><h3 id="3-1-最优性证明"><a href="#3-1-最优性证明" class="headerlink" title="3.1 最优性证明"></a>3.1 最优性证明</h3><p><strong>贪心选择性质</strong>：每次选择频率最小的两个节点合并，可以保证全局最优。</p><p><strong>数学证明思路：</strong></p><ol><li>频率最小的两个字符在最优编码中深度最大</li><li>这两个字符应该是兄弟节点</li><li>将问题规模缩小，数学归纳法证明</li></ol><h3 id="3-2-压缩效率计算"><a href="#3-2-压缩效率计算" class="headerlink" title="3.2 压缩效率计算"></a>3.2 压缩效率计算</h3><p><strong>原始编码</strong>（定长编码）：</p><ul><li>4个字符需要2位：A:00, B:01, C:10, D:11</li><li>文本”ABACABAD”长度：8字符 × 2位 &#x3D; 16位</li></ul><p><strong>哈夫曼编码</strong>：</p><ul><li>A(频率5): 1位 × 5次 &#x3D; 5位</li><li>B(频率3): 2位 × 3次 &#x3D; 6位</li><li>C(频率2): 3位 × 2次 &#x3D; 6位</li><li>D(频率1): 3位 × 1次 &#x3D; 3位</li><li>总位数：5 + 6 + 6 + 3 &#x3D; 20位</li></ul><p><strong>压缩率</strong>：(16 - 20)&#x2F;16 × 100% &#x3D; -25%（实际是膨胀，因为示例数据量小）</p><p><strong>注意</strong>：对于实际的大文本，高频字符用短编码，总体效果是压缩。</p><h3 id="3-3-复杂度分析"><a href="#3-3-复杂度分析" class="headerlink" title="3.3 复杂度分析"></a>3.3 复杂度分析</h3><p><strong>时间复杂度</strong>：O(n log n)</p><ul><li>使用最小堆选择最小权值节点</li></ul><p><strong>空间复杂度</strong>：O(n)</p><ul><li>存储哈夫曼树节点和编码表</li></ul><h2 id="四、核心特点总结"><a href="#四、核心特点总结" class="headerlink" title="四、核心特点总结"></a>四、核心特点总结</h2><h3 id="4-1-哈夫曼树特点"><a href="#4-1-哈夫曼树特点" class="headerlink" title="4.1 哈夫曼树特点"></a>4.1 哈夫曼树特点</h3><ol><li><strong>带权路径最短</strong>：WPL最小</li><li><strong>没有度为1的节点</strong>：严格的二叉树</li><li><strong>频率高的字符靠近根节点</strong></li><li><strong>频率低的字符在深层</strong></li></ol><h3 id="4-2-哈夫曼编码特点"><a href="#4-2-哈夫曼编码特点" class="headerlink" title="4.2 哈夫曼编码特点"></a>4.2 哈夫曼编码特点</h3><ol><li><strong>前缀编码</strong>：无歧义解码</li><li><strong>最优压缩</strong>：对于给定频率分布是最优的</li><li><strong>变长编码</strong>：高频字符用短编码，低频字符用长编码</li><li><strong>需要编码表</strong>：解码时需要哈夫曼树或编码表</li></ol><h2 id="五、哈夫曼树构建示例（cpp）"><a href="#五、哈夫曼树构建示例（cpp）" class="headerlink" title="五、哈夫曼树构建示例（cpp）"></a>五、哈夫曼树构建示例（cpp）</h2><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;// 哈夫曼树节点结构struct HuffmanNode &#123;    char data;           // 字符    int frequency;       // 频率    HuffmanNode *left;   // 左子树    HuffmanNode *right;  // 右子树        // 构造函数    HuffmanNode(char data, int frequency) : data(data), frequency(frequency),                                            left(nullptr), right(nullptr) &#123;&#125;&#125;;// 比较器，用于优先队列（最小堆）struct CompareNodes &#123;    bool operator()(HuffmanNode* a, HuffmanNode* b) &#123;        return a-&gt;frequency &gt; b-&gt;frequency; // 频率小的节点优先级高    &#125;&#125;;// 构建哈夫曼树HuffmanNode* buildHuffmanTree(const unordered_map&lt;char, int&gt;&amp; frequencies) &#123;    // 创建优先队列（最小堆）    priority_queue&lt;HuffmanNode*, vector&lt;HuffmanNode*&gt;, CompareNodes&gt; minHeap;        // 将所有字符节点加入堆    for (const auto&amp; pair : frequencies) &#123;        minHeap.push(new HuffmanNode(pair.first, pair.second));    &#125;        // 构建哈夫曼树    while (minHeap.size() &gt; 1) &#123;        // 取出频率最小的两个节点        HuffmanNode* left = minHeap.top();        minHeap.pop();                HuffmanNode* right = minHeap.top();        minHeap.pop();                // 创建新的内部节点，频率为两个节点频率之和        HuffmanNode* internalNode = new HuffmanNode(&#39;$&#39;, left-&gt;frequency + right-&gt;frequency);        internalNode-&gt;left = left;        internalNode-&gt;right = right;                // 将新节点加入堆        minHeap.push(internalNode);    &#125;        // 剩下的节点就是根节点    return minHeap.top();&#125;// 生成哈夫曼编码void generateHuffmanCodes(HuffmanNode* root, string currentCode,                          unordered_map&lt;char, string&gt;&amp; huffmanCodes) &#123;    if (root == nullptr) &#123;        return;    &#125;        // 如果是叶子节点，保存其编码    if (root-&gt;data != &#39;$&#39;) &#123;        huffmanCodes[root-&gt;data] = currentCode;        return;    &#125;        // 递归遍历左子树和右子树    generateHuffmanCodes(root-&gt;left, currentCode + &quot;0&quot;, huffmanCodes);    generateHuffmanCodes(root-&gt;right, currentCode + &quot;1&quot;, huffmanCodes);&#125;// 编码字符串string encodeString(const string&amp; text, const unordered_map&lt;char, string&gt;&amp; huffmanCodes) &#123;    string encodedString;    for (char c : text) &#123;        encodedString += huffmanCodes.at(c);    &#125;    return encodedString;&#125;// 解码哈夫曼编码string decodeString(const string&amp; encodedString, HuffmanNode* root) &#123;    string decodedString;    HuffmanNode* current = root;        for (char bit : encodedString) &#123;        if (bit == &#39;0&#39;) &#123;            current = current-&gt;left;        &#125; else &#123;            current = current-&gt;right;        &#125;                // 如果到达叶子节点        if (current-&gt;left == nullptr &amp;&amp; current-&gt;right == nullptr) &#123;            decodedString += current-&gt;data;            current = root; // 回到根节点，开始下一个字符的解码        &#125;    &#125;        return decodedString;&#125;// 计算字符频率unordered_map&lt;char, int&gt; calculateFrequencies(const string&amp; text) &#123;    unordered_map&lt;char, int&gt; frequencies;    for (char c : text) &#123;        frequencies[c]++;    &#125;    return frequencies;&#125;// 释放哈夫曼树内存void deleteHuffmanTree(HuffmanNode* root) &#123;    if (root == nullptr) return;    deleteHuffmanTree(root-&gt;left);    deleteHuffmanTree(root-&gt;right);    delete root;&#125;int main() &#123;    string text = &quot;this is an example for huffman encoding&quot;;        // 计算字符频率    unordered_map&lt;char, int&gt; frequencies = calculateFrequencies(text);        // 构建哈夫曼树    HuffmanNode* root = buildHuffmanTree(frequencies);        // 生成哈夫曼编码    unordered_map&lt;char, string&gt; huffmanCodes;    generateHuffmanCodes(root, &quot;&quot;, huffmanCodes);        // 输出哈夫曼编码    cout &lt;&lt; &quot;哈夫曼编码：&quot; &lt;&lt; endl;    for (const auto&amp; pair : huffmanCodes) &#123;        cout &lt;&lt; pair.first &lt;&lt; &quot; : &quot; &lt;&lt; pair.second &lt;&lt; endl;    &#125;        // 编码字符串    string encodedString = encodeString(text, huffmanCodes);    cout &lt;&lt; &quot;\n编码后的字符串：&quot; &lt;&lt; encodedString &lt;&lt; endl;        // 解码字符串    string decodedString = decodeString(encodedString, root);    cout &lt;&lt; &quot;\n解码后的字符串：&quot; &lt;&lt; decodedString &lt;&lt; endl;        // 计算压缩率    int originalSize = text.size() * 8; // 假设每个字符占8位    int compressedSize = encodedString.size();    double compressionRatio = (1.0 - (double)compressedSize / originalSize) * 100;    cout &lt;&lt; &quot;\n原始大小：&quot; &lt;&lt; originalSize &lt;&lt; &quot; 位&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;压缩后大小：&quot; &lt;&lt; compressedSize &lt;&lt; &quot; 位&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;压缩率：&quot; &lt;&lt; compressionRatio &lt;&lt; &quot;%&quot; &lt;&lt; endl;        // 释放内存    deleteHuffmanTree(root);        return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;QAQ&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
