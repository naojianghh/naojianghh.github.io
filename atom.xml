<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NaoJianghh</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-09-06T04:29:00.491Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>脑浆糊</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>页面展示与交互（进阶）</title>
    <link href="http://example.com/2025/09/06/RecyclerView%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2025/09/06/RecyclerView%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</id>
    <published>2025-09-06T04:25:56.000Z</published>
    <updated>2025-09-06T04:29:00.491Z</updated>
    
    <content type="html"><![CDATA[<p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="仿哔哩哔哩哔哩项目收藏夹的展示与交互设计"><a href="#仿哔哩哔哩哔哩项目收藏夹的展示与交互设计" class="headerlink" title="仿哔哩哔哩哔哩项目收藏夹的展示与交互设计"></a>仿哔哩哔哩哔哩项目收藏夹的展示与交互设计</h1><p>收藏夹的展示与交互是仿哔哩哔哩项目中用户体验的重要组成部分，主要体现在收藏夹列表展示、收藏操作流程和收藏内容管理三个方面。以下从 UI 设计、交互逻辑和核心实现三个维度进行详细说明：</p><h2 id="一、收藏夹的层级展示设计"><a href="#一、收藏夹的层级展示设计" class="headerlink" title="一、收藏夹的层级展示设计"></a>一、收藏夹的层级展示设计</h2><h3 id="1-收藏夹列表页（MyFavoritesActivity）"><a href="#1-收藏夹列表页（MyFavoritesActivity）" class="headerlink" title="1. 收藏夹列表页（MyFavoritesActivity）"></a>1. 收藏夹列表页（MyFavoritesActivity）</h3><p>采用分组式列表展示结构，将收藏夹分为 “默认收藏夹” 和自定义收藏夹两类，通过 RecyclerView 实现多级级列表展示：</p><pre><code class="java">// 构建收藏夹与视频的映射关系folderMap = new HashMap&lt;&gt;();List&lt;FavoriteData&gt; defaultFolderFavorites = new ArrayList&lt;&gt;();for (FavoriteData favorite : favorites) &#123;    if (favorite.getFolderName().equals(DEFAULT_FOLDER_NAME)) &#123;        defaultFolderFavorites.add(favorite);    &#125;&#125;folderMap.put(DEFAULT_FOLDER_NAME, defaultFolderFavorites);</code></pre><p>界面布局采用自定义 RecyclerView 适配器，通过多类型视图区分不同的展示元素：</p><ul><li>头部视图（TYPE_HEADER）：展示默认收藏夹</li><li>内容项（TYPE_ITEM）：展示收藏的视频缩略图</li><li>自定义收藏夹（TYPE_CREATED_FOLDERS）：展示用户创建的收藏夹</li></ul><h3 id="2-收藏夹详情页（FolderActivity）"><a href="#2-收藏夹详情页（FolderActivity）" class="headerlink" title="2. 收藏夹详情页（FolderActivity）"></a>2. 收藏夹详情页（FolderActivity）</h3><p>单收藏夹内容展示采用采用 “标题栏 + 功能区 + 视频列表” 的布局结构：</p><ul><li>顶部显示收藏夹名称和返回按钮</li><li>支持设置收藏夹封面图（相机拍摄或相册选择）</li><li>列表展示该收藏夹下所有视频，点击可跳转至视频播放页</li></ul><p>核心代码实现：</p><pre><code class="java">// 加载收藏夹封面图String coverPath = databaseHelper.getFolderCover(folderName);if (coverPath != null &amp;&amp; !coverPath.isEmpty()) &#123;    setPicture.setVisibility(View.VISIBLE);    // 区分封面类型：路径（相机图）/ Uri字符串（相册图）    if (coverPath.startsWith(&quot;/&quot;)) &#123;        // 相机图：通过路径加载图片（压缩避免OOM）        Bitmap compressedBitmap = decodeCompressedBitmap(coverPath, 80, 80);        setPicture.setImageBitmap(compressedBitmap);    &#125; else if (coverPath.startsWith(&quot;content://&quot;)) &#123;        // 相册图：通过Uri加载        Uri coverUri = Uri.parse(coverPath.split(&quot;\\|&quot;)[0]);        setPicture.setImageURI(coverUri);    &#125;&#125;</code></pre><h2 id="二、核心交互流程"><a href="#二、核心交互流程" class="headerlink" title="二、核心交互流程"></a>二、核心交互流程</h2><h3 id="1-视频收藏操作流程"><a href="#1-视频收藏操作流程" class="headerlink" title="1. 视频收藏操作流程"></a>1. 视频收藏操作流程</h3><p><strong>触发入口</strong>：视频详情页的收藏按钮（item_video_function.xml 中的 collect ImageView）</p><p><strong>交互流程</strong>：</p><ol><li>点击收藏按钮，弹出底部夹弹窗（FavoriteDialogFragment）</li><li>弹窗展示现有有收藏夹列表，支持创建新收藏夹</li><li>选择目标收藏夹后，通过数据库 DatabaseHelper 将视频添加到对应收藏夹</li><li>收藏成功后实时新 UI 状态，更新收藏按钮样式</li></ol><p>弹窗交互核心代码：</p><pre><code class="java">saveFavoriteButton.setOnClickListener(v -&gt; &#123;    FavoriteDialogDialogFragment dialog = new FavoriteDialogFragment(currentVideoData);    dialog.show(getSupportFragmentManager(), &quot;favorite_dialog&quot;);    // 监听收藏结果    getSupportFragmentManager().setFragmentResultListener(&quot;request_key&quot;, this,         (requestKey, result) -&gt; &#123;            String folderName = result.getString(&quot;selected_folder_name&quot;);            if (folderName != null) &#123;                // 更新UI显示收藏状态                updateFavoriteButtonState(true);            &#125;        &#125;);&#125;);</code></pre><h3 id="2-收藏夹管理交互"><a href="#2-收藏夹管理交互" class="headerlink" title="2. 收藏夹管理交互"></a>2. 收藏夹管理交互</h3><p><strong>创建收藏夹</strong>：</p><ul><li>通过 MyFavoritesActivity 中的 “创建收藏夹” 按钮触发</li><li>跳转至 CreateFolderActivity 输入收藏夹名称</li><li>创建成功后自动新收藏夹列表</li></ul><p><strong>删除收藏夹</strong>：</p><ul><li>长按收藏夹或点击更多按钮弹出删除确认</li><li>通过 FolderMoreDialogFragment 实现删除确认交互</li><li>删除时同步删除该收藏夹下所有视频</li></ul><pre><code class="java">folderMoreDialogFragment.setListener(new FolderMoreDialogFragment.OnDeleteButtonClickListener() &#123;    @Override    public void onDeleteButtonClick() &#123;        databaseHelperHelper.deleteFolder(folderName);        updateFavoriteList(); // 刷新列表        folderMoreDialogFragment.dismiss();    &#125;&#125;);</code></pre><p><strong>收藏夹封面设置</strong>：</p><ul><li>支持从相机拍摄或相册选择图片作为封面</li><li>通过图片压缩处理避免 OOM：</li></ul><pre><code class="java">private Bitmap private decodeCompressedBitmap(String imagePath, int reqWidthDp, int reqHeightDp) &#123;    int reqWidth = dp2px(reqWidthDp);    int reqHeight = dp2px(reqHeightDp);        // 先获取图片原始尺寸（不加载完整图片）    BitmapFactory.Options options = new BitmapFactory.Options();    options.inJustDecodeBounds = true;    BitmapFactory.decodeFile(imagePath, options);        // 计算压缩比例    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);        // 加载压缩后的图片    options.inJustDecodeBounds = false;    return BitmapFactoryFactory.decodeFile(imagePath, options);&#125;</code></pre><h2 id="三、UI-组件与交互细节"><a href="#三、UI-组件与交互细节" class="headerlink" title="三、UI 组件与交互细节"></a>三、UI 组件与交互细节</h2><h3 id="1-底部弹窗（FavoriteDialogFragment）"><a href="#1-底部弹窗（FavoriteDialogFragment）" class="headerlink" title="1. 底部弹窗（FavoriteDialogFragment）"></a>1. 底部弹窗（FavoriteDialogFragment）</h3><p>采用 BottomSheetDialogFragment 实现，支持：</p><ul><li>上下滑动关闭</li><li>收藏夹列表选择</li><li>新建收藏夹创建入口</li></ul><p>滑动关闭实现：</p><pre><code class="java">View dragHandle = view.findViewById(R.id.drag_handle);dragHandle.setOnTouchListener(new SwipeDismissTouchListener(dragHandle, null,     new SwipeDismissTouchListener.OnDismissCallback() &#123;        @Override        public void onDismiss(View view) &#123;            dismiss();        &#125;    &#125;));</code></pre><h3 id="2-收藏状态视觉反馈"><a href="#2-收藏状态视觉反馈" class="headerlink" title="2. 收藏状态视觉反馈"></a>2. 收藏状态视觉反馈</h3><ul><li>未收藏状态：显示灰色收藏图标</li><li>已收藏状态：显示红色填充图标</li><li>收藏数量实时更新（item_video_function.xml 中的 collect_text）</li></ul><h3 id="3-空状态处理"><a href="#3-空状态处理" class="headerlink" title="3. 空状态处理"></a>3. 空状态处理</h3><p>当收藏夹为空时，通过 FavoritesAdapter 控制列表展示：</p><pre><code class="java">@Overridepublic int getItemCount() &#123;    if (favorites.size() == 0) &#123;        return 0; // 不显示任何内容或显示空状态提示    &#125; else &#123;        return favorites.size() + 1; // +1 用于显示功能区    &#125;&#125;</code></pre><h2 id="四、数据流转与状态同步"><a href="#四、数据流转与状态同步" class="headerlink" title="四、数据流转与状态同步"></a>四、数据流转与状态同步</h2><ol><li><strong>收藏状态同步</strong>：<ul><li>视频详情页通过<code>isFavoriteExists()</code>方法检查收藏状态</li><li>收藏 &#x2F; 取消收藏操作后通过接口回调更新 UI</li></ul></li><li><strong>列表刷新机制</strong>：<ul><li>所有收藏操作后调用<code>updateFavoriteList()</code>刷新列表</li><li>使用<code>notifyDataSetChanged()</code>更新适配器数据</li></ul></li><li><strong>跨页面数据传递</strong>：<ul><li>通过 Intent 传递收藏夹名称和视频 ID</li><li>使用 ActivityResultLauncher 处理封面设置等交互结果</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>自定义视频播放界面</title>
    <link href="http://example.com/2025/09/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E7%95%8C%E9%9D%A2/"/>
    <id>http://example.com/2025/09/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E7%95%8C%E9%9D%A2/</id>
    <published>2025-09-06T04:16:43.000Z</published>
    <updated>2025-09-06T08:22:32.641Z</updated>
    
    <content type="html"><![CDATA[<p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="VideoActivity-的视频播放设计详解"><a href="#VideoActivity-的视频播放设计详解" class="headerlink" title="VideoActivity 的视频播放设计详解"></a>VideoActivity 的视频播放设计详解</h1><p>VideoActivity 是仿哔哩哔哩项目中负责视频详情展示与播放控制的核心组件，其设计围绕视频播放体验优化，实现了完整的播放控制功能。以下是具体设计细节：</p><h2 id="一、核心功能架构"><a href="#一、核心功能架构" class="headerlink" title="一、核心功能架构"></a>一、核心功能架构</h2><p>VideoActivity 主要实现了四大核心功能模块：</p><ul><li>视频播放控制（播放 &#x2F; 暂停、进度调整）</li><li>全屏切换与状态保持</li><li>控制栏交互（自动隐藏 &#x2F; 显示）</li><li>推荐视频列表展示</li></ul><p>核心组件关系：</p><pre><code class="plaintext">VideoActivity├── VideoView（视频播放核心）├── 控制栏组件（顶部+底部）│   ├── 播放/暂停按钮│   ├── 进度条（SeekBar）│   ├── 时间显示（TextView）│   └── 全屏切换按钮├── Handler（进度更新与UI控制）└── RecyclerView（推荐视频列表）</code></pre><h2 id="二、布局设计（activity-video-xml）"><a href="#二、布局设计（activity-video-xml）" class="headerlink" title="二、布局设计（activity_video.xml）"></a>二、布局设计（activity_video.xml）</h2><p>采用 LinearLayout 作为根布局，分为视频播放区和推荐列表区两部分：</p><ol><li><strong>视频播放区</strong>：<ul><li>使用 ConstraintLayout 实现视频容器，包含 VideoView 和控制栏</li><li>顶部控制栏（videoTopController）：返回按钮和主页跳转按钮，背景使用渐变透明效果</li><li>底部控制栏（videoBottomController）：播放 &#x2F; 暂停按钮、进度条、时间显示和全屏按钮</li></ul></li><li><strong>布局关键代码</strong>：</li></ol><pre><code class="xml">&lt;!-- 视频播放核心组件 --&gt;&lt;VideoView    android:id=&quot;@+id/video&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintEnd_toEndOf=&quot;parent&quot;    app:layout_constraintStart_toStartOf=&quot;parent&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    android:clickable=&quot;true&quot;/&gt;&lt;!-- 底部控制栏 --&gt;&lt;LinearLayout    android:id=&quot;@+id/videoBottomController&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintBottom_toBottomOf=&quot;@id/video&quot;    android:background=&quot;@drawable/gradient_transparent&quot;    android:visibility=&quot;gone&quot;&gt;        &lt;ImageView        android:id=&quot;@+id/pause_or_start&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_weight=&quot;148&quot;        android:src=&quot;@drawable/start&quot;/&gt;    &lt;LinearLayout        android:id=&quot;@+id/schedule&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;match_parent&quot;        android:layout_weight=&quot;812&quot;&gt;                &lt;SeekBar            android:id=&quot;@+id/seek_bar&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;540&quot;            android:progressDrawable=&quot;@drawable/custom_seekbar&quot;            android:thumb=&quot;@drawable/custom_cursor&quot;/&gt;        &lt;TextView            android:id=&quot;@id/video_time&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_weight=&quot;272&quot;            android:textColor=&quot;@color/white&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;ImageView        android:id=&quot;@+id/full_screen&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_weight=&quot;300&quot;        android:src=&quot;@drawable/full_screen&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="三、核心播放逻辑实现"><a href="#三、核心播放逻辑实现" class="headerlink" title="三、核心播放逻辑实现"></a>三、核心播放逻辑实现</h2><h3 id="1-视频初始化流程"><a href="#1-视频初始化流程" class="headerlink" title="1. 视频初始化流程"></a>1. 视频初始化流程</h3><pre><code class="java">private void initVideoPlayLogic() &#123;    // 设置视频源（默认使用raw目录下的视频）    Uri videoUri = Uri.parse(&quot;android.resource://&quot; + getPackageName() + &quot;/&quot; + R.raw.video);    videoView.setVideoURI(videoUri);    videoView.setMediaController(null); // 禁用系统默认控制器    videoView.requestFocus();    videoView.start();    btnPlayPause.setImageResource(R.drawable.pause);    // 视频准备完成监听    videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123;        @Override        public void onPrepared(MediaPlayer mp) &#123;            totalDuration = mp.getDuration(); // 获取总时长            seekBar.setMax(totalDuration);            startProgressUpdate(); // 启动进度更新            videoTime.setText(convertTime(0));        &#125;    &#125;);    // 播放完成监听    videoView.setOnCompletionListener(mp -&gt; &#123;        seekBar.setProgress(0);        videoTime.setText(convertTime(0));        btnPlayPause.setImageResource(R.drawable.start);        stopProgressUpdate();    &#125;);&#125;</code></pre><h3 id="2-进度更新机制"><a href="#2-进度更新机制" class="headerlink" title="2. 进度更新机制"></a>2. 进度更新机制</h3><p>使用 Handler 实现每秒更新一次进度：</p><pre><code class="java">private void initRunnables() &#123;    // 进度更新Runnable    progressRunnable = new Runnable() &#123;        @Override        public void run() &#123;            if (!isFinishing() &amp;&amp; !isDragging) &#123;                int currentPosition = videoView.getCurrentPosition();                seekBar.setProgress(currentPosition);                videoTime.setText(convertTime(currentPosition));                handler.postDelayed(this, 1000); // 每秒更新一次            &#125;        &#125;    &#125;;    // 控制栏自动隐藏Runnable    controlHideRunnable = new Runnable() &#123;        @Override        public void run() &#123;            if (isControlVisible &amp;&amp; !isFinishing() &amp;&amp; !isDragging) &#123;                topController.setVisibility(View.GONE);                bottomController.setVisibility(View.GONE);                isControlVisible = false;            &#125;        &#125;    &#125;;&#125;</code></pre><h3 id="3-进度条拖动处理"><a href="#3-进度条拖动处理" class="headerlink" title="3. 进度条拖动处理"></a>3. 进度条拖动处理</h3><p>解决进度条拖动与视频同步问题：</p><pre><code class="java">seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123;    @Override    public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123;        if (fromUser &amp;&amp; isDragging) &#123;            videoView.seekTo(progress);            // 延迟更新时间显示，确保跳转完成            handler.postDelayed(() -&gt; &#123;                int actualPosition = videoView.getCurrentPosition();                videoTime.setText(convertTime(actualPosition));            &#125;, 50);        &#125;    &#125;    @Override    public void onStartTrackingTouch(SeekBar seekBar) &#123;        isDragging = true;        wasPlayingBeforeDrag = videoView.isPlaying();        videoView.pause(); // 拖动时暂停播放        stopProgressUpdate();        refreshControlHideTime(); // 延长控制栏显示时间    &#125;    @Override    public void onStopTrackingTouch(SeekBar seekBar) &#123;        isDragging = false;        // 延迟获取实际位置，确保seekTo完成        handler.postDelayed(() -&gt; &#123;            int finalActualPosition = videoView.getCurrentPosition();            seekBar.setProgress(finalActualPosition);            videoTime.setText(convertTime(finalActualPosition));        &#125;, 100);        // 恢复播放状态        if (wasPlayingBeforeDrag) &#123;            videoView.start();            btnPlayPause.setImageResource(R.drawable.pause);        &#125; else &#123;            btnPlayPause.setImageResource(R.drawable.start);        &#125;        startProgressUpdate();        refreshControlHideTime();    &#125;&#125;);</code></pre><h2 id="四、全屏切换功能"><a href="#四、全屏切换功能" class="headerlink" title="四、全屏切换功能"></a>四、全屏切换功能</h2><p>实现 VideoActivity 与 FullScreenActivity 之间的无缝切换：</p><h3 id="1-跳转至全屏"><a href="#1-跳转至全屏" class="headerlink" title="1. 跳转至全屏"></a>1. 跳转至全屏</h3><pre><code class="java">// 全屏按钮点击事件btnFullScreen.setOnClickListener(v -&gt; &#123;    Intent intent = new Intent(VideoActivity.this, FullScreenActivity.class);    // 传递当前播放状态    intent.putExtra(&quot;current_position&quot;, videoView.getCurrentPosition());    intent.putExtra(&quot;is_playing&quot;, videoView.isPlaying());    intent.putExtra(&quot;video_path&quot;, getVideoPath()); // 传递视频路径    fullScreenResultLauncher.launch(intent);&#125;);</code></pre><h3 id="2-从全屏返回恢复状态"><a href="#2-从全屏返回恢复状态" class="headerlink" title="2. 从全屏返回恢复状态"></a>2. 从全屏返回恢复状态</h3><pre><code class="java">private void initFullScreenResultLauncher() &#123;    fullScreenResultLauncher = registerForActivityResult(            new ActivityResultContracts.StartActivityForResult(),            new ActivityResultCallback&lt;ActivityResult&gt;() &#123;                @Override                public void onActivityResult(ActivityResult result) &#123;                    if (result.getResultCode() == RESULT_OK &amp;&amp; result.getData() != null) &#123;                        Intent data = result.getData();                        int returnPosition = data.getIntExtra(&quot;current_position&quot;, 0);                        boolean returnIsPlaying = data.getBooleanExtra(&quot;is_playing&quot;, false);                        restoreVideoState(returnPosition, returnIsPlaying);                    &#125;                &#125;            &#125;    );&#125;// 恢复视频播放状态private void restoreVideoState(int targetPosition, boolean isPlaying) &#123;    if (videoView != null &amp;&amp; totalDuration &gt; 0) &#123;        stopProgressUpdate();        videoView.seekTo(targetPosition);                if (isPlaying) &#123;            videoView.start();            btnPlayPause.setImageResource(R.drawable.pause);            startProgressUpdate();        &#125; else &#123;            videoView.pause();            btnPlayPause.setImageResource(R.drawable.start);        &#125;                seekBar.setProgress(targetPosition);        videoTime.setText(convertTime(targetPosition));        if (!isControlVisible) &#123;            toggleControlVisibility(); // 显示控制栏        &#125;    &#125;&#125;</code></pre><h2 id="五、控制栏交互设计"><a href="#五、控制栏交互设计" class="headerlink" title="五、控制栏交互设计"></a>五、控制栏交互设计</h2><ol><li><strong>触摸显示 &#x2F; 隐藏控制栏</strong>：</li></ol><pre><code class="java">videoView.setOnTouchListener(new View.OnTouchListener() &#123;    @Override    public boolean onTouch(View v, MotionEvent event) &#123;        if (event.getAction() == MotionEvent.ACTION_UP) &#123;            toggleControlVisibility(); // 切换控制栏可见性            return true;        &#125;        return false;    &#125;&#125;);</code></pre><ol><li><strong>自动隐藏逻辑</strong>：</li></ol><pre><code class="java">private void startControlHideTimer() &#123;    handler.removeCallbacks(controlHideRunnable);    handler.postDelayed(controlHideRunnable, 3000); // 3秒后自动隐藏&#125;private void refreshControlHideTime() &#123;    handler.removeCallbacks(controlHideRunnable);    handler.postDelayed(controlHideRunnable, 3000); // 刷新隐藏倒计时&#125;</code></pre><h2 id="六、时间格式转换工具"><a href="#六、时间格式转换工具" class="headerlink" title="六、时间格式转换工具"></a>六、时间格式转换工具</h2><p>将毫秒转换为 “分：秒 &#x2F; 总时长” 格式：</p><pre><code class="java">private String convertTime(int currentTimeMs) &#123;    if (totalDuration &lt;= 0) return &quot;00:00/00:00&quot;;    int currentSec = currentTimeMs / 1000;    int currentMin = currentSec / 60;    currentSec = currentSec % 60;    int totalSec = totalDuration / 1000;    int totalMin = totalSec / 60;    totalSec = totalSec % 60;    return String.format(&quot;%02d:%02d/%02d:%02d&quot;, currentMin, currentSec, totalMin, totalSec);&#125;</code></pre><h2 id="七、关键技术亮点"><a href="#七、关键技术亮点" class="headerlink" title="七、关键技术亮点"></a>七、关键技术亮点</h2><ol><li><strong>状态保持机制</strong>：通过 Intent 传递播放进度和状态，实现全屏切换时的无缝衔接</li><li><strong>进度同步优化</strong>：使用延迟更新解决 SeekBar 拖动与视频实际进度不同步问题</li><li><strong>用户体验优化</strong>：控制栏自动隐藏 &#x2F; 显示，触摸交互响应及时</li><li><strong>模块化设计</strong>：将初始化、播放逻辑、控制逻辑分离，便于维护</li></ol><h1 id="FullScreenActivity-视频播放设计详解"><a href="#FullScreenActivity-视频播放设计详解" class="headerlink" title="FullScreenActivity 视频播放设计详解"></a>FullScreenActivity 视频播放设计详解</h1><p>FullScreenActivity 是仿哔哩哔哩项目中负责负责视频全屏播放的核心组件，专注于提供沉浸式视频观看体验，其设计围绕全屏场景下的播放控制优化，实现了与竖屏播放状态的无缝衔接。</p><h2 id="一、核心功能定位"><a href="#一、核心功能定位" class="headerlink" title="一、核心功能定位"></a>一、核心功能定位</h2><p>FullScreenActivity 作为 VideoActivity 的补充，主要解决以下核心问题：</p><ul><li>提供沉浸式全屏播放体验</li><li>保持与竖屏播放状态的完全同步（进度、播放状态）</li><li>优化横屏场景下的控制栏布局与交互</li><li>解决全屏 &#x2F; 窗口模式切换时的状态一致性问题</li></ul><h2 id="二、布局设计（activity-full-screen-xml）"><a href="#二、布局设计（activity-full-screen-xml）" class="headerlink" title="二、布局设计（activity_full_screen.xml）"></a>二、布局设计（activity_full_screen.xml）</h2><p>采用 ConstraintLayout 作为根布局，专为横屏优化：</p><ol><li><strong>视频播放区</strong>：<ul><li>VideoView 占据整个屏幕空间，确保全屏显示</li><li>背景设置为黑色，消除边缘色差</li></ul></li><li><strong>控制栏设计</strong>：<ul><li>顶部控制栏（top_controller）：仅保留返回按钮，最小化干扰</li><li>底部控制栏（bottom_controller）：包含播放 &#x2F; 暂停按钮、进度条、时间显示</li><li>控制栏背景使用渐变透明效果，既影响视频内容观看</li></ul></li></ol><pre><code class="xml">&lt;!-- 全屏视频核心布局 --&gt;&lt;VideoView    android:id=&quot;@+id/videoView&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;match_parent&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;    app:layout_constraintEnd_toEndOf=&quot;parent&quot;    app:layout_constraintStart_toStartOf=&quot;parent&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    android:clickable=&quot;true&quot;/&gt;&lt;!-- 底部控制栏 --&gt;&lt;LinearLayout    android:id=&quot;@+id/bottom_controller&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;    android:background=&quot;@drawable/gradient_transparent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;TextView        android:id=&quot;@+id/video_time&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:textColor=&quot;@color/white&quot;        android:textSize=&quot;12dp&quot;/&gt;    &lt;SeekBar        android:id=&quot;@+id/seek_bar&quot;        android:layout_width=&quot;match_parent&quot;        android:progressDrawable=&quot;@drawable/custom_seekbar&quot;        android:thumb=&quot;@drawable/custom_cursor2&quot;/&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;horizontal&quot;&gt;        &lt;ImageView            android:id=&quot;@+id/play_or_pause&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;460&quot;            android:src=&quot;@drawable/video_controller_bottom_left_pause&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="三、核心播放逻辑实现-1"><a href="#三、核心播放逻辑实现-1" class="headerlink" title="三、核心播放逻辑实现"></a>三、核心播放逻辑实现</h2><h3 id="1-状态传递与初始化"><a href="#1-状态传递与初始化" class="headerlink" title="1. 状态传递与初始化"></a>1. 状态传递与初始化</h3><p>全屏 Activity 通过 Intent 接收来自 VideoActivity 的播放状态：</p><pre><code class="java">private void getVideoStateFromIntent() &#123;    Intent intent = getIntent();    currentPosition = intent.getIntExtra(&quot;current_position&quot;, 0);    isPlaying = intent.getBooleanExtra(&quot;is_playing&quot;, false);    videoPath = intent.getStringExtra(&quot;video_path&quot;);&#125;</code></pre><p>初始化时恢复播放状态：</p><pre><code class="java">videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123;    @Override    public void onPrepared(MediaPlayer mp) &#123;        // 设置seek完成监听，解决进度同步问题        mp.setOnSeekCompleteListener(mp1 -&gt; &#123;            int newPos = videoView.getCurrentPosition();            seekBar.setProgress(newPos);            videoTime.setText(convertTime(newPos));        &#125;);        totalDuration = mp.getDuration();        seekBar.setMax(totalDuration);        videoView.seekTo(currentPosition); // 恢复到竖屏时的进度        // 恢复播放状态        if (isPlaying) &#123;            videoView.start();            playOrPause.setImageResource(R.drawable.video_controller_controller_bottom_left_pause);            startProgressUpdate();        &#125; else &#123;            playOrPause.setImageResource(R.drawable.video_controller_bottom_left_play);        &#125;    &#125;&#125;);</code></pre><h3 id="2-进度同步优化"><a href="#2-进度同步优化" class="headerlink" title="2. 进度同步优化"></a>2. 进度同步优化</h3><p>针对视频 seek 操作延迟问题，引入目标位置跟踪机制：</p><pre><code class="java">// 进度更新Runnable优化progressRunnable = new Runnable() &#123;    @Override    public void run() &#123;        if (!isFinishing() &amp;&amp; !isDragging) &#123;            int currentPos = videoView.getCurrentPosition();            // 处理seek操作的进度同步            if (targetSeekPosition != -1) &#123;                // 当实际位置接近目标位置时，视为seek完成                if (Math.abs.abs(currentPos - targetSeekPosition) &lt; 500) &#123;                    targetSeekPosition = -1;                &#125;            &#125;            seekBar.setProgress(currentPos);            videoTime.setText(convertTime(currentPos));            handler.postDelayed(this, 1000);        &#125;    &#125;&#125;;</code></pre><h3 id="3-进度条拖动处理-1"><a href="#3-进度条拖动处理-1" class="headerlink" title="3. 进度条拖动处理"></a>3. 进度条拖动处理</h3><p>优化拖动体验，避免 UI 与实际进度不同步：</p><pre><code class="java">seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123;    @Override    public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123;        if (fromUser &amp;&amp; isDragging) &#123;            // 拖动时先更新时间显示，不立即同步到视频            videoTime.setText(convertTime(progress));            targetSeekPosition = progress; // 记录目标位置        &#125;    &#125;    @Override    public void onStartTrackingTouch(SeekBar seekBar) &#123;        isDragging = true;        wasPlayingBeforeDrag = videoView.isPlaying();        videoView.pause(); // 拖动时暂停        stopProgressUpdate();    &#125;    @Override    public void onStopTrackingTouch(SeekBar seekBar) &#123;        isDragging = false;        // 执行seek操作，等待完成后更新UI        if (targetSeekPosition != -1) &#123;            videoView.seekTo(targetSeekPosition);        &#125;        // 恢复播放状态        if (wasPlayingBeforeDrag) &#123;            videoView.start();            startProgressUpdate();        &#125;    &#125;&#125;);</code></pre><h2 id="四、控制栏交互设计"><a href="#四、控制栏交互设计" class="headerlink" title="四、控制栏交互设计"></a>四、控制栏交互设计</h2><ol><li><strong>自动隐藏机制</strong>：</li></ol><pre><code class="java">controlHideRunnable = new Runnable() &#123;    @Override    public void run() &#123;        if (isControlVisible &amp;&amp; !isFinishing() &amp;&amp; !isDragging &amp;&amp; videoView.isPlaying()) &#123;            hideControls(); // 播放状态下自动隐藏控制栏        &#125;    &#125;&#125;;</code></pre><ol><li><strong>触摸交互</strong>：</li></ol><pre><code class="java">videoView.setOnTouchListener(new View.OnTouchListener() &#123;    private long lastTouchTime = 0;    private static final long DOUBLE_TAP_THRESHOLD = 300;    @Override    public boolean onTouch(View v, MotionEvent event) &#123;        if (event.getAction() == MotionEvent.ACTION_UP) &#123;            long currentTime = System.currentTimeMillis();            // 处理双击事件（预留扩展）            if (currentTime - lastTouchTime &lt; DOUBLE_TAP_THRESHOLD) &#123;                lastTouchTime = 0;                return true;            &#125;            lastTouchTime = currentTime;                        toggleControlVisibility(); // 单击切换控制栏显示状态            return true;        &#125;        return false;    &#125;&#125;);</code></pre><h2 id="五、返回竖屏状态处理"><a href="#五、返回竖屏状态处理" class="headerlink" title="五、返回竖屏状态处理"></a>五、返回竖屏状态处理</h2><p>实现全屏到窗口模式的无缝切换：</p><pre><code class="java">private void returnToVideoActivity() &#123;    // 准备返回数据    Intent intent = new Intent();    intent.putExtra(&quot;current_position&quot;, videoView.getCurrentPosition());    intent.putExtra(&quot;is_playing&quot;, videoView.isPlaying());    setResult(RESULT_OK, intent);    finish();    // 添加转场动画    overridePendingTransition(R.anim.fade_in, R.anim.fade_out);&#125;</code></pre><h2 id="六、技术亮点"><a href="#六、技术亮点" class="headerlink" title="六、技术亮点"></a>六、技术亮点</h2><ol><li><strong>状态无缝衔接</strong>：通过 Intent 精确传递播放进度和状态，实现两种模式平滑切换</li><li><strong>进度同步优化</strong>：使用目标位置跟踪和 seek 完成监听，解决视频进度更新延迟问题</li><li><strong>沉浸式体验</strong>：隐藏系统 UI，控制栏自动隐藏，最大化视频观看区域</li><li><strong>交互一致性</strong>：保持与竖屏模式相同的操作逻辑，降低用户学习成本</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>相机和相册的对接</title>
    <link href="http://example.com/2025/09/06/%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9B%B8%E5%86%8C%E7%9A%84%E5%AF%B9%E6%8E%A5/"/>
    <id>http://example.com/2025/09/06/%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9B%B8%E5%86%8C%E7%9A%84%E5%AF%B9%E6%8E%A5/</id>
    <published>2025-09-06T04:13:07.000Z</published>
    <updated>2025-09-06T08:22:39.032Z</updated>
    
    <content type="html"><![CDATA[<p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="照相和相册的-API-对接实现详解"><a href="#照相和相册的-API-对接实现详解" class="headerlink" title="照相和相册的 API 对接实现详解"></a>照相和相册的 API 对接实现详解</h1><p>在仿哔哩哔哩项目中，用户可以通过相机拍摄或从相册选择图片来设置收藏夹封面，这一功能主要通过 Android 系统提供的相机和相册 API 实现，核心代码集中在<code>CreateFolderActivity</code>中。以下是具体实现细节：</p><h2 id="一、权限配置"><a href="#一、权限配置" class="headerlink" title="一、权限配置"></a>一、权限配置</h2><p>使用相机和相册功能需要在AndroidManifest.xml中声明相关权限：</p><pre><code class="xml">&lt;!-- 相机权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&lt;!-- 存储权限（针对Android 10以下） --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 声明明显式使用相机硬件 --&gt;&lt;uses-feature    android:name=&quot;android.hardware.camera&quot;    android:required=&quot;true&quot; /&gt;</code></pre><p>同时在<code>application</code>标签中添加文件提供者配置，用于安全地共享相机拍摄的图片：</p><pre><code class="xml">&lt;application ...&gt;    &lt;!-- 文件提供者配置，用于相机照片的安全访问 --&gt;    &lt;provider        android:name=&quot;androidx.core.content.FileProvider&quot;        android:authorities=&quot;com.naojianghh.bilibili3&quot;        android:exported=&quot;false&quot;        android:grantUriPermissions=&quot;true&quot;&gt;        &lt;meta-data            android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;            android:resource=&quot;@xml/file_paths&quot; /&gt;    &lt;/provider&gt;&lt;/application&gt;</code></pre><h2 id="二、UI-交互入口"><a href="#二、UI-交互入口" class="headerlink" title="二、UI 交互入口"></a>二、UI 交互入口</h2><p>通过底部弹窗 (<code>BottomSheetDialog</code>) 提供相机和相册选择入口，布局文件为dialog_picture.xml：</p><pre><code class="xml">&lt;!-- 相机选择按钮 --&gt;&lt;Button    android:id=&quot;@+id/btn_camera&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;60dp&quot;    android:backgroundTint=&quot;@android:color/transparent&quot;    android:text=&quot;拍照&quot;    android:textColor=&quot;@color/black&quot;    android:textSize=&quot;16sp&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;    app:layout_constraintTop_toBottomOf=&quot;@+id/btn_gallery&quot;/&gt;&lt;!-- 相册选择按钮 --&gt;&lt;Button    android:id=&quot;@+id/btn_gallery&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;60dp&quot;    android:backgroundTint=&quot;@android:color/transparent&quot;    android:text=&quot;从相册选择&quot;    android:textColor=&quot;@color/black&quot;    android:textSize=&quot;16sp&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    app:layout_constraintBottom_toTopOf=&quot;@+id/btn_camera&quot;/&gt;</code></pre><p>在<code>CreateFolderActivity</code>中初始化弹窗并设置点击事件：</p><pre><code class="java">private void showImagePickerBottomSheet() &#123;    // 初始化BottomSheetDialog    bottomSheetDialog = new BottomSheetDialog(this);    // 加载布局    View view = LayoutInflater.from(this).inflate(R.layout.dialog_picture, null);    bottomSheetDialog.setContentView(view);    // 相机按钮点击事件    view.findViewById(R.id.btn_camera).setOnClickListener(v -&gt; &#123;        checkPermissionsAndOpenCamera(); // 检查权限后打开相机        bottomSheetDialog.dismiss();    &#125;);    // 相册按钮点击事件    view.findViewById(R.id.btn_gallery).setOnClickListener(v -&gt; &#123;        openGallery(); // 打开相册        bottomSheetDialog.dismiss();    &#125;);    // 显示对话框    bottomSheetDialog.show();&#125;</code></pre><h2 id="三、相机-API-对接"><a href="#三、相机-API-对接" class="headerlink" title="三、相机 API 对接"></a>三、相机 API 对接</h2><h3 id="1-权限检查"><a href="#1-权限检查" class="headerlink" title="1. 权限检查"></a>1. 权限检查</h3><p>在打开相机前检查并请求必要权限：</p><pre><code class="java">private void checkPermissionsAndOpenCamera() &#123;    // 检查相机和存储权限    if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)            != PackageManager.PERMISSION_GRANTED ||        ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)            != PackageManager.PERMISSION_GRANTED) &#123;        // 请求权限        ActivityCompat.requestPermissions(this,                new String[]&#123;Manifest.permission.CAMERA,                            Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,                REQUEST_PERMISSIONS);    &#125; else &#123;        // 权限已授予，直接打开相机        openCamera();    &#125;&#125;</code></pre><h3 id="2-打开相机"><a href="#2-打开相机" class="headerlink" title="2. 打开相机"></a>2. 打开相机</h3><p>使用<code>MediaStore.ACTION_IMAGE_CAPTURE</code>意图打开系统相机：</p><pre><code class="java">private void openCamera() &#123;    Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);    // 检查是否有相机应用可以响应    if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123;        File photoFile = null;        try &#123;            // 创建临时图片文件            photoFile = createImageFile();        &#125; catch (IOException ex) &#123;            ex.printStackTrace();        &#125;        if (photoFile != null) &#123;            // 通过FileProvider获取安全的Uri            Uri photoURI = FileProvider.getUriForFile(this,                    &quot;com.naojianghh.bilibili3&quot;, // 与Manifest中配置的authorities一致                    photoFile);            // 设置图片保存路径            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);            // 启动相机，等待返回结果            startActivityForResult(takePictureIntent, REQUEST_CAMERA);        &#125;    &#125;&#125;</code></pre><h3 id="3-创建图片文件"><a href="#3-创建图片文件" class="headerlink" title="3. 创建图片文件"></a>3. 创建图片文件</h3><pre><code class="java">private File createImageFile() throws IOException &#123;    // 生成唯一文件名（基于时间戳）    String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;, Locale.getDefault()).format(new Date());    String imageFileName = &quot;JPEG_&quot; + timeStamp + &quot;_&quot;;    // 获取应用私有图片目录    File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);    // 创建临时文件    File image = File.createTempFile(            imageFileName,  // 文件名前缀            &quot;.jpg&quot;,         // 文件后缀            storageDir      // 存储目录    );    // 保存图片路径用于后续处理    currentPhotoPath = image.getAbsolutePath();    return image;&#125;</code></pre><h2 id="四、相册-API-对接"><a href="#四、相册-API-对接" class="headerlink" title="四、相册 API 对接"></a>四、相册 API 对接</h2><p>使用<code>ACTION_OPEN_DOCUMENT</code>意图打开系统相册，支持持久化访问权限：</p><pre><code class="java">private void openGallery() &#123;    Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);    intent.setType(&quot;image/*&quot;); // 只显示图片类型    // 请求持久化访问权限    intent.addFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);    // 启动相册，等待返回结果    startActivityForResult(intent, REQUEST_GALLERY);&#125;</code></pre><h2 id="五、处理返回结果"><a href="#五、处理返回结果" class="headerlink" title="五、处理返回结果"></a>五、处理返回结果</h2><p>在<code>onActivityResult</code>中处理相机和相册返回的图片：</p><pre><code class="java">@Overrideprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;    super.onActivityResult(requestCode, resultCode, data);        // 处理相机返回结果    if (requestCode == REQUEST_CAMERA &amp;&amp; resultCode == RESULT_OK) &#123;        // 通过路径加载图片        Bitmap bitmap = BitmapFactory.decodeFile(currentPhotoPath);        ivSelectedImage.setImageBitmap(bitmap);        // 保存图片路径用于后续存储        selectedImageIdentifier = currentPhotoPath;    &#125;    // 处理相册返回结果    else if (requestCode == REQUEST_GALLERY &amp;&amp; resultCode == RESULT_OK &amp;&amp; data != null) &#123;        Uri selectedImageUri = data.getData();        if (selectedImageUri != null) &#123;            // 显示选中的图片            ivSelectedImage.setImageURI(selectedImageUri);                        try &#123;                // 获取持久化访问权限                int takeFlags = data.getFlags() &amp; (Intent.FLAG_GRANT_READ_URI_PERMISSION |                                                   Intent.FLAG_GRANT_WRITE_URI_PERMISSION);                getContentResolver().takePersistableUriPermission(selectedImageUri, takeFlags);                // 保存带权限标记的Uri                selectedImageIdentifier = selectedImageUri.toString() + &quot;|with_permission&quot;;            &#125; catch (SecurityException e) &#123;                Log.e(&quot;PermissionError&quot;, &quot;无法获取持久化权限: &quot; + e.getMessage());                selectedImageIdentifier = selectedImageUri.toString();                Toast.makeText(this, &quot;无法永久访问该图片，仅本次有效&quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="六、图片展示与存储"><a href="#六、图片展示与存储" class="headerlink" title="六、图片展示与存储"></a>六、图片展示与存储</h2><p>在<code>FolderActivity</code>中加载并展示选中的图片（区分相机图片和相册图片）：</p><pre><code class="java">// 获取数据库中存储的封面路径String coverPath = databaseHelper.getFolderCover(folderName);if (coverPath != null &amp;&amp; !coverPath.isEmpty()) &#123;    setPicture.setVisibility(View.VISIBLE);    // 区分封面类型：路径（相机图）/ Uri字符串（相册图）    if (coverPath.startsWith(&quot;/&quot;)) &#123;        // 相机图：通过路径加载图片（压缩避免OOM）        Bitmap compressedBitmap = decodeCompressedBitmap(coverPath, 80, 80);        setPicture.setImageBitmap(compressedBitmap);    &#125; else if (coverPath.startsWith(&quot;content://&quot;)) &#123;        // 相册图：通过Uri加载        String[] coverParts = coverPath.split(&quot;\\|&quot;);        Uri coverUri = Uri.parse(coverParts[0]);                try &#123;            setPicture.setImageURI(coverUri);        &#125; catch (SecurityException e) &#123;            // 权限不足时的备选方案            try (InputStream inputStream = getContentResolver().openInputStream(coverUri)) &#123;                Bitmap bitmap = BitmapFactory.decodeStream(inputStream);                setPicture.setImageBitmap(bitmap);            &#125; catch (Exception ex) &#123;                ex.printStackTrace();                setPicture.setVisibility(View.GONE);            &#125;        &#125;    &#125;&#125; else &#123;    setPicture.setVisibility(View.GONE);&#125;</code></pre><h2 id="七、关键技术点"><a href="#七、关键技术点" class="headerlink" title="七、关键技术点"></a>七、关键技术点</h2><ol><li><strong>权限管理</strong>：<ul><li>动态请求相机和存储权限</li><li>使用<code>takePersistableUriPermission</code>获取相册图片的持久化访问权</li></ul></li><li><strong>安全机制</strong>：<ul><li>通过<code>FileProvider</code>生成 content:&#x2F;&#x2F; 类型的 Uri，避免暴露文件路径</li><li>对相机拍摄的图片进行压缩处理，防止 OOM</li></ul></li><li><strong>兼容性处理</strong>：<ul><li>区分相机图片（文件路径）和相册图片（Uri）的不同处理方式</li><li>处理权限获取失败的异常情况</li></ul></li><li><strong>数据存储</strong>：<ul><li>相机图片存储在应用私有目录，避免权限问题</li><li>相册图片存储 Uri 字符串，配合权限标记实现持久访问</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>数据库搭建</title>
    <link href="http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/</id>
    <published>2025-09-06T04:07:14.000Z</published>
    <updated>2025-09-06T08:22:46.537Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SQLite</strong>的使用</p><p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="项目数据库搭建详解"><a href="#项目数据库搭建详解" class="headerlink" title="项目数据库搭建详解"></a>项目数据库搭建详解</h1><p>该仿哔哩哔哩项目采用 <strong>SQLite</strong> 作为本地数据库，主要用于存储用户收藏相关数据，通过 <code>FavoriteDatabaseHelper</code> 类实现数据库的创建、升级及数据 CRUD 操作，以下是具体实现细节：</p><h2 id="一、数据库核心设计"><a href="#一、数据库核心设计" class="headerlink" title="一、数据库核心设计"></a>一、数据库核心设计</h2><h3 id="1-数据库与表结构"><a href="#1-数据库与表结构" class="headerlink" title="1. 数据库与表结构"></a>1. 数据库与表结构</h3><p>项目包含两个核心表，分别用于存储收藏内容和收藏夹信息：</p><table><thead><tr><th>表名</th><th>作用</th><th>核心字段</th></tr></thead><tbody><tr><td><code>favorites</code></td><td>存储用户收藏的视频数据</td><td>自增 ID、原始视频 ID、所属文件夹名、视频描述、资源 ID 等</td></tr><tr><td><code>folders</code></td><td>存储收藏夹信息</td><td>收藏夹 ID、显示名称、封面图路径</td></tr></tbody></table><h3 id="2-核心常量定义"><a href="#2-核心常量定义" class="headerlink" title="2. 核心常量定义"></a>2. 核心常量定义</h3><p>在 <code>FavoriteDatabaseHelper</code> 中定义数据库名称、版本及表结构常量：</p><pre><code class="java">// 数据库名称和版本private static final String DATABASE_NAME = &quot;favorite.db&quot;;private static final int DATABASE_VERSION = 4; // 版本号随结构变更递增// 收藏内容表（favorites）private static final String TABLE_FAVORITES = &quot;favorites&quot;;private static final String COLUMN_ID = &quot;id&quot;; // 数据库自增主键private static final String COLUMN_ORIGINAL_ID = &quot;original_id&quot;; // 视频原始ID（关联源数据）private static final String COLUMN_FOLDER_NAME = &quot;title&quot;; // 所属文件夹名称private static final String COLUMN_DESCRIPTION = &quot;description&quot;; // 视频描述private static final String COLUMN_IMAGE_VIDEO_LIST_ID = &quot;image_video_list_id&quot;; // 列表封面资源ID// 其他资源ID字段...// 收藏夹表（folders）private static final String TABLE_FOLDERS = &quot;folders&quot;;private static final String COLUMN_FOLDER_ID = &quot;folder_id&quot;; // 收藏夹自增IDprivate static final String COLUMN_FOLDER_DISPLAY_NAME = &quot;folder_display_name&quot;; // 显示名称private static final String COLUMN_FOLDER_COVER = &quot;folder_cover&quot;; // 封面图路径</code></pre><h2 id="二、数据库创建与升级"><a href="#二、数据库创建与升级" class="headerlink" title="二、数据库创建与升级"></a>二、数据库创建与升级</h2><h3 id="1-表创建-SQL-语句"><a href="#1-表创建-SQL-语句" class="headerlink" title="1. 表创建 SQL 语句"></a>1. 表创建 SQL 语句</h3><p>通过 <code>CREATE TABLE</code> 语句定义表结构，包含字段类型和约束：</p><pre><code class="java">// 创建收藏内容表（包含原始视频ID字段，用于关联源数据）private static final String CREATE_TABLE_FAVORITES = &quot;CREATE TABLE &quot; + TABLE_FAVORITES + &quot; (&quot; +        COLUMN_ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; +        COLUMN_ORIGINAL_ID + &quot; INTEGER, &quot; + // 关联视频原始ID        COLUMN_FOLDER_NAME + &quot; TEXT, &quot; +        COLUMN_DESCRIPTION + &quot; TEXT, &quot; +        COLUMN_IMAGE_ID + &quot; INTEGER, &quot; +        COLUMN_IMAGE_VIDEO_ID + &quot; INTEGER, &quot; +        COLUMN_IMAGE_VIDEO_LIST_ID + &quot; INTEGER);&quot;;// 创建收藏夹表（包含封面图字段）private static final String CREATE_TABLE_FOLDERS = &quot;CREATE TABLE &quot; + TABLE_FOLDERS + &quot; (&quot; +        COLUMN_FOLDER_ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; +        COLUMN_FOLDER_DISPLAY_NAME + &quot; TEXT, &quot; +        COLUMN_FOLDER_COVER + &quot; TEXT);&quot;;</code></pre><h3 id="2-初始化数据库"><a href="#2-初始化数据库" class="headerlink" title="2. 初始化数据库"></a>2. 初始化数据库</h3><p>在 <code>onCreate</code> 中执行表创建，并初始化默认收藏夹：</p><pre><code class="java">@Overridepublic void onCreate(SQLiteDatabase db) &#123;    // 创建两个核心表    db.execSQL(CREATE_TABLE_FAVORITES);    db.execSQL(CREATE_TABLE_FOLDERS);        // 初始化默认收藏夹    ContentValues values = new ContentValues();    values.put(COLUMN_FOLDER_DISPLAY_NAME, &quot;默认收藏夹&quot;);    values.put(COLUMN_FOLDER_COVER, (String) null); // 初始无封面    db.insert(TABLE_FOLDERS, null, values);&#125;</code></pre><h3 id="3-数据库升级策略"><a href="#3-数据库升级策略" class="headerlink" title="3. 数据库升级策略"></a>3. 数据库升级策略</h3><p>通过 <code>onUpgrade</code> 处理版本变更，支持新增字段或表结构调整：</p><pre><code class="java">@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;    // 版本3→4：为收藏表新增original_id字段（兼容旧数据）    if (oldVersion &lt; 4) &#123;        db.execSQL(&quot;ALTER TABLE &quot; + TABLE_FAVORITES +                &quot; ADD COLUMN &quot; + COLUMN_ORIGINAL_ID + &quot; INTEGER DEFAULT -1;&quot;);    &#125;    // 版本2→3：为收藏夹表新增封面字段    if (oldVersion &lt; 3) &#123;        db.execSQL(&quot;ALTER TABLE &quot; + TABLE_FOLDERS +                &quot; ADD COLUMN &quot; + COLUMN_FOLDER_COVER + &quot; TEXT DEFAULT NULL;&quot;);    &#125;&#125;</code></pre><h2 id="三、核心数据操作（CRUD）"><a href="#三、核心数据操作（CRUD）" class="headerlink" title="三、核心数据操作（CRUD）"></a>三、核心数据操作（CRUD）</h2><h3 id="1-收藏内容管理"><a href="#1-收藏内容管理" class="headerlink" title="1. 收藏内容管理"></a>1. 收藏内容管理</h3><h4 id="（1）添加收藏"><a href="#（1）添加收藏" class="headerlink" title="（1）添加收藏"></a>（1）添加收藏</h4><pre><code class="java">public void addFavorite(FavoriteData favorite) &#123;    SQLiteDatabase db = this.getWritableDatabase();    // 构建插入SQL（处理特殊字符转义，如单引号）    String insertQuery = &quot;INSERT INTO &quot; + TABLE_FAVORITES + &quot; (&quot; +            COLUMN_ORIGINAL_ID + &quot;, &quot; + // 关联视频原始ID            COLUMN_FOLDER_NAME + &quot;, &quot; +            COLUMN_DESCRIPTION + &quot;, &quot; +            COLUMN_IMAGE_ID + &quot;, &quot; +            COLUMN_IMAGE_VIDEO_ID + &quot;, &quot; +            COLUMN_IMAGE_VIDEO_LIST_ID + &quot;) VALUES (&quot; +            favorite.getOriginalId() + &quot;, &#39;&quot; +             favorite.getFolderName().replace(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;) + &quot;&#39;, &#39;&quot; + // 转义单引号            favorite.getDescription().replace(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;) + &quot;&#39;, &quot; +            favorite.getImageResourceId() + &quot;, &quot; +            favorite.getVideoImageResourceId() + &quot;, &quot; +            favorite.getVideoListImageResourceId() + &quot;);&quot;;    db.execSQL(insertQuery);    db.close();&#125;</code></pre><h4 id="（2）查询所有收藏"><a href="#（2）查询所有收藏" class="headerlink" title="（2）查询所有收藏"></a>（2）查询所有收藏</h4><pre><code class="java">public List&lt;FavoriteData&gt; getALLFavorites() &#123;    List&lt;FavoriteData&gt; favorites = new ArrayList&lt;&gt;();    SQLiteDatabase db = this.getReadableDatabase();    Cursor cursor = db.query(TABLE_FAVORITES, null, null, null, null, null, null);        if (cursor.moveToFirst()) &#123;        do &#123;            int id = cursor.getInt(cursor.getColumnIndex(COLUMN_ID));            int originalId = cursor.getInt(cursor.getColumnIndex(COLUMN_ORIGINAL_ID)); // 读取原始ID            String title = cursor.getString(cursor.getColumnIndex(COLUMN_FOLDER_NAME));            // 其他字段读取...            favorites.add(new FavoriteData(description, imageId, videoImageId, videoListImageId, title, id, originalId));        &#125; while (cursor.moveToNext());    &#125;    cursor.close();    db.close();    return favorites;&#125;</code></pre><h4 id="（3）删除收藏"><a href="#（3）删除收藏" class="headerlink" title="（3）删除收藏"></a>（3）删除收藏</h4><pre><code class="java">// 根据视频原始ID删除（更高效的关联删除）public void deleteFavorite(Data data) &#123;    SQLiteDatabase db = getWritableDatabase();    db.delete(            TABLE_FAVORITES,            COLUMN_ORIGINAL_ID + &quot; = ?&quot;, // 条件：原始ID匹配            new String[]&#123;String.valueOf(data.getId())&#125;    );&#125;</code></pre><h4 id="（4）判断是否已收藏"><a href="#（4）判断是否已收藏" class="headerlink" title="（4）判断是否已收藏"></a>（4）判断是否已收藏</h4><pre><code class="java">public boolean isFavoriteExists(Data data) &#123;    SQLiteDatabase db = this.getReadableDatabase();    // 通过原始ID查询，避免重复收藏    String query = &quot;SELECT * FROM &quot; + TABLE_FAVORITES            + &quot; WHERE &quot; + COLUMN_ORIGINAL_ID + &quot; = ?&quot;;    Cursor cursor = db.rawQuery(query, new String[]&#123;String.valueOf(data.getId())&#125;);    boolean exists = cursor.getCount() &gt; 0;    cursor.close();    return exists;&#125;</code></pre><h3 id="2-收藏夹管理"><a href="#2-收藏夹管理" class="headerlink" title="2. 收藏夹管理"></a>2. 收藏夹管理</h3><h4 id="（1）添加收藏夹"><a href="#（1）添加收藏夹" class="headerlink" title="（1）添加收藏夹"></a>（1）添加收藏夹</h4><pre><code class="java">public void addFolder(String folderName) &#123;    try (SQLiteDatabase db = this.getWritableDatabase()) &#123;        ContentValues values = new ContentValues();        values.put(COLUMN_FOLDER_DISPLAY_NAME, folderName);        values.put(COLUMN_FOLDER_COVER, (String) null); // 初始无封面        db.insert(TABLE_FOLDERS, null, values);    &#125;&#125;</code></pre><h4 id="（2）查询所有收藏夹"><a href="#（2）查询所有收藏夹" class="headerlink" title="（2）查询所有收藏夹"></a>（2）查询所有收藏夹</h4><pre><code class="java">public List&lt;Folder&gt; getAllFolders() &#123;    List&lt;Folder&gt; folders = new ArrayList&lt;&gt;();    try (SQLiteDatabase db = this.getReadableDatabase()) &#123;        Cursor cursor = db.query(                TABLE_FOLDERS,                new String[]&#123;COLUMN_FOLDER_DISPLAY_NAME, COLUMN_FOLDER_COVER&#125;,                null, null, null, null, null        );        if (cursor.moveToFirst()) &#123;            do &#123;                String folderName = cursor.getString(cursor.getColumnIndex(COLUMN_FOLDER_DISPLAY_NAME));                String folderCover = cursor.getString(cursor.getColumnIndex(COLUMN_FOLDER_COVER));                folders.add(new Folder(folderName, folderCover));            &#125; while (cursor.moveToNext());        &#125;        cursor.close();    &#125;    return folders;&#125;</code></pre><h4 id="（3）删除收藏夹（级联删除下属收藏）"><a href="#（3）删除收藏夹（级联删除下属收藏）" class="headerlink" title="（3）删除收藏夹（级联删除下属收藏）"></a>（3）删除收藏夹（级联删除下属收藏）</h4><pre><code class="java">public void deleteFolder(String folderName) &#123;    try (SQLiteDatabase db = this.getWritableDatabase()) &#123;        // 1. 删除收藏夹本身        String whereClause = COLUMN_FOLDER_DISPLAY_NAME + &quot; =?&quot;;        String[] whereArgs = &#123;folderName&#125;;        db.delete(TABLE_FOLDERS, whereClause, whereArgs);                // 2. 级联删除该收藏夹下的所有收藏        whereClause = COLUMN_FOLDER_NAME + &quot; =?&quot;;        db.delete(TABLE_FAVORITES, whereClause, whereArgs);    &#125;&#125;</code></pre><h4 id="（4）更新收藏夹封面"><a href="#（4）更新收藏夹封面" class="headerlink" title="（4）更新收藏夹封面"></a>（4）更新收藏夹封面</h4><pre><code class="java">public void setFolderCover(String folderName, String coverPathOrUri) &#123;    try (SQLiteDatabase db = this.getWritableDatabase()) &#123;        ContentValues values = new ContentValues();        values.put(COLUMN_FOLDER_COVER, coverPathOrUri); // 存储封面路径或URI        String whereClause = COLUMN_FOLDER_DISPLAY_NAME + &quot; = ?&quot;;        String[] whereArgs = &#123;folderName&#125;;        db.update(TABLE_FOLDERS, values, whereClause, whereArgs);    &#125;&#125;</code></pre><h2 id="四、数据模型设计"><a href="#四、数据模型设计" class="headerlink" title="四、数据模型设计"></a>四、数据模型设计</h2><h3 id="1-收藏数据模型（FavoriteData-java）"><a href="#1-收藏数据模型（FavoriteData-java）" class="headerlink" title="1. 收藏数据模型（FavoriteData.java）"></a>1. 收藏数据模型（FavoriteData.java）</h3><pre><code class="java">public class FavoriteData &#123;    private String description; // 视频描述    private int imageResourceId; // 图片资源ID    private int videoImageResourceId; // 视频封面资源ID    private int videoListImageResourceId; // 列表封面资源ID    private String folderName; // 所属文件夹名称    private int id; // 数据库自增ID    private int originalId; // 关联的原始视频ID（核心关联字段）    // 构造方法（包含originalId）    public FavoriteData(String description, int imageResourceId, int videoImageResourceId,                        int videoListImageResourceId, String folderName, int id, int originalId) &#123;        this.description = description;        this.imageResourceId = imageResourceId;        this.videoImageResourceId = videoImageResourceId;        this.videoListImageResourceId = videoListImageResourceId;        this.folderName = folderName;        this.id = id;        this.originalId = originalId; // 关联原始视频    &#125;    // Getter和Setter...&#125;</code></pre><h3 id="2-收藏夹模型（内部类）"><a href="#2-收藏夹模型（内部类）" class="headerlink" title="2. 收藏夹模型（内部类）"></a>2. 收藏夹模型（内部类）</h3><pre><code class="java">public static class Folder &#123;    private String folderName; // 收藏夹名称    private String folderCover; // 封面路径    public Folder(String folderName, String folderCover) &#123;        this.folderName = folderName;        this.folderCover = folderCover;    &#125;    // Getter和Setter...&#125;</code></pre><h2 id="五、数据库使用场景"><a href="#五、数据库使用场景" class="headerlink" title="五、数据库使用场景"></a>五、数据库使用场景</h2><ol><li><strong>视频收藏</strong>：在视频详情页（<code>VideoActivity</code>）中，通过 <code>isFavoriteExists</code> 检查状态，调用 <code>addFavorite</code> 或 <code>deleteFavorite</code> 切换收藏状态。</li><li><strong>收藏夹管理</strong>：在 <code>CreateFolderActivity</code> 中调用 <code>addFolder</code> 创建新收藏夹，支持设置封面图（<code>setFolderCover</code>）。</li><li><strong>数据展示</strong>：收藏页通过 <code>getAllFolders</code> 和 <code>getALLFavorites</code> 加载数据，展示收藏夹列表及下属视频。</li><li><strong>状态同步</strong>：收藏操作后通过接口回调更新 UI，确保本地数据库状态与 UI 展示一致。</li></ol><h2 id="六、数据库设计亮点"><a href="#六、数据库设计亮点" class="headerlink" title="六、数据库设计亮点"></a>六、数据库设计亮点</h2><ol><li><strong>关联设计</strong>：通过 <code>original_id</code> 关联视频原始数据（<code>Data</code> 类的 <code>id</code>），避免收藏数据与源数据脱节。</li><li><strong>版本兼容</strong>：通过 <code>onUpgrade</code> 实现平滑升级，新增字段时保留旧数据（如 <code>DEFAULT -1</code>）。</li><li><strong>安全性</strong>：插入数据时对特殊字符（如单引号）进行转义，避免 SQL 注入风险。</li><li><strong>资源优化</strong>：使用 <code>try-with-resources</code> 自动关闭数据库连接，避免资源泄漏。</li><li><strong>级联操作</strong>：删除收藏夹时自动删除下属所有收藏，保证数据一致性。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;SQLite&lt;/strong&gt;的使用&lt;/p&gt;
&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>后端对接(Retrofit + OkHttp)</title>
    <link href="http://example.com/2025/09/06/%E5%90%8E%E7%AB%AF%E5%AF%B9%E6%8E%A5/"/>
    <id>http://example.com/2025/09/06/%E5%90%8E%E7%AB%AF%E5%AF%B9%E6%8E%A5/</id>
    <published>2025-09-06T04:02:30.000Z</published>
    <updated>2025-09-06T08:22:53.521Z</updated>
    
    <content type="html"><![CDATA[<p>通过 <strong>Retrofit + OkHttp</strong> 实现与后端服务的通信</p><p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="项目的后端对接方案详解"><a href="#项目的后端对接方案详解" class="headerlink" title="项目的后端对接方案详解"></a>项目的后端对接方案详解</h1><p>该仿哔哩哔哩项目通过 <strong>Retrofit + OkHttp</strong> 实现与后端服务的通信，主要涉及用户认证、视频数据获取等核心功能的接口对接，以下是具体实现细节：</p><h2 id="一、网络请求框架搭建"><a href="#一、网络请求框架搭建" class="headerlink" title="一、网络请求框架搭建"></a>一、网络请求框架搭建</h2><h3 id="1-核心依赖"><a href="#1-核心依赖" class="headerlink" title="1. 核心依赖"></a>1. 核心依赖</h3><p>项目使用 <code>Retrofit</code> 作为网络请求核心框架，配合 <code>OkHttp</code> 处理底层网络通信，相关依赖在 build.gradle.kts 中声明：</p><pre><code class="kotlin">// 网络请求相关依赖implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;) // Gson解析implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;) // 日志拦截器</code></pre><h3 id="2-后端基础配置（Url-java）"><a href="#2-后端基础配置（Url-java）" class="headerlink" title="2. 后端基础配置（Url.java）"></a>2. 后端基础配置（Url.java）</h3><p>统一管理后端服务的主机地址和基础路径：</p><pre><code class="java">public class Url &#123;    // 后端服务IP和端口（示例为本地测试地址）    public static String host = &quot;192.168.136.9:4523&quot;;    // 接口基础URL    public static String url = &quot;http://&quot; + host + &quot;/m1/6993757-6712033-default/&quot;;&#125;</code></pre><h2 id="二、Retrofit-客户端配置（ApiClient-java）"><a href="#二、Retrofit-客户端配置（ApiClient-java）" class="headerlink" title="二、Retrofit 客户端配置（ApiClient.java）"></a>二、Retrofit 客户端配置（ApiClient.java）</h2><h3 id="1-单例模式创建-Retrofit-实例"><a href="#1-单例模式创建-Retrofit-实例" class="headerlink" title="1. 单例模式创建 Retrofit 实例"></a>1. 单例模式创建 Retrofit 实例</h3><p>通过单例模式确保 Retrofit 实例唯一，减少资源消耗：</p><pre><code class="java">public class ApiClient &#123;    private static final String BASE_URL = Url.url;    private static Retrofit retrofit = null;    // 固定Token（实际项目中应通过登录动态获取）    private static final String TOKEN = &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...&quot;;    // 获取Retrofit实例    public static Retrofit getRetrofit() &#123;        if (retrofit == null) &#123;            // 日志拦截器：打印请求和响应信息（调试用）            HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();            loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);            // 配置OkHttp客户端，添加请求头和拦截器            OkHttpClient client = new OkHttpClient.Builder()                    .addInterceptor(chain -&gt; &#123;                        // 构建新请求并添加统一请求头                        Request newRequest = chain.request().newBuilder()                                .header(&quot;Authorization&quot;, TOKEN) // 认证Token                                .header(&quot;User-Agent&quot;, &quot;Apifox/1.0.0&quot;)                                .header(&quot;Accept&quot;, &quot;*/*&quot;)                                .header(&quot;Host&quot;, Url.host)                                .build();                        return chain.proceed(newRequest);                    &#125;)                    .addInterceptor(loggingInterceptor) // 添加日志拦截器                    .build();            // 初始化Retrofit            retrofit = new Retrofit.Builder()                    .baseUrl(BASE_URL)                    .client(client)                    .addConverterFactory(GsonConverterFactory.create()) // Gson解析                    .build();        &#125;        return retrofit;    &#125;    // 获取API服务接口实例    public static ApiService getApiService() &#123;        return getRetrofit().create(ApiService.class);    &#125;&#125;</code></pre><h2 id="三、API-接口定义（ApiService-java）"><a href="#三、API-接口定义（ApiService-java）" class="headerlink" title="三、API 接口定义（ApiService.java）"></a>三、API 接口定义（ApiService.java）</h2><p>通过 Retrofit 注解定义后端接口，目前主要实现视频推荐数据的获取：</p><pre><code class="java">public interface ApiService &#123;    /**     * 获取推荐视频数据     * @param page 页码（分页参数）     * @param pageSize 每页数量     * @return 视频数据响应     */    @GET(&quot;user/video/recommend&quot;) // 接口路径（拼接在BASE_URL后）    Call&lt;VideoResponse&gt; getVideoData(            @Query(&quot;page&quot;) int page,            @Query(&quot;pagesize&quot;) int pageSize    );&#125;</code></pre><h2 id="四、数据模型设计"><a href="#四、数据模型设计" class="headerlink" title="四、数据模型设计"></a>四、数据模型设计</h2><h3 id="1-响应体结构（VideoResponse-java）"><a href="#1-响应体结构（VideoResponse-java）" class="headerlink" title="1. 响应体结构（VideoResponse.java）"></a>1. 响应体结构（VideoResponse.java）</h3><p>对应后端返回的 JSON 结构，使用 <code>@SerializedName</code> 注解映射字段：</p><pre><code class="java">public class VideoResponse &#123;    @SerializedName(&quot;code&quot;) // 状态码（200表示成功）    private int code;    @SerializedName(&quot;msg&quot;) // 提示信息    private String msg;    @SerializedName(&quot;data&quot;) // 视频数据列表    private List&lt;VideoData&gt; data;    // Getter和Setter方法&#125;</code></pre><h3 id="2-视频数据模型（VideoData-java）"><a href="#2-视频数据模型（VideoData-java）" class="headerlink" title="2. 视频数据模型（VideoData.java）"></a>2. 视频数据模型（VideoData.java）</h3><p>存储单个视频的详细信息：</p><pre><code class="java">public class VideoData implements Serializable &#123;    @SerializedName(&quot;id&quot;) // 视频ID    private String id;    @SerializedName(&quot;title&quot;) // 视频标题    private String title;    @SerializedName(&quot;thumbPhoto&quot;) // 视频封面图URL    private String thumbPhoto;    @SerializedName(&quot;isLike&quot;) // 是否点赞    private boolean isLike;    @SerializedName(&quot;isCollect&quot;) // 是否收藏    private boolean isCollect;    @SerializedName(&quot;upData&quot;) // 上传者信息（嵌套对象）    private UpData upData;    // 其他字段（点赞数、收藏数等）及Getter/Setter&#125;</code></pre><h3 id="3-上传者信息模型（UpData-java）"><a href="#3-上传者信息模型（UpData-java）" class="headerlink" title="3. 上传者信息模型（UpData.java）"></a>3. 上传者信息模型（UpData.java）</h3><p>嵌套在 <code>VideoData</code> 中，存储 UP 主信息：</p><pre><code class="java">public class UpData implements Serializable &#123;    @SerializedName(&quot;name&quot;) // 用户名    private String name;    @SerializedName(&quot;fans&quot;) // 粉丝数    private int fans;    @SerializedName(&quot;avator&quot;) // 头像URL    private String avator;    // 其他字段及Getter/Setter&#125;</code></pre><h2 id="五、接口调用示例（以视频数据获取为例）"><a href="#五、接口调用示例（以视频数据获取为例）" class="headerlink" title="五、接口调用示例（以视频数据获取为例）"></a>五、接口调用示例（以视频数据获取为例）</h2><p>在 <code>Tab2Fragment</code> 中调用推荐视频接口，实现数据加载：</p><pre><code class="java">private void fetchData(int page, int pageSize, boolean isRefresh) &#123;    // 调用ApiClient获取服务实例    ApiService apiService = ApiClient.getApiService();    // 构建请求（传入分页参数）    Call&lt;VideoResponse&gt; call = apiService.getVideoData(page, pageSize);    // 异步执行请求    call.enqueue(new Callback&lt;VideoResponse&gt;() &#123;        @Override        public void onResponse(Call&lt;VideoResponse&gt; call, Response&lt;VideoResponse&gt; response) &#123;            if (response.isSuccessful() &amp;&amp; response.body() != null) &#123;                VideoResponse videoResponse = response.body();                if (videoResponse.getCode() == 200) &#123; // 后端约定200为成功                    List&lt;VideoData&gt; newData = videoResponse.getData();                    // 处理数据（刷新或加载更多）                    if (isRefresh) &#123;                        videoList.clear(); // 下拉刷新时清空旧数据                    &#125;                    videoList.addAll(newData); // 添加新数据                    adapter.notifyDataSetChanged(); // 更新列表                &#125; else &#123;                    // 处理业务错误（如参数错误）                    Toast.makeText(requireContext(), videoResponse.getMsg(), Toast.LENGTH_SHORT).show();                &#125;            &#125; else &#123;                // 处理HTTP错误（如404、500）                Toast.makeText(requireContext(), &quot;请求失败&quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;        @Override        public void onFailure(Call&lt;VideoResponse&gt; call, Throwable t) &#123;            // 处理网络错误（如无网络、连接超时）            Toast.makeText(requireContext(), &quot;网络错误: &quot; + t.getMessage(), Toast.LENGTH_SHORT).show();        &#125;    &#125;);&#125;</code></pre><h2 id="六、用户认证对接（登录功能）"><a href="#六、用户认证对接（登录功能）" class="headerlink" title="六、用户认证对接（登录功能）"></a>六、用户认证对接（登录功能）</h2><p>登录功能通过 <code>OkHttp</code> 直接发送 POST 请求（未使用 Retrofit，保持与后端登录接口的灵活性）：</p><pre><code class="java">private void loginRequest(String username, String password) &#123;    // 构建JSON请求体（与后端约定的格式一致）    MediaType mediaType = MediaType.parse(&quot;application/json; charset=utf-8&quot;);    RequestBody body = RequestBody.create(mediaType,            &quot;&#123;\&quot;username\&quot;:\&quot;&quot; + username + &quot;\&quot;,\&quot;password\&quot;:\&quot;&quot; + password + &quot;\&quot;&#125;&quot;    );    // 构建登录请求    Request request = new Request.Builder()            .url(LOGIN_URL) // 登录接口URL（单独配置，未使用BASE_URL）            .post(body)            .build();    // 发送异步请求    client.newCall(request).enqueue(new okhttp3.Callback() &#123;        @Override        public void onResponse(okhttp3.Call call, Response response) throws IOException &#123;            if (response.isSuccessful()) &#123;                String responseData = response.body().string();                JSONObject jsonObject = new JSONObject(responseData);                if (jsonObject.optInt(&quot;code&quot;) == 200) &#123;                    // 登录成功：保存Token到本地（使用SpUtils）                    String token = jsonObject.optString(&quot;data&quot;);                    SpUtils.saveToken(LoginActivity.this, token);                    // 跳转至主页                    startActivity(new Intent(LoginActivity.this, MainActivity.class));                &#125;            &#125;        &#125;        @Override        public void onFailure(okhttp3.Call call, IOException e) &#123;            // 处理登录失败        &#125;    &#125;);&#125;</code></pre><h2 id="七、后端对接的核心特点"><a href="#七、后端对接的核心特点" class="headerlink" title="七、后端对接的核心特点"></a>七、后端对接的核心特点</h2><ol><li><strong>统一请求头管理</strong>：通过 OkHttp 拦截器统一添加 <code>Authorization</code>（Token）、<code>Host</code> 等请求头，避免重复代码。</li><li><strong>数据解析自动化</strong>：使用 <code>GsonConverterFactory</code> 自动将 JSON 响应转换为 Java 对象，减少手动解析成本。</li><li><strong>日志调试</strong>：添加 <code>HttpLoggingInterceptor</code> 打印请求详情（URL、参数、响应体），方便调试接口。</li><li><strong>错误处理</strong>：区分网络错误（<code>onFailure</code>）、HTTP 错误（如 401 未授权）和业务错误（如 code 非 200），分别处理。</li><li><strong>Token 管理</strong>：登录成功后将 Token 保存到本地（<code>SpUtils</code>），作为后续请求的认证凭证。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过 &lt;strong&gt;Retrofit + OkHttp&lt;/strong&gt; 实现与后端服务的通信&lt;/p&gt;
&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Activity和Fragment的多级嵌套</title>
    <link href="http://example.com/2025/09/06/Activity%E5%92%8CFragment%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B5%8C%E5%A5%97/"/>
    <id>http://example.com/2025/09/06/Activity%E5%92%8CFragment%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B5%8C%E5%A5%97/</id>
    <published>2025-09-06T02:58:44.000Z</published>
    <updated>2025-09-06T08:22:22.659Z</updated>
    
    <content type="html"><![CDATA[<p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="项目中嵌套结构详解：MainActivity-→-HomeFragment-→-子-TabFragment"><a href="#项目中嵌套结构详解：MainActivity-→-HomeFragment-→-子-TabFragment" class="headerlink" title="项目中嵌套结构详解：MainActivity → HomeFragment → 子 TabFragment"></a>项目中嵌套结构详解：MainActivity → HomeFragment → 子 TabFragment</h1><h2 id="一、整体架构概述"><a href="#一、整体架构概述" class="headerlink" title="一、整体架构概述"></a>一、整体架构概述</h2><p>该项目采用了 “Activity + Fragment” 的多层嵌套架构，核心嵌套关系为：<br><code>MainActivity</code>（主活动）→ <code>HomeFragment</code>（一级碎片）→ <code>Tab1Fragment</code>至<code>Tab6Fragment</code>（二级碎片）</p><p>这种架构的优势在于：</p><ul><li>实现底部导航与顶部内容区的分离管理</li><li>支持单 Activity 多 Fragment 的轻量切换</li><li>便于维护和扩展不同功能模块</li></ul><h2 id="二、各层级实现细节"><a href="#二、各层级实现细节" class="headerlink" title="二、各层级实现细节"></a>二、各层级实现细节</h2><h3 id="1-最外层：MainActivity（主活动）"><a href="#1-最外层：MainActivity（主活动）" class="headerlink" title="1. 最外层：MainActivity（主活动）"></a>1. 最外层：MainActivity（主活动）</h3><p><strong>核心作用</strong>：作为应用容器，管理底部导航和一级 Fragment 切换</p><pre><code class="java">// MainActivity.java 关键代码fragments = new Fragment[]&#123;    new HomeFragment(),    // 首页Fragment（核心）    new FocusFragment(),   // 关注Fragment    new CreateFragment(),  // 创建Fragment    new ShoppingFragment(),// 购物Fragment    new MineFragment()     // 我的Fragment&#125;;// 初始化时默认显示HomeFragmentgetSupportFragmentManager().beginTransaction()    .add(R.id.main_frame,fragments[0])    .commit();</code></pre><p><strong>布局容器</strong>：<br>通过activity_main.xml中的<code>FrameLayout</code>（<code>@+id/main_frame</code>）作为一级 Fragment 的容器，底部通过<code>BottomNavigationView</code>实现导航切换。</p><p><strong>切换逻辑</strong>：<br>通过<code>switchFragment()</code>方法管理 Fragment 的显示 &#x2F; 隐藏，避免重复创建：</p><pre><code class="java">private void switchFragment(int to)&#123;    if (lastFragmentIndex == to) return;    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();    if (!fragments[to].isAdded()) &#123;        transaction.add(R.id.main_frame,fragments[to]);    &#125; else &#123;        transaction.show(fragments[to]);    &#125;    transaction.hide(fragments[lastFragmentIndex]).commitAllowingStateLoss();    lastFragmentIndex = to;&#125;</code></pre><h3 id="2-中间层：HomeFragment（一级碎片）"><a href="#2-中间层：HomeFragment（一级碎片）" class="headerlink" title="2. 中间层：HomeFragment（一级碎片）"></a>2. 中间层：HomeFragment（一级碎片）</h3><p><strong>核心作用</strong>：作为首页容器，管理顶部导航栏和二级 TabFragment 切换</p><p><strong>布局结构</strong>（fragment_home.xml）：</p><ul><li>顶部导航栏（包含头像、搜索框等）</li><li>TabLayout（标签栏，<code>@+id/tab_layout</code>）</li><li>右侧固定 Tab（<code>@+id/tab_layout_fixed</code>）</li><li>ViewPager（<code>@+id/vp</code>，用于承载二级 Fragment）</li></ul><p><strong>Tab 与 ViewPager 绑定</strong>：<br>通过<code>HomeFragmentAdapter</code>将 Tab 与二级 Fragment 关联：</p><pre><code class="java">// HomeFragment.java 关键代码homeFragmentAdapter = new HomeFragmentAdapter(getChildFragmentManager());homeFragmentAdapter.setmBean(beans); // 设置Tab标题数据viewPager.setAdapter(homeFragmentAdapter);tabLayout.setupWithViewPager(viewPager); // 绑定TabLayout和ViewPagerviewPager.setCurrentItem(1); // 默认显示第2个Tab（推荐）</code></pre><p>**为什么使用 getChildFragmentManager ()**：<br>在 Fragment 中嵌套子 Fragment 时，必须使用<code>getChildFragmentManager()</code>而非<code>getFragmentManager()</code>，否则会导致子 Fragment 状态管理异常。</p><h3 id="3-最内层：Tab1Fragment-至-Tab6Fragment（二级碎片）"><a href="#3-最内层：Tab1Fragment-至-Tab6Fragment（二级碎片）" class="headerlink" title="3. 最内层：Tab1Fragment 至 Tab6Fragment（二级碎片）"></a>3. 最内层：Tab1Fragment 至 Tab6Fragment（二级碎片）</h3><p><strong>核心作用</strong>：各自承载不同的首页内容（直播、推荐、热门等）</p><p><strong>实现方式</strong>：<br>所有二级 Fragment 均继承自<code>BaseFragment</code>，统一实现布局加载和视图初始化：</p><pre><code class="java">// 以Tab1Fragment为例public class Tab1Fragment extends BaseFragment &#123;    @Override    protected void initViews() &#123;        // 初始化当前Tab的视图    &#125;    @Override    protected int getLayoutId() &#123;        return R.layout.tab1_fragment; // 返回对应布局    &#125;&#125;</code></pre><p><strong>特殊实现：Tab2Fragment</strong><br>作为 “推荐” 标签页，实现了更复杂的功能：</p><ul><li>下拉刷新（<code>SwipeRefreshLayout</code>）</li><li>上拉加载更多（RecyclerView 滚动监听）</li><li>网络数据请求（通过<code>ApiService</code>获取视频数据）</li><li>混合布局（Banner 轮播 + 本地数据 + 网络视频数据）</li></ul><h2 id="三、嵌套关系的关键技术点"><a href="#三、嵌套关系的关键技术点" class="headerlink" title="三、嵌套关系的关键技术点"></a>三、嵌套关系的关键技术点</h2><ol><li><p><strong>FragmentManager 层级关系</strong>：</p><ul><li>MainActivity 使用<code>getSupportFragmentManager()</code>管理一级 Fragment</li><li>HomeFragment 使用<code>getChildFragmentManager()</code>管理二级 Fragment</li><li>确保 Fragment 的添加 &#x2F; 移除操作在正确的管理器中执行</li></ul></li><li><p><strong>ViewPager 与 FragmentPagerAdapter</strong>：</p><pre><code class="java">// HomeFragmentAdapter.java 关键代码@NonNull@Overridepublic Fragment getItem(int position) &#123;    switch (position) &#123;        case 0: return new Tab1Fragment();        case 1: return new Tab2Fragment();        // ... 其他Tab对应的Fragment        default: return new Tab2Fragment();    &#125;&#125;</code></pre></li><li><p><strong>生命周期管理</strong>：</p><ul><li>当 MainActivity 切换到 HomeFragment 时，HomeFragment 执行<code>onResume()</code></li><li>当 ViewPager 切换 Tab 时，对应的子 Fragment 会执行<code>onResume()</code>&#x2F;<code>onPause()</code></li><li>通过<code>ViewPager.setOffscreenPageLimit(n)</code>控制预加载的子 Fragment 数量（默认预加载左右各 1 个）</li></ul></li><li><p><strong>数据通信</strong>：</p><ul><li>子 Fragment 与 HomeFragment 通信：可通过接口回调（如之前优化方案中提到的<code>OnTabFragmentInteractionListener</code>）</li><li>跨层级通信：可使用 ViewModel 或 EventBus 实现 MainActivity 与子 Fragment 的数据传递</li></ul></li></ol><h2 id="四、布局嵌套关系可视化"><a href="#四、布局嵌套关系可视化" class="headerlink" title="四、布局嵌套关系可视化"></a>四、布局嵌套关系可视化</h2><pre><code class="plaintext">MainActivity（activity_main.xml）├─ FrameLayout（@+id/main_frame）  // 一级Fragment容器│  └─ HomeFragment（fragment_home.xml）│     ├─ 顶部导航栏（LinearLayout）│     ├─ TabLayout（@+id/tab_layout）  // 标签栏│     ├─ 右侧固定Tab（@+id/tab_layout_fixed）│     └─ ViewPager（@+id/vp）  // 二级Fragment容器│        ├─ Tab1Fragment（tab1_fragment.xml）  // 直播│        ├─ Tab2Fragment（tab2_fragment.xml）  // 推荐│        ├─ Tab3Fragment（tab3_fragment.xml）  // 热门│        ├─ Tab4Fragment（tab4_fragment.xml）  // 动画│        ├─ Tab5Fragment（tab5_fragment.xml）  // 影视│        └─ Tab6Fragment（tab6_fragment.xml）  // 新征程└─ BottomNavigationView（底部导航）</code></pre><h2 id="五、这种嵌套结构的优缺点"><a href="#五、这种嵌套结构的优缺点" class="headerlink" title="五、这种嵌套结构的优缺点"></a>五、这种嵌套结构的优缺点</h2><p><strong>优点</strong>：</p><ol><li>功能模块清晰分离，便于团队协作开发</li><li>单个页面内容过多时，可拆分到不同子 Fragment 中管理</li><li>利用 ViewPager 的缓存机制，提升 Tab 切换的流畅度</li><li>底部导航切换时，HomeFragment 中的子 Tab 状态可保留</li></ol><p><strong>缺点</strong>：</p><ol><li>层级较深时，Fragment 生命周期管理复杂</li><li>子 Fragment 与 Activity 通信需要通过中间层（HomeFragment）转发</li><li>过度嵌套可能导致内存占用增加</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>框架</title>
    <link href="http://example.com/2025/04/23/%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2025/04/23/%E6%A1%86%E6%9E%B6/</id>
    <published>2025-04-23T15:05:04.000Z</published>
    <updated>2025-05-01T08:54:43.788Z</updated>
    
    <content type="html"><![CDATA[<p>不知道写什么 QAQ</p><span id="more"></span><h1 id="框架意义"><a href="#框架意义" class="headerlink" title="框架意义"></a>框架意义</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745420756417.png" alt="1745420756417"></p><h1 id="框架优缺点"><a href="#框架优缺点" class="headerlink" title="框架优缺点"></a>框架优缺点</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745420790853.png" alt="1745420790853"></p><h1 id="常见java框架"><a href="#常见java框架" class="headerlink" title="常见java框架"></a>常见java框架</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745420896871.png" alt="1745420896871"></p><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="一种持久层框架"><a href="#一种持久层框架" class="headerlink" title="一种持久层框架"></a>一种持久层框架</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745421039699.png" alt="1745421039699"></p><h2 id="一种ORM框架"><a href="#一种ORM框架" class="headerlink" title="一种ORM框架"></a>一种ORM框架</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745421323953.png" alt="1745421323953"></p><h2 id="搭建MyBatis框架"><a href="#搭建MyBatis框架" class="headerlink" title="搭建MyBatis框架"></a>搭建MyBatis框架</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745421520937.png" alt="1745421520937"></p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在pom.xml中</p><pre><code class="xml">&lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.30&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.11&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h3 id="创建MyBatis的配置文件"><a href="#创建MyBatis的配置文件" class="headerlink" title="创建MyBatis的配置文件"></a>创建MyBatis的配置文件</h3><p>（可以去阅读MyBatis的入门文档）</p><p>将文件创建在resources的目录下</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/zxy?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;mapper/BookMapper.xml&quot;&gt;&lt;/mapper&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>创建实体类（一般创建在pojo的包下）</p><pre><code class="java">package com.zxy.pojo;public class Book &#123;    private int id;    private String name;    private String author;    private double price;    public Book(int id, String name, String author, double price) &#123;        this.id = id;        this.name = name;        this.author = author;        this.price = price;    &#125;    public Book() &#123;    &#125;    public double getPrice() &#123;        return price;    &#125;    public int getId() &#123;        return id;    &#125;    public String getAuthor() &#123;        return author;    &#125;    public String getName() &#123;        return name;    &#125;&#125;</code></pre><p>创建映射文件（一般在resources下创建个mapper包，在mapper包下创建各种映射文件）</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;zxy&quot;&gt;    &lt;select id=&quot;selectAllBooks&quot; resultType=&quot;com.zxy.pojo.Book&quot;&gt;        select * from t_book    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>在这个文件中可以写各种SQL语言</p><h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><pre><code class="java">package com.zxy.test;import com.zxy.pojo.Book;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123;    public static void main(String[] args) throws IOException &#123;        String resource = &quot;Mybatis.xml&quot;;//配置文件        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        List&lt;Book&gt; selectAllBooks = sqlSession.selectList(&quot;zxy.selectAllBooks&quot;);        for (Book book: selectAllBooks) &#123;            System.out.println(book.getAuthor() + &quot;---&quot; + book.getName() + &quot;----&quot; + book.getPrice());        &#125;    &#125;&#125;</code></pre><h2 id="别名设置、内置别名"><a href="#别名设置、内置别名" class="headerlink" title="别名设置、内置别名"></a>别名设置、内置别名</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745504154207.png" alt="1745504154207"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745504495531.png" alt="1745504495531"></p><h2 id="属性文件配置"><a href="#属性文件配置" class="headerlink" title="属性文件配置"></a>属性文件配置</h2><p>在resources目录下创建db.properties文件</p><pre><code class="properties">url=jdbc:mysql://localhost/zxy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=truedriver=com.mysql.cj.jdbc.Driverusername=rootpassword=root</code></pre><p>使用属性文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;                 &lt;!-- $&#123;driver&#125;中的内容要与属性文件的一一对应 --&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;mapper/BookMapper.xml&quot;&gt;&lt;/mapper&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h2 id="MyBatis启动日志功能"><a href="#MyBatis启动日志功能" class="headerlink" title="MyBatis启动日志功能"></a>MyBatis启动日志功能</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745505302231.png" alt="1745505302231"></p><h2 id="接口绑定方案"><a href="#接口绑定方案" class="headerlink" title="接口绑定方案"></a>接口绑定方案</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745557468921.png" alt="1745557468921"></p><h3 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h3><p>一般创建在java下的com.zxy（公司名）.mapper下</p><pre><code class="java">package com.zxy.mapper;import java.util.List;public interface BookMapper &#123;    List selectAllBooks();&#125;</code></pre><h3 id="创建映射文件"><a href="#创建映射文件" class="headerlink" title="创建映射文件"></a>创建映射文件</h3><p>路径与java下的mapper相同，只不过是创建在resources目录下</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.zxy.mapper.BookMapper&quot;&gt;    &lt;select id=&quot;selectAllBooks&quot; resultType=&quot;com.zxy.pojo.Book&quot;&gt;        select * from t_book    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>注意mapper的命名空间</p><h3 id="编写测试类-1"><a href="#编写测试类-1" class="headerlink" title="编写测试类"></a>编写测试类</h3><pre><code class="java">package com.zxy.test;import com.zxy.mapper.BookMapper;import com.zxy.pojo.Book;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123;    public static void main(String[] args) throws IOException &#123;        String resource = &quot;Mybatis.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();                //相当于BookMapper mapper = BookMapper实现类        BookMapper mapper = sqlSession.getMapper(BookMapper.class);        List&lt;Book&gt; selectAllBooks = mapper.selectAllBooks();        for (Book book: selectAllBooks) &#123;            System.out.println(book.getAuthor() + &quot;---&quot; + book.getName() + &quot;----&quot; + book.getPrice());        &#125;        sqlSession.close();        inputStream.close();    &#125;&#125;</code></pre><h2 id="参数传递问题"><a href="#参数传递问题" class="headerlink" title="参数传递问题"></a>参数传递问题</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745557255483.png" alt="1745557255483"></p><h2 id="获取数据方式"><a href="#获取数据方式" class="headerlink" title="获取数据方式"></a>获取数据方式</h2><h3 id="通过内置名称"><a href="#通过内置名称" class="headerlink" title="通过内置名称"></a>通过内置名称</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745559435932.png" alt="1745559435932"></p><pre><code class="xml">    &lt;select id=&quot;selectOneBook&quot; resultType=&quot;com.zxy.pojo.Book&quot;&gt;        select * from t_book where name =#&#123;arg0&#125; and author = #&#123;arg1&#125;    &lt;/select&gt;</code></pre><pre><code class="java">BookMapper mapper = sqlSession.getMapper(BookMapper.class);        Book book1 = mapper.selectOneBook(&quot;小红书&quot;, &quot;郑晓羽&quot;);        System.out.println(book1.getAuthor() + &quot;---&quot; + book1.getName() + &quot;----&quot; + book1.getPrice());</code></pre><h3 id="通过封装成具体对象"><a href="#通过封装成具体对象" class="headerlink" title="通过封装成具体对象"></a>通过封装成具体对象</h3><pre><code class="xml">    &lt;select id=&quot;selectOneBook2&quot; resultType=&quot;com.zxy.pojo.Book&quot;&gt;        select * from t_book where name =#&#123;name&#125; and author = #&#123;author&#125;    &lt;/select&gt;</code></pre><pre><code class="java">Book b = new Book();        b.setAuthor(&quot;脑浆糊&quot;);        b.setName(&quot;你啊&quot;);        Book book2 = mapper.selectOneBook2(b);        System.out.println(book2.getAuthor() + &quot;---&quot; + book2.getName() + &quot;----&quot; + book2.getPrice());</code></pre><h3 id="多个参数且参数有对象，获取参数如何处理呢？"><a href="#多个参数且参数有对象，获取参数如何处理呢？" class="headerlink" title="多个参数且参数有对象，获取参数如何处理呢？"></a>多个参数且参数有对象，获取参数如何处理呢？</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745560032761.png" alt="1745560032761"></p><pre><code class="xml">    &lt;select id=&quot;selectOneBook3&quot; resultType=&quot;com.zxy.pojo.Book&quot;&gt;        select * from t_book where name =#&#123;param1&#125; and author = #&#123;param2.author&#125;    &lt;/select&gt;</code></pre><pre><code class="java">Book b1 = new Book();        b1.setAuthor(&quot;郑晓羽&quot;);        Book book3 = mapper.selectOneBook3(&quot;小黄书&quot;,b1);        System.out.println(book3.getAuthor() + &quot;---&quot; + book3.getName() + &quot;----&quot; + book3.getPrice());</code></pre><h2 id="增删改操作"><a href="#增删改操作" class="headerlink" title="增删改操作"></a>增删改操作</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745563311291.png" alt="1745563311291"></p><p>注意：要记得提交事务。</p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745593753781.png" alt="1745593753781"></p><h2 id="Spring-Ioc-DI"><a href="#Spring-Ioc-DI" class="headerlink" title="Spring  Ioc&#x2F;DI"></a>Spring  Ioc&#x2F;DI</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745594488686.png" alt="1745594488686"></p><h3 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745595604487.png" alt="1745595604487"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745595635465.png" alt="1745595635465"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745595653205.png" alt="1745595653205"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745596022401.png" alt="1745596022401"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745656605563.png" alt="1745656605563"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745656826437.png" alt="1745656826437"></p><p><strong>applicationContext.xml文件</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;book&quot; class=&quot;com.zxy.pojo.Book&quot;/&gt;&lt;/beans&gt;</code></pre><p><strong>测试类</strong></p><pre><code class="java">package com.zxy.test;import com.zxy.pojo.Book;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        Book book = (Book) context.getBean(&quot;book&quot;);    &#125;&#125;</code></pre><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745657978917.png" alt="1745657978917"></p><p>在创建容器的时候对象就已经存在了。</p><h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><pre><code class="xml">    &lt;bean id=&quot;book&quot; class=&quot;com.zxy.pojo.Book&quot;&gt;        &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;name&quot; value=&quot;小红书&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><p>底层调用的是实例类的set函数。</p><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><pre><code class="xml">    &lt;bean id=&quot;book2&quot; class=&quot;com.zxy.pojo.Book&quot;&gt;        &lt;constructor-arg name=&quot;id&quot; value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;小黄书&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;</code></pre><p>要保证实例类有相应参数的构造函数。</p><h4 id="引用数据类型属性注入"><a href="#引用数据类型属性注入" class="headerlink" title="引用数据类型属性注入"></a>引用数据类型属性注入</h4><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745677996755.png" alt="1745677996755"></p><pre><code class="xml">    &lt;bean id=&quot;boy&quot; class=&quot;com.zxy.pojo.Boy&quot;&gt;        &lt;property name=&quot;age&quot; value=&quot;25&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;name&quot; value=&quot;小明&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;girl&quot; class=&quot;com.zxy.pojo.Girl&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;丽丽&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;25&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;boyfriend&quot; ref=&quot;boy&quot; &gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><h4 id="IoC-DI的相关注解"><a href="#IoC-DI的相关注解" class="headerlink" title="IoC&#x2F;DI的相关注解"></a>IoC&#x2F;DI的相关注解</h4><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745678438972.png" alt="1745678438972"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745678540319.png" alt="1745678540319"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745678961355.png" alt="1745678961355"></p><h5 id="注解创建对象的属性注入"><a href="#注解创建对象的属性注入" class="headerlink" title="注解创建对象的属性注入"></a>注解创建对象的属性注入</h5><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745679023806.png" alt="1745679023806"></p><p>不需要依赖set方法。</p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745679195959.png" alt="1745679195959"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745679177941.png" alt="1745679177941"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745679209803.png" alt="1745679209803"></p><h1 id="通过Maven搭建web项目"><a href="#通过Maven搭建web项目" class="headerlink" title="通过Maven搭建web项目"></a>通过Maven搭建web项目</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-27%20215520.png"></p><h2 id="配置自带的tomcat插件"><a href="#配置自带的tomcat插件" class="headerlink" title="配置自带的tomcat插件"></a>配置自带的tomcat插件</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745763790032.png" alt="1745763790032"></p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745764311944.png" alt="1745764311944"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745840399954.png" alt="1745840399954"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745764329847.png" alt="1745764329847"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745840359763.png" alt="1745840359763"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745841674569.png" alt="1745841674569"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745842882514.png" alt="1745842882514"></p><p><strong>TestController</strong></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745843515539.png" alt="1745843515539"></p><pre><code class="java">package com.zxy.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestController &#123;    @RequestMapping(&quot;/test1&quot;)    public String text1()&#123;        //响应给浏览器index.jsp页面        return &quot;index.jsp&quot;;        //这里返回的为文件的名称，在web-app包下    &#125;&#125;</code></pre><p><strong>springmvc.xml</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.zxy.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt;</code></pre><p><strong>web.xml</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee        http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;        version=&quot;4.0&quot;         metadata-complete=&quot;true&quot;&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h2 id="前后端参数交互"><a href="#前后端参数交互" class="headerlink" title="前后端参数交互"></a>前后端参数交互</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844485538.png" alt="1745844485538"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844227203.png" alt="1745844227203"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844244237.png" alt="1745844244237"></p><pre><code class="java">@RequestMapping(&quot;/testParam&quot;)public String testParam(String name,int age)&#123;    System.out.println(name + &quot;----&quot; + age);    return &quot;index2.jsp&quot;;&#125;</code></pre><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844497524.png" alt="1745844497524"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844475960.png" alt="1745844475960"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844787181.png" alt="1745844787181"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844802635.png" alt="1745844802635"></p><pre><code class="java">    @RequestMapping(&quot;/testParam2&quot;)    public String testParam2(Person person)&#123;        System.out.println(person.getName() + &quot;----&quot; + person.getAge() + &quot;----&quot; + person.getScore());        return &quot;index2.jsp&quot;;    &#125;</code></pre><h1 id="springBoot"><a href="#springBoot" class="headerlink" title="springBoot"></a>springBoot</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746086414531.png" alt="1746086414531"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746086469782.png" alt="1746086469782"></p><h2 id="SpringBoot项目搭建"><a href="#SpringBoot项目搭建" class="headerlink" title="SpringBoot项目搭建"></a>SpringBoot项目搭建</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746087743658.png" alt="1746087743658"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746087910275.png" alt="1746087910275"></p><h3 id="启动器、启动类"><a href="#启动器、启动类" class="headerlink" title="启动器、启动类"></a>启动器、启动类</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746088018955.png" alt="1746088018955"></p><pre><code class="xml">    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;version&gt;2.7.6&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746088464267.png" alt="1746088464267"></p><h2 id="SpringBoot的相关配置"><a href="#SpringBoot的相关配置" class="headerlink" title="SpringBoot的相关配置"></a>SpringBoot的相关配置</h2><p>用application.properties配置</p><pre><code class="properties">server.port=8888server.servlet.context-path=/springboot01</code></pre><p>用application.yml配置</p><h3 id="yml配置文件介绍"><a href="#yml配置文件介绍" class="headerlink" title="yml配置文件介绍"></a>yml配置文件介绍</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746089643476.png" alt="1746089643476"></p><pre><code class="yml">server:  port: 9999  servlet:    context-path: /sb01</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知道写什么 QAQ&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HTML,CSS and JS</title>
    <link href="http://example.com/2025/04/22/HTML/"/>
    <id>http://example.com/2025/04/22/HTML/</id>
    <published>2025-04-22T12:53:41.000Z</published>
    <updated>2025-04-22T13:51:22.494Z</updated>
    
    <content type="html"><![CDATA[<p>速通 web前端</p><span id="more"></span><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><img src="/../images/HTML/1745326536644.png" alt="1745326536644"></p><p>要展示的内容写在body标签内部。</p><p>写中文时要把编码格式改成<code>UTF-8</code></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p><img src="/../images/HTML/1745326875856.png" alt="1745326875856"></p><h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><p><img src="/../images/HTML/1745327426564.png" alt="1745327426564"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;速通 web前端&lt;/p&gt;</summary>
    
    
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="http://example.com/2025/04/22/JDBC/"/>
    <id>http://example.com/2025/04/22/JDBC/</id>
    <published>2025-04-22T11:53:46.000Z</published>
    <updated>2025-04-24T15:42:19.930Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/JDBC/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-22%20195308.png"></p><span id="more"></span><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><img src="/../images/JDBC/1745322888409.png" alt="1745322888409"></p><h1 id="JDBC访问数据库步骤"><a href="#JDBC访问数据库步骤" class="headerlink" title="JDBC访问数据库步骤"></a>JDBC访问数据库步骤</h1><p><img src="/../images/JDBC/1745323351334.png" alt="1745323351334"></p><h2 id="getConnection方法参数"><a href="#getConnection方法参数" class="headerlink" title="getConnection方法参数"></a>getConnection方法参数</h2><p><img src="/../images/JDBC/1745324040778.png" alt="1745324040778"></p><h2 id="增删改操作"><a href="#增删改操作" class="headerlink" title="增删改操作"></a>增删改操作</h2><pre><code class="java">package com.naojianghh;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class Test &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        //加载驱动        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);        //获取数据库连接        String url = &quot;jdbc:mysql://localhost/zxy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;        String usrName = &quot;root&quot;;        String passWord = &quot;root&quot;;        Connection connection = DriverManager.getConnection(url,usrName,passWord);        //创建会话        Statement statement = connection.createStatement();        //发送SQL        int i = statement.executeUpdate(&quot;insert into t_book (id,name,author,price) values (3,&#39;小黄书&#39;,&#39;郑晓羽&#39;,28)&quot;);        //处理结果        if (i &gt; 0)&#123;//证明对数据库的数据条数有影响            System.out.println(&quot;插入成功！&quot;);        &#125; else &#123;            System.out.println(&quot;插入失败！&quot;);        &#125;        //关闭资源        statement.close();        connection.close();    &#125;&#125;</code></pre><p>url : “jdbc:mysql:&#x2F;&#x2F;<code>localhost</code>（本机IP地址）&#x2F;<code>zxy</code>（数据库名）?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai&amp;allowPublicKeyRetrieval&#x3D;true”</p><p><img src="/../images/JDBC/1745324495029.png" alt="1745324495029"></p><p><img src="/../images/JDBC/1745324451974.png" alt="1745324451974"></p><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><pre><code class="java">package com.naojianghh;import java.sql.*;public class Test &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        //加载驱动        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);        //获取数据库连接        String url = &quot;jdbc:mysql://localhost/zxy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;        String usrName = &quot;root&quot;;        String passWord = &quot;root&quot;;        Connection connection = DriverManager.getConnection(url,usrName,passWord);        //创建会话        Statement statement = connection.createStatement();        //发送SQL//        int i = statement.executeUpdate(&quot;insert into t_book (id,name,author,price) values (3,&#39;小黄书&#39;,&#39;郑晓羽&#39;,28)&quot;);        ResultSet resultSet = statement.executeQuery(&quot;select * from t_book&quot;); // 返回值为结果的一个集合        //处理结果        while (resultSet.next())&#123;            System.out.println(resultSet.getInt(&quot;id&quot;) + &quot;---&quot; + resultSet.getString(&quot;name&quot;)            + &quot;---&quot; + resultSet.getString(&quot;author&quot;) + &quot;---&quot; + resultSet.getDouble(&quot;price&quot;));        &#125;//        if (i &gt; 0)&#123;//证明对数据库的数据条数有影响//            System.out.println(&quot;插入成功！&quot;);//        &#125; else &#123;//            System.out.println(&quot;插入失败！&quot;);//        &#125;        //关闭资源        statement.close();        connection.close();    &#125;&#125;</code></pre><p><img src="/../images/JDBC/1745325214314.png" alt="1745325214314"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/JDBC/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-22%20195308.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2025/04/22/MYSQL/"/>
    <id>http://example.com/2025/04/22/MYSQL/</id>
    <published>2025-04-22T04:20:34.000Z</published>
    <updated>2025-04-22T11:52:16.347Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/MYSQL/1745295711714.png" alt="1745295711714"></p><span id="more"></span><h1 id="程序交互过程"><a href="#程序交互过程" class="headerlink" title="程序交互过程"></a>程序交互过程</h1><p><img src="/../images/MYSQL/1745295733913.png" alt="1745295733913"></p><p>浏览器表示前端，后端即是服务器。</p><h1 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h1><p><img src="/../images/MYSQL/1745296002463.png" alt="1745296002463"></p><p><img src="/../images/MYSQL/1745321008374.png" alt="1745321008374"></p><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p><img src="/../images/MYSQL/1745321042517.png" alt="1745321042517"></p><h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p><img src="/../images/MYSQL/1745321138707.png" alt="1745321138707"></p><h1 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h1><p><img src="/../images/MYSQL/1745321204981.png" alt="1745321204981"></p><p><img src="/../images/MYSQL/1745321549032.png" alt="1745321549032"></p><p><img src="/../images/MYSQL/1745321597382.png" alt="1745321597382"></p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p><img src="/../images/MYSQL/1745321695915.png" alt="1745321695915"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/MYSQL/1745295711714.png&quot; alt=&quot;1745295711714&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="http://example.com/2025/04/20/XML/"/>
    <id>http://example.com/2025/04/20/XML/</id>
    <published>2025-04-20T14:09:23.000Z</published>
    <updated>2025-04-20T15:41:20.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/XML/1745158509549.png" alt="1745158509549"></p><span id="more"></span><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><img src="/../images/XML/1745158546980.png" alt="1745158546980"></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><img src="/../images/XML/1745158795883.png" alt="1745158795883"></p><h1 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h1><p>下载dom4j，并导入</p><p><img src="/../images/XML/1745162013410.png" alt="1745162013410"></p><p><img src="/../images/XML/1745161961040.png" alt="1745161961040"></p><pre><code class="java">package com.zxy.text02;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.File;import java.util.Iterator;import java.util.List;public class test &#123;    public static void main(String[] args) throws DocumentException &#123;        SAXReader sr = new SAXReader();        Document dom = sr.read(new File(&quot;src/com/zxy/text02/students.xml&quot;));        System.out.println(dom);        Element studentsEle = dom.getRootElement();        Iterator&lt;Element&gt; it1 = studentsEle.elementIterator();        while(it1.hasNext())&#123;            Element studentEle = it1.next();            List&lt;Attribute&gt; atts = studentEle.attributes();            for (Attribute a : atts)&#123;                System.out.println(&quot;该子节点的属性&quot; + a.getName() + &quot;---&quot; + a.getText());            &#125;            Iterator&lt;Element&gt; it2 = studentEle.elementIterator();            while (it2.hasNext())&#123;                Element eles = it2.next();                System.out.println(&quot;节点&quot; + eles.getName() + &quot;---&quot; + eles.getText());            &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre><p><img src="/../images/XML/1745163654986.png" alt="1745163654986"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/XML/1745158509549.png&quot; alt=&quot;1745158509549&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="xml" scheme="http://example.com/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://example.com/2025/04/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2025/04/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2025-04-20T13:13:26.000Z</published>
    <updated>2025-04-20T14:15:27.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155002448.png" alt="1745155002448"></p><span id="more"></span><h1 id="网络编程概念明晰"><a href="#网络编程概念明晰" class="headerlink" title="网络编程概念明晰"></a>网络编程概念明晰</h1><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155026178.png" alt="1745155026178"></p><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155210799.png" alt="1745155210799"></p><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155257072.png" alt="1745155257072"></p><h2 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h2><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155520221.png" alt="1745155520221"></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="java">package com.zxy.test01;import java.io.DataOutputStream;import java.io.IOException;import java.io.OutputStream;import java.net.Socket;import java.util.Arrays;public class TestClient &#123;    public static void main(String[] args) throws IOException &#123;        System.out.println(&quot;客户端启动&quot;);        //套接字：指定服务器的ip和端口号        Socket s = new Socket(&quot;10.134.42.56&quot;,8888);        //利用输出流传送数据        OutputStream os = s.getOutputStream();        DataOutputStream dos = new DataOutputStream(os);        //传送数据        dos.writeUTF(&quot;你好，服务器，我是客户端&quot;);        //流、网络资源关闭        dos.close();        os.close();        s.close();    &#125;&#125;</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre><code class="java">package com.zxy.test01;import java.io.DataInputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class TestServer &#123;    public static void main(String[] args) throws IOException &#123;        //套接字        ServerSocket ss = new ServerSocket(8888);        //等待客户端发送数据        Socket s = ss.accept();        //服务器端感受到的输入流        InputStream is = s.getInputStream();        DataInputStream dis = new DataInputStream(is);        //接收客户端发送的数据        String str = dis.readUTF();        System.out.println(str);        //流、网络资源关闭        dis.close();        is.close();        s.close();        ss.close();    &#125;&#125;</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><p>要先启动服务器，再启动客户端。</p></li><li><p>流、网络资源关闭要自下而上的关闭（先创建后关闭）。</p></li></ol><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745157361901.png" alt="1745157361901"></p><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745157375822.png" alt="1745157375822"></p><h3 id="客户端与服务器双向通信"><a href="#客户端与服务器双向通信" class="headerlink" title="客户端与服务器双向通信"></a>客户端与服务器双向通信</h3><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="java">//对服务器返回的数据做处理        InputStream is = s.getInputStream();        DataInputStream dis = new DataInputStream(is);        String str = dis.readUTF();        System.out.println(&quot;服务器对我说&quot; + str);</code></pre><h3 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h3><pre><code class="java">//服务器发送数据给客户端        OutputStream os = s.getOutputStream();        DataOutputStream dos = new DataOutputStream(os);        dos.writeUTF(&quot;你好，客户端，我接收到你的信息了&quot;);</code></pre><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745158011137.png" alt="1745158011137"></p><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745158025293.png" alt="1745158025293"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155002448.png&quot; alt=&quot;1745155002448&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库SQLite</title>
    <link href="http://example.com/2025/03/28/SQLite/"/>
    <id>http://example.com/2025/03/28/SQLite/</id>
    <published>2025-03-28T12:48:35.000Z</published>
    <updated>2025-04-04T14:55:43.090Z</updated>
    
    <content type="html"><![CDATA[<p>SQLite 数据库存储</p><span id="more"></span><h1 id="SQL基础语法"><a href="#SQL基础语法" class="headerlink" title="SQL基础语法"></a>SQL基础语法</h1><h2 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1. 数据库操作"></a>1. 数据库操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><pre><code class="sql">CREATE DATABASE database_name;</code></pre><p>示例：</p><pre><code class="sql">CREATE DATABASE testdb;</code></pre><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre><code class="sql">DROP DATABASE database_name;</code></pre><p>示例：</p><pre><code class="sql">DROP DATABASE testdb;</code></pre><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><pre><code class="sql">USE database_name;</code></pre><p>示例：</p><pre><code class="sql">USE testdb;</code></pre><h2 id="2-表操作"><a href="#2-表操作" class="headerlink" title="2. 表操作"></a>2. 表操作</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code class="sql">CREATE TABLE table_name (    column1 datatype,    column2 datatype,    column3 datatype,    ...);</code></pre><p>示例：</p><pre><code class="sql">CREATE TABLE customers (    id INT PRIMARY KEY,    name VARCHAR(255),    age INT,    email VARCHAR(255));</code></pre><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre><code class="sql">DROP TABLE table_name;</code></pre><p>示例：</p><pre><code class="sql">DROP TABLE customers;</code></pre><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><ul><li><strong>添加列</strong></li></ul><pre><code class="sql">ALTER TABLE table_nameADD column_name datatype;</code></pre><p>示例：</p><pre><code class="sql">ALTER TABLE customersADD address VARCHAR(255);</code></pre><ul><li><strong>删除列</strong></li></ul><pre><code class="sql">ALTER TABLE table_nameDROP COLUMN column_name;</code></pre><p>示例：</p><pre><code class="sql">ALTER TABLE customersDROP COLUMN address;</code></pre><h2 id="3-数据操作"><a href="#3-数据操作" class="headerlink" title="3. 数据操作"></a>3. 数据操作</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><pre><code class="sql">INSERT INTO table_name (column1, column2, column3, ...)VALUES (value1, value2, value3, ...);</code></pre><p>示例：</p><pre><code class="sql">INSERT INTO customers (id, name, age, email)VALUES (1, &#39;John Doe&#39;, 30, &#39;john@example.com&#39;);</code></pre><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><pre><code class="sql">SELECT column1, column2, ...FROM table_name;</code></pre><p>示例：</p><pre><code class="sql">SELECT id, name, ageFROM customers;</code></pre><ul><li><strong>查询所有列</strong></li></ul><pre><code class="sql">SELECT * FROM table_name;</code></pre><p>示例：</p><pre><code class="sql">SELECT * FROM customers;</code></pre><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><pre><code class="sql">UPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition;</code></pre><p>示例：</p><pre><code class="sql">UPDATE customersSET age = 31WHERE id = 1;</code></pre><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><pre><code class="sql">DELETE FROM table_nameWHERE condition;</code></pre><p>示例：</p><pre><code class="sql">DELETE FROM customersWHERE id = 1;</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/../images/SQLite/1743167022146.png" alt="1743167022146"></p><h1 id="SQLiteDatabase"><a href="#SQLiteDatabase" class="headerlink" title="SQLiteDatabase"></a>SQLiteDatabase</h1><pre><code class="java">package com.example.practice;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.database.sqlite.SQLiteDatabase;import android.os.Build;import android.os.Bundle;import android.view.View;import android.widget.TextView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import java.sql.SQLData;public class MainActivity extends AppCompatActivity &#123;    private String mDatabaseName;    private String desc = null;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        mDatabaseName = getFilesDir() + &quot;/test.db&quot;;        TextView tv = findViewById(R.id.tv);        //创建数据库        findViewById(R.id.bt1).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                SQLiteDatabase db =  openOrCreateDatabase(mDatabaseName,Context.MODE_PRIVATE,null);                desc = String.format(&quot;数据库%s创建%s&quot;,db.getPath(),(db != null) ? &quot;成功&quot;:&quot;失败&quot;);                tv.setText(desc);            &#125;        &#125;);        //删除数据库        findViewById(R.id.bt2).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                boolean result = deleteDatabase(mDatabaseName);                desc = String.format(&quot;数据库删除%s&quot;,result ? &quot;成功&quot;:&quot;失败&quot;);                tv.setText(desc);            &#125;        &#125;);    &#125;&#125;</code></pre><p><img src="/../images/SQLite/1743169364403.png" alt="1743169364403"></p><p><img src="/../images/SQLite/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-28%20214126.png"></p><p><img src="/../images/SQLite/1743169533489.png" alt="1743169533489"></p><p><img src="/../images/SQLite/1743169571765.png" alt="1743169571765"></p><h1 id="SQLiteOpenHelper"><a href="#SQLiteOpenHelper" class="headerlink" title="SQLiteOpenHelper"></a>SQLiteOpenHelper</h1><p><img src="/../images/SQLite/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-28%20214638.png"></p><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>SQLiteOpenHelper:</p><pre><code class="java">package com.example.practice.database;import android.content.ContentValues;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import androidx.annotation.NonNull;import androidx.annotation.Nullable;public class UserDataHelper extends SQLiteOpenHelper &#123;    private static final String TABLE_NAME = &quot;user_info&quot;;    private static final String DB_NAME = &quot;user.db&quot;;    private static final int DB_VERSION = 3;    private static UserDataHelper mHelper = null;    private SQLiteDatabase mRDB = null;    private SQLiteDatabase mWDB = null;   private UserDataHelper(Context context)&#123;       super(context,DB_NAME,null,DB_VERSION);   &#125;   public static UserDataHelper getInstance(Context context)&#123;       if (mHelper == null)&#123;           mHelper = new UserDataHelper(context);       &#125;       return mHelper;   &#125;   public SQLiteDatabase openReadLink()&#123;       if (mRDB == null || !mRDB.isOpen())&#123;           mRDB = mHelper.getReadableDatabase();       &#125;       return mRDB;   &#125;    public SQLiteDatabase openWriteLink()&#123;        if (mWDB == null || !mWDB.isOpen())&#123;            mWDB = mHelper.getWritableDatabase();        &#125;        return mWDB;    &#125;    public void closeLink()&#123;       if(mRDB != null &amp;&amp; mRDB.isOpen())&#123;           mRDB.close();           mRDB = null;       &#125;        if(mWDB != null &amp;&amp; mWDB.isOpen())&#123;            mWDB.close();            mWDB = null;        &#125;    &#125;    @Override    //构建一个包含name属性的表    public void onCreate(@NonNull SQLiteDatabase db) &#123;        String sql = &quot;CREATE TABLE &quot; + TABLE_NAME + &quot; (&quot; +                &quot;id INTEGER PRIMARY KEY AUTOINCREMENT, &quot; +                &quot;name TEXT);&quot;;        db.execSQL(sql);    &#125;    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;        db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_NAME);        onCreate(db);    &#125;    //添加数据    public long insert(@NonNull User user)&#123;        ContentValues values = new ContentValues();        values.put(&quot;name&quot;,user.name);        return mWDB.insert(TABLE_NAME,null,values);    &#125;&#125;</code></pre><p>SQLiteActivity</p><pre><code class="java">package com.example.practice;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.EditText;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import com.example.practice.database.User;import com.example.practice.database.UserDataHelper;public class SQLiteOpenHelperActivity extends AppCompatActivity &#123;    private EditText et_name;    private UserDataHelper mHelper;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_sqlite_open_helper);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        et_name = findViewById(R.id.et1);        //添加数据        findViewById(R.id.bt_add).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String name = et_name.getText().toString();                User user = new User(name);                if (mHelper.insert(user) &gt; 0)&#123;                    Log.d(&quot;Data&quot;, &quot;onClick: &quot; + &quot;添加成功&quot;);                &#125;            &#125;        &#125;);    &#125;    @Override    protected void onStart() &#123;        super.onStart();        mHelper = UserDataHelper.getInstance(this);        mHelper.openWriteLink();        mHelper.openReadLink();    &#125;    @Override    protected void onStop() &#123;        super.onStop();        mHelper.closeLink();    &#125;&#125;</code></pre><p><img src="/../images/SQLite/1743691657504.png" alt="1743691657504"></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><img src="/../images/SQLite/1743692517822.png" alt="1743692517822"></p><h3 id="根据名字来删除"><a href="#根据名字来删除" class="headerlink" title="根据名字来删除"></a>根据名字来删除</h3><p>SQLiteOpenHelper</p><pre><code class="java"> public long deleteByName(String name)&#123;       return mWDB.delete(TABLE_NAME,&quot;name=?&quot;,new String[]&#123;name&#125;);   &#125;</code></pre><p>Activity</p><pre><code class="java">        findViewById(R.id.bt_delete).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String name = et_name.getText().toString();                if (mHelper.deleteByName(name) &gt; 0)&#123;                    Log.d(&quot;Data&quot;, &quot;onClick: &quot; + &quot;删除成功&quot;);                &#125;            &#125;        &#125;);</code></pre><p>若要根据多个属性来删除，在<code>delete</code>的第二个参数后加上<code>and</code>，并在第三个的字符串数组参数加上相应的属性。</p><p>例如：<code>name = ? and age = ?</code></p><p>​<code>new String[]&#123;name ,age&#125;</code></p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>Activity</p><pre><code class="java">        findViewById(R.id.bt_update).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String name = et_name.getText().toString();                User user = new User(name);                if (mHelper.update(user) &gt; 0)&#123;                    Log.d(&quot;Data&quot;, &quot;onClick: &quot; + &quot;修改成功&quot;);                &#125;            &#125;        &#125;);</code></pre><p>Helper</p><pre><code class="java">   public long update(User user)&#123;       ContentValues values = new ContentValues();       values.put(&quot;name&quot;,user.name);       return mWDB.update(TABLE_NAME,values,&quot;name=?&quot;,new String[]&#123;user.name&#125;);   &#125;</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>Helper</p><pre><code class="java">   public List&lt;User&gt; queryAll()&#123;       List&lt;User&gt; userList = new ArrayList&lt;&gt;();       Cursor cursor = mRDB.query(TABLE_NAME,null,null,null,null,null,null,null);       while (cursor.moveToNext())&#123;           User user = new User();           user.name = cursor.getString(1);           userList.add(user);       &#125;       return userList;   &#125;</code></pre><p><img src="/../images/SQLite/1743694689283.png" alt="1743694689283"></p><p><img src="/../images/SQLite/1743694706444.png" alt="1743694706444"></p><p>Avtivity</p><pre><code class="java">findViewById(R.id.bt_find).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                List&lt;User&gt; list = mHelper.queryAll();                for (User u : list)&#123;                    Log.d(&quot;Data&quot;, &quot;onClick: &quot; + u.toString());                &#125;            &#125;        &#125;);</code></pre><h2 id="事务管理相关方法"><a href="#事务管理相关方法" class="headerlink" title="事务管理相关方法"></a>事务管理相关方法</h2><p><img src="/../images/SQLite/1743169560978.png" alt="1743169560978"></p><ol><li>**<code>beginTransaction()</code>**：用于开始一个事务。调用该方法后，后续对数据库的操作都将作为事务的一部分，直到事务结束。</li><li>**<code>setTransactionSuccessful()</code>**：设置事务的成功标志。在事务执行过程中，当所有操作都正确完成后，调用此方法标记事务成功。若未调用该方法，事务会在结束时自动回滚。</li><li>**<code>endTransaction()</code>**：结束事务。执行该方法时，会检查事务是否已通过<code>setTransactionSuccessful()</code>设置为成功。如果已设置成功标志，则提交事务，将事务内的操作结果持久化到数据库；若未设置成功标志，则回滚事务，撤销事务内的所有操作。</li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设在一个简单的记账应用中，有两个账户（账户 A 和账户 B），要实现从账户 A 向账户 B 转账的操作，且这两个操作需作为一个事务来确保数据一致性。代码如下：</p><pre><code class="java">// 假设已获取SQLiteDatabase实例，名为dbdb.beginTransaction(); // 开启事务try &#123;    // 从账户A扣除转账金额，假设账户A的表名为account，id为1，金额字段为balance，转账金额为transferAmount    db.execSQL(&quot;UPDATE account SET balance = balance -? WHERE id = 1&quot;, new String[]&#123;String.valueOf(transferAmount)&#125;);    // 向账户B增加转账金额，假设账户B的id为2    db.execSQL(&quot;UPDATE account SET balance = balance +? WHERE id = 2&quot;, new String[]&#123;String.valueOf(transferAmount)&#125;);    db.setTransactionSuccessful(); // 设置事务成功标志&#125; catch (Exception e) &#123;    e.printStackTrace();&#125; finally &#123;    db.endTransaction(); // 结束事务，若设置了成功标志则提交，否则回滚&#125;</code></pre><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>异常处理</strong>：在事务执行代码块中，要妥善处理可能出现的异常。一旦出现异常，通常不希望事务继续执行，避免数据不一致，如上述示例中在<code>catch</code>块捕获异常并打印堆栈信息。</li><li><strong>操作顺序</strong>：<code>setTransactionSuccessful()</code>方法需在事务执行的关键操作完成且都正确时调用，并且要在<code>endTransaction()</code>之前调用。</li><li><strong>自动提交模式</strong>：在 SQLite 中，默认情况下每个 SQL 语句都是一个自动提交的事务。但通过显式调用<code>beginTransaction()</code>等方法，可将多个 SQL 语句组合成一个事务进行处理 。</li></ul><h2 id="数据库版本升级"><a href="#数据库版本升级" class="headerlink" title="数据库版本升级"></a>数据库版本升级</h2><p>首先修改版本号</p><p>然后在<code>onUpgrade</code>中写上升级内容，例：增加两个字段</p><p><img src="/../images/SQLite/1743742365252.png" alt="1743742365252"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQLite 数据库存储&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android基础组件</title>
    <link href="http://example.com/2025/03/23/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2025/03/23/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/</id>
    <published>2025-03-23T14:12:20.000Z</published>
    <updated>2025-03-28T07:30:41.855Z</updated>
    
    <content type="html"><![CDATA[<p>Activity，Service等等。</p><span id="more"></span><h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="Activity的创建"><a href="#Activity的创建" class="headerlink" title="Activity的创建"></a>Activity的创建</h2><p>创建一个Activity需要在<code>AndroidManifest</code>里进行注册</p><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1742742015579.png" alt="1742742015579"></p><p>然后在新建的java代码页面中继承<code>AppCompatActivity</code>，并重写<code>onCreate</code>代码，</p><p>设置布局页面。</p><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1742741952400.png" alt="1742741952400"></p><h2 id="Activity的跳转"><a href="#Activity的跳转" class="headerlink" title="Activity的跳转"></a>Activity的跳转</h2><p>在布局中设置按钮并通过点击事件实现跳转。</p><pre><code class="java">public void ac1(View view) &#123;        startActivity(new Intent(this,MainActivity.class));    &#125;</code></pre><p>其中，<code>this</code>为当前页面，<code>MainActivity.class</code>为需要跳转的页面。</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><p>MainActivity</p><pre><code class="java">package com.example.practice;import android.content.Intent;import android.os.Bundle;import android.view.View;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);    &#125;    public void ac2(View view) &#123;        startActivity(new Intent(this,MainActivity2.class));    &#125;&#125;</code></pre><p>MainActivity2</p><pre><code class="java">package com.example.practice;import android.content.Intent;import android.os.Bundle;import android.view.View;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;public class MainActivity2 extends AppCompatActivity &#123;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main2);    &#125;    public void ac1(View view) &#123;        startActivity(new Intent(this,MainActivity.class));    &#125;&#125;</code></pre><p>activity_main</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;       &lt;TextView           android:layout_gravity=&quot;center_horizontal&quot;           android:gravity=&quot;center_horizontal&quot;           android:layout_width=&quot;wrap_content&quot;           android:layout_height=&quot;wrap_content&quot;           android:textSize=&quot;50dp&quot;           android:text=&quot;我是第一个Activity&quot;/&gt;        &lt;Button            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_gravity=&quot;center&quot;            android:onClick=&quot;ac2&quot;            android:text=&quot;进入&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p>activity_main2</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;我是第二个Activity&quot;            android:layout_gravity=&quot;center_horizontal&quot;            android:gravity=&quot;center_horizontal&quot;            android:textSize=&quot;50dp&quot;/&gt;        &lt;Button            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_gravity=&quot;center&quot;            android:onClick=&quot;ac1&quot;            android:text=&quot;返回&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><ol><li>启动阶段<ul><li>**onCreate()**：Activity 第一次被创建时调用，是生命周期的起点。在这个方法中，通常进行一些初始化操作，如设置布局文件（<code>setContentView</code>）、初始化成员变量、绑定事件监听器等。但要注意避免在此处执行耗时操作，否则会导致应用启动缓慢甚至卡顿。</li><li>**onStart()**：在<code>onCreate</code>之后调用，此时 Activity 对用户来说已经可见，但还未出现在前台与用户交互。可进行一些准备显示的操作，比如开始动画的准备工作。</li><li>**onResume()**：Activity 进入前台，获取到焦点，此时可以与用户进行交互。像开启传感器监听、启动动画等操作可在此处进行。</li></ul></li><li>运行阶段<ul><li>当 Activity 处于前台并与用户交互时，它处于运行状态，此时<code>onResume</code>方法已执行完毕，系统会保持其运行，直到有其他 Activity 切入或其他事件发生。</li></ul></li><li>暂停阶段<ul><li>**onPause()**：当 Activity 失去焦点，比如有新的 Activity 部分遮挡它（如弹出一个对话框）或者切换到其他应用时，该方法被调用。在这个方法中，通常要保存一些重要的状态数据，停止动画、释放一些系统资源（如关闭传感器监听）等，但不能执行耗时操作，因为只有当<code>onPause</code>执行完，新的 Activity 才会完全显示。</li></ul></li><li>停止阶段<ul><li>**onStop()**：当 Activity 完全被其他 Activity 遮挡，对用户不可见时调用。相比<code>onPause</code>，此时 Activity 对用户来说已经不可见，可执行一些更重量级的资源释放操作，如停止后台线程、关闭数据库连接等。</li></ul></li><li>销毁阶段<ul><li>**onDestroy()**：Activity 被销毁前调用，这是生命周期的终点。通常在 Activity 不再需要，或者应用退出等情况下触发。在此方法中，要确保释放所有的资源，避免内存泄漏，比如取消所有的监听器绑定、关闭文件流等。</li></ul></li><li>恢复阶段<ul><li>**onRestart()**：当 Activity 由停止状态再次启动时调用，比如用户从其他应用切换回该应用。在这个方法之后，会依次调用<code>onStart()</code>和<code>onResume()</code>，使 Activity 重新回到前台可交互状态。</li></ul></li></ol><h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><ul><li><strong>基本概念</strong>：Fragment 有自己的生命周期，可包含布局和实现逻辑，能让开发者在一个 Activity 中构建灵活多变的用户界面，实现界面模块化，提高代码复用性。比如在一个新闻类 App 中，可将文章列表、文章详情分别用不同的 Fragment 展示。</li><li><strong>生命周期</strong>：与 Activity 类似，有创建（<code>onCreate</code>）、创建视图（<code>onCreateView</code>）、视图创建完成（<code>onViewCreated</code>）、可见（<code>onResume</code>）、不可见（<code>onPause</code>）、销毁视图（<code>onDestroyView</code>）、销毁（<code>onDestroy</code>）等阶段，开发者可在这些阶段处理不同任务。</li><li><strong>与 Activity 的关系</strong>：依赖于 Activity 存在，可通过<code>getActivity()</code>获取关联的 Activity。Activity 可管理 Fragment 的添加、移除、替换等事务，使用<code>FragmentManager</code>和<code>FragmentTransaction</code>类来实现。</li><li><strong>通信方式</strong>：Fragment 之间通信可通过 Activity 作为中介、接口回调、共享 ViewModel 等方式；Fragment 与 Activity 通信则可在 Fragment 中调用 Activity 的公共方法，或通过接口让 Activity 实现相应逻辑 。</li><li><strong>使用场景</strong>：常用于开发响应式界面，在平板等大屏设备上可同时展示多个 Fragment；也适用于 Tab 布局、导航抽屉等，每个 Tab 或导航项对应一个 Fragment 。</li></ul><h2 id="在一个Activity页面中添加多个fragment"><a href="#在一个Activity页面中添加多个fragment" class="headerlink" title="在一个Activity页面中添加多个fragment"></a>在一个Activity页面中添加多个fragment</h2><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1743054636292.png" alt="1743054636292"></p><h2 id="Fragment的动态添加与管理"><a href="#Fragment的动态添加与管理" class="headerlink" title="Fragment的动态添加与管理"></a>Fragment的动态添加与管理</h2><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1743058276500.png" alt="1743058276500"></p><ul><li><strong>添加碎片</strong>：<code>add(int containerViewId, Fragment fragment)</code>，第一个参数是容器的<code>id</code>，碎片将被添加到这个容器中；第二个参数是要添加的<code>Fragment</code>实例。比如<code>transaction.add(R.id.fragment_container, new MyFragment());</code> 。</li><li><strong>替换碎片</strong>：<code>replace(int containerViewId, Fragment fragment)</code>，同样第一个参数是容器<code>id</code>，第二个是新的<code>Fragment</code>实例。它会先移除容器中已有的碎片，再添加新的碎片，如<code>transaction.replace(R.id.fragment_container, new AnotherFragment());</code> 。</li><li><strong>移除碎片</strong>：<code>remove(Fragment fragment)</code>，参数是要移除的<code>Fragment</code>实例，例如<code>transaction.remove(myFragment);</code> 。</li><li><strong>隐藏碎片</strong>：<code>hide(Fragment fragment)</code>，将指定的<code>Fragment</code>隐藏，不销毁，只是从视图中移除，<code>transaction.hide(myFragment);</code> 。</li><li><strong>显示碎片</strong>：<code>show(Fragment fragment)</code>，和<code>hide</code>对应，用于显示之前隐藏的<code>Fragment</code>，<code>transaction.show(myFragment);</code> 。</li><li><strong>提交事务</strong>：<code>commit()</code>，在完成一系列<code>Fragment</code>操作后，必须调用该方法来提交事务，让前面的操作生效。不过要注意，<code>commit()</code>必须在<code>Activity</code>的<code>onSaveInstanceState()</code>方法调用之前调用，否则可能会抛出异常。如果希望事务在未来某个时间点提交，可以使用<code>commitAllowingStateLoss()</code> 。</li><li>**addToBackStack(String name)**：将当前事务添加到返回栈中，参数<code>name</code>是给这个事务在返回栈中的命名，可<code>null</code>。添加后，用户按下返回键时，可以回退到之前的<code>Fragment</code>状态。如<code>transaction.addToBackStack(&quot;myFragmentTransaction&quot;);</code> 。</li></ul><h3 id="Fragment页面切换"><a href="#Fragment页面切换" class="headerlink" title="Fragment页面切换"></a>Fragment页面切换</h3><p>在主布局中添加Framelayout</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;FrameLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:id=&quot;@+id/framelayout&quot;/&gt;    &lt;include layout=&quot;@layout/bottom_layout&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>在相应java代码中</p><pre><code class="java">package com.example.practice;import android.os.Bundle;import android.view.View;import android.widget.Button;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentTransaction;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        Button bt1 = findViewById(R.id.bt1);        Button bt2 = findViewById(R.id.bt2);        bt1.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                replaceFragment(new BlankFragment2());            &#125;        &#125;);        bt2.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                replaceFragment(new BlankFragment1());            &#125;        &#125;);    &#125;    private void replaceFragment(Fragment fragment)&#123;        FragmentManager fragmentManager = getSupportFragmentManager();        FragmentTransaction transaction = fragmentManager.beginTransaction();        transaction.replace(R.id.framelayout,fragment);        transaction.commit();    &#125;&#125;</code></pre><h2 id="Activity与Fragment通信"><a href="#Activity与Fragment通信" class="headerlink" title="Activity与Fragment通信"></a>Activity与Fragment通信</h2><h3 id="原生方案：Bundle"><a href="#原生方案：Bundle" class="headerlink" title="原生方案：Bundle"></a>原生方案：Bundle</h3><p>在Activity相关java代码中</p><pre><code class="java">@Override            public void onClick(View v) &#123;                Bundle bundle = new Bundle();                bundle.putString(&quot;message&quot;,&quot;今天天气不错&quot;);                BlankFragment2 bf2 = new BlankFragment2();                bf2.setArguments(bundle);                replaceFragment(bf2);            &#125;</code></pre><p>在Fragment相关代码中</p><pre><code class="java"> @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        Bundle bundle = getArguments();        String string = bundle.getString(&quot;message&quot;);        Log.d(TAG, &quot;onCreate: &quot; + string);        if (getArguments() != null) &#123;            mParam1 = getArguments().getString(ARG_PARAM1);            mParam2 = getArguments().getString(ARG_PARAM2);        &#125;    &#125;</code></pre><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1743058108620.png" alt="1743058108620"></p><h3 id="java接口方案"><a href="#java接口方案" class="headerlink" title="java接口方案"></a>java接口方案</h3><p>首先定义一个接口</p><pre><code class="java">package com.example.practice;public interface IFragmentCallback &#123;    void sendMsgToActivity(String msg);    String getMsgFromActivity(String msg);&#125;</code></pre><p>在Activity实现匿名接口，并接受，发送信息</p><pre><code class="java">            public void onClick(View v) &#123;                BlankFragment2 bf2 = new BlankFragment2();                bf2.setFragmentCallback(new IFragmentCallback() &#123;                    @Override                    public void sendMsgToActivity(String msg) &#123;                        Toast.makeText(MainActivity.this,msg,Toast.LENGTH_SHORT).show();                    &#125;                    @Override                    public String getMsgFromActivity(String msg) &#123;                        return &quot;Hello,I&#39;m From Activity&quot;;                    &#125;                &#125;);                replaceFragment(bf2);            &#125;</code></pre><p>在Fragment定义一个接口</p><pre><code class="java">private IFragmentCallback fragmentCallback;</code></pre><p>在Fragment的onCreateView中接收，发出信息</p><pre><code class="java">@Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        if (root == null) &#123;            root = inflater.inflate(R.layout.fragment_blank2, container, false);        &#125;        bt3 = root.findViewById(R.id.bt3);        bt3.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                //fragmentCallback.sendMsgToActivity(&quot;Hello,I&#39;m from Fragment&quot;);                String string = fragmentCallback.getMsgFromActivity(&quot;null&quot;);                Toast.makeText(BlankFragment2.this.getContext(),string,Toast.LENGTH_SHORT).show();            &#125;        &#125;);        return root;    &#125;</code></pre><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1743070940126.png" alt="1743070940126"></p><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-27%20182931.png"></p><h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><p>eventBus，LiveData …</p><h2 id="Fragment生命周期"><a href="#Fragment生命周期" class="headerlink" title="Fragment生命周期"></a>Fragment生命周期</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/1743081017653.png" alt="1743081017653"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/1743081713305.png" alt="1743081713305"></p><ol><li><strong>关联阶段</strong>：<code>onAttach()</code>，当 Fragment 被添加到 Activity 时调用，表明 Fragment 已依附到 Activity 上，可在此接收 Activity 传递的参数并做初始化操作，比如获取 Activity 中的数据 。</li><li>创建阶段：<ul><li><code>onCreate()</code>，Fragment 被创建时调用，用于初始化一些资源，像开启线程、读取文件等，但不适合进行与 UI 相关的操作。</li><li><code>onCreateView()</code>，创建 Fragment 的布局 UI，返回一个 View 对象用于在 Activity 中显示该 Fragment。例如，通过 LayoutInflater 将布局文件转换为 View 视图并返回。</li><li><code>onViewCreated()</code>，在视图创建完成后调用，可进行与视图相关的初始化，如给视图中的控件设置监听器等。</li><li><code>onActivityCreated()</code>，在 Activity 的<code>onCreate()</code>方法执行完毕后调用，意味着 Fragment 所依附的 Activity 已初始化完成，此时可进行与 Activity 交互的 UI 操作。</li></ul></li><li>可见阶段：<ul><li><code>onStart()</code>，当 Fragment 可见时调用，此时 Fragment 已和 Activity 关联，但还未处于前台与用户交互。</li><li><code>onResume()</code>，Fragment 处于前台，能与用户交互时调用，可在此执行一些耗时操作或与用户交互相关的逻辑。</li></ul></li><li>不可见阶段：<ul><li><code>onPause()</code>，Fragment 失去焦点，即将暂停时调用，一般用于保存数据、停止动画等，不能进行耗时操作。</li><li><code>onStop()</code>，Fragment 不可见时调用，比如所在 Activity 进入停止状态或 Fragment 被移除并加入后退栈，此时可停止一些较消耗资源的操作。</li></ul></li><li>销毁阶段：<ul><li><code>onDestroyView()</code>，从 Fragment 中删除相应的 UI 界面，此时 Fragment 还未完全销毁。</li><li><code>onDestroy()</code>，Fragment 被销毁时调用，用于释放资源，如关闭线程、释放内存等。</li><li><code>onDetach()</code>，Fragment 和 Activity 解除关联时调用，表明 Fragment 已从 Activity 上分离。</li></ul></li></ol><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p><code>Service</code>是组件，需要在<code>AndroidManifest</code>中注册</p><h2 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h2><p>startService是不与Activity挂钩的，即使Activity关闭，startService也可在后台运行</p><h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><p>MainActivity3</p><pre><code class="java">package com.example.practice;import android.content.Intent;import android.os.Bundle;import android.view.View;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity3 extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main3);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);    &#125;    public void startService(View view) &#123;        startService(new Intent(this,MyService.class));    &#125;    public void stopService(View view) &#123;        stopService(new Intent(this,MyService.class));    &#125;&#125;</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity3&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        &gt;        &lt;Button            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;startService&quot;            android:onClick=&quot;startService&quot;            /&gt;        &lt;Button            android:text=&quot;stopService&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:onClick=&quot;stopService&quot;            /&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>通过 <code>startService</code> 启动服务时，其生命周期方法调用顺序为：</p><ul><li>**<code>onCreate</code>**：当服务第一次被创建时调用，用于执行一些一次性的初始化操作，比如初始化成员变量、注册广播接收器等。如果服务已经处于运行状态，再次通过 <code>startService</code> 启动时，该方法不会被重复调用。</li><li>**<code>onStartCommand</code>**：每次客户端调用 <code>startService</code> 方法启动服务时都会回调此方法。在这个方法中可以根据传入的 <code>Intent</code> 来确定服务要执行的具体任务，并且可以返回不同的结果来指示系统在服务被系统销毁后如何重启服务 。</li><li>**<code>onDestroy</code>**：当服务不再被使用且需要销毁时调用，比如调用了 <code>stopService</code> 方法，或者所在应用被完全终止等情况。在该方法中，应该释放服务持有的所有资源，如停止线程、注销监听器等。</li></ul><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1742878501499.png" alt="1742878501499"></p><h2 id="bindService"><a href="#bindService" class="headerlink" title="bindService"></a>bindService</h2><p>bindService是与Activity相挂钩的</p><h3 id="生命周期方法调用流程"><a href="#生命周期方法调用流程" class="headerlink" title="生命周期方法调用流程"></a>生命周期方法调用流程</h3><ul><li><strong>首次绑定</strong>：当客户端（如 Activity）通过<code>bindService</code>方法绑定服务时，如果服务尚未创建，系统会先调用服务的<code>onCreate</code>方法进行初始化，比如初始化成员变量、建立数据库连接等；接着调用<code>onBind</code>方法，该方法需返回一个<code>IBinder</code>接口实例，以便客户端与服务进行通信，如获取服务的运行状态或调用服务内的方法 。例如，在音乐播放服务中，可通过返回的<code>IBinder</code>获取播放控制方法。</li><li><strong>多次绑定</strong>：若同一个客户端多次调用<code>bindService</code>绑定同一个服务，<code>onCreate</code>和<code>onBind</code>方法不会再次调用，因为服务已经存在且绑定关系已建立。</li><li><strong>解除绑定</strong>：当客户端调用<code>unbindService</code>方法解除与服务的绑定时，会触发服务的<code>onUnbind</code>方法。该方法可用于处理解绑时的清理工作，如停止一些与客户端交互相关的操作。若此时没有其他客户端与该服务绑定（即所有绑定都已解除），系统会进一步调用<code>onDestroy</code>方法，标志着服务生命周期结束，在这个方法中应释放服务占用的所有资源，如停止线程、关闭文件句柄等。</li><li><strong>特殊情况（允许重绑定）</strong>：如果在<code>onUnbind</code>方法中返回<code>true</code>，表示允许服务被重绑定。当有新的客户端尝试绑定时，服务的<code>onRebind</code>方法会被调用，而不是再次调用<code>onBind</code>方法 。</li></ul><h3 id="与调用者的关系"><a href="#与调用者的关系" class="headerlink" title="与调用者的关系"></a>与调用者的关系</h3><p>绑定的服务与调用它的客户端（如 Activity）关联紧密。当客户端（如 Activity）被销毁（例如用户返回或切换应用） ，若没有解除与服务的绑定，可能会导致内存泄漏等问题。因此，通常在客户端的<code>onDestroy</code>方法中调用<code>unbindService</code>方法来解除绑定，以确保服务能正常结束生命周期。而且，若绑定服务的客户端进程意外终止（如被系统杀死），服务的<code>onUnbind</code>和<code>onDestroy</code>方法也会被调用，以清理服务资源。</p><h3 id="与startService启动方式的结合"><a href="#与startService启动方式的结合" class="headerlink" title="与startService启动方式的结合"></a>与<code>startService</code>启动方式的结合</h3><p>一个服务可以同时被<code>startService</code>和<code>bindService</code>启动。在这种情况下：</p><ul><li>服务的<code>onCreate</code>方法只会在服务首次创建时调用一次；<code>onStartCommand</code>方法会在每次通过<code>startService</code>启动服务时被调用。</li><li>服务的终止需要<code>stopService</code>和所有客户端的<code>unbindService</code>都被调用。即如果先调用<code>unbindService</code>，服务不会立即终止，直到<code>stopService</code>被调用；反之，先调用<code>stopService</code>，服务也不会终止，直到所有绑定都被解除（所有客户端调用<code>unbindService</code>或客户端进程终止） 。</li></ul><h3 id="代码实例-2"><a href="#代码实例-2" class="headerlink" title="代码实例"></a>代码实例</h3><p>Mainactivity3</p><pre><code class="java">package com.example.practice;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.view.View;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity3 extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main3);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);    &#125;    public void bindService(View view) &#123;        bindService(new Intent(this,MyService.class),connection, Context.BIND_AUTO_CREATE);    &#125;    public void unbindService(View view) &#123;        unbindService(connection);    &#125;    private ServiceConnection connection = new ServiceConnection() &#123;        @Override        public void onServiceConnected(ComponentName name, IBinder service) &#123;        &#125;        @Override        public void onServiceDisconnected(ComponentName name) &#123;        &#125;    &#125;;&#125;</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity3&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        &gt;        &lt;Button            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;bindService&quot;            android:onClick=&quot;bindService&quot;            /&gt;        &lt;Button            android:text=&quot;unbindService&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:onClick=&quot;unbindService&quot;            /&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1742897635388.png" alt="1742897635388"></p><h1 id="Receiver"><a href="#Receiver" class="headerlink" title="Receiver"></a>Receiver</h1><h2 id="静态注册接收广播"><a href="#静态注册接收广播" class="headerlink" title="静态注册接收广播"></a>静态注册接收广播</h2><p>定义一个广播接收者类</p><pre><code class="java">package com.example.practice;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.util.Log;public class CustomReceiver extends BroadcastReceiver &#123;    public String TAG = &quot;CustomReceiver&quot;;    @Override    public void onReceive(Context context, Intent intent) &#123;        if (intent.getAction() == null) &#123;            Log.d(TAG, &quot;onReceive: 未接收&quot;);        &#125;        else &#123;            Log.d(TAG, &quot;onReceive: 已接收&quot;);        &#125;    &#125;&#125;</code></pre><p>在Manifest中注册广播接收者</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;        android:fullBackupContent=&quot;@xml/backup_rules&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/Theme.Practice&quot;        tools:targetApi=&quot;31&quot;&gt;        &lt;activity            android:name=&quot;.MainActivity&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;receiver            android:exported=&quot;false&quot;            android:name=&quot;.CustomReceiver&quot;&gt;            &lt;intent-filter &gt;                &lt;action android:name=&quot;com.example.practice.receiver_flag_&quot;/&gt;            &lt;/intent-filter&gt;        &lt;/receiver&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>在MainActivity中传入Action，传入的Action要与注册的Action保持一致</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/1743140594734.png" alt="1743140594734"></p><pre><code class="java">package com.example.practice;import android.content.ComponentName;import android.content.Intent;import android.os.Bundle;import android.view.View;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);    &#125;    public void sendAction(View view) &#123;        Intent intent = new Intent();        intent.setAction(ActionUtils.ACTION_FLAG);        ComponentName componentName = new ComponentName(MainActivity.this, CustomReceiver.class);        intent.setComponent(componentName);        sendBroadcast(intent);    &#125;&#125;</code></pre><p>将其设置为显式广播</p><pre><code class="java">ComponentName componentName = new ComponentName(MainActivity.this, CustomReceiver.class);        intent.setComponent(componentName);</code></pre><h3 id="显隐式广播区别"><a href="#显隐式广播区别" class="headerlink" title="显隐式广播区别"></a>显隐式广播区别</h3><ul><li><strong>显式广播</strong>：发送广播时明确指定接收者，通过<code>Intent</code>的<code>setComponent()</code>或<code>setClass()</code>方法指定具体的组件（广播接收器类）。系统会直接将广播消息传递给指定接收者 。比如，<code>Intent intent = new Intent(); intent.setComponent(new ComponentName(&quot;com.example&quot;, &quot;com.example.MyReceiver&quot;)); sendBroadcast(intent);</code> ，这里就明确告知系统该广播由<code>com.example.MyReceiver</code>接收。</li><li><strong>隐式广播</strong>：发送广播时不指定特定接收者，而是设置广播动作（action）等信息。系统根据接收者在<code>AndroidManifest.xml</code>中注册的<code>intent - filter</code>（包含<code>action</code>等过滤条件 ），自动匹配符合条件的广播接收器来传递消息。像<code>Intent intent = new Intent(); intent.setAction(&quot;com.example.MY_ACTION&quot;); sendBroadcast(intent);</code> ，任何注册了<code>com.example.MY_ACTION</code>动作的接收器都可能收到此广播。</li></ul><h3 id="隐式广播版本限制"><a href="#隐式广播版本限制" class="headerlink" title="隐式广播版本限制"></a>隐式广播版本限制</h3><ul><li><strong>Android 8.0（API 级别 26）及以上</strong>：为提升性能和节省电量，系统对隐式广播做了诸多限制。大部分隐式广播无法被静态注册的广播接收器接收 ，仅部分系统白名单内（如<code>ACTION_BOOT_COMPLETED</code> 等少数特定广播 ）或设置特定标志的隐式广播除外。若使用静态注册方式且发送的不是此类特殊隐式广播，就会接收失败。比如，监听网络连接变化的隐式广播，在静态注册下，Android 8.0 及以上系统中可能无法被接收 。</li><li><strong>Android 12 及以上</strong>：对动态注册的广播接收器接收隐式广播进一步限制。当应用处于后台等不活跃状态时，部分隐式广播会被系统筛选掉，以增强安全性和提升性能。例如，动态注册一个监听系统事件的隐式广播接收器，在应用后台时，可能无法接收到相关广播。</li><li><strong>Android 14（API 级别 34）及以上</strong>：如果应用的<code>targetSdkVersion</code>设置为 34 及以上，隐式广播行为有更多限制。隐式<code>Intent</code>只会发送给外部组件（<code>android:exported</code>为<code>true</code> ），若广播接收器所在组件为内部组件（<code>android:exported</code>为<code>false</code> ），则无法接收隐式广播 。</li></ul><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/1743144551187.png" alt="1743144551187"></p><h2 id="动态注册接收广播"><a href="#动态注册接收广播" class="headerlink" title="动态注册接收广播"></a>动态注册接收广播</h2><pre><code class="java">UpdateIpSelectCity updateIpSelectCity = new UpdateIpSelectCity();IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(ActionUtils.ACTION_EQUES_UPDATE_IP);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) &#123;    registerReceiver(updateIpSelectCity, intentFilter, Context.RECEIVER_NOT_EXPORTED);&#125; else &#123;    registerReceiver(updateIpSelectCity, intentFilter);&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Activity，Service等等。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android基础控件</title>
    <link href="http://example.com/2025/03/21/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/"/>
    <id>http://example.com/2025/03/21/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/</id>
    <published>2025-03-21T12:39:10.000Z</published>
    <updated>2025-03-27T15:19:08.901Z</updated>
    
    <content type="html"><![CDATA[<p>TextView，Button，EditText，ImageView，listview，viewpage 等等</p><span id="more"></span><h1 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742483840121.png" alt="1742483840121"></p><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><ul><li><strong>text</strong>：用于设置 TextView 中显示的文本内容。例如：<code>android:text=&quot;Hello World&quot;</code>。</li><li><strong>textSize</strong>：设置文本的大小。可以使用<code>sp</code>（scale-independent pixel）作为单位，如<code>android:textSize=&quot;16sp&quot;</code>。</li><li><strong>textColor</strong>：用于指定文本的颜色。可以使用颜色值或颜色资源，如<code>android:textColor=&quot;#FF0000&quot;</code>表示红色。</li><li><strong>gravity</strong>：设置文本在 TextView 中的对齐方式。常见的值有<code>center</code>（居中）、<code>left</code>（左对齐）、<code>right</code>（右对齐）、<code>top</code>（顶部对齐）、<code>bottom</code>（底部对齐）等。例如：<code>android:gravity=&quot;center&quot;</code>。</li><li><strong>background</strong>：设置 TextView 的背景颜色或背景图片。如<code>android:background=&quot;#CCCCCC&quot;</code>设置背景为灰色。</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><code>setText(CharSequence text)</code>：动态设置 TextView 的文本内容。例如：<code>textView.setText(&quot;New Text&quot;);</code>。</li><li><code>getText()</code>：获取 TextView 中当前显示的文本内容。</li><li><code>setTextColor(int color)</code>：动态设置文本的颜色。例如：<code>textView.setTextColor(Color.BLUE);</code>。</li><li><code>setTextSize(float size)</code>：动态设置文本的大小。单位是<code>sp</code>，例如：<code>textView.setTextSize(18);</code>。</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>在布局文件中定义一个 TextView：</p><pre><code class="xml">&lt;TextView    android:id=&quot;@+id/textView&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;This is a TextView&quot;    android:textSize=&quot;20sp&quot;    android:textColor=&quot;#000000&quot;    android:gravity=&quot;center&quot;/&gt;</code></pre><p><strong>java获取控件对象：</strong></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742483655602.png" alt="1742483655602"></p><p>java设置的文本内容会覆盖xml设置的文本内容。</p><p>正规开发需要把文本内容，颜色写在<code>values</code>里，然后在布局中引用。</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484175236.png" alt="1742484175236"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484133492.png" alt="1742484133492"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484233819.png" alt="1742484233819"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484244902.png" alt="1742484244902"></p><h2 id="设置带阴影的TextView"><a href="#设置带阴影的TextView" class="headerlink" title="设置带阴影的TextView"></a>设置带阴影的TextView</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484345432.png" alt="1742484345432"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484487161.png" alt="1742484487161"></p><pre><code class="xml">&lt;LinearLayout       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;match_parent&quot;       android:gravity=&quot;center&quot;&gt;       &lt;TextView           android:layout_width=&quot;200dp&quot;           android:layout_height=&quot;200dp&quot;           android:gravity=&quot;center_horizontal&quot;           android:text=&quot;hello world&quot;           android:textSize=&quot;30sp&quot;           android:shadowColor=&quot;#FFFF0000&quot;           android:shadowRadius=&quot;3.0&quot;           android:shadowDx=&quot;20&quot;           android:shadowDy=&quot;20&quot;           /&gt;   &lt;/LinearLayout&gt;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742485090166.png" alt="1742485090166"></p><h2 id="实现跑马灯效果的TextView"><a href="#实现跑马灯效果的TextView" class="headerlink" title="实现跑马灯效果的TextView"></a>实现跑马灯效果的TextView</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742485123868.png" alt="1742485123868"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742486325822.png" alt="1742486325822"></p><p>java重写textview，让文本框时刻保持点击</p><pre><code class="java">package mytextview;import android.content.Context;import android.util.AttributeSet;import android.widget.TextView;import androidx.annotation.Nullable;public class MyTextView extends TextView &#123;    public MyTextView(Context context) &#123;        super(context);    &#125;    public MyTextView(Context context, @Nullable AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    @Override    public boolean isFocused() &#123;        return true;    &#125;&#125;</code></pre><p>在Layout中引用</p><pre><code class="xml"> &lt;LinearLayout       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;match_parent&quot;       android:gravity=&quot;center&quot;&gt;       &lt;mytextview.MyTextView           android:layout_width=&quot;match_parent&quot;           android:layout_height=&quot;200dp&quot;           android:gravity=&quot;center&quot;           android:text=&quot;@string/TV_one&quot;           android:textSize=&quot;30sp&quot;           android:shadowColor=&quot;#FFFF0000&quot;           android:shadowRadius=&quot;3.0&quot;           android:shadowDx=&quot;20&quot;           android:singleLine=&quot;true&quot;           android:focusable=&quot;true&quot;           android:focusableInTouchMode=&quot;true&quot;           android:ellipsize=&quot;marquee&quot;           android:marqueeRepeatLimit=&quot;marquee_forever&quot;           android:shadowDy=&quot;20&quot;           /&gt;   &lt;/LinearLayout&gt;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-21%20000059.png"></p><h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><h2 id="一、根据按钮状态改变背景形状和背景颜色"><a href="#一、根据按钮状态改变背景形状和背景颜色" class="headerlink" title="一、根据按钮状态改变背景形状和背景颜色"></a>一、根据按钮状态改变背景形状和背景颜色</h2><h3 id="1-在drawable目录下新建一个xml文件"><a href="#1-在drawable目录下新建一个xml文件" class="headerlink" title="1. 在drawable目录下新建一个xml文件"></a>1. 在drawable目录下新建一个xml文件</h3><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742562172701.png" alt="1742562172701"></p><h3 id="2-在item中设置不同的图片效果"><a href="#2-在item中设置不同的图片效果" class="headerlink" title="2. 在item中设置不同的图片效果"></a>2. 在<code>item</code>中设置不同的图片效果</h3><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742561025494.png" alt="1742561025494"></p><pre><code class="xml">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:drawable=&quot;@drawable/baseline_airplanemode_active_24&quot; android:state_pressed=&quot;true&quot;/&gt;    &lt;item android:drawable=&quot;@drawable/baseline_airport_shuttle_24&quot; /&gt;&lt;/selector&gt;</code></pre><h3 id="3-设置Button的背景属性"><a href="#3-设置Button的背景属性" class="headerlink" title="3. 设置Button的背景属性"></a>3. 设置Button的背景属性</h3><pre><code class="xml">&lt;LinearLayout       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;match_parent&quot;       android:gravity=&quot;center&quot;&gt;       &lt;Button           android:layout_width=&quot;200dp&quot;           android:layout_height=&quot;200dp&quot;           android:background=&quot;@drawable/btn_selector&quot;           &gt;       &lt;/Button&gt;   &lt;/LinearLayout&gt;</code></pre><p>未点击</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563002757.png" alt="1742563002757"></p><p>点击且未松开</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563034429.png" alt="1742563034429"></p><h2 id="二、Button事件处理"><a href="#二、Button事件处理" class="headerlink" title="二、Button事件处理"></a>二、Button事件处理</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563266418.png" alt="1742563266418"></p><h3 id="1-在Layout中给Button取个id"><a href="#1-在Layout中给Button取个id" class="headerlink" title="1. 在Layout中给Button取个id"></a>1. 在Layout中给Button取个id</h3><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563433482.png" alt="1742563433482"></p><h3 id="2-在java中获取该Button"><a href="#2-在java中获取该Button" class="headerlink" title="2. 在java中获取该Button"></a>2. 在java中获取该Button</h3><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563447999.png" alt="1742563447999"></p><h3 id="3-设置事件"><a href="#3-设置事件" class="headerlink" title="3. 设置事件"></a>3. 设置事件</h3><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563497142.png" alt="1742563497142"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563512360.png" alt="1742563512360"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563533043.png" alt="1742563533043"></p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><code>setOnClickListener(View.OnClickListener listener)</code>：为按钮设置点击事件监听器，当按钮被点击时，会触发监听器中的<code>onClick</code>方法。例如：</li></ul><pre><code class="java">button.setOnClickListener(new View.OnClickListener() &#123;    @Override    public void onClick(View v) &#123;        // 在这里编写按钮点击后的逻辑代码    &#125;&#125;);</code></pre><ul><li><code>setText(CharSequence text)</code>：动态设置按钮上显示的文本内容，如<code>button.setText(&quot;新的文本&quot;)</code>。</li><li><code>setEnabled(boolean enabled)</code>：设置按钮是否可用，<code>true</code>表示可用，<code>false</code>表示不可用。例如<code>button.setEnabled(false)</code>会使按钮变灰且无法点击。</li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><p>在布局文件中定义一个 Button：</p><pre><code class="xml">&lt;Button    android:id=&quot;@+id/button&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;点击我&quot;    android:textSize=&quot;20sp&quot;    android:textColor=&quot;#FFFFFF&quot;    android:background=&quot;#007BFF&quot; /&gt;</code></pre><p>在 Java 或 Kotlin 代码中获取并操作 Button：</p><pre><code class="java">public class MainActivity extends AppCompatActivity &#123;    private Button button;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        button = findViewById(R.id.button);        button.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                // 弹出一个Toast提示                Toast.makeText(MainActivity.this, &quot;按钮被点击了&quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;);    &#125;&#125;</code></pre><h1 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742564582585.png" alt="1742564582585"></p><h2 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h2><ol><li><strong>hint</strong>：设置输入框内的提示文本，当输入框没有内容时显示，提示用户应该输入的内容，例如<code>android:hint=&quot;请输入用户名&quot;</code>。</li><li><strong>textSize</strong>：指定输入文本的大小，单位一般为<code>sp</code>，如<code>android:textSize=&quot;16sp&quot;</code>。</li><li><strong>textColor</strong>：设置输入文本的颜色，例如<code>android:textColor=&quot;#333333&quot;</code>。</li><li><strong>background</strong>：用于设置 EditText 的背景，既可以是颜色值，也可以是一张图片。默认情况下，EditText 有一个带有边框的背景样式。如果想去掉默认背景，可以设置为<code>android:background=&quot;@null&quot;</code>。</li><li><strong>inputType</strong>：规定输入的类型，如文本、数字、密码等。例如，<code>android:inputType=&quot;textPassword&quot;</code>用于输入密码，会隐藏输入的内容；<code>android:inputType=&quot;number&quot;</code>限制只能输入数字。</li><li><strong>maxLength</strong>：限制输入的最大长度，如<code>android:maxLength=&quot;10&quot;</code>表示最多能输入 10 个字符。</li><li><strong>imeOptions</strong>：设置软键盘的一些选项，如<code>android:imeOptions=&quot;actionDone&quot;</code>，会将软键盘的 “完成” 按钮显示为 “Done”，用户点击该按钮可以完成输入。</li></ol><h2 id="EditText实例操作"><a href="#EditText实例操作" class="headerlink" title="EditText实例操作"></a>EditText实例操作</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742567980479.png" alt="1742567980479"></p><pre><code class="xml">&lt;LinearLayout       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;match_parent&quot;       android:orientation=&quot;vertical&quot;       android:gravity=&quot;center&quot;       &gt;       &lt;EditText           android:id=&quot;@+id/User&quot;           android:layout_width=&quot;350dp&quot;           android:layout_height=&quot;75dp&quot;           android:hint=&quot;请输入用户名&quot;           android:drawablePadding=&quot;10dp&quot;           android:paddingLeft=&quot;20dp&quot;           android:drawableLeft=&quot;@drawable/baseline_account_circle_24&quot;           android:background=&quot;@color/material_dynamic_secondary80&quot;/&gt;       &lt;TextView           android:layout_width=&quot;30dp&quot;           android:layout_height=&quot;30dp&quot;/&gt;       &lt;EditText           android:id=&quot;@+id/Password&quot;           android:layout_width=&quot;350dp&quot;           android:layout_height=&quot;75dp&quot;           android:hint=&quot;请输入密码&quot;           android:drawableLeft=&quot;@drawable/baseline_lock_24&quot;           android:paddingLeft=&quot;20dp&quot;           android:inputType=&quot;numberPassword&quot;           android:drawablePadding=&quot;10dp&quot;           android:background=&quot;@color/material_dynamic_secondary80&quot;/&gt;       &lt;TextView           android:layout_width=&quot;20dp&quot;           android:layout_height=&quot;20dp&quot;/&gt;       &lt;Button           android:text=&quot;登入&quot;           android:layout_width=&quot;100dp&quot;           android:layout_height=&quot;50dp&quot;           android:id=&quot;@+id/bt&quot;/&gt;   &lt;/LinearLayout&gt;</code></pre><pre><code class="kotlin">package com.example.myapplicationimport android.os.Bundleimport android.util.Logimport android.util.LogPrinterimport android.widget.Buttonimport android.widget.EditTextimport androidx.activity.enableEdgeToEdgeimport androidx.appcompat.app.AppCompatActivityimport androidx.core.view.ViewCompatimport androidx.core.view.WindowInsetsCompatimport java.util.logging.Loggerclass MainActivity : AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        enableEdgeToEdge()        setContentView(R.layout.activity_main)        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        &#125;        val et1 = findViewById&lt;EditText&gt;(R.id.User)        val et2 = findViewById&lt;EditText&gt;(R.id.Password)        val bt1 = findViewById&lt;Button&gt;(R.id.bt)        bt1.setOnClickListener &#123;            Log.e(&quot;leo&quot;,&quot;账号&quot; + et1.getText().toString())            Log.e(&quot;leo&quot;,&quot;密码&quot; + et2.getText().toString())            Log.e(&quot;leo&quot;,&quot;hhhh,你的号被我盗了&quot;)        &#125;    &#125;&#125;</code></pre><h1 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742568167500.png" alt="1742568167500"></p><h2 id="缩放类型"><a href="#缩放类型" class="headerlink" title="缩放类型"></a>缩放类型</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742568189407.png" alt="1742568189407"></p><h1 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742627014974.png" alt="1742627014974"></p><pre><code class="java">package com.example.practice;import android.os.Bundle;import android.view.View;import android.widget.ProgressBar;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    private ProgressBar pb1;    private ProgressBar pb2;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        pb1 = findViewById(R.id.pb1);        pb2 = findViewById(R.id.pb2);    &#125;    public void LeoClick(View view) &#123;        if (pb1.getVisibility() == View.GONE)&#123;            pb1.setVisibility(View.VISIBLE);        &#125;        else &#123;            pb1.setVisibility(View.GONE);        &#125;    &#125;    public void LeoClick2(View view) &#123;        int progress = pb2.getProgress();        progress += 10;        pb2.setProgress(progress);    &#125;&#125;</code></pre><pre><code class="xml">&lt;ProgressBar            android:id=&quot;@+id/pb1&quot;            android:layout_width=&quot;50dp&quot;            android:layout_height=&quot;50dp&quot;            /&gt;        &lt;Button            android:id=&quot;@+id/bt1&quot;            android:text=&quot;显示隐藏进度条&quot;            android:textSize=&quot;10dp&quot;            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot;            android:onClick=&quot;LeoClick&quot;             /&gt;        &lt;ProgressBar            android:id=&quot;@+id/pb2&quot;            android:layout_width=&quot;200dp&quot;            android:layout_height=&quot;30dp&quot;            android:max=&quot;100&quot;            style=&quot;@style/Widget.AppCompat.ProgressBar.Horizontal&quot;/&gt;        &lt;Button            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot;            android:text=&quot;模拟下载&quot;            android:textSize=&quot;10dp&quot;            android:onClick=&quot;LeoClick2&quot;/&gt;</code></pre><p><strong>代码解释</strong> ：</p><p>xml中</p><ol><li>第一个 <code>ProgressBar</code>（<code>pb1</code>）：<ul><li><code>android:id=&quot;@+id/pb1&quot;</code>：为这个进度条组件定义了一个唯一的标识符 <code>pb1</code>，方便在 Java 代码中通过这个 ID 来引用它。</li><li><code>android:layout_width=&quot;50dp&quot;</code> 和 <code>android:layout_height=&quot;50dp&quot;</code>：设置了进度条的宽度和高度都为 50 密度像素（dp）。这个进度条默认是圆形的不确定模式（因为没有设置特定的样式来改变它），用于显示操作正在进行但不明确具体进度的情况。</li></ul></li><li>第一个 <code>Button</code>（<code>bt1</code>）：<ul><li><code>android:id=&quot;@+id/bt1&quot;</code>：给按钮定义了 ID 为 <code>bt1</code>。</li><li><code>android:text=&quot;显示隐藏进度条&quot;</code>：设置按钮上显示的文本内容为 “显示隐藏进度条”。</li><li><code>android:textSize=&quot;10dp&quot;</code>：指定按钮上文本的大小为 10 密度像素。</li><li><code>android:layout_width=&quot;100dp&quot;</code> 和 <code>android:layout_height=&quot;50dp&quot;</code>：设置按钮的宽度为 100 密度像素，高度为 50 密度像素。</li><li><code>android:onClick=&quot;LeoClick&quot;</code>：指定当按钮被点击时，会调用在 <code>MainActivity</code> 中定义的名为 <code>LeoClick</code> 的方法。</li></ul></li><li>第二个 <code>ProgressBar</code>（<code>pb2</code>）：<ul><li><code>android:id=&quot;@+id/pb2&quot;</code>：定义了进度条的 ID 为 <code>pb2</code>。</li><li><code>android:layout_width=&quot;200dp&quot;</code> 和 <code>android:layout_height=&quot;30dp&quot;</code>：设置进度条的宽度为 200 密度像素，高度为 30 密度像素。</li><li><code>android:max=&quot;100&quot;</code>：设置这个进度条的最大值为 100，用于表示进度的范围。</li><li><code>style=&quot;@style/Widget.AppCompat.ProgressBar.Horizontal&quot;</code>：应用了 <code>AppCompat</code> 库中定义的水平进度条样式，使进度条以水平的形式展示进度。</li></ul></li><li>第二个 <code>Button</code>（<code>bt2</code>）：<ul><li><code>android:layout_width=&quot;100dp&quot;</code> 和 <code>android:layout_height=&quot;50dp&quot;</code>：设置按钮的宽度为 100 密度像素，高度为 50 密度像素。</li><li><code>android:text=&quot;模拟下载&quot;</code>：设置按钮上显示的文本为 “模拟下载”。</li><li><code>android:textSize=&quot;10dp&quot;</code>：指定按钮文本的大小为 10 密度像素。</li><li><code>android:onClick=&quot;LeoClick2&quot;</code>：表示当按钮被点击时，会调用 <code>MainActivity</code> 中的 <code>LeoClick2</code> 方法。</li></ul></li></ol><p>Java代码中</p><ol><li>成员变量声明：</li></ol><ul><li><code>private ProgressBar pb1;</code> 和 <code>private ProgressBar pb2;</code>：声明了两个私有类型的 <code>ProgressBar</code> 变量 <code>pb1</code> 和 <code>pb2</code>，用于在整个活动类中引用布局文件中的两个进度条组件。</li></ul><ol start="2"><li><code>LeoClick</code> 方法：</li></ol><ul><li><code>public void LeoClick(View view)</code>：定义了一个公共的方法 <code>LeoClick</code>，它接受一个 <code>View</code> 参数（这个参数通常是触发该方法的视图，在这里就是点击的按钮 <code>bt1</code>）。</li><li>方法体内部通过 <code>if-else</code> 语句判断 <code>pb1</code> 的可见性状态：如果 <code>pb1</code> 是隐藏的（<code>View.GONE</code>），就将其设置为可见（<code>View.VISIBLE</code>）；否则，将其设置为隐藏。</li></ul><ol start="3"><li><code>LeoClick2</code> 方法：</li></ol><ul><li><code>public void LeoClick2(View view)</code>：定义了一个公共的方法 <code>LeoClick2</code>，接受一个 <code>View</code> 参数（点击的按钮 <code>bt2</code>）。</li><li>在方法体中，首先获取 <code>pb2</code> 的当前进度值（<code>int progress = pb2.getProgress();</code>），然后将进度值增加 10（<code>progress += 10;</code>），最后通过 <code>pb2.setProgress(progress);</code> 将更新后的进度值设置到 <code>pb2</code> 进度条上，从而实现模拟下载进度增加的效果。</li></ul><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742628984801.png" alt="1742628984801"></p><h1 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742629608998.png" alt="1742629608998"></p><h2 id="NotificationChannel"><a href="#NotificationChannel" class="headerlink" title="NotificationChannel"></a>NotificationChannel</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742631039499.png" alt="1742631039499"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742631226236.png" alt="1742631226236"></p><h3 id="创建通知的步骤"><a href="#创建通知的步骤" class="headerlink" title="创建通知的步骤"></a>创建通知的步骤</h3><h4 id="1-创建通知渠道（Android-8-0-及以上）"><a href="#1-创建通知渠道（Android-8-0-及以上）" class="headerlink" title="1. 创建通知渠道（Android 8.0 及以上）"></a>1. 创建通知渠道（Android 8.0 及以上）</h4><p>从 Android 8.0（API 级别 26）开始，必须为通知创建渠道，以便用户对通知进行分类管理。</p><pre><code class="java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;    CharSequence name = &quot;渠道名称&quot;;    String description = &quot;渠道描述&quot;;    int importance = NotificationManager.IMPORTANCE_DEFAULT;    NotificationChannel channel = new NotificationChannel(&quot;channel_id&quot;, name, importance);    channel.setDescription(description);    NotificationManager notificationManager = getSystemService(NotificationManager.class);    notificationManager.createNotificationChannel(channel);&#125;</code></pre><h4 id="2-创建通知构建器"><a href="#2-创建通知构建器" class="headerlink" title="2. 创建通知构建器"></a>2. 创建通知构建器</h4><p>使用 <code>NotificationCompat.Builder</code> 来构建通知内容。</p><pre><code class="java">NotificationCompat.Builder builder = new NotificationCompat.Builder(this, &quot;channel_id&quot;)        .setSmallIcon(R.drawable.notification_icon)        .setContentTitle(&quot;通知标题&quot;)        .setContentText(&quot;通知内容&quot;)        .setPriority(NotificationCompat.PRIORITY_DEFAULT);</code></pre><h4 id="3-创建通知意图（可选）"><a href="#3-创建通知意图（可选）" class="headerlink" title="3. 创建通知意图（可选）"></a>3. 创建通知意图（可选）</h4><p>若希望用户点击通知后打开特定的界面，需创建 <code>PendingIntent</code>。</p><pre><code class="java">Intent intent = new Intent(this, MainActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);builder.setContentIntent(pendingIntent);</code></pre><h4 id="4-发送通知"><a href="#4-发送通知" class="headerlink" title="4. 发送通知"></a>4. 发送通知</h4><p>借助 <code>NotificationManager</code> 发送通知。</p><pre><code class="java">NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);int notificationId = 1;notificationManager.notify(notificationId, builder.build());</code></pre><h3 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h3><ul><li><strong>普通通知</strong>：显示标题、内容和小图标，是最常见的通知类型。</li><li><strong>进度通知</strong>：可显示操作进度，如文件下载进度。</li></ul><pre><code class="java">NotificationCompat.Builder builder = new NotificationCompat.Builder(this, &quot;channel_id&quot;)        .setContentTitle(&quot;文件下载&quot;)        .setContentText(&quot;正在下载...&quot;)        .setSmallIcon(R.drawable.download_icon)        .setPriority(NotificationCompat.PRIORITY_LOW)        .setProgress(100, 0, false);// 更新进度builder.setProgress(100, progress, false);notificationManager.notify(notificationId, builder.build());</code></pre><ul><li><strong>大视图通知</strong>：能显示更多内容，如长文本、图片等。</li></ul><pre><code class="java">NotificationCompat.BigTextStyle bigTextStyle = new NotificationCompat.BigTextStyle();bigTextStyle.bigText(&quot;这是一段很长的文本内容...&quot;);builder.setStyle(bigTextStyle);</code></pre><h3 id="管理通知"><a href="#管理通知" class="headerlink" title="管理通知"></a>管理通知</h3><ul><li><strong>取消通知</strong>：使用 <code>NotificationManager</code> 的 <code>cancel</code> 方法取消单个通知，或使用 <code>cancelAll</code> 方法取消所有通知。</li></ul><pre><code class="java">notificationManager.cancel(notificationId);</code></pre><ul><li><strong>更新通知</strong>：再次调用 <code>notify</code> 方法，使用相同的通知 ID 即可更新通知内容。</li></ul><pre><code class="java">builder.setContentText(&quot;更新后的通知内容&quot;);notificationManager.notify(notificationId, builder.build());</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>要实现一个通知必须要设置的三个通知内容：</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742638186444.png" alt="1742638186444"></p><p>其中小图标格式：</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-22%20180800.png"></p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><pre><code class="java">package com.example.practice;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.os.Build;import android.os.Bundle;import android.view.View;import android.widget.ProgressBar;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.NotificationCompat;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    private NotificationManager manager;    private Notification notification;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;            NotificationChannel channel = new NotificationChannel(&quot;leo&quot;, &quot;测试通知&quot;, NotificationManager.IMPORTANCE_HIGH);            manager.createNotificationChannel(channel);        &#125;        notification = new NotificationCompat.Builder(this, &quot;leo&quot;)                .setContentTitle(&quot;官方通知&quot;)                .setContentText(&quot;hello world&quot;)                .setSmallIcon(R.drawable.ic_launcher_foreground)                .build();    &#125;    public void fire_notification(View view) &#123;        manager.notify(1, notification);    &#125;    public void cancel_notification(View view) &#123;        manager.cancel(1);    &#125;&#125;</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center&quot;&gt;        &lt;Button            android:id=&quot;@+id/bt3&quot;            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot;            android:text=&quot;发起通知&quot;            android:textSize=&quot;10dp&quot;            android:onClick=&quot;fire_notification&quot;/&gt;        &lt;TextView            android:layout_width=&quot;10dp&quot;            android:layout_height=&quot;20dp&quot;/&gt;        &lt;Button            android:id=&quot;@+id/bt4&quot;            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot;            android:text=&quot;取消通知&quot;            android:textSize=&quot;10dp&quot;            android:onClick=&quot;cancel_notification&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742638439766.png" alt="1742638439766"></p><h1 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742647683114.png" alt="1742647683114"></p><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><ol><li>在布局文件中添加 Toolbar：</li></ol><pre><code class="xml">&lt;androidx.appcompat.widget.Toolbar    android:id=&quot;@+id/toolbar&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;?attr/actionBarSize&quot;    android:background=&quot;?attr/colorPrimary&quot;    android:elevation=&quot;4dp&quot;    android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt;    &lt;!-- 可以在这里添加自定义的视图或按钮 --&gt;&lt;/androidx.appcompat.widget.Toolbar&gt;</code></pre><ol start="2"><li>设置Toolbar点击事件</li></ol><pre><code class="java">tb = findViewById(R.id.tb);        tb.setNavigationOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                Log.e(&quot;leo&quot;, &quot;hello world&quot;);            &#125;        &#125;);</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742649370766.png" alt="1742649370766"></p><h1 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742649103353.png" alt="1742649103353"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742649344436.png" alt="1742649344436"></p><h2 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h2><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><pre><code class="java">package com.example.practice;import android.app.AlertDialog;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.content.DialogInterface;import android.os.Build;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.ProgressBar;import android.widget.TextView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.appcompat.widget.Toolbar;import androidx.core.app.NotificationCompat;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    private  View dialog_view;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        dialog_view = getLayoutInflater().inflate(R.layout.dialog_view, null);    &#125;    public void leoClick(View view) &#123;        AlertDialog.Builder dialog = new AlertDialog.Builder(this);        dialog.setIcon(R.mipmap.ic_launcher_round)                .setTitle(&quot;你好！！！&quot;)                .setMessage(&quot;今天天气怎么样&quot;)                .setView(dialog_view)                .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123;                    @Override                    public void onClick(DialogInterface dialog, int which) &#123;                        Log.e(&quot;leo&quot;, &quot;onClick: 点击了确定&quot;);                    &#125;                &#125;)                .setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123;                    @Override                    public void onClick(DialogInterface dialog, int which) &#123;                        Log.e(&quot;leo&quot;, &quot;onClick: 点击了取消&quot;);                    &#125;                &#125;)                .setNeutralButton(&quot;查看详细&quot;, new DialogInterface.OnClickListener() &#123;                    @Override                    public void onClick(DialogInterface dialog, int which) &#123;                        Log.e(&quot;leo&quot;, &quot;onClick: 点击了查看详细信息&quot;);                    &#125;                &#125;)                .create()                .show();    &#125;&#125;</code></pre><p><strong>注意：</strong>在链式构建dialog的时候create()，和show()的位置不能改变，因为它们的返回值不是builder。</p><h3 id="自定义布局"><a href="#自定义布局" class="headerlink" title="自定义布局"></a>自定义布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    android:gravity=&quot;center&quot;&gt;    &lt;ImageView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:src=&quot;@drawable/ic_launcher_foreground&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:gravity=&quot;center&quot;        android:text=&quot;你找到了全世界&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h3 id="主布局"><a href="#主布局" class="headerlink" title="主布局"></a>主布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;&gt;        &lt;Button            android:onClick=&quot;leoClick&quot;            android:layout_marginTop=&quot;10dp&quot;            android:textSize=&quot;10dp&quot;            android:text=&quot;显示dialog&quot;            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742651592045.png" alt="1742651592045"></p><h1 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742653749151.png" alt="1742653749151"></p><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><h3 id="java代码-1"><a href="#java代码-1" class="headerlink" title="java代码"></a>java代码</h3><pre><code class="java">package com.example.practice;import android.app.AlertDialog;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.content.DialogInterface;import android.os.Build;import android.os.Bundle;import android.util.Log;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.PopupWindow;import android.widget.ProgressBar;import android.widget.TextView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.appcompat.widget.Toolbar;import androidx.core.app.NotificationCompat;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);    &#125;    public void leoClick(View view) &#123;        View popupview = getLayoutInflater().inflate(R.layout.poppupwindow_view, null);        PopupWindow popupwindow = new PopupWindow(popupview,                ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT,true);        popupwindow.showAsDropDown(view,-300,0);        Button bt1 = popupview.findViewById(R.id.bt1);        bt1.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                Log.e(&quot;leo&quot;, &quot;onClick: 欢迎来到北京&quot;);                popupwindow.dismiss();            &#125;        &#125;);    &#125;&#125;</code></pre><p>设置是否获取焦点可以让PopupWindow在点击空白处时自动关闭</p><h3 id="PopupWindow布局"><a href="#PopupWindow布局" class="headerlink" title="PopupWindow布局"></a>PopupWindow布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    android:background=&quot;@drawable/ic_launcher_background&quot;&gt;    &lt;ImageView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:src=&quot;@drawable/ic_launcher_foreground&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:gravity=&quot;center&quot;        android:text=&quot;你找到了全世界&quot;/&gt;    &lt;Button        android:id=&quot;@+id/bt1&quot;        android:layout_marginLeft=&quot;10dp&quot;        android:text=&quot;北京&quot;        android:gravity=&quot;center&quot;        android:textSize=&quot;10dp&quot;        android:layout_width=&quot;80dp&quot;        android:layout_height=&quot;40dp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h3 id="主布局-1"><a href="#主布局-1" class="headerlink" title="主布局"></a>主布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;&gt;        &lt;Button            android:onClick=&quot;leoClick&quot;            android:layout_marginTop=&quot;10dp&quot;            android:textSize=&quot;10dp&quot;            android:text=&quot;显示Popupwindow&quot;            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot; /&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742655190094.png" alt="1742655190094"></p><h1 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742717494138.png" alt="1742717494138"></p><h2 id="代码实例（未优化）"><a href="#代码实例（未优化）" class="headerlink" title="代码实例（未优化）"></a>代码实例（未优化）</h2><h3 id="activity-main"><a href="#activity-main" class="headerlink" title="activity_main"></a>activity_main</h3><pre><code class="java">package com.example.practice;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.AdapterView;import android.widget.ListView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123;    private List&lt;Bean&gt; data = new ArrayList&lt;&gt;();    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        // 循环 100 次，创建 100 个 Bean 对象并设置其名称，然后添加到 data 列表中        for (int i = 0;i &lt; 100;i ++)&#123;            Bean bean = new Bean();            bean.setName(&quot;栏目&quot; + (i + 1));            data.add(bean);        &#125;        // 通过 findViewById 方法获取布局文件中 id 为 lv 的 ListView 实例        ListView listView = findViewById(R.id.lv);        // 为 ListView 设置适配器 MyAdapter，传入数据列表 data 和当前活动的上下文 this        listView.setAdapter(new MyAdapter(data,this));        // 为 ListView 设置项点击监听器        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;            @Override            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;                Log.e(&quot;zxy&quot;, &quot;onItemClick: &quot; + position );            &#125;        &#125;);    &#125;&#125;</code></pre><h3 id="MyAdapter"><a href="#MyAdapter" class="headerlink" title="MyAdapter"></a>MyAdapter</h3><pre><code class="java">package com.example.practice;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.TextView;import java.util.List;public class MyAdapter extends BaseAdapter &#123;    // 声明一个用于存储数据的 List，泛型为 Bean 类型    private List&lt;Bean&gt; data;    // 声明一个 Context 对象，用于获取系统资源等    private Context context;    // 构造函数，传入数据列表 data 和上下文 context    public MyAdapter(List&lt;Bean&gt; data,Context context) &#123;        this.context = context;        this.data = data;    &#125;    // 获取数据列表的大小，即列表项的数量    @Override    public int getCount() &#123;        return data.size();    &#125;    // 获取指定位置的列表项对象，这里返回 null（可能需要根据实际情况修改）    @Override    public Object getItem(int position) &#123;        return null;    &#125;    // 获取指定位置的列表项的唯一标识，这里简单返回位置索引    @Override    public long getItemId(int position) &#123;        return position;    &#125;    // 获取每个列表项的视图    @Override    public View getView(int position, View convertView, ViewGroup parent) &#123;        // 如果 convertView 为空，说明是第一次创建该列表项视图        if (convertView == null) &#123;            // 使用 LayoutInflater 从 context 中加载 list_item.xml 布局文件，并将其转换为视图对象            convertView = LayoutInflater.from(context).inflate(R.layout.list_item, parent, false);        &#125;        // 在 convertView 中找到 id 为 tv 的 TextView 实例        TextView textView = convertView.findViewById(R.id.tv);        // 设置 TextView 的文本为 data 列表中指定位置的 Bean 对象的名称        textView.setText(data.get(position).getName());        return convertView;    &#125;&#125;</code></pre><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><pre><code class="java">package com.example.practice;public class Bean &#123;    String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;</code></pre><h3 id="主布局-2"><a href="#主布局-2" class="headerlink" title="主布局"></a>主布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;       &lt;ListView           android:layout_width=&quot;match_parent&quot;           android:layout_height=&quot;match_parent&quot;           android:id=&quot;@+id/lv&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><h3 id="item布局"><a href="#item布局" class="headerlink" title="item布局"></a>item布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:id=&quot;@+id/tv&quot;        android:textSize=&quot;30sp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><h3 id="MyAdapter-1"><a href="#MyAdapter-1" class="headerlink" title="MyAdapter"></a>MyAdapter</h3><pre><code class="java">package com.example.practice;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.TextView;import java.util.List;public class MyAdapter extends BaseAdapter &#123;    private List&lt;Bean&gt; data;    private Context context;    public MyAdapter(List&lt;Bean&gt; data,Context context) &#123;        this.context = context;        this.data = data;    &#125;    @Override    public int getCount() &#123;        return data.size();    &#125;    @Override    public Object getItem(int position) &#123;        return null;    &#125;    @Override    public long getItemId(int position) &#123;        return position;    &#125;    @Override    public View getView(int position, View convertView, ViewGroup parent) &#123;        ViewHolder viewHolder;        if (convertView == null) &#123;            viewHolder = new ViewHolder();            convertView = LayoutInflater.from(context).inflate(R.layout.list_item, parent, false);            viewHolder.textView = convertView.findViewById(R.id.tv);            convertView.setTag(viewHolder);        &#125;        else &#123;            viewHolder = (ViewHolder) convertView.getTag();        &#125;        viewHolder.textView.setText(data.get(position).getName());        return convertView;    &#125;    private final class ViewHolder &#123;        TextView textView;    &#125;&#125;</code></pre><h1 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h1><p>使用前要导入recyclerview依赖包</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742718997143.png" alt="1742718997143"></p><h2 id="代码实例-2"><a href="#代码实例-2" class="headerlink" title="代码实例"></a>代码实例</h2><h3 id="activity-main-1"><a href="#activity-main-1" class="headerlink" title="activity_main"></a>activity_main</h3><pre><code class="java">package com.example.practice;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.AdapterView;import android.widget.LinearLayout;import android.widget.ListView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import androidx.recyclerview.widget.GridLayoutManager;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123;    private List&lt;Bean&gt; data = new ArrayList&lt;&gt;();    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        for (int i = 0;i &lt; 100;i ++)&#123;            Bean bean = new Bean();            bean.setName(&quot;栏目&quot; + (i + 1));            data.add(bean);        &#125;        RecyclerView recyclerView = findViewById(R.id.rv);      LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this);      recyclerView.setLayoutManager(linearLayoutManager);//        GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 2);//        recyclerView.setLayoutManager(gridLayoutManager);        MyAdapter myAdapter = new MyAdapter(data,this);        recyclerView.setAdapter(myAdapter);        myAdapter.setRecyclerItemClickListener(new MyAdapter.OnRecyclerItemClickListener() &#123;            @Override            public void onRecyclerItemClick(int position) &#123;                Log.e(&quot;zxy&quot;, &quot;onRecyclerItemClick: &quot; + position );            &#125;        &#125;);    &#125;&#125;</code></pre><h3 id="MyAdapter-2"><a href="#MyAdapter-2" class="headerlink" title="MyAdapter"></a>MyAdapter</h3><pre><code class="java">package com.example.practice;import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import java.util.List;public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123;    private  List&lt;Bean&gt; data;    private  Context context;    public MyAdapter(List&lt;Bean&gt; data,Context context) &#123;        this.context = context;        this.data = data;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = View.inflate(context,R.layout.list_item,null);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.tv.setText(data.get(position).getName());    &#125;    @Override    public int getItemCount() &#123;        return data == null ? 0 : data.size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private TextView tv;        public MyViewHolder(@NonNull View itemView)&#123;            super(itemView);            tv = itemView.findViewById(R.id.tv1);            itemView.setOnClickListener(new View.OnClickListener() &#123;                @Override                public void onClick(View v) &#123;                    if (mOnItemClickListener != null)&#123;                        mOnItemClickListener.onRecyclerItemClick(getAdapterPosition());                    &#125;                &#125;            &#125;);        &#125;    &#125;    private OnRecyclerItemClickListener mOnItemClickListener;    public void setRecyclerItemClickListener(OnRecyclerItemClickListener listener)&#123;        mOnItemClickListener = listener;    &#125;    public interface OnRecyclerItemClickListener &#123;        void onRecyclerItemClick(int position);    &#125;&#125;</code></pre><h3 id="主布局-3"><a href="#主布局-3" class="headerlink" title="主布局"></a>主布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;       &lt;androidx.recyclerview.widget.RecyclerView           android:layout_width=&quot;match_parent&quot;           android:layout_height=&quot;match_parent&quot;           android:id=&quot;@+id/rv&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><h3 id="item布局-1"><a href="#item布局-1" class="headerlink" title="item布局"></a>item布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:id=&quot;@+id/tv&quot;        android:orientation=&quot;vertical&quot;&gt;        &lt;ImageView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:src=&quot;@drawable/ic_launcher_foreground&quot;/&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:id=&quot;@+id/tv1&quot;            android:gravity=&quot;center&quot;            android:layout_gravity=&quot;center&quot;            android:textSize=&quot;30sp&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;</code></pre><h4 id="其中"><a href="#其中" class="headerlink" title="其中"></a>其中</h4><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742737925025.png" alt="1742737925025"></p><p>可以通过更换<code>Manager</code>来变换<code>RecyclerView</code>的布局</p><p>例如：</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742738011458.png" alt="1742738011458"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742738022538.png" alt="1742738022538"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742738052712.png" alt="1742738052712"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742738073741.png" alt="1742738073741"></p><h1 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1743053322919.png" alt="1743053322919"></p><h2 id="代码实例-3"><a href="#代码实例-3" class="headerlink" title="代码实例"></a>代码实例</h2><h3 id="主布局-4"><a href="#主布局-4" class="headerlink" title="主布局"></a>主布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;androidx.viewpager.widget.ViewPager        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:id=&quot;@+id/vp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h3 id="main-java"><a href="#main-java" class="headerlink" title="main_java"></a>main_java</h3><pre><code class="java">package com.example.practice;import android.content.Intent;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import androidx.viewpager.widget.ViewPager;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123;    private ViewPager viewPager;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        LayoutInflater lf = getLayoutInflater().from(this);        View view1 = lf.inflate(R.layout.layout1,null);        View view2 = lf.inflate(R.layout.layout2,null);        View view3 = lf.inflate(R.layout.layout3,null);        List&lt;View&gt; viewList = new ArrayList&lt;&gt;();        viewList.add(view1);        viewList.add(view2);        viewList.add(view3);        MyAdapter myAdapter = new MyAdapter(viewList);        viewPager = findViewById(R.id.vp);        viewPager.setAdapter(myAdapter);    &#125;&#125;</code></pre><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><pre><code class="java">package com.example.practice;import android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.viewpager.widget.PagerAdapter;import java.util.List;public class MyAdapter extends PagerAdapter &#123;    private List&lt;View&gt; mListView;    public MyAdapter(List&lt;View&gt; mListView) &#123;        this.mListView = mListView;    &#125;    @NonNull    @Override    public Object instantiateItem(@NonNull ViewGroup container, int position) &#123;        container.addView(mListView.get(position), 0);        return mListView.get(position);    &#125;    @Override    public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123;        container.removeView(mListView.get(position));    &#125;    @Override    public int getCount() &#123;        return mListView.size();    &#125;    @Override    public boolean isViewFromObject(@NonNull View view, @NonNull Object object) &#123;        return view == object;    &#125;&#125;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1743054423130.png" alt="1743054423130"></p><h1 id="ViewPager2"><a href="#ViewPager2" class="headerlink" title="ViewPager2"></a>ViewPager2</h1><p><code>main_java</code></p><pre><code class="java">package com.example.practice;import android.os.Bundle;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import androidx.viewpager2.widget.ViewPager2;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        ViewPager2 viewPager = findViewById(R.id.vp);        List&lt;String&gt; titles = new ArrayList&lt;&gt;();        titles.add(&quot;热点&quot;);        titles.add(&quot;推荐&quot;);        titles.add(&quot;影视&quot;);        titles.add(&quot;音乐&quot;);        ViewPagerAdapter viewPagerAdapter = new ViewPagerAdapter(titles);        viewPager.setAdapter(viewPagerAdapter);    &#125;&#125;</code></pre><p>适配器</p><pre><code class="java">package com.example.practice;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import java.util.ArrayList;import java.util.List;public class ViewPagerAdapter extends RecyclerView.Adapter&lt;ViewPagerAdapter.ViewPagerViewHolder&gt; &#123;    private List&lt;String&gt; titles = new ArrayList&lt;&gt;();    public ViewPagerAdapter(List&lt;String&gt; titles) &#123;        this.titles = titles;    &#125;    @NonNull    @Override    public ViewPagerViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        return new ViewPagerViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_pager,parent,false));    &#125;    @Override    public void onBindViewHolder(@NonNull ViewPagerViewHolder holder, int position) &#123;        holder.mTv.setText(titles.get(position));    &#125;    @Override    public int getItemCount() &#123;        return titles.size();    &#125;    class ViewPagerViewHolder extends RecyclerView.ViewHolder &#123;        TextView mTv;        LinearLayout mContainer;        public ViewPagerViewHolder(@NonNull View itemView) &#123;            super(itemView);            mContainer = itemView.findViewById(R.id.ly);            mTv = itemView.findViewById(R.id.tvTitle);        &#125;    &#125;&#125;</code></pre><p>主布局</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;androidx.viewpager2.widget.ViewPager2        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:id=&quot;@+id/vp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><p>item布局</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:id=&quot;@+id/ly&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tvTitle&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center&quot;        android:gravity=&quot;center&quot;        android:text=&quot;Hello World&quot;        android:textColor=&quot;#ff4532&quot;        android:textSize=&quot;32dp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="ViewPager2-Fragment"><a href="#ViewPager2-Fragment" class="headerlink" title="ViewPager2 + Fragment"></a>ViewPager2 + Fragment</h2><p>在<code>main_java</code>中</p><pre><code class="java">private ViewPager2 viewPager;private void initPager()&#123;        viewPager = findViewById(R.id.viewpager);        ArrayList&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;();        fragments.add(BlankFragment.newInstance(&quot;热点&quot;));        fragments.add(BlankFragment.newInstance(&quot;推荐&quot;));        fragments.add(BlankFragment.newInstance(&quot;直播&quot;));        fragments.add(BlankFragment.newInstance(&quot;动画&quot;));        fragments.add(BlankFragment.newInstance(&quot;影视&quot;));        MyFragmentPagerAdapter pagerAdapter = new MyFragmentPagerAdapter(getSupportFragmentManager(), getLifecycle(),fragments);        viewPager.setAdapter(pagerAdapter);        viewPager.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() &#123;            @Override            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;                super.onPageScrolled(position, positionOffset, positionOffsetPixels);            &#125;            @Override            public void onPageSelected(int position) &#123;                super.onPageSelected(position);            &#125;            @Override            public void onPageScrollStateChanged(int state) &#123;                super.onPageScrollStateChanged(state);            &#125;        &#125;);    &#125;</code></pre><p><code>MyFragmentPagerAdapter</code>适配器</p><pre><code class="java">package com.example.bilibili;import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentPagerAdapter;import androidx.fragment.app.FragmentStatePagerAdapter;import androidx.fragment.app.ListFragment;import androidx.lifecycle.Lifecycle;import androidx.viewpager2.adapter.FragmentStateAdapter;import java.util.ArrayList;import java.util.List;public class MyFragmentPagerAdapter extends FragmentStateAdapter &#123;    List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;();    public MyFragmentPagerAdapter(@NonNull FragmentManager fragmentManager, @NonNull Lifecycle lifecycle,List&lt;Fragment&gt; fragments) &#123;        super(fragmentManager, lifecycle);        fragmentList = fragments;    &#125;    @NonNull    @Override    public Fragment createFragment(int position) &#123;        return fragmentList.get(position);    &#125;    @Override    public int getItemCount() &#123;        return fragmentList.size();    &#125;&#125;</code></pre><p><code>BlankFragment</code>空白Fragment</p><pre><code class="java">package MyFragment;import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import com.example.bilibili.R;public class BlankFragment extends Fragment &#123;        private static final String ARG_TEXT = &quot;param1&quot;;    private String mTextString;    View rootView;    public BlankFragment() &#123;    &#125;        public static BlankFragment newInstance(String param1) &#123;        BlankFragment fragment = new BlankFragment();        Bundle args = new Bundle();        args.putString(ARG_TEXT, param1);        fragment.setArguments(args);        return fragment;    &#125;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        if (getArguments() != null) &#123;            mTextString = getArguments().getString(ARG_TEXT);        &#125;    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        if (rootView == null) &#123;            rootView = inflater.inflate(R.layout.fragment_blank, container, false);        &#125;        initView();        return rootView;    &#125;    private void initView() &#123;        TextView textView = rootView.findViewById(R.id.text);        textView.setText(mTextString);    &#125;&#125;</code></pre><p>主布局加入<code>ViewPaper2</code>控件</p><pre><code class="xml">&lt;androidx.viewpager2.widget.ViewPager2        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:id=&quot;@+id/viewpager&quot;/&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;TextView，Button，EditText，ImageView，listview，viewpage 等等&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android基本布局方式</title>
    <link href="http://example.com/2025/03/20/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2025/03/20/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</id>
    <published>2025-03-20T13:18:57.000Z</published>
    <updated>2025-03-23T07:26:41.611Z</updated>
    
    <content type="html"><![CDATA[<p>线性布局，相对布局，流式布局，表格布局。</p><span id="more"></span><h1 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h1><p><code>xml</code>注释：</p><p><img src="/../images/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/1742479184047.png" alt="1742479184047"></p><pre><code class="xml">&lt;!-- 注释内容 --&gt;</code></pre><p>**<code>wrap_content</code>**： <code>wrap_content</code> 表示视图的宽度或高度会根据其内容的大小自动调整，也就是视图会刚好包裹住其内部的内容，不多占用额外的空间。 </p><p> **<code>match_parent</code>**：<code>match_parent</code> 表示视图的宽度或高度会扩展至其父视图所允许的最大空间。也就是说，该视图会填充其父视图剩余的可用空间。 </p><h2 id="自闭合标签合普通闭合标签"><a href="#自闭合标签合普通闭合标签" class="headerlink" title="自闭合标签合普通闭合标签"></a>自闭合标签合普通闭合标签</h2><h3 id="自闭合标签"><a href="#自闭合标签" class="headerlink" title="自闭合标签"></a>自闭合标签</h3><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><p>自闭合标签以 <code>&lt;</code> 开始，标签名和属性紧跟其后，最后以 <code>/&gt;</code> 结束。示例如下：</p><pre><code class="xml">&lt;ImageView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:src=&quot;@drawable/my_image&quot; /&gt;</code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>简洁性</strong>：自闭合标签的写法简洁明了，能让代码更加紧凑，减少不必要的字符，使布局文件更易读。</li><li><strong>无嵌套内容</strong>：自闭合标签不能包含子元素，它只用于定义单个的视图组件，如 <code>ImageView</code>、<code>EditText</code> 等。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>单一视图组件</strong>：适用于那些不需要嵌套子元素的视图组件，如展示图片的 <code>ImageView</code>、输入文本的 <code>EditText</code>、显示文本的 <code>TextView</code> 等。</li></ul><h3 id="普通闭合标签"><a href="#普通闭合标签" class="headerlink" title="普通闭合标签"></a>普通闭合标签</h3><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><p>普通闭合标签由开始标签 <code>&lt;标签名 属性&gt;</code> 和结束标签 &#96;&#96; 组成，中间可以包含子元素。示例如下：</p><pre><code class="xml">&lt;LinearLayout    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;这是一个文本视图&quot; /&gt;    &lt;Button        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;这是一个按钮&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>可嵌套内容</strong>：普通闭合标签的主要特点是可以包含一个或多个子元素，用于创建复杂的布局结构。</li><li><strong>结构清晰</strong>：使用普通闭合标签可以清晰地展示布局的层次结构，方便开发者理解和维护代码。</li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>布局容器</strong>：常用于布局容器类组件，如 <code>LinearLayout</code>、<code>RelativeLayout</code>、<code>FrameLayout</code> 等，这些组件需要包含多个子视图来实现复杂的布局。</li><li><strong>自定义组件</strong>：当创建自定义的复合组件时，也会使用普通闭合标签，将多个子视图组合在一起形成一个新的组件。</li></ul><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul><li><strong>嵌套能力</strong>：自闭合标签不能包含子元素，而普通闭合标签可以包含一个或多个子元素，用于构建复杂的布局结构。</li><li><strong>语法结构</strong>：自闭合标签以 <code>/&gt;</code> 结束，语法简洁；普通闭合标签由开始标签和结束标签组成，结构相对复杂，但能清晰展示布局的层次关系。</li><li><strong>使用场景</strong>：自闭合标签适用于单一的视图组件，而普通闭合标签主要用于布局容器和自定义组件。</li></ul><h1 id="线性布局-LinearLayout"><a href="#线性布局-LinearLayout" class="headerlink" title="线性布局(LinearLayout)"></a>线性布局(LinearLayout)</h1><p> 在安卓开发里，线性布局（<code>LinearLayout</code>）是常用的布局方式，它能让子视图按水平或者垂直方向排列。 </p><h2 id="1-线性布局的基本属性"><a href="#1-线性布局的基本属性" class="headerlink" title="1. 线性布局的基本属性"></a>1. 线性布局的基本属性</h2><p><img src="/../images/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/1742655631006.png" alt="1742655631006"></p><ul><li>**<code>android:orientation</code>**：此属性用于指定布局方向，有 <code>horizontal</code>（水平方向）和 <code>vertical</code>（垂直方向）两个可选值。</li><li>**<code>android:gravity</code>**：该属性用于设置子视图在布局中的对齐方式，例如 <code>center</code>（居中）、<code>left</code>（居左）、<code>right</code>（居右）等。</li><li>**<code>android:layout_gravity</code>**：此属性用于设置当前视图在其父布局中的对齐方式。</li><li>**<code>android:layout_weight</code>**：这是一个重要属性，可用于分配剩余空间。数值越大，分配到的剩余空间就越多。</li></ul><h2 id="2-在-XML-中使用线性布局"><a href="#2-在-XML-中使用线性布局" class="headerlink" title="2. 在 XML 中使用线性布局"></a>2. 在 XML 中使用线性布局</h2><h3 id="水平线性布局示例"><a href="#水平线性布局示例" class="headerlink" title="水平线性布局示例"></a>水平线性布局示例</h3><pre><code class="xml">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    android:gravity=&quot;center&quot;&gt;    &lt;Button        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;按钮1&quot; /&gt;    &lt;Button        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;按钮2&quot; /&gt;    &lt;Button        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;按钮3&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>在上述代码中，<code>LinearLayout</code> 的 <code>orientation</code> 属性被设置为 <code>horizontal</code>，这意味着子视图会按水平方向排列。<code>gravity</code> 属性设置为 <code>center</code>，使子视图在布局中居中显示。</p><h3 id="垂直线性布局示例"><a href="#垂直线性布局示例" class="headerlink" title="垂直线性布局示例"></a>垂直线性布局示例</h3><pre><code class="xml">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:gravity=&quot;center&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;文本1&quot; /&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;文本2&quot; /&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;文本3&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>这里 <code>LinearLayout</code> 的 <code>orientation</code> 属性设置为 <code>vertical</code>，子视图会按垂直方向排列。</p><h3 id="线性布局中的权重"><a href="#线性布局中的权重" class="headerlink" title="线性布局中的权重"></a>线性布局中的权重</h3><h4 id="使用-layout-weight-分配空间示例"><a href="#使用-layout-weight-分配空间示例" class="headerlink" title="使用 layout_weight 分配空间示例"></a>使用 <code>layout_weight</code> 分配空间示例</h4><pre><code class="xml">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;&gt;    &lt;Button        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_weight=&quot;1&quot;        android:text=&quot;按钮1&quot; /&gt;    &lt;Button        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_weight=&quot;2&quot;        android:text=&quot;按钮2&quot; /&gt;    &lt;Button        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_weight=&quot;1&quot;        android:text=&quot;按钮3&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>在这个例子中，<code>layout_width</code> 被设置为 <code>0dp</code>，通过 <code>layout_weight</code> 来分配水平方向的剩余空间。<code>按钮2</code> 的 <code>layout_weight</code> 为 2，它会占据的水平空间是 <code>按钮1</code> 和 <code>按钮3</code> 的两倍。</p><h1 id="相对布局-RelativeLayout"><a href="#相对布局-RelativeLayout" class="headerlink" title="相对布局( RelativeLayout )"></a>相对布局( RelativeLayout )</h1><p> 在 Android 开发中，相对布局（<code>RelativeLayout</code>）是一种强大且常用的布局方式，它允许子视图根据其他视图或父容器的位置来确定自身位置。 </p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>灵活性高</strong>：子视图的位置可以根据其他视图或父容器的相对位置进行调整，能实现复杂的布局效果。</li><li><strong>减少嵌套</strong>：相较于线性布局等，相对布局可以减少布局的嵌套层级，提高布局性能。</li></ul><h2 id="常用属性及作用"><a href="#常用属性及作用" class="headerlink" title="常用属性及作用"></a>常用属性及作用</h2><p><img src="/../images/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/1742655694059.png" alt="1742655694059"></p><h3 id="相对于父容器的定位属性"><a href="#相对于父容器的定位属性" class="headerlink" title="相对于父容器的定位属性"></a>相对于父容器的定位属性</h3><ul><li>**<code>android:layout_alignParentTop</code>**：值为 <code>true</code> 时，视图会与父容器的顶部对齐。</li><li>**<code>android:layout_alignParentBottom</code>**：值为 <code>true</code> 时，视图会与父容器的底部对齐。</li><li>**<code>android:layout_alignParentLeft</code>**：值为 <code>true</code> 时，视图会与父容器的左侧对齐。</li><li>**<code>android:layout_alignParentRight</code>**：值为 <code>true</code> 时，视图会与父容器的右侧对齐。</li><li>**<code>android:layout_centerInParent</code>**：值为 <code>true</code> 时，视图会在父容器中居中显示。</li><li>**<code>android:layout_centerHorizontal</code>**：值为 <code>true</code> 时，视图会在父容器中水平居中。</li><li>**<code>android:layout_centerVertical</code>**：值为 <code>true</code> 时，视图会在父容器中垂直居中。</li></ul><h3 id="相对于其他视图的定位属性"><a href="#相对于其他视图的定位属性" class="headerlink" title="相对于其他视图的定位属性"></a>相对于其他视图的定位属性</h3><ul><li>**<code>android:layout_above</code>**：指定视图位于另一个视图的上方，值为另一个视图的 <code>id</code>。</li><li>**<code>android:layout_below</code>**：指定视图位于另一个视图的下方，值为另一个视图的 <code>id</code>。</li><li>**<code>android:layout_toLeftOf</code>**：指定视图位于另一个视图的左侧，值为另一个视图的 <code>id</code>。</li><li>**<code>android:layout_toRightOf</code>**：指定视图位于另一个视图的右侧，值为另一个视图的 <code>id</code>。</li><li>**<code>android:layout_alignTop</code>**：指定视图的顶部与另一个视图的顶部对齐，值为另一个视图的 <code>id</code>。</li><li>**<code>android:layout_alignBottom</code>**：指定视图的底部与另一个视图的底部对齐，值为另一个视图的 <code>id</code>。</li><li>**<code>android:layout_alignLeft</code>**：指定视图的左侧与另一个视图的左侧对齐，值为另一个视图的 <code>id</code>。</li><li>**<code>android:layout_alignRight</code>**：指定视图的右侧与另一个视图的右侧对齐，值为另一个视图的 <code>id</code>。</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><pre><code class="xml">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;Button        android:id=&quot;@+id/button1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;按钮1&quot;        android:layout_alignParentTop=&quot;true&quot;        android:layout_alignParentLeft=&quot;true&quot; /&gt;    &lt;Button        android:id=&quot;@+id/button2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;按钮2&quot;        android:layout_below=&quot;@id/button1&quot;        android:layout_alignLeft=&quot;@id/button1&quot; /&gt;    &lt;Button        android:id=&quot;@+id/button3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;按钮3&quot;        android:layout_alignParentTop=&quot;true&quot;        android:layout_alignParentRight=&quot;true&quot; /&gt;    &lt;Button        android:id=&quot;@+id/button4&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;按钮4&quot;        android:layout_below=&quot;@id/button3&quot;        android:layout_alignRight=&quot;@id/button3&quot; /&gt;    &lt;Button        android:id=&quot;@+id/button5&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;按钮5&quot;        android:layout_centerInParent=&quot;true&quot; /&gt;&lt;/RelativeLayout&gt;</code></pre><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><ul><li><strong>按钮 1</strong>：通过 <code>android:layout_alignParentTop=&quot;true&quot;</code> 和 <code>android:layout_alignParentLeft=&quot;true&quot;</code> 使其位于父容器的左上角。</li><li><strong>按钮 2</strong>：使用 <code>android:layout_below=&quot;@id/button1&quot;</code> 和 <code>android:layout_alignLeft=&quot;@id/button1&quot;</code>，让按钮 2 位于按钮 1 的下方且左侧对齐。</li><li><strong>按钮 3</strong>：利用 <code>android:layout_alignParentTop=&quot;true&quot;</code> 和 <code>android:layout_alignParentRight=&quot;true&quot;</code> 使其处于父容器的右上角。</li><li><strong>按钮 4</strong>：通过 <code>android:layout_below=&quot;@id/button3&quot;</code> 和 <code>android:layout_alignRight=&quot;@id/button3&quot;</code>，让按钮 4 位于按钮 3 的下方且右侧对齐。</li><li><strong>按钮 5</strong>：使用 <code>android:layout_centerInParent=&quot;true&quot;</code> 使按钮 5 在父容器中居中显示。</li></ul><h1 id="流式布局-FlowLayout"><a href="#流式布局-FlowLayout" class="headerlink" title="流式布局(FlowLayout)"></a>流式布局(FlowLayout)</h1><p> 在 Android 开发中，流式布局（FlowLayout）并非 Android 系统自带的布局，它是一种自定义布局，常用于实现类似标签云、关键词排列等需要自动换行的布局效果。 </p><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>自动换行</strong>：当子视图的总宽度超过布局的可用宽度时，会自动将剩余的子视图排列到下一行，使布局更加灵活。</li><li><strong>自适应子视图大小</strong>：能够根据子视图的大小自动调整布局，保证子视图合理排列。</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="自定义流式布局类"><a href="#自定义流式布局类" class="headerlink" title="自定义流式布局类"></a>自定义流式布局类</h3><p>以下是一个简单的自定义流式布局的实现代码：</p><pre><code class="java">import android.content.Context;import android.util.AttributeSet;import android.view.View;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;public class FlowLayout extends ViewGroup &#123;    private List&lt;List&lt;View&gt;&gt; mAllViews = new ArrayList&lt;&gt;();    private List&lt;Integer&gt; mLineHeight = new ArrayList&lt;&gt;();    public FlowLayout(Context context) &#123;        this(context, null);    &#125;    public FlowLayout(Context context, AttributeSet attrs) &#123;        this(context, attrs, 0);    &#125;    public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;        int sizeWidth = MeasureSpec.getSize(widthMeasureSpec);        int modeWidth = MeasureSpec.getMode(widthMeasureSpec);        int sizeHeight = MeasureSpec.getSize(heightMeasureSpec);        int modeHeight = MeasureSpec.getMode(heightMeasureSpec);        // 记录每一行的宽度和高度        int lineWidth = 0;        int lineHeight = 0;        // 记录整个流式布局的高度        int height = 0;        int cCount = getChildCount();        for (int i = 0; i &lt; cCount; i++) &#123;            View child = getChildAt(i);            measureChild(child, widthMeasureSpec, heightMeasureSpec);            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();            int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;            int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;            if (lineWidth + childWidth &gt; sizeWidth - getPaddingLeft() - getPaddingRight()) &#123;                // 需要换行                height += lineHeight;                lineWidth = childWidth;                lineHeight = childHeight;            &#125; else &#123;                // 不需要换行                lineWidth += childWidth;                lineHeight = Math.max(lineHeight, childHeight);            &#125;            if (i == cCount - 1) &#123;                height += lineHeight;            &#125;        &#125;        setMeasuredDimension(                modeWidth == MeasureSpec.EXACTLY ? sizeWidth : lineWidth + getPaddingLeft() + getPaddingRight(),                modeHeight == MeasureSpec.EXACTLY ? sizeHeight : height + getPaddingTop() + getPaddingBottom()        );    &#125;    @Override    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;        mAllViews.clear();        mLineHeight.clear();        int width = getWidth();        int lineWidth = 0;        int lineHeight = 0;        List&lt;View&gt; lineViews = new ArrayList&lt;&gt;();        int cCount = getChildCount();        for (int i = 0; i &lt; cCount; i++) &#123;            View child = getChildAt(i);            MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();            int childWidth = child.getMeasuredWidth();            int childHeight = child.getMeasuredHeight();            if (lineWidth + childWidth + lp.leftMargin + lp.rightMargin &gt; width - getPaddingLeft() - getPaddingRight()) &#123;                // 需要换行                mLineHeight.add(lineHeight);                mAllViews.add(lineViews);                lineWidth = 0;                lineHeight = childHeight + lp.topMargin + lp.bottomMargin;                lineViews = new ArrayList&lt;&gt;();            &#125;            lineWidth += childWidth + lp.leftMargin + lp.rightMargin;            lineHeight = Math.max(lineHeight, childHeight + lp.topMargin + lp.bottomMargin);            lineViews.add(child);        &#125;        // 处理最后一行        mLineHeight.add(lineHeight);        mAllViews.add(lineViews);        int left = getPaddingLeft();        int top = getPaddingTop();        int lineNum = mAllViews.size();        for (int i = 0; i &lt; lineNum; i++) &#123;            lineViews = mAllViews.get(i);            lineHeight = mLineHeight.get(i);            for (int j = 0; j &lt; lineViews.size(); j++) &#123;                View child = lineViews.get(j);                if (child.getVisibility() == View.GONE) &#123;                    continue;                &#125;                MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();                int lc = left + lp.leftMargin;                int tc = top + lp.topMargin;                int rc = lc + child.getMeasuredWidth();                int bc = tc + child.getMeasuredHeight();                child.layout(lc, tc, rc, bc);                left += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;            &#125;            left = getPaddingLeft();            top += lineHeight;        &#125;    &#125;    @Override    public LayoutParams generateLayoutParams(AttributeSet attrs) &#123;        return new MarginLayoutParams(getContext(), attrs);    &#125;&#125;</code></pre><h3 id="在布局文件中使用流式布局"><a href="#在布局文件中使用流式布局" class="headerlink" title="在布局文件中使用流式布局"></a>在布局文件中使用流式布局</h3><pre><code class="xml">&lt;com.example.flowlayout.FlowLayout    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:padding=&quot;10dp&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;5dp&quot;        android:background=&quot;@android:color/darker_gray&quot;        android:padding=&quot;10dp&quot;        android:text=&quot;标签1&quot; /&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;5dp&quot;        android:background=&quot;@android:color/darker_gray&quot;        android:padding=&quot;10dp&quot;        android:text=&quot;标签2&quot; /&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;5dp&quot;        android:background=&quot;@android:color/darker_gray&quot;        android:padding=&quot;10dp&quot;        android:text=&quot;这是一个较长的标签3&quot; /&gt;    &lt;!-- 可以添加更多的子视图 --&gt;&lt;/com.example.flowlayout.FlowLayout&gt;</code></pre><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ul><li><strong><code>onMeasure</code> 方法</strong>：用于测量子视图的大小和计算布局的总宽度和总高度。当子视图的总宽度超过布局的可用宽度时，会自动换行，并记录每一行的高度。</li><li><strong><code>onLayout</code> 方法</strong>：用于确定子视图在布局中的位置。它会将子视图按行排列，并根据测量的结果进行布局。</li><li><strong><code>generateLayoutParams</code> 方法</strong>：用于生成布局参数，这里使用 <code>MarginLayoutParams</code> 支持子视图的外边距设置。</li></ul><h1 id="表格布局-TableLayout"><a href="#表格布局-TableLayout" class="headerlink" title="表格布局(TableLayout)"></a>表格布局(TableLayout)</h1><p> 在 Android 开发里，表格布局（<code>TableLayout</code>）是一种实用的布局方式，它能够以表格形式对视图进行排列，也就是将子视图按行和列来组织。 </p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>按行列排列</strong>：可以把界面元素整齐地按行和列排列，就像表格一样，适用于需要呈现结构化数据或者整齐布局的场景。</li><li><strong>灵活控制</strong>：可以灵活控制每一行和每一列的属性，例如隐藏列、设置列的权重等。</li><li><strong>自动换行</strong>：当子视图数量超出列数时，会自动换行显示。</li></ul><h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><ul><li>**<code>TableLayout</code>**：作为表格布局的根容器，用来容纳行和列。</li><li>**<code>TableRow</code>**：代表表格中的一行，每个 <code>TableRow</code> 可以包含多个子视图，这些子视图会依次排列成列。</li></ul><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><p><img src="/../images/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/1742656024567.png" alt="1742656024567"></p><h4 id="TableLayout-的属性"><a href="#TableLayout-的属性" class="headerlink" title="TableLayout 的属性"></a><code>TableLayout</code> 的属性</h4><ul><li>**<code>android:shrinkColumns</code>**：指定哪些列可以收缩，以适应布局空间。例如 <code>android:shrinkColumns=&quot;1,2&quot;</code> 表示第 2 列和第 3 列可以收缩。</li><li>**<code>android:stretchColumns</code>**：指定哪些列可以拉伸，以填充剩余空间。例如 <code>android:stretchColumns=&quot;*&quot;</code> 表示所有列都可以拉伸。</li><li>**<code>android:collapseColumns</code>**：指定哪些列需要隐藏。例如 <code>android:collapseColumns=&quot;2&quot;</code> 表示第 3 列会被隐藏。</li></ul><h4 id="TableRow-的属性"><a href="#TableRow-的属性" class="headerlink" title="TableRow 的属性"></a><code>TableRow</code> 的属性</h4><ul><li>通常不需要为 <code>TableRow</code> 设置太多特殊属性，它主要用于容纳子视图。</li></ul><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="xml">&lt;TableLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:stretchColumns=&quot;*&quot;&gt;    &lt;!-- 第一行 --&gt;    &lt;TableRow&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;姓名&quot;            android:padding=&quot;10dp&quot; /&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;年龄&quot;            android:padding=&quot;10dp&quot; /&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;性别&quot;            android:padding=&quot;10dp&quot; /&gt;    &lt;/TableRow&gt;    &lt;!-- 第二行 --&gt;    &lt;TableRow&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;张三&quot;            android:padding=&quot;10dp&quot; /&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;25&quot;            android:padding=&quot;10dp&quot; /&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;男&quot;            android:padding=&quot;10dp&quot; /&gt;    &lt;/TableRow&gt;    &lt;!-- 第三行 --&gt;    &lt;TableRow&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;李四&quot;            android:padding=&quot;10dp&quot; /&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;30&quot;            android:padding=&quot;10dp&quot; /&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;女&quot;            android:padding=&quot;10dp&quot; /&gt;    &lt;/TableRow&gt;&lt;/TableLayout&gt;</code></pre><h3 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h3><ul><li>**<code>TableLayout</code>**：根布局使用 <code>TableLayout</code>，并设置 <code>android:stretchColumns=&quot;*&quot;</code>，这表示所有列都可以拉伸以填充剩余空间。</li><li>**<code>TableRow</code>**：每个 <code>TableRow</code> 代表表格的一行，其中包含多个 <code>TextView</code>，每个 <code>TextView</code> 代表表格中的一个单元格。</li><li>**<code>TextView</code>**：用于显示文本内容，设置了 <code>android:padding=&quot;10dp&quot;</code> 来增加单元格的内边距，使界面更美观。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>列数由第一行的子视图数量决定，后续行的子视图数量可以少于第一行，但不能多于第一行。</li><li>可以通过 <code>android:shrinkColumns</code>、<code>android:stretchColumns</code> 和 <code>android:collapseColumns</code> 属性来灵活控制列的显示和布局。</li></ul><h1 id="帧布局-FrameLayout"><a href="#帧布局-FrameLayout" class="headerlink" title="帧布局(FrameLayout)"></a>帧布局(FrameLayout)</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>FrameLayout</code> 是一种单帧布局，所有添加到 <code>FrameLayout</code> 中的子视图都堆叠在左上角（默认情况下），后添加的子视图会覆盖在前面子视图之上。它通常用于在界面上创建一个区域，在这个区域内显示单个视图或者多个重叠的视图。</p><h2 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>简单直接</strong>：<code>FrameLayout</code> 的布局规则简单，不需要复杂的约束条件，适合快速搭建一些简单的界面结构，比如在一个固定区域内显示图标、文本等内容。</li><li><strong>重叠效果</strong>：由于子视图会重叠放置，<code>FrameLayout</code> 非常适合实现一些需要重叠显示的效果，如在图片上添加遮罩层、显示进度条覆盖在其他视图上、在地图上添加标记等。</li></ul><h2 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h2><ul><li><code>android:layout_width</code> 和 <code>android:layout_height</code>：用于设置 <code>FrameLayout</code> 本身的宽度和高度，常见的值有 <code>match_parent</code>（与父容器宽度或高度相同）、<code>wrap_content</code>（包裹子视图的内容）以及具体的数值（如 <code>100dp</code>）。</li><li><code>android:background</code>：设置 <code>FrameLayout</code> 的背景颜色、Drawable 资源等，例如 <code>android:background=&quot;@color/colorPrimary&quot;</code> 可以设置背景为定义好的颜色资源。</li><li><code>android:foreground</code>：设置 <code>FrameLayout</code> 的前景，前景会绘制在所有子视图之上，可以用于添加一些装饰性的元素，如阴影等。</li><li><code>android:foregroundGravity</code>：控制前景的位置，例如 <code>android:foregroundGravity=&quot;center&quot;</code> 表示将前景放置在 <code>FrameLayout</code> 的中心位置。</li></ul><pre><code class="xml">&lt;FrameLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:background=&quot;@color/white&quot;&gt;    &lt;!-- 第一个子视图，显示一张图片 --&gt;    &lt;ImageView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:src=&quot;@drawable/sample_image&quot;        android:scaleType=&quot;centerCrop&quot; /&gt;    &lt;!-- 第二个子视图，一个半透明的遮罩层 --&gt;    &lt;View        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:background=&quot;#80000000&quot; /&gt;    &lt;!-- 第三个子视图，显示一段文本 --&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;这是一段文字&quot;        android:textColor=&quot;@color/white&quot;        android:textSize=&quot;20sp&quot;        android:layout_gravity=&quot;center&quot; /&gt;&lt;/FrameLayout&gt;</code></pre><p>在上述示例中，<code>FrameLayout</code> 包含了三个子视图：一个 <code>ImageView</code> 用于显示图片，一个 <code>View</code> 作为半透明的遮罩层，还有一个 <code>TextView</code> 用于显示文本。由于 <code>FrameLayout</code> 的特性，这三个子视图会重叠显示，通过设置 <code>android:layout_gravity</code> 属性（这里 <code>TextView</code> 设置为 <code>center</code> 使其居中显示）可以调整子视图的位置。</p><h1 id="网格布局-GridLayout"><a href="#网格布局-GridLayout" class="headerlink" title="网格布局(GridLayout)"></a>网格布局(GridLayout)</h1><p><img src="/../images/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/1742713556910.png" alt="1742713556910"></p><h2 id="子控件属性"><a href="#子控件属性" class="headerlink" title="子控件属性"></a>子控件属性</h2><p><img src="/../images/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/1742713654325.png" alt="1742713654325"></p><h1 id="约束布局-ConstraintLayout"><a href="#约束布局-ConstraintLayout" class="headerlink" title="约束布局(ConstraintLayout)"></a>约束布局(ConstraintLayout)</h1><h2 id="常用属性-2"><a href="#常用属性-2" class="headerlink" title="常用属性"></a>常用属性</h2><ul><li><code>app:layout_constraintLeft_toLeftOf</code>、<code>app:layout_constraintRight_toRightOf</code> 等：用于设置视图之间在水平和垂直方向上的对齐关系。例如，<code>app:layout_constraintLeft_toLeftOf=&quot;@id/view1&quot;</code> 表示当前视图的左边与 <code>view1</code> 的左边对齐。</li><li><code>app:layout_constraintTop_toBottomOf</code>、<code>app:layout_constraintBottom_toTopOf</code> 等：用于设置视图在垂直方向上的相对位置关系。如 <code>app:layout_constraintTop_toBottomOf=&quot;@id/view2&quot;</code> 表示当前视图的顶部在 <code>view2</code> 的底部下方。</li><li><code>app:layout_constraintHorizontal_bias</code> 和 <code>app:layout_constraintVertical_bias</code>：用于设置视图在水平和垂直方向上的偏移比例，取值范围是 <code>0</code> 到 <code>1</code>。<code>0</code> 表示偏向起始位置，<code>1</code> 表示偏向结束位置，<code>0.5</code> 表示居中。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;线性布局，相对布局，流式布局，表格布局。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>java回调</title>
    <link href="http://example.com/2025/03/19/java%E5%9B%9E%E8%B0%83/"/>
    <id>http://example.com/2025/03/19/java%E5%9B%9E%E8%B0%83/</id>
    <published>2025-03-19T13:18:09.000Z</published>
    <updated>2025-03-19T15:23:37.280Z</updated>
    
    <content type="html"><![CDATA[<p>java回调入门学习。</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p> 回调是一种双向调用机制，简单来说，就是 A 类调用 B 类的方法 C，B 类在执行方法 C 的过程中，在某个特定时刻调用 A 类的方法 D，这里方法 D 就是回调方法。 </p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>Java 实现回调通常需要以下几个步骤：</p><ol><li><strong>定义回调接口</strong>：声明回调方法，该方法将在合适的时机被调用。</li><li><strong>实现回调接口</strong>：创建一个类来实现这个回调接口，并实现其中的回调方法。</li><li><strong>在被调用类中使用回调接口</strong>：被调用类接收一个实现了回调接口的对象作为参数，并在适当的时候调用回调方法。</li></ol><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><pre><code class="java">// 1. 定义回调接口interface TaskCompletionCallback &#123;    void onTaskCompleted(String result);&#125;// 2. 实现回调接口class TaskCaller implements TaskCompletionCallback &#123;    @Override    public void onTaskCompleted(String result) &#123;        System.out.println(&quot;任务已完成，结果是: &quot; + result);    &#125;&#125;// 3. 在被调用类中使用回调接口class TaskExecutor &#123;    private TaskCompletionCallback callback;    public TaskExecutor(TaskCompletionCallback callback) &#123;        this.callback = callback;    &#125;    public void executeTask() &#123;        // 模拟任务执行        System.out.println(&quot;正在执行任务...&quot;);        try &#123;            Thread.sleep(2000); // 模拟耗时操作        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        String result = &quot;任务成功完成&quot;;        // 任务完成后调用回调方法        callback.onTaskCompleted(result);    &#125;&#125;// 测试代码public class CallbackExample &#123;    public static void main(String[] args) &#123;        TaskCaller caller = new TaskCaller();        TaskExecutor executor = new TaskExecutor(caller);        executor.executeTask();    &#125;&#125;    </code></pre><h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><ol><li>**定义回调接口 <code>TaskCompletionCallback</code>**：该接口中定义了一个 <code>onTaskCompleted</code> 方法，用于在任务完成时通知调用者。</li><li>**实现回调接口 <code>TaskCaller</code>**：<code>TaskCaller</code> 类实现了 <code>TaskCompletionCallback</code> 接口，并实现了 <code>onTaskCompleted</code> 方法，当任务完成时，会打印任务结果。</li><li>**被调用类 <code>TaskExecutor</code>**：<code>TaskExecutor</code> 类接收一个 <code>TaskCompletionCallback</code> 类型的对象作为参数，并在 <code>executeTask</code> 方法中模拟任务执行。任务完成后，调用回调对象的 <code>onTaskCompleted</code> 方法。</li><li><strong>测试代码</strong>：在 <code>main</code> 方法中，创建了 <code>TaskCaller</code> 和 <code>TaskExecutor</code> 对象，并调用 <code>executeTask</code> 方法来执行任务。</li></ol><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><h2 id="实现异步处理"><a href="#实现异步处理" class="headerlink" title="实现异步处理"></a>实现异步处理</h2><p>在 Java 程序里，一些操作（像网络请求、文件读写等）会消耗大量时间。若采用同步方式，程序会暂停直到操作完成，这会严重影响性能和响应能力。通过回调机制，可在发起操作后继续执行其他任务，等操作完成时，再利用回调函数处理结果。</p><pre><code class="java">// 定义回调接口interface DownloadCallback &#123;    void onDownloadComplete(String result);&#125;// 模拟下载任务类class Downloader &#123;    public void downloadFile(DownloadCallback callback) &#123;        new Thread(() -&gt; &#123;            try &#123;                // 模拟下载耗时                Thread.sleep(2000);                String result = &quot;文件下载完成&quot;;                callback.onDownloadComplete(result);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;// 调用者类class Main &#123;    public static void main(String[] args) &#123;        Downloader downloader = new Downloader();        downloader.downloadFile(result -&gt; System.out.println(result));        System.out.println(&quot;主线程继续执行其他任务&quot;);    &#125;&#125;</code></pre><p>在上述代码中，<code>Downloader</code> 类的 <code>downloadFile</code> 方法开启一个新线程模拟文件下载，下载完成后通过回调函数 <code>onDownloadComplete</code> 通知调用者。主线程在发起下载请求后可继续执行其他任务。</p><h2 id="事件驱动编程"><a href="#事件驱动编程" class="headerlink" title="事件驱动编程"></a>事件驱动编程</h2><p>在图形用户界面（GUI）编程、游戏开发等场景，经常需要处理各种事件（如按钮点击、鼠标移动）。回调机制能为每个事件绑定相应的回调函数，当事件触发时，执行对应的回调函数。</p><pre><code class="java">import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class ButtonExample &#123;    public static void main(String[] args) &#123;        JFrame frame = new JFrame(&quot;按钮示例&quot;);        JButton button = new JButton(&quot;点击我&quot;);        // 为按钮的点击事件绑定回调函数        button.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                System.out.println(&quot;按钮被点击了&quot;);            &#125;        &#125;);        frame.add(button);        frame.setSize(300, 200);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        frame.setVisible(true);    &#125;&#125;</code></pre><p>在这个例子中，通过 <code>addActionListener</code> 方法为按钮的点击事件绑定了一个回调函数 <code>actionPerformed</code>，当按钮被点击时，该回调函数会被调用。</p><h2 id="代码解耦与复用"><a href="#代码解耦与复用" class="headerlink" title="代码解耦与复用"></a>代码解耦与复用</h2><p>回调机制能够将不同的功能模块分离，降低代码间的耦合度，增强代码的复用性。一个模块可以定义通用的接口，其他模块通过实现这些接口来提供特定的行为。</p><pre><code class="java">// 定义通用的排序接口interface SortingStrategy &#123;    int[] sort(int[] array);&#125;// 具体的排序实现类class BubbleSort implements SortingStrategy &#123;    @Override    public int[] sort(int[] array) &#123;        // 冒泡排序实现        int n = array.length;        for (int i = 0; i &lt; n - 1; i++) &#123;            for (int j = 0; j &lt; n - i - 1; j++) &#123;                if (array[j] &gt; array[j + 1]) &#123;                    int temp = array[j];                    array[j] = array[j + 1];                    array[j + 1] = temp;                &#125;            &#125;        &#125;        return array;    &#125;&#125;class QuickSort implements SortingStrategy &#123;    @Override    public int[] sort(int[] array) &#123;        // 快速排序实现        quickSort(array, 0, array.length - 1);        return array;    &#125;    private void quickSort(int[] array, int low, int high) &#123;        if (low &lt; high) &#123;            int pi = partition(array, low, high);            quickSort(array, low, pi - 1);            quickSort(array, pi + 1, high);        &#125;    &#125;    private int partition(int[] array, int low, int high) &#123;        int pivot = array[high];        int i = (low - 1);        for (int j = low; j &lt; high; j++) &#123;            if (array[j] &lt; pivot) &#123;                i++;                int temp = array[i];                array[i] = array[j];                array[j] = temp;            &#125;        &#125;        int temp = array[i + 1];        array[i + 1] = array[high];        array[high] = temp;        return i + 1;    &#125;&#125;// 排序工具类class SortingUtils &#123;    public static int[] performSort(int[] array, SortingStrategy strategy) &#123;        return strategy.sort(array);    &#125;&#125;// 调用示例public class Main &#123;    public static void main(String[] args) &#123;        int[] array = &#123;5, 4, 3, 2, 1&#125;;        SortingStrategy bubbleSort = new BubbleSort();        int[] sortedArray = SortingUtils.performSort(array, bubbleSort);        for (int num : sortedArray) &#123;            System.out.print(num + &quot; &quot;);        &#125;    &#125;&#125;</code></pre><p> 在这个示例中，<code>SortingUtils</code> 类定义了一个通用的 <code>performSort</code> 方法，它接受一个 <code>SortingStrategy</code> 接口类型的参数。不同的排序算法（如冒泡排序、快速排序）可以通过实现 <code>SortingStrategy</code> 接口来提供不同的排序行为，这样 <code>SortingUtils</code> 类就可以复用，而不需要关心具体的排序实现。 </p><h1 id="回调实现异步详细介绍"><a href="#回调实现异步详细介绍" class="headerlink" title="回调实现异步详细介绍"></a>回调实现异步详细介绍</h1><h2 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h2><pre><code class="java">// 定义回调接口interface TaskCallback &#123;    void onTaskCompleted(String result);&#125;// 执行异步任务的类class AsyncTaskExecutor &#123;    public void executeAsyncTask(TaskCallback callback) &#123;        // 创建并启动一个新线程来执行耗时任务        new Thread(() -&gt; &#123;            try &#123;                System.out.println(&quot;开始执行耗时任务...&quot;);                // 模拟耗时操作，这里让线程休眠 2 秒                Thread.sleep(2000);                String result = &quot;任务完成，这是任务结果&quot;;                System.out.println(&quot;耗时任务执行完毕&quot;);                // 任务完成后调用回调方法                callback.onTaskCompleted(result);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;public class AsyncCallbackWithoutCompletableFuture &#123;    public static void main(String[] args) &#123;        // 创建 AsyncTaskExecutor 实例，用于执行异步任务        AsyncTaskExecutor executor = new AsyncTaskExecutor();        // 定义回调逻辑        TaskCallback callback = (result) -&gt; &#123;            System.out.println(&quot;收到回调，结果是: &quot; + result);        &#125;;        // 调用 executeAsyncTask 方法开始执行异步任务，并传入回调实例        executor.executeAsyncTask(callback);        System.out.println(&quot;主线程继续执行其他操作&quot;);    &#125;&#125;</code></pre><h2 id="代码执行过程"><a href="#代码执行过程" class="headerlink" title="代码执行过程"></a>代码执行过程</h2><h3 id="1-程序启动，主线程开始执行-main-方法"><a href="#1-程序启动，主线程开始执行-main-方法" class="headerlink" title="1. 程序启动，主线程开始执行 main 方法"></a>1. 程序启动，主线程开始执行 <code>main</code> 方法</h3><p>当运行程序时，<code>main</code> 方法会被首先执行。此方法是整个程序的入口点。</p><h3 id="2-创建-AsyncTaskExecutor-实例"><a href="#2-创建-AsyncTaskExecutor-实例" class="headerlink" title="2. 创建 AsyncTaskExecutor 实例"></a>2. 创建 <code>AsyncTaskExecutor</code> 实例</h3><pre><code class="java">AsyncTaskExecutor executor = new AsyncTaskExecutor();</code></pre><p>这行代码创建了 <code>AsyncTaskExecutor</code> 类的一个实例，该类负责执行异步任务。</p><h3 id="3-定义回调逻辑"><a href="#3-定义回调逻辑" class="headerlink" title="3. 定义回调逻辑"></a>3. 定义回调逻辑</h3><pre><code class="java">TaskCallback callback = (result) -&gt; &#123;    System.out.println(&quot;收到回调，结果是: &quot; + result);&#125;;</code></pre><p>这里通过 Lambda 表达式实现了 <code>TaskCallback</code> 接口的 <code>onTaskCompleted</code> 方法，用于在任务完成后处理结果。</p><h3 id="4-调用-executeAsyncTask-方法"><a href="#4-调用-executeAsyncTask-方法" class="headerlink" title="4. 调用 executeAsyncTask 方法"></a>4. 调用 <code>executeAsyncTask</code> 方法</h3><pre><code class="java">executor.executeAsyncTask(callback);</code></pre><ul><li>调用 <code>AsyncTaskExecutor</code> 实例的 <code>executeAsyncTask</code> 方法，同时传入回调实例。</li><li>在 <code>executeAsyncTask</code> 方法内部，会创建一个新的线程来执行耗时任务。</li></ul><h3 id="5-新线程开始执行耗时任务"><a href="#5-新线程开始执行耗时任务" class="headerlink" title="5. 新线程开始执行耗时任务"></a>5. 新线程开始执行耗时任务</h3><pre><code class="java">new Thread(() -&gt; &#123;    try &#123;        System.out.println(&quot;开始执行耗时任务...&quot;);        Thread.sleep(2000);        String result = &quot;任务完成，这是任务结果&quot;;        System.out.println(&quot;耗时任务执行完毕&quot;);        callback.onTaskCompleted(result);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;).start();</code></pre><ul><li>新线程启动后，会打印 “开始执行耗时任务…”。</li><li>接着线程进入 2 秒的休眠状态，以此模拟耗时操作。</li></ul><h3 id="6-主线程继续执行"><a href="#6-主线程继续执行" class="headerlink" title="6. 主线程继续执行"></a>6. 主线程继续执行</h3><pre><code class="java">System.out.println(&quot;主线程继续执行其他操作&quot;);</code></pre><p>主线程不会等待新线程中的耗时任务完成，而是会继续执行后续代码，打印 “主线程继续执行其他操作”。这体现了异步处理的特性，即主线程不会被阻塞。</p><h3 id="7-新线程完成耗时任务"><a href="#7-新线程完成耗时任务" class="headerlink" title="7. 新线程完成耗时任务"></a>7. 新线程完成耗时任务</h3><ul><li>2 秒休眠结束后，新线程会打印 “耗时任务执行完毕”。</li><li>然后调用回调接口的 <code>onTaskCompleted</code> 方法，并将任务结果作为参数传入。</li></ul><h3 id="8-触发回调"><a href="#8-触发回调" class="headerlink" title="8. 触发回调"></a>8. 触发回调</h3><pre><code class="java">callback.onTaskCompleted(result);</code></pre><ul><li>调用 <code>callback</code> 实例的 <code>onTaskCompleted</code> 方法，执行之前定义的回调逻辑。</li><li>打印 “收到回调，结果是：任务完成，这是任务结果”。</li></ul><h1 id="自己写的代码"><a href="#自己写的代码" class="headerlink" title="自己写的代码"></a>自己写的代码</h1><pre><code class="java">import java.util.OptionalInt;interface  Work &#123;    void work(String result);&#125;class Boss implements Work&#123;    public void work(String result)&#123;        if (result.equals(&quot;ok&quot;))&#123;            System.out.println(&quot;继续努力，给你加薪！！&quot;);        &#125;        else &#123;            System.out.println(&quot;开除，开除！！&quot;);        &#125;    &#125;&#125;class Manager implements Work &#123;    public void work(String result)&#123;        if (result.equals(&quot;ok&quot;))&#123;            System.out.println(&quot;继续努力，给你吃个大饼！！&quot;);        &#125;        else &#123;            System.out.println(&quot;废物一个！！&quot;);        &#125;    &#125;&#125;class Employee &#123;    public Work accept;    public void work () &#123;        System.out.println(&quot;疯狂努力敲代码！！！&quot;);        accept.work(&quot;ok&quot;);    &#125;    public void setAccept (Work accept)&#123;        this.accept = accept;    &#125;&#125;public class Main &#123;    @SuppressWarnings(&#123;&quot;all&quot;&#125;)    public static void main(String[] args) &#123;        Employee employee = new Employee();        Work texter = result -&gt; &#123;            if (result.equals(&quot;ok&quot;))&#123;                System.out.println(&quot;虽然过了，但是，一般啊！！&quot;);            &#125;            else &#123;                System.out.println(&quot;bug,bug,大bug！！&quot;);            &#125;        &#125;;        employee.setAccept(texter);        employee.work();        employee.setAccept((new Manager()));        employee.work();    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;java回调入门学习。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Use_of_Git</title>
    <link href="http://example.com/2025/03/17/Use-of-Git/"/>
    <id>http://example.com/2025/03/17/Use-of-Git/</id>
    <published>2025-03-17T14:53:47.000Z</published>
    <updated>2025-03-19T15:19:52.394Z</updated>
    
    <content type="html"><![CDATA[<p>Git基础操作入门</p><span id="more"></span> <h1 id="Git-概述"><a href="#Git-概述" class="headerlink" title="Git 概述"></a>Git 概述</h1><p>Git 是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种项目。</p><p>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。</p><h1 id="何为版本控制"><a href="#何为版本控制" class="headerlink" title="何为版本控制"></a>何为版本控制</h1><p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p><h2 id="核心目标"><a href="#核心目标" class="headerlink" title="核心目标"></a>核心目标</h2><ul><li><strong>记录变化</strong>：精准记录文件在不同时间点的内容变动，包括新增、修改、删除等操作。</li><li><strong>追溯历史</strong>：方便开发者随时回溯到过去的某个版本，查看当时的文件状态，了解项目的演变过程。</li></ul><h2 id="基本操作理念"><a href="#基本操作理念" class="headerlink" title="基本操作理念"></a>基本操作理念</h2><ul><li><strong>快照机制</strong>：每次提交时对项目当前状态进行 “快照” 保存，而非简单记录文件差异，确保能完整还原特定时刻的项目全貌。</li><li><strong>分支管理</strong>：允许同时存在多个开发线路，各分支可独立进行功能开发、问题修复等操作，互不干扰，提高开发效率。</li><li><strong>合并操作</strong>：在合适时机将不同分支上的修改合并到主分支或其他目标分支，整合各方开发成果。</li></ul><h2 id="核心价值体现"><a href="#核心价值体现" class="headerlink" title="核心价值体现"></a>核心价值体现</h2><ul><li><strong>提升协作效率</strong>：多人协作开发时，版本控制系统能有效管理不同开发者的修改，避免冲突，确保代码的一致性和完整性。</li><li><strong>保障项目安全</strong>：提供历史版本备份，即使出现误操作或代码损坏，也能轻松恢复到之前的稳定版本。</li></ul><h1 id="Git-工作机制"><a href="#Git-工作机制" class="headerlink" title="Git 工作机制"></a>Git 工作机制</h1><p><img src="/../images/Use-of-Git/1742225773776.png" alt="1742225773776"></p><p>本地库还可以用**<code>push</code><strong>指令推送到</strong>代码托管中心<strong>（也就是</strong>远程库**）</p><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><p><img src="/../images/Use-of-Git/1742227145016.png" alt="1742227145016"></p><h2 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="bash">git init</code></pre><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p> 进入想要进行版本控制的项目目录。可以在文件资源管理器中找到该目录，然后右键选择 “Git Bash Here”（Windows 系统）打开命令行；</p><p>在命令行中执行<code>git init</code>命令 ，执行后会在该目录下生成一个隐藏的<code>.git</code>文件夹（若在 Windows 系统下看不到隐藏文件，需设置显示隐藏文件）。这个文件夹用于存储版本控制信息，如提交历史、分支信息等，不要随意删除或修改里面的内容。 </p><h2 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="bash">git status</code></pre><p>初始化完成后，可以使用<code>git status</code>命令查看当前仓库的状态，会显示是否有未跟踪的文件等信息。例如，如果项目目录下有新文件，命令行可能提示这些文件是 “untracked files”（未跟踪文件），表示这些文件还未纳入版本控制。</p><p>至此，本地库初始化完成。后续若要将项目文件纳入版本控制，还需进行添加文件到暂存区（<code>git add</code> ）和提交到本地库（<code>git commit</code> ）等操作。</p><h2 id="添加-删除-暂存区"><a href="#添加-删除-暂存区" class="headerlink" title="添加&amp;删除 暂存区"></a>添加&amp;删除 暂存区</h2><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="bash">git add example.txt</code></pre><pre><code class="bash">git rm --cached &lt;文件名1&gt; &lt;文件名2&gt; ...</code></pre><p>删除只是将暂存区的文件删了，并不是将工作区的文件删了。</p><h2 id="提交本地库"><a href="#提交本地库" class="headerlink" title="提交本地库"></a>提交本地库</h2><h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="bash">git commit -m &quot;提交信息&quot; filename</code></pre><p>其中，<code>-m</code> 选项用于指定提交信息，你需要将 <code>&quot;提交信息&quot;</code> 替换为具体的描述，例如：</p><pre><code class="bash">git commit -m &quot;修复登录功能的 bug&quot; filename</code></pre><p>一个好的提交信息应该简洁明了，能够准确描述本次提交所做的更改，方便后续查看和理解项目的历史记录。</p><h4 id="跳过暂存区直接提交"><a href="#跳过暂存区直接提交" class="headerlink" title="跳过暂存区直接提交"></a>跳过暂存区直接提交</h4><p>如果你想直接将工作区中所有已跟踪文件的修改提交到本地库，而不经过暂存区，可以使用 <code>-a</code> 选项。但需要注意，该选项只会提交已跟踪文件的修改，不会处理新创建的未跟踪文件。</p><pre><code class="bash">git commit -a -m &quot;提交所有已跟踪文件的修改&quot;</code></pre><h2 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h2><p><img src="/../images/Use-of-Git/1742276486650.png" alt="1742276486650"></p><h3 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h3><ul><li><strong>查看完整的引用日志</strong>：在仓库目录下直接执行 <code>git reflog</code> 命令，会显示所有引用的更新记录，每条记录包含操作的哈希值、操作名称、提交信息和操作时间等。</li></ul><pre><code class="bash">git reflog</code></pre><p>示例输出：</p><pre><code class="plaintext">f5a3d2b (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: Add new feature8c7d1e3 HEAD@&#123;1&#125;: reset: moving to 8c7d1e33b9a4f6 HEAD@&#123;2&#125;: commit: Fix bug</code></pre><pre><code class="bash">git log</code></pre><p>在 Git 仓库目录下，直接执行<code>git log</code>命令，它会按照时间倒序（最新提交在前）显示所有提交的详细信息，默认输出包含以下内容：</p><ul><li><strong>提交哈希值</strong>：一个唯一标识该提交的 40 位十六进制字符串。</li><li><strong>作者信息</strong>：包含作者姓名和邮箱。</li><li><strong>提交日期</strong>：记录提交发生的时间。</li><li><strong>提交信息</strong>：提交者添加的描述本次提交更改的文字。</li></ul><pre><code class="plaintext">commit 3a8d2c1e4f5g6h7i8j9k0l1m2n3o4p5q6r7s8t9uAuthor: John Doe &lt;johndoe@example.com&gt;Date:   Mon Mar 18 14:30:00 2025 +0800    Add new feature to the project</code></pre><h2 id="创建-预览-文本"><a href="#创建-预览-文本" class="headerlink" title="创建&amp;预览 文本"></a>创建&amp;预览 文本</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1. 打开文件"></a>1. 打开文件</h4><p>在终端中输入以下命令来打开你想要修改的文件，将 <code>filename</code> 替换为实际的文件名。</p><pre><code class="bash">vim hello.txt</code></pre><p>如果文件不存在，Vim 会创建一个新文件；如果文件已存在，Vim 会打开该文件供你编辑。</p><h4 id="2-进入编辑模式"><a href="#2-进入编辑模式" class="headerlink" title="2. 进入编辑模式"></a>2. 进入编辑模式</h4><p>Vim 有多种模式，刚打开文件时处于正常模式，在该模式下不能直接输入文本。若要修改文件内容，需要进入插入模式，有以下几种常用的进入方式：</p><ul><li><strong><code>i</code> 键</strong>：在当前光标所在位置之前插入文本。</li><li><strong><code>a</code> 键</strong>：在当前光标所在位置之后插入文本。</li><li><strong><code>o</code> 键</strong>：在当前行的下一行插入新行并进入插入模式。</li><li><strong><code>O</code> 键</strong>：在当前行的上一行插入新行并进入插入模式。</li></ul><h4 id="3-进行文本编辑"><a href="#3-进行文本编辑" class="headerlink" title="3. 进行文本编辑"></a>3. 进行文本编辑</h4><p>进入插入模式后，你就可以像使用普通文本编辑器一样输入、修改和删除文本了：</p><ul><li><strong>输入文本</strong>：直接输入需要添加的内容。</li><li><strong>删除文本</strong>：使用 <code>Backspace</code> 或 <code>Delete</code> 键删除字符。</li><li><strong>移动光标</strong>：使用方向键（上、下、左、右）或者 <code>h</code>（左）、<code>j</code>（下）、<code>k</code>（上）、<code>l</code>（右）在文本中移动光标位置。</li></ul><h4 id="4-保存和退出"><a href="#4-保存和退出" class="headerlink" title="4. 保存和退出"></a>4. 保存和退出</h4><p>完成编辑后，需要先从插入模式返回到正常模式，按下 <code>Esc</code> 键即可。然后，在正常模式下可以使用以下命令来保存和退出文件：</p><ul><li><strong>保存并退出</strong>：输入 <code>:wq</code> 然后按 <code>Enter</code> 键，<code>w</code> 表示写入（保存），<code>q</code> 表示退出。</li><li><strong>仅保存不退出</strong>：输入 <code>:w</code> 然后按 <code>Enter</code> 键。</li><li><strong>不保存直接退出</strong>：输入 <code>:q!</code> 然后按 <code>Enter</code> 键，<code>!</code> 表示强制执行该操作。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>修改后的文件并不会直接添加到暂存区。</p><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><pre><code class="bash">cat hello.txt</code></pre><p><img src="/../images/Use-of-Git/1742276133427.png" alt="1742276133427"></p><h2 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h2><pre><code class="bash">git reset --hard &lt;commit-hash&gt;</code></pre><p>上面的<code>&lt;commit-hash&gt;</code> 为版本号，可以先用<code>git reflogx</code>查看版本号</p><ul><li><strong><code>--hard</code> 模式</strong>：移动分支指针，同时更新暂存区和工作目录的内容，使其与指定提交版本一致。</li></ul><p> 使用 <code>git reset --hard</code> 改变了分支指针的位置，这些提交对象本身并不会立即从磁盘上被删除，而是会在一段时间内（默认是 30 天）作为 “悬空对象（dangling objects）” 保留在仓库里。 </p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><img src="/../images/Use-of-Git/1742277690118.png" alt="1742277690118"></p><p><img src="/../images/Use-of-Git/1742277754126.png" alt="1742277754126"></p><p> <code>master</code>为主线分支</p><h3 id="分支的好处"><a href="#分支的好处" class="headerlink" title="分支的好处"></a>分支的好处</h3><p><img src="/../images/Use-of-Git/1742277887295.png" alt="1742277887295"></p><h3 id="分支的相关操作"><a href="#分支的相关操作" class="headerlink" title="分支的相关操作"></a>分支的相关操作</h3><p><img src="/../images/Use-of-Git/1742277915445.png" alt="1742277915445"></p><h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><p><img src="/../images/Use-of-Git/1742278264344.png" alt="1742278264344"></p><p>先查看分支，然后创建分支<code>hot-fix</code>，再次查看分支，编辑<code>hello.txt</code>，</p><p>将<code>master</code>分支转成<code>hot-fix</code>分支，查看分支</p><p><img src="/../images/Use-of-Git/1742278335743.png" alt="1742278335743"></p><p>在<code>hot-fix</code>分支下编辑<code>hello.txt</code>，查看仓库状态，添加到暂存区，查看仓库状态，上传到本地库</p><p><img src="/../images/Use-of-Git/1742278405063.png" alt="1742278405063"></p><p>预览文本，展示版本信息</p><p><img src="/../images/Use-of-Git/1742278644385.png" alt="1742278644385"></p><p>将分支转成<code>master</code>，合并分支</p><p><img src="/../images/Use-of-Git/1742278654696.png" alt="1742278654696"></p><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p><img src="/../images/Use-of-Git/1742279203414.png" alt="1742279203414"></p><h4 id="手动解决冲突"><a href="#手动解决冲突" class="headerlink" title="手动解决冲突"></a>手动解决冲突</h4><p>用 vim 打开文本文件人为修改文件。</p><p><img src="/../images/Use-of-Git/1742279431657.png" alt="1742279431657"></p><p>然后添加暂存区。</p><p>提交本地库（<strong>注意：此时提交本地库不能带有文件名</strong>）。</p><p><strong>报错示例：</strong></p><p><img src="/../images/Use-of-Git/1742279461906.png" alt="1742279461906"></p><p>在当前分支下合并分支，只会修改当前分支。</p><h3 id="head指针"><a href="#head指针" class="headerlink" title="head指针"></a>head指针</h3><p><img src="/../images/Use-of-Git/1742279594624.png" alt="1742279594624"></p><h1 id="Git-团队协作机制"><a href="#Git-团队协作机制" class="headerlink" title="Git 团队协作机制"></a>Git 团队协作机制</h1><h2 id="团队内协作"><a href="#团队内协作" class="headerlink" title="团队内协作"></a>团队内协作</h2><p><img src="/../images/Use-of-Git/1742287892857.png" alt="1742287892857"></p><h2 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h2><p><img src="/../images/Use-of-Git/1742288101677.png" alt="1742288101677"></p><h1 id="远程库操作命令"><a href="#远程库操作命令" class="headerlink" title="远程库操作命令"></a>远程库操作命令</h1><p><img src="/../images/Use-of-Git/1742288499837.png" alt="1742288499837"></p><h2 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h2><p><img src="/../images/Use-of-Git/1742288559737.png" alt="1742288559737"></p><h2 id="推送本地库分支到远程库"><a href="#推送本地库分支到远程库" class="headerlink" title="推送本地库分支到远程库"></a>推送本地库分支到远程库</h2><p><img src="/../images/Use-of-Git/1742288771694.png" alt="1742288771694"></p><p>推送后会弹出该页面进行登入</p><p><img src="/../images/Use-of-Git/1742288783567.png" alt="1742288783567"></p><h2 id="拉取远程库到本地库"><a href="#拉取远程库到本地库" class="headerlink" title="拉取远程库到本地库"></a>拉取远程库到本地库</h2><p><img src="/../images/Use-of-Git/1742289034982.png" alt="1742289034982"></p><h2 id="克隆远程库到本地库"><a href="#克隆远程库到本地库" class="headerlink" title="克隆远程库到本地库"></a>克隆远程库到本地库</h2><p><img src="/../images/Use-of-Git/1742291569191.png" alt="1742291569191"></p><p>克隆代码不需要账号,克隆会自动取上origin别名</p><h2 id="团队内协作-1"><a href="#团队内协作-1" class="headerlink" title="团队内协作"></a>团队内协作</h2><p><img src="/../images/Use-of-Git/1742292441416.png" alt="1742292441416"></p><p><img src="/../images/Use-of-Git/1742292459325.png" alt="1742292459325"></p><p><img src="/../images/Use-of-Git/1742292474045.png" alt="1742292474045"></p><p><img src="/../images/Use-of-Git/1742292501601.png" alt="1742292501601"></p><p>在Github的远程库的<code>settings</code>中，的<code>manage access</code>选项，邀请人员成员团队内成员，并会产生邀请链接，对方在自己的GitHub账户中打开链接接受邀请。</p><p><img src="/../images/Use-of-Git/1742292364344.png" alt="1742292364344"></p><p>然后该人员就可以<code>push</code>自己的内容到远程库中</p><h2 id="跨团队协作-1"><a href="#跨团队协作-1" class="headerlink" title="跨团队协作"></a>跨团队协作</h2><p><img src="/../images/Use-of-Git/1742292693332.png" alt="1742292693332"></p><p>在自己的账户中用对方的远程库链接访问对方远程库，然后点击<code>Fork</code>，在自己的账户下就有了对方在远程库中的文件。</p><p><img src="/../images/Use-of-Git/1742293046572.png" alt="1742293046572"></p><p><img src="/../images/Use-of-Git/1742293240657.png" alt="1742293240657"></p><p><img src="/../images/Use-of-Git/1742293324117.png" alt="1742293324117"></p><p>在修改完文件之后可以点击上传，然后进入<code>Pull request</code> ，创建请求，</p><p><img src="/../images/Use-of-Git/1742293547991.png" alt="1742293547991"></p><p>对方就可以在自己的库中的<code>Pull request</code>看到我们的拉取请求，并且可以审核修改后的文件，然后合并文件。</p><h2 id="SSH协议免密登录"><a href="#SSH协议免密登录" class="headerlink" title="SSH协议免密登录"></a>SSH协议免密登录</h2><p>在<code>asus</code>目录下打开<code>Git bash</code></p><p>输入</p><pre><code class="bash">ssh-keygen -t rsa -C 邮箱</code></pre><p>再连续按三次回车，就会再<code>asus</code>目录下创建<code>.ssh</code>文件</p><p><img src="/../images/Use-of-Git/1742305152028.png" alt="1742305152028"></p><p>然后查看公钥信息</p><p><img src="/../images/Use-of-Git/1742305393813.png" alt="1742305393813"></p><p>将内符复制到账号设置内添加公钥</p><p><img src="/../images/Use-of-Git/1742305429367.png" alt="1742305429367"></p><p>添加成功后，再次将本地库推送到远程库或拉取文件时，可以不用再登入Github</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git基础操作入门&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Android-Development</title>
    <link href="http://example.com/2025/03/16/Android-Development/"/>
    <id>http://example.com/2025/03/16/Android-Development/</id>
    <published>2025-03-15T16:01:24.000Z</published>
    <updated>2025-03-26T16:03:11.932Z</updated>
    
    <content type="html"><![CDATA[<p>也是转到开发了呢。</p><span id="more"></span> <h1 id="开发镜像设置"><a href="#开发镜像设置" class="headerlink" title="开发镜像设置"></a>开发镜像设置</h1><p> https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;gradle&#x2F; </p><p><img src="/../images/Android-Development/1742480409420.png" alt="1742480409420"></p><p> <a href="https://mirrors.cloud.tencent.com/nexus/repository/maven-public">https://mirrors.cloud.tencent.com/nexus/repository/maven-public</a></p><p><img src="/../images/Android-Development/1742481283204.png" alt="1742481283204"></p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><p><a href="https://iconpark.oceanengine.com/home">https://iconpark.oceanengine.com/home</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;也是转到开发了呢。&lt;/p&gt;</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java_notes</title>
    <link href="http://example.com/2025/02/24/java-notes/"/>
    <id>http://example.com/2025/02/24/java-notes/</id>
    <published>2025-02-24T10:33:45.000Z</published>
    <updated>2025-03-19T14:56:47.712Z</updated>
    
    <content type="html"><![CDATA[<p>安卓逆向基础</p><span id="more"></span> <h1 id="cmd与环境变量"><a href="#cmd与环境变量" class="headerlink" title="cmd与环境变量"></a>cmd与环境变量</h1><p><img src="/../images/java/1740393417191.png" alt="1740393417191"></p><h2 id="cmd基本操作"><a href="#cmd基本操作" class="headerlink" title="cmd基本操作"></a>cmd基本操作</h2><p><strong>dir：展现当前目录</strong></p><p><strong>cd：转目录</strong></p><p><strong>cd  .. ：</strong> <strong>转上级目录</strong></p><p><strong>输入“D: ”  ：转到D盘</strong></p><p><strong>按Tab键可以补全文件命</strong></p><p><strong>右键复制粘贴</strong></p><p><strong>按上下键可以选择之前执行过的命令</strong></p><p><strong>cmd可以直接运行文件</strong></p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><ul><li><strong>定义</strong>：相对路径是相对于当前工作目录或当前文件所在位置来表示文件或目录位置的路径。它不包含从文件系统根目录开始的完整路径信息，而是基于当前位置来描述目标的位置。相对路径使用 “.”（表示当前目录）、“..”（表示上级目录）以及文件名或目录名来构建路径。</li><li><strong>示例</strong>：假设当前工作目录是<code>C:\Users\John\Documents</code>，如果要访问<code>Documents</code>目录下的<code>Projects</code>文件夹中的<code>file.txt</code>文件，相对路径可以表示为<code>Projects/file.txt</code>。如果要访问当前目录的上一级目录中的<code>Images</code>文件夹，相对路径可以写成<code>../Images</code>。</li></ul><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><ul><li><strong>定义</strong>：绝对路径是从文件系统的根目录开始，完整地指定文件或目录在整个文件系统中的位置的路径。它包含了从根目录到目标文件或目录的所有目录层次信息，具有唯一性和确定性，无论在什么环境下，绝对路径都能准确地定位到目标文件或目录。</li><li><strong>示例</strong>：在 Windows 系统中，例如<code>C:\Users\John\Documents\Projects\file.txt</code>就是一个绝对路径，它明确地指出了<code>file.txt</code>文件位于<code>C</code>盘的<code>Users</code>文件夹下的<code>John</code>文件夹中的<code>Documents</code>文件夹的<code>Projects</code>文件夹内。在 Linux 系统中，<code>/home/user/Documents/file.txt</code>也是一个绝对路径，从根目录 “&#x2F;” 开始，依次指定了各个目录层级直到目标文件。</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li><strong>用户变量</strong>：是针对特定用户设置的变量，只对当前用户的环境和应用程序起作用，不同用户的用户变量相互独立，可用于存储该用户特有的配置信息等。</li><li><strong>系统变量</strong>：是对整个系统所有用户都有效的变量，用于存储系统级的配置信息和参数，为系统和所有用户的应用程序提供通用的设置和数据。</li><li><strong>环境变量作用</strong>：在环境变量中，Path 用于指定可执行文件的搜索路径。当在命令行或程序中执行一个命令或启动一个程序时，系统会按照 Path 中指定的路径顺序去查找对应的可执行文件，以便能够找到并运行它们，而无需用户输入完整路径。</li></ul><h1 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h1><p><img src="/../images/java/1740407096683.png" alt="1740407096683"></p><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><p><img src="/../images/java/1741268784357.png" alt="1741268784357"></p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p><img src="/../images/java/1741269021214.png" alt="1741269021214"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><img src="/../images/java/1741269364034.png" alt="1741269364034"></p><p><img src="/../images/java/1741269706290.png" alt="1741269706290"></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><img src="/../images/java/1741269821892.png" alt="1741269821892"></p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p><img src="/../images/java/1741349945259.png" alt="1741349945259"></p><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>设置断点是调试的第一步，它可以让程序在指定的代码行暂停执行。</p><ul><li><strong>普通断点</strong>：在编辑器的行号旁边单击，会出现一个红色圆点，即设置了一个普通断点。当程序执行到这一行时，会暂停执行。例如，在以下代码中，在 <code>System.out.println(&quot;这是要调试的代码行&quot;);</code> 这一行的行号旁边单击设置断点：</li></ul><pre><code class="java">public class DebugExample &#123;    public static void main(String[] args) &#123;        int a = 10;        int b = 20;        int sum = a + b;        System.out.println(&quot;这是要调试的代码行&quot;);        System.out.println(&quot;两数之和为：&quot; + sum);    &#125;&#125;</code></pre><ul><li><strong>条件断点</strong>：右键单击已经设置的普通断点，选择 “Edit Breakpoint”，在弹出的对话框中可以设置条件。只有当条件满足时，程序才会在该断点处暂停。比如，在上述代码中，如果想在 <code>sum</code> 等于 30 时暂停程序，可以在条件框中输入 <code>sum == 30</code>。</li></ul><h3 id="启动调试模式"><a href="#启动调试模式" class="headerlink" title="启动调试模式"></a>启动调试模式</h3><p>设置好断点后，需要以调试模式启动程序。在 IDEA 的工具栏中，找到绿色虫子图标（Debug），点击它或者使用快捷键（通常是 Shift + F9），程序会开始执行，当遇到断点时会暂停。</p><h3 id="调试操作"><a href="#调试操作" class="headerlink" title="调试操作"></a>调试操作</h3><p>程序在断点处暂停后，可以使用以下操作来控制程序的执行和查看程序状态：</p><ul><li>单步执行<ul><li><strong>Step Over（F8）</strong>：逐行执行代码，不会进入方法内部。如果当前行调用了一个方法，会直接执行完该方法并跳到下一行。</li><li><strong>Step Into（F7）</strong>：如果当前行调用了一个方法，会进入该方法内部继续调试；如果是普通语句，则和 Step Over 效果相同。</li><li><strong>Step Out（Shift + F8）</strong>：从当前方法中跳出，继续执行该方法调用处的下一行代码。</li></ul></li><li><strong>查看变量值</strong>：在调试窗口的 “Variables” 面板中，可以查看当前作用域内的变量值。当程序暂停在断点处时，该面板会显示当前方法中所有变量的名称和值。</li><li><strong>表达式求值</strong>：在调试窗口中，有一个 “Evaluate Expression” 按钮（通常是一个带有计算器图标的按钮），点击它可以输入表达式并计算其值。例如，可以输入变量名来查看变量的值，或者输入一个复杂的表达式进行计算。</li></ul><h3 id="其他类型的断点"><a href="#其他类型的断点" class="headerlink" title="其他类型的断点"></a>其他类型的断点</h3><ul><li><strong>方法断点</strong>：在方法的声明行（方法名所在行）设置断点，当该方法被调用或者方法返回时，程序会暂停。方法断点用蓝色菱形表示。</li><li><strong>字段断点</strong>：在类的字段声明行设置断点，当该字段被读取或者写入时，程序会暂停。字段断点用黄色圆点表示。</li></ul><h3 id="管理断点"><a href="#管理断点" class="headerlink" title="管理断点"></a>管理断点</h3><ul><li><strong>禁用 &#x2F; 启用断点</strong>：右键单击断点，选择 “Disable Breakpoint” 可以禁用断点，再次右键单击选择 “Enable Breakpoint” 可以启用断点。禁用的断点不会影响程序的执行。</li><li><strong>删除断点</strong>：直接单击断点（红色圆点）即可删除断点；也可以在 “Breakpoints” 窗口（通常可以通过 “View” -&gt; “Tool Windows” -&gt; “Breakpoints” 打开）中选择要删除的断点，然后按 Delete 键删除。</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="基本调试步骤"><a href="#基本调试步骤" class="headerlink" title="基本调试步骤"></a>基本调试步骤</h3><h4 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1. 设置断点"></a>1. 设置断点</h4><p>断点是调试的关键，它能让程序在指定位置暂停执行，方便开发者查看程序状态。在 IDEA 中设置断点非常简单，只需在代码编辑器的行号旁边单击，出现红色圆点即表示成功设置断点。例如，在以下代码中，若想在 <code>sum</code> 变量计算完成后查看其值，可在 <code>System.out.println(&quot;两数之和为: &quot; + sum);</code> 这一行设置断点：</p><pre><code class="java">public class DebugExample &#123;    public static void main(String[] args) &#123;        int a = 10;        int b = 20;        int sum = a + b;        System.out.println(&quot;两数之和为: &quot; + sum);    &#125;&#125;</code></pre><h4 id="2-启动调试模式"><a href="#2-启动调试模式" class="headerlink" title="2. 启动调试模式"></a>2. 启动调试模式</h4><p>设置好断点后，有两种方式启动调试模式：</p><ul><li>点击 IDEA 工具栏上的绿色虫子图标（Debug）。</li><li>使用快捷键（通常是 <code>Shift + F9</code>）。</li></ul><p>启动调试模式后，程序会开始执行，当遇到设置的断点时会暂停。</p><h3 id="常用调试操作"><a href="#常用调试操作" class="headerlink" title="常用调试操作"></a>常用调试操作</h3><h4 id="1-单步执行"><a href="#1-单步执行" class="headerlink" title="1. 单步执行"></a>1. 单步执行</h4><ul><li><strong>StepOver（<code>F8</code>）</strong>：逐行执行代码，若当前行调用了方法，会直接执行完该方法并跳到下一行，不会进入方法内部。</li><li><strong>Step Into（<code>F7</code>）</strong>：若当前行调用了方法，会进入该方法内部继续调试；若为普通语句，则和 <code>Step Over</code> 效果相同。</li><li><strong>Step Out（<code>Shift + F8</code>）</strong>：从当前方法中跳出，继续执行该方法调用处的下一行代码。</li></ul><h4 id="2-查看变量值"><a href="#2-查看变量值" class="headerlink" title="2. 查看变量值"></a>2. 查看变量值</h4><p>程序暂停在断点处时，可在调试窗口的 “Variables” 面板中查看当前作用域内的变量值。该面板会实时显示变量的名称和值，方便开发者了解程序的运行状态。</p><h4 id="3-表达式求值"><a href="#3-表达式求值" class="headerlink" title="3. 表达式求值"></a>3. 表达式求值</h4><p>点击调窗口中带有计算器图标的 “Evaluate Expression” 按钮，可输入表达式并计算其值。例如，输入变量名查看变量值，或输入复杂表达式进行计算。</p><h3 id="断点类型"><a href="#断点类型" class="headerlink" title="断点类型"></a>断点类型</h3><h4 id="1-普通断点"><a href="#1-普通断点" class="headerlink" title="1. 普通断点"></a>1. 普通断点</h4><p>最常用的断点类型，在代码行号旁边单击即可设置，程序执行到该行时会暂停。</p><h4 id="2-条件断点"><a href="#2-条件断点" class="headerlink" title="2. 条件断点"></a>2. 条件断点</h4><p>右键单击已设置的普通断点，选择 “Edit Breakpoint”，在弹出的对话框中设置条件。只有当条件满足时，程序才会在该断点处暂停。例如，在上述代码中，若想在 <code>sum</code> 等于 30 时暂停程序，可在条件框中输入 <code>sum == 30</code>。</p><h4 id="3-方法断点"><a href="#3-方法断点" class="headerlink" title="3. 方法断点"></a>3. 方法断点</h4><p>在方法的声明行（方法名所在行）设置断点，当该方法被调用或者方法返回时，程序会暂停。方法断点用蓝色菱形表示。</p><h4 id="4-字段断点"><a href="#4-字段断点" class="headerlink" title="4. 字段断点"></a>4. 字段断点</h4><p>在类的字段声明行设置断点，当该字段被读取或者写入时，程序会暂停。字段断点用黄色圆点表示。</p><h3 id="高级调试技巧"><a href="#高级调试技巧" class="headerlink" title="高级调试技巧"></a>高级调试技巧</h3><h4 id="1-强制返回"><a href="#1-强制返回" class="headerlink" title="1. 强制返回"></a>1. 强制返回</h4><p>在调试过程中，若想提前结束当前方法的执行并返回指定值，可使用 “Force Return” 功能。在调试窗口中右键单击，选择 “Force Return”，然后输入要返回的值，程序会立即结束当前方法并返回该值。</p><h4 id="2-多线程调试"><a href="#2-多线程调试" class="headerlink" title="2. 多线程调试"></a>2. 多线程调试</h4><p>若程序包含多个线程，IDEA 支持多线程调试。在调试窗口的 “Threads” 面板中，可以查看所有线程的状态，并选择要调试的线程。</p><h4 id="3-日志断点"><a href="#3-日志断点" class="headerlink" title="3. 日志断点"></a>3. 日志断点</h4><p>在一些情况下，可能不需要暂停程序，只需在特定位置输出日志信息。可以使用日志断点，右键单击断点，在 “Log evaluated expression” 中输入要输出的日志信息，程序执行到该断点时会在控制台输出日志，但不会暂停。</p><h1 id="java-语言特点"><a href="#java-语言特点" class="headerlink" title="java 语言特点"></a>java 语言特点</h1><p><img src="/../images/java/1740458407691.png" alt="1740458407691"></p><h1 id="第一个java程序"><a href="#第一个java程序" class="headerlink" title="第一个java程序"></a>第一个java程序</h1><pre><code class="java">public class Hello &#123;    public static void main (String[] args) &#123;        System.out.println(&quot;Hello China&quot;);    &#125;&#125;</code></pre><h2 id="编译及运行"><a href="#编译及运行" class="headerlink" title="编译及运行"></a>编译及运行</h2><h3 id="编译："><a href="#编译：" class="headerlink" title="编译："></a><strong>编译：</strong></h3><p>将写好的代码保存在桌面上，且类名要与保存的文件名要一样。</p><p><strong>例：</strong> </p><p>类名 ：Hello      则文件名 ： Hello.java </p><p>然后在桌面上打开终端，输入javac + 文件名 进行编译</p><p><img src="/../images/java/1740461800775.png" alt="1740461800775"></p><p>此时桌面会得到一个编译后的文件  Hello.class </p><h3 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h3><p>在终端输入 java  +  (.class文件)文件名（不要后缀）</p><p><img src="/../images/java/1740461909477.png" alt="1740461909477"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/../images/java/1740462178975.png" alt="1740462178975"></p><h1 id="java语言基础组成"><a href="#java语言基础组成" class="headerlink" title="java语言基础组成"></a>java语言基础组成</h1><p><img src="/../images/java/1740462493599.png" alt="1740462493599"></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><img src="/../images/java/1740462613227.png" alt="1740462613227"></p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p><img src="/../images/java/1740575654215.png" alt="1740575654215"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="/../images/java/1740575933497.png" alt="1740575933497"></p><p><img src="/../images/java/1740575960520.png" alt="1740575960520"></p><p><strong>类似C</strong></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/../images/java/1740576109560.png" alt="1740576109560"></p><p><strong>与C不同点：</strong></p><p>有新的 byte</p><p>布尔型为  boolean</p><p>只有  long  没有  long long</p><p>且  char  占两个字节，并可以存中文</p><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><p><img src="/../images/java/1740576334165.png" alt="1740576334165"></p><p><strong>一字节  &#x3D;  8bit</strong></p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p><img src="/../images/java/1740576618037.png" alt="1740576618037"></p><p><strong>注意：</strong></p><p><img src="/../images/java/1740576763880.png" alt="1740576763880"></p><p><img src="/../images/java/1740576774228.png" alt="1740576774228"></p><p><strong>加入运算会影响精度</strong></p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p><img src="/../images/java/1740577000379.png" alt="1740577000379"></p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p><img src="/../images/java/1740577893027.png" alt="1740577893027"></p><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p><img src="/../images/java/1740577927233.png" alt="1740577927233"></p><p><img src="/../images/java/1740578765536.png" alt="1740578765536"></p><p><img src="/../images/java/1740578776537.png" alt="1740578776537"></p><p><strong>若运算类型含有字符串那么每个变量类型都转为字符串</strong></p><p><strong>字符串相加代表字符串连接</strong></p><p><img src="/../images/java/1740578924545.png" alt="1740578924545"></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="/../images/java/1740578980886.png" alt="1740578980886"></p><h2 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h2><ul><li><strong>关键字</strong>：是 Java 语言事先定义好的，具有特殊意义的标识符 ，用于表示一种数据类型、程序的结构等，是编译器和程序员的约定。程序员通过关键字告知编译器声明的变量类型、类、方法特性等信息。例如，<code>int</code>用于声明整数类型变量，<code>class</code>用于声明一个类，<code>if</code>用于条件语句等。关键字不能用作变量名、方法名、类名、包名和参数，并且一律用小写字母标识。Java 定义的关键字包括<code>abstract</code>、<code>assert</code>、<code>boolean</code>、<code>break</code> 等。</li><li><strong>保留字</strong>：通常指未来可能会作为关键字使用的一些单词， 目前在 Java 中没有实际的作用，但为了语言的扩展性和兼容性而保留。比如<code>goto</code>、<code>const</code> 以及<code>future</code>、<code>generic</code>、<code>operator</code>、<code>outer</code>、<code>rest</code>、<code>var</code>等，它们也不能作为标识符使用。此外，<code>null</code>、<code>true</code>、<code>false</code>虽常被认为是保留字，但更准确说是文字，包含 Java 定义的值，同样不可作为标识符 。</li></ul><h2 id="标志符"><a href="#标志符" class="headerlink" title="标志符"></a>标志符</h2><p><img src="/../images/java/1740579835980.png" alt="1740579835980"></p><p><strong>说白了就是自己取的名字</strong></p><p><strong>大驼峰（PascalCase）</strong>：</p><ul><li><strong>定义</strong>：每个单词首字母大写，无分隔符。</li><li><strong>用处</strong>：用于类名、接口名等。</li></ul><p><strong>小驼峰（camelCase）</strong>：</p><ul><li><strong>定义</strong>：首个单词首字母小写，后续单词首字母大写，无分隔符。</li><li><strong>用处</strong>：用于变量名、方法名等。</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><img src="/../images/java/1740580424234.png" alt="1740580424234"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>类似C</strong></p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="/../images/java/1740580531413.png" alt="1740580531413"></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="/../images/java/1740580829536.png" alt="1740580829536"></p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><img src="/../images/java/1740580977369.png" alt="1740580977369"></p><h3 id="三元运算符（三目运算）"><a href="#三元运算符（三目运算）" class="headerlink" title="三元运算符（三目运算）"></a>三元运算符（三目运算）</h3><p><img src="/../images/java/1740581133882.png" alt="1740581133882"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="/../images/java/1740581183917.png" alt="1740581183917"></p><h3 id="进制与位运算符"><a href="#进制与位运算符" class="headerlink" title="进制与位运算符"></a>进制与位运算符</h3><p><strong>常见的位运算符介绍：</strong></p><ol><li><strong>按位与（&amp;）</strong>：将两个数的二进制位进行比较，只有对应位都为 1 时，结果位才为 1，否则为 0。比如，5（二进制 0101）&amp; 3（二进制 0011）的结果是 1（二进制 0001）。常用于清零某些位，或者获取特定位的值。</li><li><strong>按位或（|）</strong>：对两个数的二进制位进行比较，只要对应位中有一个为 1，结果位就为 1，只有都为 0 时结果位才为 0。例如，5（二进制 0101）| 3（二进制 0011）的结果是 7（二进制 0111）。可用于设置某些位。</li><li><strong>按位异或（^）</strong>：比较两个数的二进制位，如果对应位不同，结果为 1；如果相同，结果为 0。比如，5（二进制 0101）^ 3（二进制 0011）的结果是 6（二进制 0110） 。可用于交换两个数的值等场景，无需额外变量。</li><li><strong>按位取反（~）</strong>：将一个数的每个二进制位进行反转，0 变 1，1 变 0。例如，~5（二进制 0101）的结果是 - 6（二进制 1010，补码表示）。因为 Java 中整数以补码形式存储，取反后要按补码规则转换为对应数值。</li><li><strong>左移（&lt;&lt;）</strong>：将二进制数向左移动指定的位数，空缺的位置补 0。左移 n 位相当于乘以 2 的 n 次方。比如，5（二进制 0101）&lt;&lt; 1 的结果是 10（二进制 1010） 。</li><li><strong>有符号右移（&gt;&gt;）</strong>：将二进制数向右移动指定的位数，对于负数，符号位（最高位）会被补充到空缺的位中。正数右移 n 位相当于除以 2 的 n 次方（向下取整）。比如，5（二进制 0101）&gt;&gt; 1 的结果是 2（二进制 0010） 。</li><li><strong>无符号右移（&gt;&gt;&gt;）</strong>：将二进制数向右移动指定的位数，不考虑符号位，所有空缺的位都用 0 补充。比如，5（二进制 0101）&gt;&gt;&gt; 1 的结果是 2（二进制 0010） ，常用于处理无符号数，如位图处理等场景。</li></ol><p><strong>位运算符有以下特点：</strong></p><ul><li><strong>运算高效</strong>：直接在硬件级别进行操作，比算术运算符速度更快。</li><li><strong>位移运算与乘除关系</strong>：左移一位相当于乘以 2，移动 n 位相当于乘以 2 的 n 次方；有符号右移一位相当于除以 2，移动 n 位相当于除以 2 的 n 次方（但负数右移时要注意符号位的处理） 。</li></ul><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p><img src="/../images/java/1740581486078.png" alt="1740581486078"></p><h4 id="Hex编码（十六进制编码）"><a href="#Hex编码（十六进制编码）" class="headerlink" title="Hex编码（十六进制编码）"></a>Hex编码（十六进制编码）</h4><p><strong>定义</strong></p><p>Hex 编码，即十六进制编码（Hexadecimal Encoding），是一种用十六进制数字来表示二进制数据的编码方式。在计算机领域，二进制数据是最基础的表现形式，但由于二进制数书写起来过长且不易阅读，而十六进制能更简洁、方便地表示二进制数据，所以被广泛应用。十六进制使用 0 - 9 和 A - F（或 a - f）这 16 个符号来表示数值，其中 A - F 分别对应十进制的 10 - 15。</p><p><strong>原理</strong></p><p>一个字节（Byte）由 8 位（bit）二进制数组成，其取值范围是从 00000000 到 11111111。而每 4 位二进制数可以用一个十六进制数字来表示，因为 4 位二进制数能表示的最大十进制数是 15（二进制 1111），正好对应十六进制的 F。所以一个字节的二进制数据可以用两个十六进制数字来表示。</p><p>例如，二进制数 10101100 可以拆分为 1010 和 1100 两部分，1010 对应的十进制数是 10，十六进制表示为 A；1100 对应的十进制数是 12，十六进制表示为 C。因此，二进制数 10101100 用十六进制编码后就是 AC。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p><strong>类似C</strong></p><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p><img src="/../images/java/1740582597341.png" alt="1740582597341"></p><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><img src="/../images/java/1740582682860.png" alt="1740582682860"></p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><img src="/../images/java/1740582715108.png" alt="1740582715108"></p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><img src="/../images/java/1740582753580.png" alt="1740582753580"></p><h3 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h3><p><img src="/../images/java/1740582794617.png" alt="1740582794617"></p><p><img src="/../images/java/1740583059079.png" alt="1740583059079"></p><p><strong>给循环起名字b</strong></p><p>在<strong>嵌套循环</strong>中， break 和 continue 的作用如下：</p><p><strong>break</strong></p><p> break 语句用于跳出当前所在的循环体，即仅跳出包含该 break 的最内层循环，而不是整个嵌套循环结构。示例代码如下：</p><pre><code class="python">for i in range(3):    for j in range(3):        if j == 1:            break        print(i, j)</code></pre><p>上述代码中，当 j 等于1时， break 会使程序跳出内层 for 循环，继续执行外层 for 循环的下一次迭代，因此不会输出 (0, 1) 、 (1, 1) 、 (2, 1) 。</p><p><strong>continue</strong></p><p> continue 语句用于跳过当前循环的剩余语句，直接开始下一次循环迭代，同样只作用于当前所在的循环层。示例代码如下：</p><pre><code class="python">for i in range(3):    for j in range(3):        if j == 1:            continue        print(i, j)</code></pre><p>在这段代码中，当 j 等于1时， continue 会跳过当前内层循环中 print(i, j) 这一语句，直接进入下一次内层循环，即不会输出 (0, 1) 、 (1, 1) 、 (2, 1) ，但会继续执行其他情况。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>java 数组并不方便，因此后续使用集合</strong></p><p><img src="/../images/java/1740583194527.png" alt="1740583194527"></p><p><img src="/../images/java/1740583249256.png" alt="1740583249256"></p><p><strong>这样也可</strong></p><p><img src="/../images/java/1740583361466.png" alt="1740583361466"></p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p><img src="/../images/java/1740583501523.png" alt="1740583501523"></p><p><img src="/../images/java/1740583564661.png" alt="1740583564661"></p><h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><p><img src="/../images/java/1740661241136.png" alt="1740661241136"></p><p><img src="/../images/java/1740661272806.png" alt="1740661272806"></p><p><strong>将 ints1 赋值给 ints2 是引用传递（c中指针传递，传递首地址）</strong></p><p><img src="/../images/java/1740661334644.png" alt="1740661334644"></p><p><img src="/../images/java/1740661407623.png" alt="1740661407623"></p><p><strong>int[] ints1 是在栈中开辟内存</strong></p><p><strong>ints1 &#x3D; new int[5]  是在堆开辟5个空间再将首地址赋值给ints1</strong></p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p><img src="/../images/java/1740661996604.png" alt="1740661996604"></p><p><img src="/../images/java/1740663595068.png" alt="1740663595068"></p><p><img src="/../images/java/1740663631786.png" alt="1740663631786"></p><p>加入元素</p><p><img src="/../images/java/1740663703428.png" alt="1740663703428"></p><p>反转元素</p><p><img src="/../images/java/1740663950519.png" alt="1740663950519"></p><p><img src="/../images/java/1740663967066.png" alt="1740663967066"></p><p><img src="/../images/java/1740663997184.png" alt="1740663997184"></p><h2 id="java帮助文档的查阅"><a href="#java帮助文档的查阅" class="headerlink" title="java帮助文档的查阅"></a>java帮助文档的查阅</h2><p><img src="/../images/java/1740662612177.png" alt="1740662612177"></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><img src="/../images/java/1740664064218.png" alt="1740664064218"></p><p><strong>新建文件来定义类，因为一个文件只能有一个共有类（其他方面类似C++）</strong></p><p><strong>定义变量也和C++不同</strong></p><p><img src="/../images/java/1740664988967.png" alt="1740664988967"></p><p><img src="/../images/java/1740665144280.png" alt="1740665144280"></p><p><strong>右键类可以并点击Constructor可以让idea自动帮助构建构造函数</strong></p><p><img src="/../images/java/1740665298800.png" alt="1740665298800"></p><p><img src="/../images/java/1740665385855.png" alt="1740665385855"></p><h3 id="方法的定义和调用"><a href="#方法的定义和调用" class="headerlink" title="方法的定义和调用"></a>方法的定义和调用</h3><p><img src="/../images/java/1740665811671.png" alt="1740665811671"></p><p><strong>类内定义函数</strong></p><p><img src="/../images/java/1740666090677.png" alt="1740666090677"></p><p><strong>类外只能调用非静态（非static）的函数</strong></p><h3 id="方法的返回值和参数"><a href="#方法的返回值和参数" class="headerlink" title="方法的返回值和参数"></a>方法的返回值和参数</h3><p><img src="/../images/java/1740666644568.png" alt="1740666644568"></p><h3 id="方法传参机制"><a href="#方法传参机制" class="headerlink" title="方法传参机制"></a>方法传参机制</h3><p><img src="/../images/java/1740722611662.png" alt="1740722611662"></p><p> <strong>Java 的参数传递机制</strong></p><p>Java 采用的是值传递（Pass - by - Value）机制。这意味着当你将一个变量作为参数传递给一个函数时，实际上传递的是该变量的值的副本，而不是变量本身。对于基本数据类型，传递的是其值的副本；对于引用数据类型，传递的是引用（内存地址）的副本。</p><p>String 传递时，在函数中赋值一个新字符串时，是在堆区另外开出空间来存储新字符串，并将字符串地址赋值给 String 变量，当函数结束后释放出新字符串的空间，String 变量获得原字符串地址。</p><p><strong>java代码示例</strong></p><pre><code class="java">public class StringPassingExample &#123;    public static void main(String[] args) &#123;        String original = &quot;Hello&quot;;        System.out.println(&quot;调用 changeString 方法前: &quot; + original);        changeString(original);        System.out.println(&quot;调用 changeString 方法后: &quot; + original);    &#125;    public static void changeString(String str) &#123;        str = &quot;World&quot;;        System.out.println(&quot;方法内部修改后的 str: &quot; + str);    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><strong>调用 <code>changeString</code> 方法前</strong>：在 <code>main</code> 方法中，定义了一个 <code>String</code> 变量 <code>original</code>，其值为 <code>&quot;Hello&quot;</code>。</li><li><strong>调用 <code>changeString</code> 方法时</strong>：将 <code>original</code> 作为参数传递给 <code>changeString</code> 方法。此时，传递的是 <code>original</code> 引用的副本，即该副本指向 <code>&quot;Hello&quot;</code> 这个字符串对象在内存中的地址。</li><li>**方法内部修改 <code>str</code>**：在 <code>changeString</code> 方法内部，将 <code>str</code> 赋值为 <code>&quot;World&quot;</code>。由于 <code>String</code> 是不可变的，这实际上是让 <code>str</code> 这个引用副本指向了一个新的 <code>&quot;World&quot;</code> 字符串对象，而原来的 <code>&quot;Hello&quot;</code> 字符串对象并没有被修改，<code>original</code> 仍然指向 <code>&quot;Hello&quot;</code>。</li><li><strong>调用 <code>changeString</code> 方法后</strong>：在 <code>main</code> 方法中输出 <code>original</code>，其值仍然是 <code>&quot;Hello&quot;</code>，说明 <code>original</code> 本身没有受到 <code>changeString</code> 方法内部操作的影响。</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><img src="/../images/java/1740805529328.png" alt="1740805529328"></p><p><strong>定义</strong></p><ul><li><strong>实例属性</strong>：也称为对象属性，是属于类的每个实例（对象）的属性。每个对象都有自己独立的实例属性副本，这些属性的值可以在不同对象之间有所不同。实例属性在类中定义，但不使用 <code>static</code> 关键字修饰。</li><li><strong>类属性</strong>：也称为静态属性，是属于类本身的属性，而不是属于某个特定的对象。类属性在所有该类的实例之间共享，即无论创建多少个该类的对象，类属性都只有一个副本。类属性使用 <code>static</code> 关键字修饰。</li></ul><pre><code class="java">public class Animal &#123;    // 实例属性    private String name;    private int age;    // 类属性    private static int population;    public Animal(String name, int age) &#123;        this.name = name;        this.age = age;        // 每次创建一个新的 Animal 对象时，增加种群数量        population++;    &#125;    // 获取实例属性 name    public String getName() &#123;        return name;    &#125;    // 获取实例属性 age    public int getAge() &#123;        return age;    &#125;    // 获取类属性 population    public static int getPopulation() &#123;        return population;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><strong>实例属性</strong>：在上述代码中，<code>name</code> 和 <code>age</code> 是实例属性，因为它们没有使用 <code>static</code> 关键字修饰。每个 <code>Animal</code> 对象都有自己的 <code>name</code> 和 <code>age</code> 值，这些值可以在创建对象时通过构造函数进行初始化，并且可以在不同对象之间不同。</li><li><strong>类属性</strong>：<code>population</code> 是类属性，因为它使用了 <code>static</code> 关键字修饰。<code>population</code> 记录了创建的 <code>Animal</code> 对象的总数，所有 <code>Animal</code> 对象共享这个属性。每当创建一个新的 <code>Animal</code> 对象时，<code>population</code> 的值就会增加 1。</li></ul><p><strong>定义</strong></p><ul><li><strong>对象方法（实例方法）</strong>：是属于类的每个实例（对象）的方法，不使用 <code>static</code> 关键字修饰。每个对象都有自己独立的方法调用副本，这些方法可以访问和操作对象的实例属性。</li><li><strong>类方法（静态方法）</strong>：是属于类本身的方法，使用 <code>static</code> 关键字修饰。类方法不依赖于类的任何实例，它可以在不创建对象的情况下直接通过类名调用。</li></ul><pre><code class="java">public class Calculator &#123;    // 实例属性    private int num;    // 构造函数，用于初始化实例属性    public Calculator(int num) &#123;        this.num = num;    &#125;    // 对象方法（实例方法）    public int add(int other) &#123;        return this.num + other;    &#125;    // 类方法（静态方法）    public static int multiply(int a, int b) &#123;        return a * b;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><strong>对象方法</strong>：在上述代码中，<code>add</code> 方法是对象方法，因为它没有使用 <code>static</code> 关键字修饰。<code>add</code> 方法可以访问和操作对象的实例属性 <code>num</code>，它需要通过对象来调用。</li><li><strong>类方法</strong>：<code>multiply</code> 方法是类方法，因为它使用了 <code>static</code> 关键字修饰。<code>multiply</code> 方法不依赖于类的任何实例，它只接受传入的参数进行计算，不需要访问对象的实例属性，可以直接通过类名调用。</li></ul><p><strong>调用方式</strong></p><ul><li><strong>对象方法</strong>：必须通过类的实例（对象）来调用。例如，<code>calculator.add(3)</code> 是通过 <code>calculator</code> 对象来调用 <code>add</code> 方法。</li><li><strong>类方法</strong>：可以直接通过类名调用，也可以通过对象调用（但不推荐，因为这可能会引起混淆）。例如，<code>Calculator.multiply(4, 6)</code> 是通过类名 <code>Calculator</code> 直接调用 <code>multiply</code> 方法。</li></ul><p><strong>访问权限</strong></p><ul><li><p><strong>对象方法</strong>：可以访问和修改对象的实例属性，也可以调用其他对象方法和类方法。</p></li><li><p><strong>类方法</strong>：不能直接访问对象的实例属性和调用对象方法，因为类方法不依赖于任何对象。但类方法可以访问和修改类属性，也可以调用其他类方法。</p></li></ul><p>引用类型比较一般用equals</p><p><img src="/../images/java/1740807781357.png" alt="1740807781357"></p><p>比较存放内容</p><p><img src="/../images/java/1740808183985.png" alt="1740808183985"></p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p><img src="/../images/java/1740808501147.png" alt="1740808501147"></p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p><img src="/../images/java/1740809043333.png" alt="1740809043333"></p><p><img src="/../images/java/1740809320928.png" alt="1740809320928"></p><p><img src="/../images/java/1740809256927.png" alt="1740809256927"></p><p>可变参数只能有一个并且必须放在最后一个参数位置</p><p>或者可以直接传入数组</p><p><img src="/../images/java/1740809393666.png" alt="1740809393666"></p><h3 id="构造器（构造函数）"><a href="#构造器（构造函数）" class="headerlink" title="构造器（构造函数）"></a>构造器（构造函数）</h3><p><img src="/../images/java/1740809605223.png" alt="1740809605223"></p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p><img src="/../images/java/1740828827015.png" alt="1740828827015"></p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><img src="/../images/java/1740829859933.png" alt="1740829859933"></p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p><img src="/../images/java/1740830885877.png" alt="1740830885877"></p><p> 在 Java 中，包（package）是一种对类和接口等进行组织和管理的机制，它有助于避免命名冲突、便于代码的维护和共享。 </p><p><strong>作用</strong></p><ul><li><strong>避免命名冲突</strong>：在大型项目中，可能会有很多类，如果都放在同一个命名空间下，很容易出现类名冲突的情况。通过将类放在不同的包中，可以确保不同包中的类即使名称相同也不会产生冲突。</li><li><strong>便于代码组织和管理</strong>：将相关的类和接口放在同一个包中，能够使代码结构更加清晰，易于理解和维护。比如，所有与数据库操作相关的类可以放在一个名为<code>db</code>的包中，所有与用户界面相关的类可以放在<code>ui</code>包中。</li><li><strong>控制访问权限</strong>：包可以控制类、方法和变量等的访问权限。在 Java 中，默认情况下，如果没有使用<code>public</code>、<code>private</code>或<code>protected</code>修饰符，那么类、方法和变量在同一个包内是可以访问的，而在包外则不能访问。</li></ul><p><strong>定义包</strong></p><p>在 Java 源文件的开头使用<code>package</code>关键字来定义包。例如：</p><pre><code class="java">package com.example.myapp;public class MyClass &#123;    // 类的内容&#125;</code></pre><p>这表示<code>MyClass</code>类属于<code>com.example.myapp</code>包。需要注意的是，包名一般采用小写字母，且通常遵循域名倒置的规则，以确保唯一性。比如，如果你的网站域名是<code>example.com</code>，那么你的包名可以是<code>com.example</code>开头。</p><p><strong>导入包</strong></p><p>当需要使用其他包中的类时，需要使用<code>import</code>关键字导入包。例如：</p><pre><code class="java">package com.example.main;import com.example.myapp.MyClass;public class Main &#123;    public static void main(String[] args) &#123;        MyClass myClass = new MyClass();    &#125;&#125;</code></pre><p>也可以使用通配符<code>*</code>来导入整个包中的所有类：</p><pre><code class="java">package com.example.main;import com.example.myapp.*;public class Main &#123;    public static void main(String[] args) &#123;        MyClass myClass = new MyClass();    &#125;&#125;</code></pre><p>也可以不用import直接用包中的类（包内类与包外类重名时也只能这么用）：</p><p><img src="/../images/java/1740832099375.png" alt="1740832099375"></p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p><img src="/../images/java/1740842682147.png" alt="1740842682147"></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><img src="/../images/java/1740922314336.png" alt="1740922314336"></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>按 <code>Ctrl + h</code>可以在idea中看到类的继承关系</strong></p><p><img src="/../images/java/1740922861761.png" alt="1740922861761"></p><p><strong>继承的基本语法</strong></p><p>在 Java 中，使用 <code>extends</code> 关键字来实现继承。以下是一个简单的示例：</p><pre><code class="java">// 定义父类class Animal &#123;    String name;    public void eat() &#123;        System.out.println(name + &quot; 正在吃东西&quot;);    &#125;&#125;// 定义子类，继承自 Animal 类class Dog extends Animal &#123;    public void bark() &#123;        System.out.println(name + &quot; 正在汪汪叫&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.name = &quot;旺财&quot;;        dog.eat();        dog.bark();    &#125;&#125;</code></pre><p>在上述代码中，<code>Dog</code> 类继承了 <code>Animal</code> 类，因此 <code>Dog</code> 类可以使用 <code>Animal</code> 类中定义的 <code>name</code> 属性和 <code>eat()</code> 方法，同时还可以有自己特有的方法 <code>bark()</code>。</p><p><strong>继承的特点</strong></p><ol><li><strong>单继承</strong>：Java 只支持单继承，即一个子类只能有一个直接父类。这有助于避免多继承带来的复杂问题，如菱形继承问题。不过，Java 支持多层继承，即一个子类可以有父类，父类还可以有自己的父类。</li><li><strong>传递性</strong>：如果 <code>C</code> 类继承自 <code>B</code> 类，<code>B</code> 类继承自 <code>A</code> 类，那么 <code>C</code> 类就拥有 <code>B</code> 类和 <code>A</code> 类的所有可继承的属性和方法。</li></ol><p><strong>访问父类成员</strong></p><p>在子类中，可以使用 <code>super</code> 关键字来访问父类的成员，包括属性和方法。例如：</p><pre><code class="java">class Animal &#123;    String name = &quot;动物&quot;;    public void eat() &#123;        System.out.println(&quot;动物正在吃东西&quot;);    &#125;&#125;class Dog extends Animal &#123;    String name = &quot;旺财&quot;;    public void showInfo() &#123;        // 访问父类的属性        System.out.println(super.name);        // 调用父类的方法        super.eat();    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.showInfo();    &#125;&#125;</code></pre><p>在 <code>Dog</code> 类的 <code>showInfo()</code> 方法中，使用 <code>super.name</code> 访问了父类的 <code>name</code> 属性，使用 <code>super.eat()</code> 调用了父类的 <code>eat()</code> 方法。</p><p><strong>方法重写（Override）</strong></p><p>子类可以重写父类的方法，即子类提供与父类方法具有相同名称、参数列表和返回类型的方法实现。重写方法时，需要使用 <code>@Override</code> 注解来确保重写的正确性。例如：</p><pre><code class="java">class Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;class Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        dog.makeSound();    &#125;&#125;</code></pre><p>在上述代码中，<code>Dog</code> 类重写了 <code>Animal</code> 类的 <code>makeSound()</code> 方法，当调用 <code>dog.makeSound()</code> 时，会执行 <code>Dog</code> 类中重写后的方法。</p><p><strong>构造方法的继承</strong></p><p>子类不会继承父类的构造方法，但子类的构造方法中会默认调用父类的无参构造方法。如果父类没有无参构造方法，子类的构造方法中必须使用 <code>super()</code> 显式调用父类的有参构造方法。例如：</p><pre><code class="java">class Animal &#123;    String name;    public Animal(String name) &#123;        this.name = name;    &#125;&#125;class Dog extends Animal &#123;    public Dog(String name) &#123;        // 显式调用父类的构造方法        super(name);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog(&quot;旺财&quot;);        System.out.println(dog.name);    &#125;&#125;</code></pre><p>在 <code>Dog</code> 类的构造方法中，使用 <code>super(name)</code> 调用了父类 <code>Animal</code> 的构造方法，以初始化从父类继承的 <code>name</code> 属性。</p><h4 id="父类构造器"><a href="#父类构造器" class="headerlink" title="父类构造器"></a>父类构造器</h4><p><img src="/../images/java/1740923961213.png" alt="1740923961213"></p><h4 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h4><p><img src="/../images/java/1740924652916.png" alt="1740924652916"></p><p> 需注意的是，<code>super()</code> 调用父类构造方法的语句必须是子类构造方法中的第一条语句。 </p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p><img src="/../images/java/1741005932153.png" alt="1741005932153"></p><h5 id="定义和基本语法"><a href="#定义和基本语法" class="headerlink" title="定义和基本语法"></a>定义和基本语法</h5><p>方法重写是指在子类中定义一个与父类中具有相同名称、参数列表和返回类型的方法。子类通过重写父类的方法，可以提供自己的实现逻辑。其基本语法如下：</p><pre><code class="java">// 父类class Parent &#123;    public void display() &#123;        System.out.println(&quot;这是父类的 display 方法&quot;);    &#125;&#125;// 子类class Child extends Parent &#123;    @Override    public void display() &#123;        System.out.println(&quot;这是子类重写后的 display 方法&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Child child = new Child();        child.display();     &#125;&#125;</code></pre><p>在上述代码中，<code>Child</code> 类重写了 <code>Parent</code> 类的 <code>display</code> 方法。当调用 <code>child.display()</code> 时，会执行子类中重写后的方法。</p><h5 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h5><ol><li><strong>方法签名必须相同</strong>：方法名、参数列表必须与父类中被重写的方法完全一致。</li><li><strong>返回类型必须兼容</strong>：子类重写方法的返回类型必须与父类被重写方法的返回类型相同，或者是其子类型（从 Java 5 开始支持协变返回类型）。 </li><li><strong>访问修饰符限制</strong>：子类重写方法的访问修饰符不能比父类被重写方法的访问修饰符更严格。例如，如果父类方法是 <code>public</code> 的，子类重写方法不能是 <code>protected</code> 或 <code>private</code> 的。 </li><li><strong>异常抛出限制</strong>：子类重写方法抛出的异常不能比父类被重写方法抛出的异常更宽泛。即子类重写方法可以不抛出异常，或者抛出与父类相同的异常，或者抛出父类异常的子类异常。</li></ol><h5 id="Override-注解"><a href="#Override-注解" class="headerlink" title="@Override 注解"></a><code>@Override</code> 注解</h5><p><code>@Override</code> 是 Java 中的一个注解，用于显式地表明一个方法是重写父类的方法。虽然这个注解不是必需的，但使用它可以让编译器进行检查，如果方法不符合重写规则，编译器会报错，有助于避免一些潜在的错误。例如：</p><pre><code class="java">class Parent &#123;    public void test() &#123;        System.out.println(&quot;父类的 test 方法&quot;);    &#125;&#125;class Child extends Parent &#123;    // 若此处方法名拼写错误，使用 @Override 注解编译器会报错    @Override    public void test() &#123;        System.out.println(&quot;子类重写的 test 方法&quot;);    &#125;&#125;</code></pre><h5 id="调用父类被重写的方法"><a href="#调用父类被重写的方法" class="headerlink" title="调用父类被重写的方法"></a>调用父类被重写的方法</h5><p>在子类的重写方法中，可以使用 <code>super</code> 关键字来调用父类被重写的方法。例如：</p><pre><code class="java">class Parent &#123;    public void show() &#123;        System.out.println(&quot;父类的 show 方法&quot;);    &#125;&#125;class Child extends Parent &#123;    @Override    public void show() &#123;        super.show();         System.out.println(&quot;子类重写的 show 方法&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Child child = new Child();        child.show();    &#125;&#125;</code></pre><p>在 <code>Child</code> 类的 <code>show</code> 方法中，使用 <code>super.show()</code> 调用了父类的 <code>show</code> 方法，然后再执行子类自己的逻辑。</p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p><img src="/../images/java/1741006598498.png" alt="1741006598498"></p><p><img src="/../images/java/1741007322051.png" alt="1741007322051"></p><h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><p><strong>定义</strong></p><p>静态代码块是用花括号 <code>&#123;&#125;</code> 括起来的一段代码，但它使用 <code>static</code> 关键字修饰，并且直接定义在类中。示例如下：</p><pre><code class="java">public class StaticBlockExample &#123;    // 静态代码块    static &#123;        System.out.println(&quot;这是静态代码块&quot;);    &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;这是 main 方法&quot;);    &#125;&#125;</code></pre><p><strong>执行时机</strong></p><p>静态代码块在类被加载时执行，并且只执行一次。类的加载是在程序运行过程中，当第一次使用该类时（如创建对象、调用静态方法、访问静态属性等）由 Java 虚拟机（JVM）进行的操作。</p><h5 id="普通代码块（实例代码块）"><a href="#普通代码块（实例代码块）" class="headerlink" title="普通代码块（实例代码块）"></a>普通代码块（实例代码块）</h5><p><strong>定义</strong></p><p>普通代码块是用花括号 <code>&#123;&#125;</code> 括起来的一段代码，它没有任何修饰符，并且直接定义在类中，但不在任何方法内部。示例如下：</p><pre><code class="java">public class InstanceBlockExample &#123;    // 普通代码块    &#123;        System.out.println(&quot;这是普通代码块&quot;);    &#125;    public InstanceBlockExample() &#123;        System.out.println(&quot;这是构造方法&quot;);    &#125;    public static void main(String[] args) &#123;        InstanceBlockExample obj = new InstanceBlockExample();    &#125;&#125;</code></pre><p><strong>执行时机</strong></p><p>普通代码块会在创建对象时执行，并且在构造方法之前执行。如果创建多个对象，普通代码块会在每次创建对象时都执行一次。</p><p><strong>使用场景</strong></p><p>普通代码块常用于在创建对象时进行一些通用的初始化操作，这些操作可能在多个构造方法中都需要执行，将其放在普通代码块中可以避免代码重复。例如：</p><pre><code class="java">public class Person &#123;    private String name;    private int age;    &#123;        // 初始化日志记录等操作        System.out.println(&quot;开始创建 Person 对象&quot;);    &#125;    public Person() &#123;        this.name = &quot;Unknown&quot;;        this.age = 0;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;</code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><img src="/../images/java/1741180690729.png" alt="1741180690729"></p><p><strong><code>instanceOf</code> 判断</strong></p><p><img src="/../images/java/1741181812077.png" alt="1741181812077"></p><p><strong>多态的概念</strong></p><p>多态意味着一个对象可以有多种形态。具体来说，在程序运行时，同一个方法调用可以根据实际对象的类型产生不同的行为。多态通过将父类类型的引用指向子类对象，在调用方法时根据实际对象的类型来确定执行哪个子类的方法。</p><p><strong>实现多态的条件</strong></p><ol><li><strong>继承关系</strong>：需要有父类和子类之间的继承关系。</li><li><strong>方法重写</strong>：子类需要重写父类的方法，以实现不同的行为。</li><li><strong>父类引用指向子类对象</strong>：使用父类类型的引用指向子类的对象，通过该引用调用重写的方法。</li></ol><p><strong>多态的实现方式</strong></p><p><strong>1.基于继承的多态</strong></p><p>通过子类继承父类，并重写父类的方法，然后使用父类引用指向子类对象来实现多态。</p><pre><code class="java">// 定义父类 Animalclass Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;// 定义子类 Dog，继承自 Animalclass Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;// 定义子类 Cat，继承自 Animalclass Cat extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;public class PolymorphismExample &#123;    public static void main(String[] args) &#123;        // 父类引用指向子类对象        Animal dog = new Dog();        Animal cat = new Cat();        // 调用重写的方法，实现多态        dog.makeSound();         cat.makeSound();     &#125;&#125;</code></pre><p><strong>代码解释</strong>：</p><ul><li><code>Animal</code> 是父类，包含一个 <code>makeSound</code> 方法。</li><li><code>Dog</code> 和 <code>Cat</code> 是 <code>Animal</code> 的子类，分别重写了 <code>makeSound</code> 方法。</li><li>在 <code>main</code> 方法中，使用 <code>Animal</code> 类型的引用指向 <code>Dog</code> 和 <code>Cat</code> 对象，调用 <code>makeSound</code> 方法时，根据实际对象的类型执行相应的方法。</li></ul><p><strong>2. 基于接口的多态</strong></p><p>通过实现接口，不同的类可以实现相同的接口方法，然后使用接口类型的引用指向实现类的对象来实现多态。</p><pre><code class="java">// 定义接口 Shapeinterface Shape &#123;    double area();&#125;// 定义实现类 Circle，实现 Shape 接口class Circle implements Shape &#123;    private double radius;    public Circle(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double area() &#123;        return Math.PI * radius * radius;    &#125;&#125;// 定义实现类 Rectangle，实现 Shape 接口class Rectangle implements Shape &#123;    private double length;    private double width;    public Rectangle(double length, double width) &#123;        this.length = length;        this.width = width;    &#125;    @Override    public double area() &#123;        return length * width;    &#125;&#125;public class InterfacePolymorphismExample &#123;    public static void main(String[] args) &#123;        // 接口引用指向实现类对象        Shape circle = new Circle(5);        Shape rectangle = new Rectangle(4, 6);        // 调用接口方法，实现多态        System.out.println(&quot;圆的面积: &quot; + circle.area());        System.out.println(&quot;矩形的面积: &quot; + rectangle.area());    &#125;&#125;</code></pre><p><strong>代码解释</strong>：</p><ul><li><code>Shape</code> 是一个接口，定义了一个抽象方法 <code>area</code>。</li><li><code>Circle</code> 和 <code>Rectangle</code> 是实现 <code>Shape</code> 接口的类，分别实现了 <code>area</code> 方法。</li><li>在 <code>main</code> 方法中，使用 <code>Shape</code> 类型的引用指向 <code>Circle</code> 和 <code>Rectangle</code> 对象，调用 <code>area</code> 方法时，根据实际对象的类型执行相应的方法。</li></ul><p><strong>强制向下转型</strong></p><p>可以调用子类属性和子类特有方法。</p><p><img src="/../images/java/1741181653325.png" alt="1741181653325"></p><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a><strong>多态数组</strong></h4><p><img src="/../images/java/1741181900887.png" alt="1741181900887"></p><h5 id="基于继承的多态数组"><a href="#基于继承的多态数组" class="headerlink" title="基于继承的多态数组"></a>基于继承的多态数组</h5><p>示例代码</p><pre><code class="java">// 定义父类 Animalclass Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;// 定义子类 Dog，继承自 Animalclass Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;// 定义子类 Cat，继承自 Animalclass Cat extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;public class InheritancePolymorphicArray &#123;    public static void main(String[] args) &#123;        // 创建一个 Animal 类型的数组，该数组可以存储 Animal 及其子类的对象        Animal[] animals = new Animal[2];        animals[0] = new Dog();        animals[1] = new Cat();        // 遍历数组，调用 makeSound 方法，实现多态        for (Animal animal : animals) &#123;            animal.makeSound();        &#125;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ol><li><strong>定义父类和子类</strong>：定义了一个父类 <code>Animal</code>，其中包含 <code>makeSound</code> 方法。<code>Dog</code> 和 <code>Cat</code> 类继承自 <code>Animal</code> 类，并重写了 <code>makeSound</code> 方法，以实现不同的行为。</li><li><strong>创建多态数组</strong>：创建了一个 <code>Animal</code> 类型的数组 <code>animals</code>，该数组可以存储 <code>Animal</code> 类及其子类的对象。</li><li><strong>存储不同子类对象</strong>：将 <code>Dog</code> 和 <code>Cat</code> 类的对象分别存储到数组的不同位置。</li><li><strong>遍历数组并调用方法</strong>：使用增强 <code>for</code> 循环遍历数组，调用 <code>makeSound</code> 方法。由于数组元素是 <code>Animal</code> 类型的引用，但实际指向的是 <code>Dog</code> 和 <code>Cat</code> 对象，因此会根据实际对象的类型调用相应的 <code>makeSound</code> 方法，实现多态。</li></ol><h5 id="基于接口的多态数组"><a href="#基于接口的多态数组" class="headerlink" title="基于接口的多态数组"></a>基于接口的多态数组</h5><p>示例代码</p><pre><code class="java">// 定义接口 Shapeinterface Shape &#123;    double area();&#125;// 定义实现类 Circle，实现 Shape 接口class Circle implements Shape &#123;    private double radius;    public Circle(double radius) &#123;        this.radius = radius;    &#125;    @Override    public double area() &#123;        return Math.PI * radius * radius;    &#125;&#125;// 定义实现类 Rectangle，实现 Shape 接口class Rectangle implements Shape &#123;    private double length;    private double width;    public Rectangle(double length, double width) &#123;        this.length = length;        this.width = width;    &#125;    @Override    public double area() &#123;        return length * width;    &#125;&#125;public class InterfacePolymorphicArray &#123;    public static void main(String[] args) &#123;        // 创建一个 Shape 类型的数组，该数组可以存储实现 Shape 接口的类的对象        Shape[] shapes = new Shape[2];        shapes[0] = new Circle(5);        shapes[1] = new Rectangle(4, 6);        // 遍历数组，调用 area 方法，实现多态        for (Shape shape : shapes) &#123;            System.out.println(&quot;该图形的面积是: &quot; + shape.area());        &#125;    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ol><li><strong>定义接口和实现类</strong>：定义了一个接口 <code>Shape</code>，其中包含抽象方法 <code>area</code>。<code>Circle</code> 和 <code>Rectangle</code> 类实现了 <code>Shape</code> 接口，并实现了 <code>area</code> 方法，以计算不同形状的面积。</li><li><strong>创建多态数组</strong>：创建了一个 <code>Shape</code> 类型的数组 <code>shapes</code>，该数组可以存储实现 <code>Shape</code> 接口的类的对象。</li><li><strong>存储不同实现类对象</strong>：将 <code>Circle</code> 和 <code>Rectangle</code> 类的对象分别存储到数组的不同位置。</li><li><strong>遍历数组并调用方法</strong>：使用增强 <code>for</code> 循环遍历数组，调用 <code>area</code> 方法。由于数组元素是 <code>Shape</code> 类型的引用，但实际指向的是 <code>Circle</code> 和 <code>Rectangle</code> 对象，因此会根据实际对象的类型调用相应的 <code>area</code> 方法，实现多态。</li></ol><h4 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h4><p><img src="/../images/java/1741182900629.png" alt="1741182900629"></p><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>在 Java 中，当通过父类引用调用一个被重写的方法时，编译阶段编译器会根据引用的类型（即父类类型）来检查方法是否存在，但在运行阶段，Java 虚拟机（JVM）会根据引用实际指向的对象类型（即子类类型）来决定调用哪个类的方法。这种在运行时确定调用方法的机制就是动态绑定。</p><h5 id="实现动态绑定的条件"><a href="#实现动态绑定的条件" class="headerlink" title="实现动态绑定的条件"></a>实现动态绑定的条件</h5><ol><li><strong>继承关系</strong>：存在父类和子类的继承关系，子类继承自父类。</li><li><strong>方法重写</strong>：子类重写了父类的方法，即子类定义了与父类中具有相同签名（方法名、参数列表和返回类型）的方法。</li><li><strong>父类引用指向子类对象</strong>：使用父类类型的引用变量来引用子类的对象。</li></ol><p>示例代码</p><pre><code class="java">// 定义父类 Animalclass Animal &#123;    public void makeSound() &#123;        System.out.println(&quot;动物发出声音&quot;);    &#125;&#125;// 定义子类 Dog，继承自 Animalclass Dog extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;// 定义子类 Cat，继承自 Animalclass Cat extends Animal &#123;    @Override    public void makeSound() &#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;public class DynamicBindingExample &#123;    public static void main(String[] args) &#123;        // 父类引用指向子类对象        Animal dog = new Dog();        Animal cat = new Cat();        // 调用 makeSound 方法，发生动态绑定        dog.makeSound();        cat.makeSound();    &#125;&#125;</code></pre><p>代码解释</p><ol><li><strong>定义父类和子类</strong>：定义了一个父类 <code>Animal</code>，其中包含 <code>makeSound</code> 方法。<code>Dog</code> 和 <code>Cat</code> 类继承自 <code>Animal</code> 类，并重写了 <code>makeSound</code> 方法，以实现不同的行为。</li><li><strong>父类引用指向子类对象</strong>：在 <code>main</code> 方法中，创建了 <code>Animal</code> 类型的引用变量 <code>dog</code> 和 <code>cat</code>，分别指向 <code>Dog</code> 和 <code>Cat</code> 类的对象。</li><li><strong>动态绑定过程</strong>：<ul><li>编译阶段：编译器根据引用类型 <code>Animal</code> 检查 <code>makeSound</code> 方法是否存在，由于 <code>Animal</code> 类中定义了该方法，编译通过。</li><li>运行阶段：JVM 根据引用实际指向的对象类型（<code>Dog</code> 或 <code>Cat</code>）来决定调用哪个类的 <code>makeSound</code> 方法。因此，<code>dog.makeSound()</code> 会调用 <code>Dog</code> 类的 <code>makeSound</code> 方法，输出 “汪汪汪”；<code>cat.makeSound()</code> 会调用 <code>Cat</code> 类的 <code>makeSound</code> 方法，输出 “喵喵喵”。</li></ul></li></ol><p><strong>注意事项</strong></p><ul><li><strong>静态方法和私有方法不参与动态绑定</strong>：静态方法属于类，而不是对象，它们在编译时就已经确定了调用关系，不依赖于对象的实际类型。私有方法不能被重写，因此也不会发生动态绑定。例如：</li></ul><pre><code class="java">class Parent &#123;    public static void staticMethod() &#123;        System.out.println(&quot;父类的静态方法&quot;);    &#125;    private void privateMethod() &#123;        System.out.println(&quot;父类的私有方法&quot;);    &#125;&#125;class Child extends Parent &#123;    public static void staticMethod() &#123;        System.out.println(&quot;子类的静态方法&quot;);    &#125;    // 这里并不是重写父类的私有方法，因为私有方法不能被重写    private void privateMethod() &#123;        System.out.println(&quot;子类的私有方法&quot;);    &#125;&#125;public class StaticAndPrivateMethodExample &#123;    public static void main(String[] args) &#123;        Parent parent = new Child();        parent.staticMethod(); // 调用父类的静态方法        // parent.privateMethod(); // 编译错误，私有方法不能被外部访问    &#125;&#125;</code></pre><p>在上述代码中，<code>staticMethod</code> 是静态方法，<code>parent.staticMethod()</code> 调用的是父类的静态方法，而不是子类的静态方法；<code>privateMethod</code> 是私有方法，不参与动态绑定。</p><h5 id="静态属性和方法的-“继承”-与实例属性和方法继承的区别"><a href="#静态属性和方法的-“继承”-与实例属性和方法继承的区别" class="headerlink" title="静态属性和方法的 “继承” 与实例属性和方法继承的区别"></a>静态属性和方法的 “继承” 与实例属性和方法继承的区别</h5><p><strong>方法重写方面</strong></p><p>普通的实例方法可以在子类中被重写（override），实现多态；而静态方法不能被重写，当子类中定义了和父类相同签名的静态方法时，这被称为方法隐藏（method hiding），而不是方法重写。</p><p><strong>调用时的绑定机制</strong></p><p>实例方法的调用是动态绑定的，在运行时根据对象的实际类型来确定调用哪个类的方法；而静态方法的调用是静态绑定的，在编译时就根据引用类型确定要调用的方法。</p><h3 id="默认父类方法"><a href="#默认父类方法" class="headerlink" title="默认父类方法"></a>默认父类方法</h3><p><img src="/../images/java/1741185187271.png" alt="1741185187271"></p><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p><img src="/../images/java/1741185171198.png" alt="1741185171198"></p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p><img src="/../images/java/1741185982777.png" alt="1741185982777"></p><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p><img src="/../images/java/1741185995421.png" alt="1741185995421"></p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><img src="/../images/java/1741254352036.png" alt="1741254352036"></p><h4 id="定义抽象类"><a href="#定义抽象类" class="headerlink" title="定义抽象类"></a>定义抽象类</h4><p>在 Java 中，使用 <code>abstract</code> 关键字来定义抽象类。抽象类不能被实例化，也就是不能使用 <code>new</code> 关键字来创建抽象类的对象，它主要用于被其他类继承。</p><pre><code class="java">// 定义一个抽象类 Animalabstract class Animal &#123;    // 成员变量    protected String name;    // 构造方法    public Animal(String name) &#123;        this.name = name;    &#125;    // 普通方法    public void eat() &#123;        System.out.println(name + &quot; 正在吃东西&quot;);    &#125;    // 抽象方法，没有方法体    public abstract void makeSound();&#125;</code></pre><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>抽象类中可以包含抽象方法，抽象方法使用 <code>abstract</code> 关键字修饰，并且没有方法体。抽象方法的作用是定义一个规范，要求子类必须实现这个方法。</p><pre><code class="java">// 抽象方法示例public abstract void makeSound();</code></pre><h4 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h4><p>子类继承抽象类时，必须实现抽象类中的所有抽象方法，否则子类也必须被声明为抽象类。</p><pre><code class="java">// 定义 Dog 类继承自 Animal 抽象类class Dog extends Animal &#123;    public Dog(String name) &#123;        super(name);    &#125;    // 实现抽象方法 makeSound    @Override    public void makeSound() &#123;        System.out.println(name + &quot; 汪汪叫&quot;);    &#125;&#125;// 定义 Cat 类继承自 Animal 抽象类class Cat extends Animal &#123;    public Cat(String name) &#123;        super(name);    &#125;    // 实现抽象方法 makeSound    @Override    public void makeSound() &#123;        System.out.println(name + &quot; 喵喵叫&quot;);    &#125;&#125;</code></pre><h4 id="使用抽象类"><a href="#使用抽象类" class="headerlink" title="使用抽象类"></a>使用抽象类</h4><p>虽然抽象类不能被实例化，但可以使用抽象类的引用指向子类的对象，从而实现多态。</p><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        // 抽象类的引用指向子类对象        Animal dog = new Dog(&quot;旺财&quot;);        Animal cat = new Cat(&quot;咪咪&quot;);        // 调用普通方法        dog.eat();        cat.eat();        // 调用抽象方法（多态）        dog.makeSound();        cat.makeSound();    &#125;&#125;</code></pre><h4 id="抽象类的特点和使用场景"><a href="#抽象类的特点和使用场景" class="headerlink" title="抽象类的特点和使用场景"></a>抽象类的特点和使用场景</h4><ul><li><strong>特点</strong><ul><li><strong>不能实例化</strong>：抽象类不能使用 <code>new</code> 关键字创建对象，只能作为父类被继承。</li><li><strong>可以包含抽象方法和普通方法</strong>：抽象类中既可以有抽象方法，也可以有普通方法，这样可以提供一些通用的实现，同时要求子类实现特定的行为。</li><li><strong>构造方法</strong>：抽象类可以有构造方法，用于初始化成员变量，但不能通过构造方法直接创建抽象类的对象，构造方法主要用于子类调用。</li></ul></li><li><strong>使用场景</strong><ul><li><strong>定义通用行为和规范</strong>：当多个类有一些共同的行为和属性时，可以将这些共同的部分提取到抽象类中，同时定义一些抽象方法，要求子类根据自身的特点去实现这些方法。</li><li><strong>实现多态</strong>：通过抽象类的引用指向子类的对象，可以实现多态，提高代码的灵活性和可扩展性。</li></ul></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="/../images/java/1741265807966.png" alt="1741265807966"></p><p><img src="/../images/java/1741266765499.png" alt="1741266765499"></p><h4 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h4><p>在 Java 中，使用 <code>interface</code> 关键字来定义接口，接口中的方法默认是 <code>public abstract</code> 类型（即抽象方法），字段默认是 <code>public static final</code> 类型（即常量）。</p><pre><code class="java">// 定义一个接口 Animalinterface Animal &#123;    // 常量    int LEGS = 4;    // 抽象方法    void eat();    void makeSound();&#125;</code></pre><ul><li><strong>不能实例化</strong>：接口不能使用 <code>new</code> 关键字创建对象，它主要用于被类实现或者被其他接口继承。</li><li><strong>抽象方法</strong>：接口中的方法默认是抽象方法，不需要使用 <code>abstract</code> 关键字修饰，而且这些方法必须由实现类来实现。</li><li><strong>常量</strong>：接口中的字段默认是常量，即 <code>public static final</code> 类型，必须在定义时进行初始化，且初始化后不能再修改。</li><li><strong>多实现</strong>：一个类可以实现多个接口，从而实现多重继承的效果，这弥补了 Java 类只能单继承的局限性。</li></ul><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><p>类通过 <code>implements</code> 关键字来实现接口，实现接口的类必须实现接口中定义的所有抽象方法。</p><pre><code class="java">// 定义 Dog 类实现 Animal 接口class Dog implements Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;狗在吃东西&quot;);    &#125;    @Override    public void makeSound() &#123;        System.out.println(&quot;狗汪汪叫&quot;);    &#125;&#125;// 定义 Cat 类实现 Animal 接口class Cat implements Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;猫在吃东西&quot;);    &#125;    @Override    public void makeSound() &#123;        System.out.println(&quot;猫喵喵叫&quot;);    &#125;&#125;</code></pre><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>接口可以继承其他接口，使用 <code>extends</code> 关键字，一个接口可以继承多个接口。</p><pre><code class="java">// 定义一个新的接口 Pet，继承自 Animal 接口interface Pet extends Animal &#123;    void play();&#125;// 定义 Dog 类实现 Pet 接口class Dog implements Pet &#123;    @Override    public void eat() &#123;        System.out.println(&quot;狗在吃东西&quot;);    &#125;    @Override    public void makeSound() &#123;        System.out.println(&quot;狗汪汪叫&quot;);    &#125;    @Override    public void play() &#123;        System.out.println(&quot;狗在玩耍&quot;);    &#125;&#125;</code></pre><h4 id="接口的使用场景"><a href="#接口的使用场景" class="headerlink" title="接口的使用场景"></a>接口的使用场景</h4><ul><li><strong>定义规范</strong>：接口可以定义一组规范，让不同的类去实现这些规范，从而保证这些类具有相同的行为。例如，Java 中的 <code>Runnable</code> 接口，任何实现该接口的类都必须实现 <code>run</code> 方法，这样就可以将这些类的对象作为线程任务来执行。</li><li><strong>实现多态</strong>：通过接口的引用指向实现类的对象，可以实现多态，提高代码的灵活性和可扩展性。</li></ul><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        // 接口的引用指向实现类对象        Animal dog = new Dog();        Animal cat = new Cat();        // 调用接口方法（多态）        dog.eat();        dog.makeSound();        cat.eat();        cat.makeSound();    &#125;&#125;</code></pre><h4 id="Java-8-及以后接口的新特性"><a href="#Java-8-及以后接口的新特性" class="headerlink" title="Java 8 及以后接口的新特性"></a>Java 8 及以后接口的新特性</h4><ul><li><strong>默认方法</strong>：Java 8 引入了默认方法，使用 <code>default</code> 关键字修饰，默认方法可以有方法体，实现类可以选择是否重写默认方法。</li></ul><pre><code class="java">interface Animal &#123;    void eat();    void makeSound();    // 默认方法    default void sleep() &#123;        System.out.println(&quot;动物在睡觉&quot;);    &#125;&#125;</code></pre><ul><li><strong>静态方法</strong>：Java 8 还允许接口中定义静态方法，静态方法使用 <code>static</code> 关键字修饰，通过接口名直接调用。</li></ul><pre><code class="java">interface Animal &#123;    void eat();    void makeSound();    // 静态方法    static void info() &#123;        System.out.println(&quot;这是一个动物接口&quot;);    &#125;&#125;</code></pre><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><img src="/../images/java/1741351878282.png" alt="1741351878282"></p><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p><img src="/../images/java/1741352159174.png" alt="1741352159174"></p><h5 id="定义成员内部类"><a href="#定义成员内部类" class="headerlink" title="定义成员内部类"></a>定义成员内部类</h5><p>成员内部类的定义语法很简单，在外部类的内部直接定义一个新的类即</p><pre><code class="java">// 外部类class Outer &#123;    // 成员内部类    class Inner &#123;        // 内部类的方法        public void innerMethod() &#123;            System.out.println(&quot;这是成员内部类的方法&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="创建成员内部类的对象"><a href="#创建成员内部类的对象" class="headerlink" title="创建成员内部类的对象"></a>创建成员内部类的对象</h5><p>要创建成员内部类的对象，必须先创建外部类的对象，因为成员内部类依赖于外部类的实例存在。创建成员内部类对象的语法如下：</p><pre><code class="java">// 创建外部类对象Outer outer = new Outer();// 通过外部类对象创建成员内部类对象Outer.Inner inner = outer.new Inner();</code></pre><h5 id="成员内部类访问外部类成员"><a href="#成员内部类访问外部类成员" class="headerlink" title="成员内部类访问外部类成员"></a>成员内部类访问外部类成员</h5><p>成员内部类可以访问外部类的所有成员，包括私有成员。</p><pre><code class="java">// 外部类class Outer &#123;    private int outerVariable = 10;    // 成员内部类    class Inner &#123;        public void accessOuterVariable() &#123;            // 访问外部类的私有成员            System.out.println(&quot;外部类的私有变量值: &quot; + outerVariable);        &#125;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        Outer.Inner inner = outer.new Inner();        inner.accessOuterVariable();    &#125;&#125;</code></pre><h5 id="外部类访问成员内部类成员"><a href="#外部类访问成员内部类成员" class="headerlink" title="外部类访问成员内部类成员"></a>外部类访问成员内部类成员</h5><p>外部类也可以访问成员内部类的成员，但需要先创建成员内部类的对象。</p><pre><code class="java">// 外部类class Outer &#123;    // 成员内部类    class Inner &#123;        private int innerVariable = 20;        public void innerMethod() &#123;            System.out.println(&quot;这是成员内部类的方法&quot;);        &#125;    &#125;    public void accessInnerMembers() &#123;        Inner inner = new Inner();        // 访问成员内部类的私有变量        System.out.println(&quot;成员内部类的私有变量值: &quot; + inner.innerVariable);        // 调用成员内部类的方法        inner.innerMethod();    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        outer.accessInnerMembers();    &#125;&#125;</code></pre><h5 id="成员内部类的特点"><a href="#成员内部类的特点" class="headerlink" title="成员内部类的特点"></a>成员内部类的特点</h5><ol><li><strong>依赖外部类实例</strong>：成员内部类的对象必须依赖于外部类的对象才能创建，因为它隐式地持有一个对外部类对象的引用。</li><li><strong>访问外部类成员</strong>：可以访问外部类的所有成员，包括私有成员和静态成员。</li><li><strong>编译后生成独立的.class 文件</strong>：成员内部类编译后会生成独立的 <code>.class</code> 文件，文件名格式为 <code>外部类名$内部类名.class</code>。</li></ol><h5 id="成员内部类的使用场景"><a href="#成员内部类的使用场景" class="headerlink" title="成员内部类的使用场景"></a>成员内部类的使用场景</h5><ol><li><strong>实现多继承效果</strong>：由于 Java 不支持类的多重继承，但通过成员内部类可以在一定程度上实现类似多重继承的效果，一个类可以通过成员内部类继承其他类。</li><li><strong>封装细节</strong>：当一个类的某些功能只与该类的其他成员密切相关，并且不希望被外部直接访问时，可以将这些功能封装在成员内部类中。</li><li><strong>事件处理</strong>：在 GUI 编程中，成员内部类常被用于处理事件，例如按钮点击事件等。</li></ol><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p><img src="/../images/java/1741501103771.png" alt="1741501103771"></p><h5 id="定义静态内部类"><a href="#定义静态内部类" class="headerlink" title="定义静态内部类"></a>定义静态内部类</h5><p>静态内部类的定义和普通内部类类似，只是在类定义前加上 <code>static</code> 关键字。示例代码如下：</p><pre><code class="java">// 外部类class OuterClass &#123;    // 静态内部类    static class StaticInnerClass &#123;        public void display() &#123;            System.out.println(&quot;这是静态内部类的方法&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="创建静态内部类的对象"><a href="#创建静态内部类的对象" class="headerlink" title="创建静态内部类的对象"></a>创建静态内部类的对象</h5><p>静态内部类不依赖于外部类的实例，因此可以直接创建静态内部类的对象，不需要先创建外部类的对象。创建对象的语法如下：</p><pre><code class="java">OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();</code></pre><p>完整示例代码如下：</p><pre><code class="java">class OuterClass &#123;    static class StaticInnerClass &#123;        public void display() &#123;            System.out.println(&quot;这是静态内部类的方法&quot;);        &#125;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();        inner.display();    &#125;&#125;</code></pre><h5 id="静态内部类的访问规则"><a href="#静态内部类的访问规则" class="headerlink" title="静态内部类的访问规则"></a>静态内部类的访问规则</h5><h6 id="访问外部类成员"><a href="#访问外部类成员" class="headerlink" title="访问外部类成员"></a>访问外部类成员</h6><p>静态内部类只能直接访问外部类的静态成员（静态变量和静态方法），不能直接访问外部类的非静态成员。如果要访问外部类的非静态成员，需要先创建外部类的对象。示例代码如下：</p><pre><code class="java">class OuterClass &#123;    private static int staticVariable = 10;    private int nonStaticVariable = 20;    static class StaticInnerClass &#123;        public void accessOuterMembers() &#123;            // 可以直接访问外部类的静态成员            System.out.println(&quot;外部类的静态变量: &quot; + staticVariable);            // 不能直接访问外部类的非静态成员，需要创建外部类对象            OuterClass outer = new OuterClass();            System.out.println(&quot;外部类的非静态变量: &quot; + outer.nonStaticVariable);        &#125;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        OuterClass.StaticInnerClass inner = new OuterClass.StaticInnerClass();        inner.accessOuterMembers();    &#125;&#125;</code></pre><h6 id="外部类访问静态内部类成员"><a href="#外部类访问静态内部类成员" class="headerlink" title="外部类访问静态内部类成员"></a>外部类访问静态内部类成员</h6><p>外部类可以直接访问静态内部类的静态成员，如果要访问静态内部类的非静态成员，需要创建静态内部类的对象。示例代码如下：</p><pre><code class="java">class OuterClass &#123;    static class StaticInnerClass &#123;        private static int staticInnerVariable = 30;        private int nonStaticInnerVariable = 40;        public static void staticInnerMethod() &#123;            System.out.println(&quot;静态内部类的静态方法&quot;);        &#125;        public void nonStaticInnerMethod() &#123;            System.out.println(&quot;静态内部类的非静态方法&quot;);        &#125;    &#125;    public void accessInnerMembers() &#123;        // 直接访问静态内部类的静态成员        System.out.println(&quot;静态内部类的静态变量: &quot; + StaticInnerClass.staticInnerVariable);        StaticInnerClass.staticInnerMethod();        // 创建静态内部类对象访问其非静态成员        StaticInnerClass inner = new StaticInnerClass();        System.out.println(&quot;静态内部类的非静态变量: &quot; + inner.nonStaticInnerVariable);        inner.nonStaticInnerMethod();    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        OuterClass outer = new OuterClass();        outer.accessInnerMembers();    &#125;&#125;</code></pre><h5 id="静态内部类的特点"><a href="#静态内部类的特点" class="headerlink" title="静态内部类的特点"></a>静态内部类的特点</h5><ol><li><strong>不依赖外部类实例</strong>：静态内部类不持有外部类对象的引用，它的创建不依赖于外部类的实例，这使得它在内存使用和独立性上有一定优势。</li><li><strong>只能访问外部类静态成员</strong>：由于静态内部类不依赖外部类实例，所以只能直接访问外部类的静态成员。</li><li><strong>编译后生成独立的.class 文件</strong>：静态内部类编译后会生成独立的 <code>.class</code> 文件，文件名格式为 <code>外部类名$静态内部类名.class</code>。</li></ol><h5 id="静态内部类的使用场景"><a href="#静态内部类的使用场景" class="headerlink" title="静态内部类的使用场景"></a>静态内部类的使用场景</h5><ol><li><strong>封装相关功能</strong>：当一组功能与某个外部类相关，但又不需要访问外部类的非静态成员时，可以将这些功能封装在静态内部类中，提高代码的模块化程度。</li><li><strong>数据结构嵌套</strong>：在实现一些复杂的数据结构时，如树、图等，静态内部类可以用来表示节点等嵌套结构，使代码结构更清晰。</li></ol><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p><img src="/../images/java/1741501971643.png" alt="1741501971643"></p><h5 id="定义局部内部类"><a href="#定义局部内部类" class="headerlink" title="定义局部内部类"></a>定义局部内部类</h5><p>局部内部类定义在方法、构造函数或者代码块内部，其定义语法和普通类类似，但只能在定义它的作用域内使用。以下是在方法内部定义局部内部类的示例：</p><pre><code class="java">public class OuterClass &#123;    public void outerMethod() &#123;        // 局部内部类        class LocalInnerClass &#123;            public void display() &#123;                System.out.println(&quot;这是局部内部类的方法&quot;);            &#125;        &#125;        // 在方法内部创建局部内部类的对象并调用方法        LocalInnerClass inner = new LocalInnerClass();        inner.display();    &#125;&#125;</code></pre><p>在上述代码中，<code>LocalInnerClass</code> 是定义在 <code>outerMethod</code> 方法内部的局部内部类，只能在 <code>outerMethod</code> 方法内部使用。</p><h5 id="局部内部类的特点"><a href="#局部内部类的特点" class="headerlink" title="局部内部类的特点"></a>局部内部类的特点</h5><ol><li><strong>作用域受限</strong>：局部内部类只能在定义它的方法、构造函数或代码块内部使用，出了这个作用域就无法访问。</li><li><strong>访问外部类成员</strong>：局部内部类可以访问外部类的所有成员，包括私有成员。</li><li><strong>访问局部变量</strong>：局部内部类可以访问定义它的方法中的 <code>final</code> 或 <code>effectively final</code>（Java 8 及以后，若变量值在初始化后未被修改，可视为 <code>effectively final</code>）局部变量。</li><li><strong>编译后生成独立的.class 文件</strong>：局部内部类编译后会生成独立的 <code>.class</code> 文件，文件名格式为 <code>外部类名$数字局部内部类名.class</code>，其中数字用于区分不同位置的局部内部类。</li></ol><h5 id="访问规则"><a href="#访问规则" class="headerlink" title="访问规则"></a>访问规则</h5><h6 id="访问外部类成员-1"><a href="#访问外部类成员-1" class="headerlink" title="访问外部类成员"></a>访问外部类成员</h6><p>局部内部类可以直接访问外部类的所有成员，包括私有成员。示例代码如下：</p><pre><code class="java">public class OuterClass &#123;    private int outerVariable = 10;    public void outerMethod() &#123;        class LocalInnerClass &#123;            public void accessOuterVariable() &#123;                // 访问外部类的私有成员                System.out.println(&quot;外部类的私有变量: &quot; + outerVariable);            &#125;        &#125;        LocalInnerClass inner = new LocalInnerClass();        inner.accessOuterVariable();    &#125;&#125;</code></pre><h6 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h6><p>局部内部类可以访问定义它的方法中的 <code>final</code> 或 <code>effectively final</code> 局部变量。示例代码如下：</p><pre><code class="java">public class OuterClass &#123;    public void outerMethod() &#123;        // effectively final 局部变量        int localVar = 20;        class LocalInnerClass &#123;            public void accessLocalVariable() &#123;                // 访问局部变量                System.out.println(&quot;局部变量的值: &quot; + localVar);            &#125;        &#125;        LocalInnerClass inner = new LocalInnerClass();        inner.accessLocalVariable();    &#125;&#125;</code></pre><p>需要注意的是，如果尝试修改 <code>localVar</code> 的值，就会破坏其 <code>effectively final</code> 的特性，局部内部类将无法再访问该变量。</p><h5 id="局部内部类的使用场景"><a href="#局部内部类的使用场景" class="headerlink" title="局部内部类的使用场景"></a>局部内部类的使用场景</h5><ol><li><strong>封装特定逻辑</strong>：当某个功能只在方法内部使用，且该功能有一定的复杂性，需要封装成类时，可以使用局部内部类。</li><li><strong>实现临时接口或抽象类</strong>：在方法内部需要实现某个接口或继承某个抽象类，并且这个实现只在该方法内部使用时，使用局部内部类可以避免创建过多的外部类，使代码更加简洁。</li></ol><h5 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h5><pre><code class="java">public class OuterClass &#123;    private int outerVariable = 10;    public void outerMethod() &#123;        // effectively final 局部变量        int localVar = 20;        // 局部内部类        class LocalInnerClass &#123;            public void accessOuterVariable() &#123;                // 访问外部类的私有成员                System.out.println(&quot;外部类的私有变量: &quot; + outerVariable);            &#125;            public void accessLocalVariable() &#123;                // 访问局部变量                System.out.println(&quot;局部变量的值: &quot; + localVar);            &#125;        &#125;        // 创建局部内部类的对象并调用方法        LocalInnerClass inner = new LocalInnerClass();        inner.accessOuterVariable();        inner.accessLocalVariable();    &#125;    public static void main(String[] args) &#123;        OuterClass outer = new OuterClass();        outer.outerMethod();    &#125;&#125;</code></pre><p>在上述完整示例中，我们展示了局部内部类如何访问外部类的私有成员和方法内的局部变量，同时演示了如何在方法内部创建局部内部类的对象并调用其方法。</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p><img src="/../images/java/1741507808267.png" alt="1741507808267"></p><h5 id="定义与基本语法"><a href="#定义与基本语法" class="headerlink" title="定义与基本语法"></a>定义与基本语法</h5><p>匿名内部类通常用于创建一个实现某个接口或者继承某个类的对象，并且在创建对象的同时实现接口的抽象方法或者重写父类的方法。基本语法如下：</p><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><pre><code class="java">interface MyInterface &#123;    void doSomething();&#125;public class AnonymousInnerClassExample &#123;    public static void main(String[] args) &#123;        // 匿名内部类实现接口        MyInterface myInterface = new MyInterface() &#123;            @Override            public void doSomething() &#123;                System.out.println(&quot;执行接口的方法&quot;);            &#125;        &#125;;        myInterface.doSomething();    &#125;&#125;</code></pre><h5 id="继承类"><a href="#继承类" class="headerlink" title="继承类"></a>继承类</h5><pre><code class="java">class MyClass &#123;    public void display() &#123;        System.out.println(&quot;父类的方法&quot;);    &#125;&#125;public class AnonymousInnerClassExample2 &#123;    public static void main(String[] args) &#123;        // 匿名内部类继承类        MyClass myClass = new MyClass() &#123;            @Override            public void display() &#123;                System.out.println(&quot;重写父类的方法&quot;);            &#125;        &#125;;        myClass.display();    &#125;&#125;</code></pre><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li><strong>没有类名</strong>：匿名内部类没有显式的类名，它的定义和对象的创建是同时进行的。</li><li><strong>一次性使用</strong>：通常用于创建一次性的对象，只在当前使用的地方有效，不会被其他地方复用。</li><li><strong>隐式继承或实现</strong>：匿名内部类必须继承一个类或者实现一个接口，并且只能继承一个类或者实现一个接口。</li><li><strong>访问外部变量</strong>：可以访问外部类的成员变量和方法，对于方法中的局部变量，要求该变量是 <code>final</code> 或 <code>effectively final</code>（Java 8 及以后，若变量值在初始化后未被修改，可视为 <code>effectively final</code>）。</li></ol><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li><strong>事件处理</strong>：在 GUI 编程中，经常使用匿名内部类来处理事件，例如按钮点击事件、鼠标事件等。</li></ol><pre><code class="java">import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class EventHandlingExample &#123;    public static void main(String[] args) &#123;        JFrame frame = new JFrame(&quot;匿名内部类事件处理&quot;);        JButton button = new JButton(&quot;点击我&quot;);        // 匿名内部类处理按钮点击事件        button.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                JOptionPane.showMessageDialog(frame, &quot;按钮被点击了&quot;);            &#125;        &#125;);        frame.add(button);        frame.setSize(300, 200);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        frame.setVisible(true);    &#125;&#125;</code></pre><ol><li><strong>回调机制</strong>：当需要传递一个实现了特定接口的对象作为回调时，可以使用匿名内部类简化代码。</li><li><strong>简化代码</strong>：当某个类只需要使用一次，且实现逻辑比较简单时，使用匿名内部类可以避免创建过多的类文件，使代码更加简洁。</li></ol><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li><strong>构造函数</strong>：由于匿名内部类没有类名，所以不能有显式的构造函数。如果需要进行初始化操作，可以使用实例初始化块。</li></ol><pre><code class="java">abstract class MyAbstractClass &#123;    abstract void display();&#125;public class InitializationExample &#123;    public static void main(String[] args) &#123;        MyAbstractClass myAbstractClass = new MyAbstractClass() &#123;            int value;            // 实例初始化块            &#123;                value = 10;            &#125;            @Override            public void display() &#123;                System.out.println(&quot;值为: &quot; + value);            &#125;        &#125;;        myAbstractClass.display();    &#125;&#125;</code></pre><ol start="2"><li><strong>方法重写</strong>：如果实现接口，必须实现接口中的所有抽象方法；如果继承类，通常需要重写父类的方法来实现特定的逻辑。</li></ol><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p><img src="/../images/java/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-09%20161258.png"></p><h4 id="自定义枚举"><a href="#自定义枚举" class="headerlink" title="自定义枚举"></a>自定义枚举</h4><p><img src="/../images/java/1741509009547.png" alt="1741509009547"></p><h4 id="enum枚举类"><a href="#enum枚举类" class="headerlink" title="enum枚举类"></a>enum枚举类</h4><p><img src="/../images/java/1741509045726.png" alt="1741509045726"></p><h4 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h4><p>使用 <code>enum</code> 关键字来定义枚举类，语法如下：</p><pre><code class="java">enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;</code></pre><p>在上述代码中，<code>Season</code> 是一个枚举类，它包含四个枚举常量：<code>SPRING</code>、<code>SUMMER</code>、<code>AUTUMN</code> 和 <code>WINTER</code>。每个枚举常量都是 <code>Season</code> 类的一个实例。</p><h4 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h4><h5 id="遍历枚举常量"><a href="#遍历枚举常量" class="headerlink" title="遍历枚举常量"></a>遍历枚举常量</h5><p>可以使用 <code>values()</code> 方法获取枚举类的所有枚举常量，并进行遍历。</p><pre><code class="java">enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        // 遍历枚举常量        for (Season season : Season.values()) &#123;            System.out.println(season);        &#125;    &#125;&#125;</code></pre><h5 id="根据名称获取枚举常量"><a href="#根据名称获取枚举常量" class="headerlink" title="根据名称获取枚举常量"></a>根据名称获取枚举常量</h5><p>可以使用 <code>valueOf()</code> 方法根据枚举常量的名称获取对应的枚举实例。</p><pre><code class="java">enum Season &#123;    SPRING, SUMMER, AUTUMN, WINTER&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        Season season = Season.valueOf(&quot;SPRING&quot;);        System.out.println(season);    &#125;&#125;</code></pre><h4 id="枚举类的特性"><a href="#枚举类的特性" class="headerlink" title="枚举类的特性"></a>枚举类的特性</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>枚举类可以有构造函数，但构造函数必须是私有的，以确保枚举常量的唯一性。可以为枚举常量添加属性和方法。</p><pre><code class="java">enum Season &#123;    SPRING(&quot;春天&quot;), SUMMER(&quot;夏天&quot;), AUTUMN(&quot;秋天&quot;), WINTER(&quot;冬天&quot;);    private String description;    // 私有构造函数    private Season(String description) &#123;        this.description = description;    &#125;    public String getDescription() &#123;        return description;    &#125;&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        for (Season season : Season.values()) &#123;            System.out.println(season + &quot;: &quot; + season.getDescription());        &#125;    &#125;&#125;</code></pre><h5 id="实现接口-1"><a href="#实现接口-1" class="headerlink" title="实现接口"></a>实现接口</h5><p>枚举类可以实现接口，为每个枚举常量提供不同的实现。</p><pre><code class="java">interface SeasonActivity &#123;    void activity();&#125;enum Season implements SeasonActivity &#123;    SPRING &#123;        @Override        public void activity() &#123;            System.out.println(&quot;春天适合踏青&quot;);        &#125;    &#125;,    SUMMER &#123;        @Override        public void activity() &#123;            System.out.println(&quot;夏天适合游泳&quot;);        &#125;    &#125;,    AUTUMN &#123;        @Override        public void activity() &#123;            System.out.println(&quot;秋天适合赏菊&quot;);        &#125;    &#125;,    WINTER &#123;        @Override        public void activity() &#123;            System.out.println(&quot;冬天适合滑雪&quot;);        &#125;    &#125;;&#125;public class EnumExample &#123;    public static void main(String[] args) &#123;        for (Season season : Season.values()) &#123;            season.activity();        &#125;    &#125;&#125;</code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h5><p>在程序中，经常需要表示一些固定的状态，如订单状态（未支付、已支付、已发货等）、用户状态（正常、冻结、注销等），使用枚举类可以使代码更加清晰。</p><pre><code class="java">enum OrderStatus &#123;    UNPAID, PAID, SHIPPED, DELIVERED&#125;public class Order &#123;    private OrderStatus status;    public Order(OrderStatus status) &#123;        this.status = status;    &#125;    public OrderStatus getStatus() &#123;        return status;    &#125;    public static void main(String[] args) &#123;        Order order = new Order(OrderStatus.PAID);        System.out.println(&quot;订单状态: &quot; + order.getStatus());    &#125;&#125;</code></pre><h5 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h5><p>当需要定义一组固定的配置选项时，枚举类也是一个很好的选择，如颜色选项、文件格式等。</p><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>枚举常量默认是 <code>public static final</code> 的，并且是单例的，在整个程序中只有一个实例。</li><li>枚举类不能被继承，但可以实现接口。</li><li>枚举类的 <code>values()</code>、<code>valueOf()</code> 等方法是编译器自动添加的，它们是 <code>java.lang.Enum</code> 类的子类的方法。</li></ul><h4 id="枚举类的相关方法"><a href="#枚举类的相关方法" class="headerlink" title="枚举类的相关方法"></a>枚举类的相关方法</h4><p><img src="/../images/java/1741513183213.png" alt="1741513183213"></p><ol start="2"><li>values()&#96;方法</li></ol><ul><li><strong>作用</strong>：这是编译器为枚举类自动生成的方法，它返回一个包含该枚举类所有枚举常量的数组，数组中元素的顺序就是枚举常量在枚举类中声明的顺序。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        Color[] colors = Color.values();        for (Color color : colors) &#123;            System.out.println(color);        &#125;    &#125;&#125;</code></pre><ol start="3"><li><code>valueOf()</code>方法</li></ol><ul><li><strong>作用</strong>：根据给定的字符串名称返回对应的枚举常量。字符串必须与枚举常量的名称完全匹配（包括大小写），否则会抛出<code>IllegalArgumentException</code>异常。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        Color color = Color.valueOf(&quot;RED&quot;);        System.out.println(color);    &#125;&#125;</code></pre><ol start="4"><li><code>ordinal()</code>方法</li></ol><ul><li><strong>作用</strong>：返回枚举常量在枚举类中的声明顺序，从 0 开始计数。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(Color.RED.ordinal());         System.out.println(Color.GREEN.ordinal());         System.out.println(Color.BLUE.ordinal());     &#125;&#125;</code></pre><ol start="6"><li><code>compareTo()</code>方法</li></ol><ul><li><strong>作用</strong>：用于比较两个枚举常量的顺序。它基于枚举常量的<code>ordinal</code>值进行比较，如果当前枚举常量的<code>ordinal</code>值小于参数枚举常量的<code>ordinal</code>值，则返回负整数；如果相等，则返回 0；如果大于，则返回正整数。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(Color.RED.compareTo(Color.GREEN));         System.out.println(Color.GREEN.compareTo(Color.GREEN));         System.out.println(Color.BLUE.compareTo(Color.GREEN));     &#125;&#125;</code></pre><ol start="7"><li><code>name()</code>方法</li></ol><ul><li><strong>作用</strong>：返回枚举常量的名称，与在枚举类中声明的名称一致。</li><li><strong>示例</strong></li></ul><pre><code class="java">enum Color &#123;    RED, GREEN, BLUE&#125;public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(Color.RED.name());     &#125;&#125;</code></pre><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><img src="/../images/java/1741513669438.png" alt="1741513669438"></p><h4 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h4><p>使用 <code>@interface</code> 关键字来定义注解，注解的定义类似于接口的定义。示例如下：</p><pre><code class="java">// 定义一个简单的注解public @interface MyAnnotation &#123;    // 定义注解的属性    String value() default &quot;&quot;;    int count() default 0;&#125;</code></pre><p>在上述代码中，<code>MyAnnotation</code> 是一个自定义注解，它包含两个属性：<code>value</code> 和 <code>count</code>，并分别为它们设置了默认值。</p><h4 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h4><p>Java 提供了一些内置注解，用于在不同场景下提供特定的元数据信息。</p><ul><li>**<code>@Override</code>**：用于标记一个方法是重写父类的方法。编译器会检查该方法是否真的重写了父类的方法，如果没有则会报错。</li></ul><pre><code class="java">class Parent &#123;    public void display() &#123;        System.out.println(&quot;父类的方法&quot;);    &#125;&#125;class Child extends Parent &#123;    @Override    public void display() &#123;        System.out.println(&quot;子类重写的方法&quot;);    &#125;&#125;</code></pre><ul><li>**<code>@Deprecated</code>**：用于标记一个类、方法或字段已经过时，不建议再使用。编译器会在使用这些元素时给出警告。</li></ul><pre><code class="java">class MyClass &#123;    @Deprecated    public void oldMethod() &#123;        System.out.println(&quot;这是一个过时的方法&quot;);    &#125;&#125;</code></pre><ul><li>**<code>@SuppressWarnings</code>**：用于抑制编译器的警告信息。可以指定要抑制的警告类型，如 <code>unchecked</code>、<code>deprecation</code> 等。</li></ul><pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)public void test() &#123;    java.util.List list = new java.util.ArrayList();    // 这里不会出现未检查类型转换的警告&#125;</code></pre><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>自定义注解可以根据具体需求定义属性和使用规则。</p><pre><code class="java">// 定义一个自定义注解public @interface MyAnnotation &#123;    String value() default &quot;&quot;;    int count() default 0;&#125;// 使用自定义注解@MyAnnotation(value = &quot;测试注解&quot;, count = 5)public class MyClass &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;使用自定义注解的类&quot;);    &#125;&#125;</code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="/../images/java/1741515069168.png" alt="1741515069168"></p><p><img src="/../images/java/1741515612811.png" alt="1741515612811"></p><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a><code>try-catch-finally</code></h4><p><img src="/../images/java/1741515823233.png" alt="1741515823233"></p><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p><code>try-catch</code> 语句块的基本语法如下：</p><pre><code class="java">try &#123;    // 可能会抛出异常的代码&#125; catch (ExceptionType1 e1) &#123;    // 处理 ExceptionType1 类型异常的代码&#125; catch (ExceptionType2 e2) &#123;    // 处理 ExceptionType2 类型异常的代码&#125; </code></pre><p>其中，<code>try</code> 块中放置可能会抛出异常的代码，<code>catch</code> 块用于捕获并处理特定类型的异常。每个 <code>catch</code> 块可以捕获一种特定类型的异常，当 <code>try</code> 块中的代码抛出异常时，会依次检查各个 <code>catch</code> 块，找到匹配的异常类型并执行相应的处理代码。</p><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><p>下面通过一个简单的示例来展示 <code>try-catch</code> 语句块的执行流程：</p><pre><code class="java">public class TryCatchExample &#123;    public static void main(String[] args) &#123;        try &#123;            int result = 10 / 0; // 这行代码会抛出 ArithmeticException 异常            System.out.println(&quot;结果: &quot; + result);        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;捕获到算术异常: &quot; + e.getMessage());        &#125;        System.out.println(&quot;程序继续执行&quot;);    &#125;&#125;</code></pre><p>在上述代码中，<code>try</code> 块中的 <code>10 / 0</code> 会抛出 <code>ArithmeticException</code> 异常，此时程序会立即跳转到对应的 <code>catch</code> 块中执行异常处理代码，输出异常信息。然后程序会继续执行 <code>catch</code> 块之后的代码，输出 “程序继续执行”。</p><h5 id="多-catch-块"><a href="#多-catch-块" class="headerlink" title="多 catch 块"></a>多 <code>catch</code> 块</h5><p>可以使用多个 <code>catch</code> 块来捕获不同类型的异常，按照异常类型的顺序依次进行匹配。需要注意的是，子类异常的 <code>catch</code> 块要放在父类异常的 <code>catch</code> 块之前，否则子类异常将无法被捕获。</p><pre><code class="java">public class MultipleCatchExample &#123;    public static void main(String[] args) &#123;        try &#123;            int[] arr = new int[5];            System.out.println(arr[10]); // 这行代码会抛出 ArrayIndexOutOfBoundsException 异常            int result = 10 / 0; // 这行代码不会执行，因为前面已经抛出异常        &#125; catch (ArrayIndexOutOfBoundsException e) &#123;            System.out.println(&quot;捕获到数组越界异常: &quot; + e.getMessage());        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;捕获到算术异常: &quot; + e.getMessage());        &#125; catch (Exception e) &#123;            System.out.println(&quot;捕获到其他异常: &quot; + e.getMessage());        &#125;        System.out.println(&quot;程序继续执行&quot;);    &#125;&#125;</code></pre><p>在上述代码中，<code>try</code> 块中的 <code>arr[10]</code> 会抛出 <code>ArrayIndexOutOfBoundsException</code> 异常，程序会跳转到对应的 <code>catch</code> 块中执行异常处理代码。由于异常已经被捕获，后面的 <code>10 / 0</code> 代码不会执行。</p><h5 id="finally-块"><a href="#finally-块" class="headerlink" title="finally 块"></a><code>finally</code> 块</h5><p><code>finally</code> 块是可选的，它通常跟在 <code>try-catch</code> 语句块之后，无论 <code>try</code> 块中的代码是否抛出异常，<code>finally</code> 块中的代码都会被执行。</p><pre><code class="java">public class FinallyExample &#123;    public static void main(String[] args) &#123;        try &#123;            int result = 10 / 0; // 这行代码会抛出 ArithmeticException 异常            System.out.println(&quot;结果: &quot; + result);        &#125; catch (ArithmeticException e) &#123;            System.out.println(&quot;捕获到算术异常: &quot; + e.getMessage());        &#125; finally &#123;            System.out.println(&quot;finally 块中的代码一定会执行&quot;);        &#125;        System.out.println(&quot;程序继续执行&quot;);    &#125;&#125;</code></pre><p>在上述代码中，<code>try</code> 块中的 <code>10 / 0</code> 会抛出 <code>ArithmeticException</code> 异常，程序会跳转到 <code>catch</code> 块中执行异常处理代码，然后执行 <code>finally</code> 块中的代码，最后继续执行 <code>finally</code> 块之后的代码。</p><h5 id="异常处理的注意事项"><a href="#异常处理的注意事项" class="headerlink" title="异常处理的注意事项"></a>异常处理的注意事项</h5><ul><li><strong>异常类型匹配</strong>：<code>catch</code> 块中的异常类型要与 <code>try</code> 块中可能抛出的异常类型相匹配，确保能够捕获到相应的异常。</li><li><strong>子类异常在前</strong>：在使用多个 <code>catch</code> 块时，子类异常的 <code>catch</code> 块要放在父类异常的 <code>catch</code> 块之前，避免子类异常被父类异常的 <code>catch</code> 块捕获。</li><li><strong><code>finally</code> 块的使用</strong>：<code>finally</code> 块通常用于释放资源，如关闭文件、数据库连接等，确保资源在任何情况下都能被正确释放。</li></ul><h4 id="throws-与-throw"><a href="#throws-与-throw" class="headerlink" title="throws 与 throw"></a><code>throws</code> 与 <code>throw</code></h4><p><img src="/../images/java/1741516755212.png" alt="1741516755212"></p><h5 id="throws-关键字"><a href="#throws-关键字" class="headerlink" title="throws 关键字"></a>throws 关键字</h5><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><p><code>throws</code> 关键字用于方法声明处，用于声明该方法可能会抛出的异常类型。它告知调用者，这个方法在执行过程中可能会产生某些异常，调用者需要对这些异常进行处理或者继续向上抛出。</p><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><pre><code class="java">修饰符 返回值类型 方法名(参数列表) throws 异常类型1, 异常类型2, ... &#123;    // 方法体&#125;</code></pre><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><pre><code class="java">import java.io.FileInputStream;import java.io.FileNotFoundException;public class ThrowsExample &#123;    // 声明该方法可能会抛出 FileNotFoundException 异常    public void readFile() throws FileNotFoundException &#123;        // 尝试打开一个文件，如果文件不存在会抛出 FileNotFoundException 异常        FileInputStream fis = new FileInputStream(&quot;nonexistentfile.txt&quot;);    &#125;    public static void main(String[] args) &#123;        ThrowsExample example = new ThrowsExample();        try &#123;            example.readFile();        &#125; catch (FileNotFoundException e) &#123;            System.out.println(&quot;文件未找到: &quot; + e.getMessage());        &#125;    &#125;&#125;</code></pre><p>在上述示例中，<code>readFile</code> 方法使用 <code>throws</code> 关键字声明可能会抛出 <code>FileNotFoundException</code> 异常。在 <code>main</code> 方法中调用 <code>readFile</code> 方法时，需要使用 <code>try-catch</code> 语句块来捕获并处理该异常。</p><h6 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li><code>throws</code> 后面可以跟多个异常类型，多个异常类型之间用逗号分隔。</li><li>如果一个方法声明了可能会抛出某个异常，但实际上该方法内部并没有抛出该异常，也是合法的。</li><li>子类重写父类的方法时，如果父类方法声明了某些异常，子类方法可以不声明这些异常，也可以声明父类方法声明的异常的子类异常，但不能声明比父类方法声明的异常范围更大的异常。</li></ul><h5 id="throw-关键字"><a href="#throw-关键字" class="headerlink" title="throw 关键字"></a>throw 关键字</h5><h6 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h6><p><code>throw</code> 关键字用于在方法内部手动抛出一个异常对象。当程序执行到 <code>throw</code> 语句时，会立即停止当前方法的执行，并将异常对象抛出给调用者。</p><h6 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h6><pre><code class="java">throw 异常对象;</code></pre><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><pre><code class="java">public class ThrowExample &#123;    public void checkAge(int age) &#123;        if (age &lt; 0) &#123;            // 手动抛出 IllegalArgumentException 异常            throw new IllegalArgumentException(&quot;年龄不能为负数&quot;);        &#125;        System.out.println(&quot;年龄合法: &quot; + age);    &#125;    public static void main(String[] args) &#123;        ThrowExample example = new ThrowExample();        try &#123;            example.checkAge(-5);        &#125; catch (IllegalArgumentException e) &#123;            System.out.println(&quot;捕获到异常: &quot; + e.getMessage());        &#125;    &#125;&#125;</code></pre><p>在上述示例中，<code>checkAge</code> 方法内部检查传入的 <code>age</code> 参数，如果 <code>age</code> 小于 0，则使用 <code>throw</code> 关键字手动抛出一个 <code>IllegalArgumentException</code> 异常。在 <code>main</code> 方法中调用 <code>checkAge</code> 方法时，使用 <code>try-catch</code> 语句块来捕获并处理该异常。</p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>Java 提供了 8 种基本数据类型，对应有 8 个包装类，具体如下：</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>Byte</code></td></tr><tr><td><code>short</code></td><td><code>Short</code></td></tr><tr><td><code>int</code></td><td><code>Integer</code></td></tr><tr><td><code>long</code></td><td><code>Long</code></td></tr><tr><td><code>float</code></td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td><code>Double</code></td></tr><tr><td><code>char</code></td><td><code>Character</code></td></tr><tr><td><code>boolean</code></td><td><code>Boolean</code></td></tr></tbody></table><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><ul><li><strong>自动装箱</strong>：将基本数据类型自动转换为对应的包装类对象。例如，将 <code>int</code> 类型的值赋给 <code>Integer</code> 类型的变量时，会自动进行装箱操作。</li></ul><pre><code class="java">int num = 10;Integer integerObj = num; // 自动装箱</code></pre><ul><li><strong>自动拆箱</strong>：将包装类对象自动转换为对应的基本数据类型。例如，将 <code>Integer</code> 类型的对象赋给 <code>int</code> 类型的变量时，会自动进行拆箱操作。</li></ul><pre><code class="java">Integer integerObj = 20;int num = integerObj; // 自动拆箱</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>不同的包装类提供了一些常用的方法，以下以 <code>Integer</code> 类为例进行介绍：</p><ul><li><strong><code>valueOf()</code> 方法</strong>：用于将基本数据类型或字符串转换为包装类对象。</li></ul><pre><code class="java">Integer intObj1 = Integer.valueOf(30);Integer intObj2 = Integer.valueOf(&quot;40&quot;);</code></pre><ul><li><strong><code>parseInt()</code> 方法</strong>：用于将字符串转换为 <code>int</code> 类型。</li></ul><pre><code class="java">int num = Integer.parseInt(&quot;50&quot;);</code></pre><ul><li><strong><code>toString()</code> 方法</strong>：用于将包装类对象转换为字符串。</li></ul><pre><code class="java">Integer intObj = 60;String str = intObj.toString();</code></pre><ul><li><strong><code>compareTo()</code> 方法</strong>：用于比较两个包装类对象的大小。</li></ul><pre><code class="java">Integer intObj1 = 70;Integer intObj2 = 80;int result = intObj1.compareTo(intObj2);if (result &lt; 0) &#123;    System.out.println(&quot;intObj1 小于 intObj2&quot;);&#125; else if (result == 0) &#123;    System.out.println(&quot;intObj1 等于 intObj2&quot;);&#125; else &#123;    System.out.println(&quot;intObj1 大于 intObj2&quot;);&#125;</code></pre><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>部分包装类（如 <code>Integer</code>、<code>Byte</code>、<code>Short</code>、<code>Long</code>、<code>Character</code>）存在缓存机制，对于一些常用的值，会将其对应的包装类对象缓存起来，当再次使用相同的值时，会直接从缓存中获取对象，而不是重新创建。</p><pre><code class="java">Integer a = 10;Integer b = 10;System.out.println(a == b); // 输出 true，因为使用了缓存Integer c = 128;Integer d = 128;System.out.println(c == d); // 输出 false，超出了缓存范围</code></pre><p><code>Integer</code> 类的缓存范围是 -128 到 127，不同的包装类缓存范围可能不同。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><img src="/../images/java/1741527233539.png" alt="1741527233539"></p><h4 id="1-String-类的创建"><a href="#1-String-类的创建" class="headerlink" title="1. String 类的创建"></a>1. <code>String</code> 类的创建</h4><p>在 Java 中创建 <code>String</code> 对象有多种方式，常见的如下：</p><h5 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h5><pre><code class="java">String str1 = &quot;Hello&quot;;</code></pre><p>这种方式会先检查字符串常量池中是否已经存在 <code>&quot;Hello&quot;</code> 这个字符串，如果存在则直接引用该字符串，若不存在则在常量池中创建该字符串对象。</p><h5 id="使用-new-关键字"><a href="#使用-new-关键字" class="headerlink" title="使用 new 关键字"></a>使用 <code>new</code> 关键字</h5><pre><code class="java">String str2 = new String(&quot;World&quot;);</code></pre><p>使用 <code>new</code> 关键字会在堆内存中创建一个新的 <code>String</code> 对象，即使字符串常量池中已经存在相同内容的字符串。</p><h4 id="2-String-类的不可变性"><a href="#2-String-类的不可变性" class="headerlink" title="2. String 类的不可变性"></a>2. <code>String</code> 类的不可变性</h4><p><code>String</code> 类的对象是不可变的，这意味着一旦一个 <code>String</code> 对象被创建，它的内容就不能被修改。例如：</p><pre><code class="java">String str = &quot;Java&quot;;str = str + &quot; Programming&quot;;</code></pre><p>这里看似 <code>str</code> 的内容发生了改变，但实际上是创建了一个新的 <code>String</code> 对象 <code>&quot;Java Programming&quot;</code>，并让 <code>str</code> 引用这个新对象，原来的 <code>&quot;Java&quot;</code> 对象依然存在于内存中。</p><p><code>String</code> 类不可变的好处主要有安全性、线程安全、可以作为哈希表的键等。</p><h4 id="3-String-类的常用方法"><a href="#3-String-类的常用方法" class="headerlink" title="3. String 类的常用方法"></a>3. <code>String</code> 类的常用方法</h4><h5 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h5><pre><code class="java">String str = &quot;Example&quot;;int length = str.length(); // 返回 7</code></pre><h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h5><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = &quot; World&quot;;String result = str1.concat(str2); // 结果为 &quot;Hello World&quot;</code></pre><h5 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h5><pre><code class="java">String str = &quot;Java Programming&quot;;int index = str.indexOf(&quot;Programming&quot;); // 返回 5</code></pre><h5 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h5><pre><code class="java">String str = &quot;Java Programming&quot;;String subStr = str.substring(5); // 结果为 &quot;Programming&quot;String subStr2 = str.substring(5, 10); // 结果为 &quot;Progr&quot;</code></pre><h5 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h5><pre><code class="java">String str = &quot;Java Programming&quot;;String newStr = str.replace(&quot;Java&quot;, &quot;Python&quot;); // 结果为 &quot;Python Programming&quot;</code></pre><h5 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h5><pre><code class="java">String str = &quot;Hello&quot;;String upperCase = str.toUpperCase(); // 结果为 &quot;HELLO&quot;String lowerCase = str.toLowerCase(); // 结果为 &quot;hello&quot;</code></pre><h5 id="去除字符串首尾空格"><a href="#去除字符串首尾空格" class="headerlink" title="去除字符串首尾空格"></a>去除字符串首尾空格</h5><pre><code class="java">String str = &quot;  Hello  &quot;;String trimmedStr = str.trim(); // 结果为 &quot;Hello&quot;</code></pre><h5 id="getBytes-方法"><a href="#getBytes-方法" class="headerlink" title="getBytes() 方法"></a><code>getBytes()</code> 方法</h5><h6 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h6><p><code>getBytes()</code> 方法有两个重载形式：</p><ul><li><code>public byte[] getBytes()</code>：使用平台的默认字符编码将字符串编码为字节序列，并将结果存储到一个新的字节数组中。</li><li><code>public byte[] getBytes(String charsetName)</code>：使用指定的字符编码将字符串编码为字节序列，并将结果存储到一个新的字节数组中。如果指定的字符编码不支持，会抛出 <code>UnsupportedEncodingException</code> 异常。</li></ul><h6 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h6><pre><code class="java">import java.io.UnsupportedEncodingException;public class GetBytesExample &#123;    public static void main(String[] args) &#123;        String str = &quot;Hello, 世界!&quot;;        // 使用平台默认编码        byte[] defaultBytes = str.getBytes();        System.out.println(&quot;默认编码后的字节数组长度: &quot; + defaultBytes.length);        try &#123;            // 使用 UTF-8 编码            byte[] utf8Bytes = str.getBytes(&quot;UTF-8&quot;);            System.out.println(&quot;UTF-8 编码后的字节数组长度: &quot; + utf8Bytes.length);            // 使用 GBK 编码            byte[] gbkBytes = str.getBytes(&quot;GBK&quot;);            System.out.println(&quot;GBK 编码后的字节数组长度: &quot; + gbkBytes.length);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h6 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h6><ul><li><code>str.getBytes()</code>：使用平台的默认字符编码对字符串 <code>str</code> 进行编码，返回一个字节数组。</li><li><code>str.getBytes(&quot;UTF-8&quot;)</code>：使用 UTF - 8 字符编码对字符串 <code>str</code> 进行编码，返回一个字节数组。</li><li><code>str.getBytes(&quot;GBK&quot;)</code>：使用 GBK 字符编码对字符串 <code>str</code> 进行编码，返回一个字节数组。</li></ul><h5 id="String-byte-bytes-String-charsetName-构造函数"><a href="#String-byte-bytes-String-charsetName-构造函数" class="headerlink" title="String(byte[] bytes, String charsetName) 构造函数"></a><code>String(byte[] bytes, String charsetName)</code> 构造函数</h5><h6 id="构造函数概述"><a href="#构造函数概述" class="headerlink" title="构造函数概述"></a>构造函数概述</h6><p>该构造函数用于通过指定的字符编码将字节数组解码为字符串。如果指定的字符编码不支持，会抛出 <code>UnsupportedEncodingException</code> 异常。</p><h6 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h6><pre><code class="java">import java.io.UnsupportedEncodingException;public class StringConstructorExample &#123;    public static void main(String[] args) &#123;        String originalStr = &quot;Hello, 世界!&quot;;        try &#123;            // 使用 UTF-8 编码将字符串转换为字节数组            byte[] utf8Bytes = originalStr.getBytes(&quot;UTF-8&quot;);            // 使用 UTF-8 编码将字节数组解码为字符串            String decodedStr = new String(utf8Bytes, &quot;UTF-8&quot;);            System.out.println(&quot;解码后的字符串: &quot; + decodedStr);            // 使用错误的编码进行解码（会导致乱码）            String wrongDecodedStr = new String(utf8Bytes, &quot;GBK&quot;);            System.out.println(&quot;使用错误编码解码后的字符串: &quot; + wrongDecodedStr);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h6 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h6><ul><li><code>new String(utf8Bytes, &quot;UTF-8&quot;)</code>：使用 UTF - 8 字符编码将字节数组 <code>utf8Bytes</code> 解码为字符串。由于编码和解码使用的是相同的字符编码，所以解码后的字符串与原始字符串相同。</li><li><code>new String(utf8Bytes, &quot;GBK&quot;)</code>：使用 GBK 字符编码将字节数组 <code>utf8Bytes</code> 解码为字符串。由于编码使用的是 UTF - 8，解码使用的是 GBK，编码和解码使用的字符编码不一致，所以解码后的字符串会出现乱码。</li></ul><h4 id="4-字符串拼接"><a href="#4-字符串拼接" class="headerlink" title="4. 字符串拼接"></a>4. 字符串拼接</h4><p>除了使用 <code>concat</code> 方法进行字符串拼接外，还可以使用 <code>+</code> 运算符：</p><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = &quot; World&quot;;String result = str1 + str2; // 结果为 &quot;Hello World&quot;</code></pre><p>在 Java 中，当使用 <code>+</code> 运算符进行字符串拼接时，如果其中一个操作数是字符串，那么其他操作数会自动转换为字符串类型。不过在大量拼接字符串时，使用 <code>+</code> 运算符会产生较多临时对象，性能较低，此时建议使用 <code>StringBuilder</code> 或 <code>StringBuffer</code> 类。</p><h4 id="5-字符串比较"><a href="#5-字符串比较" class="headerlink" title="5. 字符串比较"></a>5. 字符串比较</h4><h5 id="使用-比较"><a href="#使用-比较" class="headerlink" title="使用 == 比较"></a>使用 <code>==</code> 比较</h5><p><code>==</code> 比较的是两个字符串对象的引用是否相等，即是否指向同一个内存地址。</p><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = &quot;Hello&quot;;String str3 = new String(&quot;Hello&quot;);System.out.println(str1 == str2); // 输出 true，因为它们引用常量池中的同一个对象System.out.println(str1 == str3); // 输出 false，因为 str3 在堆内存中是新对象</code></pre><h5 id="使用-equals-方法比较"><a href="#使用-equals-方法比较" class="headerlink" title="使用 equals 方法比较"></a>使用 <code>equals</code> 方法比较</h5><p><code>equals</code> 方法比较的是两个字符串的内容是否相等。</p><pre><code class="java">String str1 = &quot;Hello&quot;;String str2 = new String(&quot;Hello&quot;);System.out.println(str1.equals(str2)); // 输出 true，因为内容相同</code></pre><h4 id="6-字符串分割"><a href="#6-字符串分割" class="headerlink" title="6. 字符串分割"></a>6. 字符串分割</h4><pre><code class="java">String str = &quot;Java,Python,C++&quot;;String[] parts = str.split(&quot;,&quot;);for (String part : parts) &#123;    System.out.println(part);&#125;</code></pre><p>上述代码将字符串按逗号进行分割，结果存储在字符串数组中。</p><h4 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h4><p><img src="/../images/java/1741698218188.png" alt="1741698218188"></p><h5 id="1-Java-字符串的内部表示"><a href="#1-Java-字符串的内部表示" class="headerlink" title="1. Java 字符串的内部表示"></a>1. Java 字符串的内部表示</h5><p>在 Java 中，<code>String</code> 类的对象在内存中是以 Unicode 编码形式存储的，Unicode 是一种字符编码标准，它为世界上几乎所有的字符都分配了一个唯一的数字代码，这使得 Java 能够处理各种语言的文本。</p><h5 id="2-编码与解码操作"><a href="#2-编码与解码操作" class="headerlink" title="2. 编码与解码操作"></a>2. 编码与解码操作</h5><h6 id="编码（将字符串转换为字节数组）"><a href="#编码（将字符串转换为字节数组）" class="headerlink" title="编码（将字符串转换为字节数组）"></a>编码（将字符串转换为字节数组）</h6><p>使用 <code>String</code> 类的 <code>getBytes()</code> 方法可以将字符串按照指定的字符编码转换为字节数组。如果不指定编码，默认使用平台的默认字符编码。</p><pre><code class="java">import java.io.UnsupportedEncodingException;public class StringEncodingExample &#123;    public static void main(String[] args) &#123;        String str = &quot;你好，世界！&quot;;        try &#123;            // 使用 UTF-8 编码将字符串转换为字节数组            byte[] utf8Bytes = str.getBytes(&quot;UTF-8&quot;);            System.out.println(&quot;UTF-8 编码后的字节数组长度: &quot; + utf8Bytes.length);            // 使用 GBK 编码将字符串转换为字节数组            byte[] gbkBytes = str.getBytes(&quot;GBK&quot;);            System.out.println(&quot;GBK 编码后的字节数组长度: &quot; + gbkBytes.length);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>在上述代码中，我们将字符串 <code>&quot;你好，世界！&quot;</code> 分别使用 UTF - 8 和 GBK 编码转换为字节数组，并输出字节数组的长度。由于不同的编码方案对字符的编码方式不同，所以得到的字节数组长度可能不同。</p><h6 id="解码（将字节数组转换为字符串）"><a href="#解码（将字节数组转换为字符串）" class="headerlink" title="解码（将字节数组转换为字符串）"></a>解码（将字节数组转换为字符串）</h6><p>使用 <code>String</code> 类的构造函数可以将字节数组按照指定的字符编码转换为字符串。</p><pre><code class="java">import java.io.UnsupportedEncodingException;public class StringDecodingExample &#123;    public static void main(String[] args) &#123;        String str = &quot;你好，世界！&quot;;        try &#123;            // 使用 UTF-8 编码将字符串转换为字节数组            byte[] utf8Bytes = str.getBytes(&quot;UTF-8&quot;);            // 使用 UTF-8 编码将字节数组解码为字符串            String decodedStr = new String(utf8Bytes, &quot;UTF-8&quot;);            System.out.println(&quot;解码后的字符串: &quot; + decodedStr);        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>在上述代码中，我们先将字符串使用 UTF - 8 编码转换为字节数组，然后再使用相同的编码将字节数组解码为字符串，并输出解码后的字符串。</p><h5 id="3-常见的字符编码"><a href="#3-常见的字符编码" class="headerlink" title="3. 常见的字符编码"></a>3. 常见的字符编码</h5><h6 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF - 8"></a>UTF - 8</h6><p>UTF - 8 是一种可变长度的 Unicode 编码，它使用 1 到 4 个字节来表示一个字符。对于 ASCII 字符（即 Unicode 编码范围在 0 - 127 之间的字符），UTF - 8 只使用 1 个字节，与 ASCII 编码兼容。对于大多数常用的汉字，UTF - 8 使用 3 个字节表示。UTF - 8 是互联网上最常用的字符编码，因为它能够处理各种语言的文本，并且对于英文文本的存储效率较高。</p><h6 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h6><p>GBK 是中国国家标准的中文字符编码，它是对 GB2312 编码的扩展，能够表示 21003 个汉字和图形符号。GBK 使用 2 个字节来表示一个汉字，对于 ASCII 字符，GBK 同样只使用 1 个字节。GBK 主要用于中文操作系统和中文文本处理。</p><h6 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO - 8859 - 1"></a>ISO - 8859 - 1</h6><p>ISO - 8859 - 1 是一种单字节编码，它只能表示 256 个字符，主要用于西欧语言。ISO - 8859 - 1 是 Java 中默认的字符编码之一，但它不能表示中文等非西欧语言的字符。</p><h5 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h5><ul><li><strong>编码一致性</strong>：在进行编码和解码操作时，必须确保使用相同的字符编码，否则会导致乱码问题。例如，如果使用 UTF - 8 编码将字符串转换为字节数组，那么在解码时也必须使用 UTF - 8 编码。</li><li><strong>异常处理</strong>：在使用 <code>getBytes()</code> 方法和 <code>String</code> 构造函数时，可能会抛出 <code>UnsupportedEncodingException</code> 异常，因此需要进行异常处理。</li></ul><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p><img src="/../images/java/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-11%20214218.png"></p><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><code>StringBuffer</code> 是一个线程安全的可变字符序列。它继承自 <code>AbstractStringBuilder</code> 类，与 <code>String</code> 不同，<code>StringBuffer</code> 对象的内容可以被动态修改，不会像 <code>String</code> 那样每次修改都创建新的对象，从而避免了频繁创建对象带来的性能开销。</p><h5 id="创建-StringBuffer-对象"><a href="#创建-StringBuffer-对象" class="headerlink" title="创建 StringBuffer 对象"></a>创建 <code>StringBuffer</code> 对象</h5><p>可以通过以下几种方式创建 <code>StringBuffer</code> 对象：</p><pre><code class="java">// 1. 创建一个空的 StringBuffer 对象StringBuffer sb1 = new StringBuffer();// 2. 创建一个初始容量为 20 的 StringBuffer 对象StringBuffer sb2 = new StringBuffer(20);// 3. 使用指定的字符串初始化 StringBuffer 对象StringBuffer sb3 = new StringBuffer(&quot;Hello&quot;);</code></pre><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="1-append-方法"><a href="#1-append-方法" class="headerlink" title="1. append() 方法"></a>1. <code>append()</code> 方法</h6><p>用于将各种类型的数据追加到 <code>StringBuffer</code> 的末尾。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.append(&quot; World&quot;); // 追加字符串sb.append(123); // 追加整数System.out.println(sb); // 输出: Hello World123</code></pre><h6 id="2-insert-方法"><a href="#2-insert-方法" class="headerlink" title="2. insert() 方法"></a>2. <code>insert()</code> 方法</h6><p>用于在指定位置插入各种类型的数据。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.insert(2, &quot;abc&quot;); // 在索引为 2 的位置插入字符串System.out.println(sb); // 输出: Heabcllo</code></pre><h6 id="3-delete-方法"><a href="#3-delete-方法" class="headerlink" title="3. delete() 方法"></a>3. <code>delete()</code> 方法</h6><p>用于删除指定范围内的字符。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello World&quot;);sb.delete(6, 11); // 删除索引从 6 到 10 的字符System.out.println(sb); // 输出: Hello</code></pre><h6 id="4-replace-方法"><a href="#4-replace-方法" class="headerlink" title="4. replace() 方法"></a>4. <code>replace()</code> 方法</h6><p>用于替换指定范围内的字符。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.replace(1, 4, &quot;abc&quot;); // 替换索引从 1 到 3 的字符System.out.println(sb); // 输出: Habco</code></pre><h6 id="5-reverse-方法"><a href="#5-reverse-方法" class="headerlink" title="5. reverse() 方法"></a>5. <code>reverse()</code> 方法</h6><p>用于反转 <code>StringBuffer</code> 中的字符序列。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);sb.reverse();System.out.println(sb); // 输出: olleH</code></pre><h6 id="6-toString-方法"><a href="#6-toString-方法" class="headerlink" title="6. toString() 方法"></a>6. <code>toString()</code> 方法</h6><p>将 <code>StringBuffer</code> 对象转换为 <code>String</code> 对象。</p><pre><code class="java">StringBuffer sb = new StringBuffer(&quot;Hello&quot;);String str = sb.toString();System.out.println(str); // 输出: Hello</code></pre><h5 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h5><p><code>StringBuffer</code> 是线程安全的，这意味着在多线程环境下可以安全地使用它。它的大部分方法都使用了 <code>synchronized</code> 关键字进行同步，确保在同一时间只有一个线程可以修改 <code>StringBuffer</code> 的内容。</p><h5 id="与-StringBuilder-的比较"><a href="#与-StringBuilder-的比较" class="headerlink" title="与 StringBuilder 的比较"></a>与 <code>StringBuilder</code> 的比较</h5><p><code>StringBuilder</code> 也是一个可变的字符序列类，它与 <code>StringBuffer</code> 的功能非常相似，但 <code>StringBuilder</code> 是非线程安全的。在单线程环境下，由于不需要进行同步操作，<code>StringBuilder</code> 的性能通常比 <code>StringBuffer</code> 要好。因此，如果是在单线程环境中进行字符串的频繁修改，建议使用 <code>StringBuilder</code>；如果是在多线程环境中，为了保证线程安全，应该使用 <code>StringBuffer</code>。</p><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p><img src="/../images/java/1741702404265.png" alt="1741702404265"></p><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p><img src="/../images/java/1741702461774.png" alt="1741702461774"></p><h4 id="1-对基本数据类型数组排序"><a href="#1-对基本数据类型数组排序" class="headerlink" title="1. 对基本数据类型数组排序"></a>1. 对基本数据类型数组排序</h4><p><code>Arrays.sort()</code> 可以对基本数据类型的数组进行排序，如 <code>int</code>、<code>double</code>、<code>char</code> 等。排序是按照升序进行的，使用的是双轴快速排序（Dual-Pivot Quicksort）算法，对于小规模数组会使用插入排序。</p><p><strong>示例代码</strong></p><pre><code class="java">import java.util.Arrays;public class BasicArraySorting &#123;    public static void main(String[] args) &#123;        // 对 int 数组排序        int[] intArray = &#123;5, 3, 8, 1, 2&#125;;        Arrays.sort(intArray);        System.out.println(&quot;排序后的 int 数组: &quot; + Arrays.toString(intArray));        // 对 char 数组排序        char[] charArray = &#123;&#39;d&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;&#125;;        Arrays.sort(charArray);        System.out.println(&quot;排序后的 char 数组: &quot; + Arrays.toString(charArray));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li>对于 <code>int</code> 数组 <code>intArray</code>，调用 <code>Arrays.sort(intArray)</code> 后，数组元素会按升序排列。</li><li>对于 <code>char</code> 数组 <code>charArray</code>，同样调用 <code>Arrays.sort(charArray)</code> 进行升序排序。</li></ul><h4 id="2-对对象数组排序"><a href="#2-对对象数组排序" class="headerlink" title="2. 对对象数组排序"></a>2. 对对象数组排序</h4><p>当对对象数组进行排序时，数组中的元素类型必须实现 <code>java.lang.Comparable</code> 接口，或者在调用 <code>Arrays.sort()</code> 方法时传入一个 <code>java.util.Comparator</code> 对象来指定排序规则。</p><h5 id="2-1-实现-Comparable-接口"><a href="#2-1-实现-Comparable-接口" class="headerlink" title="2.1 实现 Comparable 接口"></a>2.1 实现 <code>Comparable</code> 接口</h5><p><code>Comparable</code> 接口有一个抽象方法 <code>compareTo()</code>，用于定义对象之间的比较规则。</p><pre><code class="java">import java.util.Arrays;class Student implements Comparable&lt;Student&gt; &#123;    private String name;    private int age;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public int compareTo(Student other) &#123;        return Integer.compare(this.age, other.age);    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;name=&#39;&quot; + name + &quot;&#39;, age=&quot; + age + &quot;&#125;&quot;;    &#125;&#125;public class ObjectArraySortingComparable &#123;    public static void main(String[] args) &#123;        Student[] students = &#123;                new Student(&quot;Alice&quot;, 20),                new Student(&quot;Bob&quot;, 18),                new Student(&quot;Charlie&quot;, 22)        &#125;;        Arrays.sort(students);        System.out.println(&quot;按年龄排序后的学生数组: &quot; + Arrays.toString(students));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><code>Student</code> 类实现了 <code>Comparable</code> 接口，并重写了 <code>compareTo()</code> 方法，按照学生的年龄进行比较。</li><li>调用 <code>Arrays.sort(students)</code> 时，会根据 <code>compareTo()</code> 方法定义的规则对学生数组进行排序。</li></ul><h5 id="2-2-使用-Comparator-接口"><a href="#2-2-使用-Comparator-接口" class="headerlink" title="2.2 使用 Comparator 接口"></a>2.2 使用 <code>Comparator</code> 接口</h5><p>如果不想修改类的定义，或者需要临时定义不同的排序规则，可以使用 <code>Comparator</code> 接口。</p><pre><code class="java">import java.util.Arrays;import java.util.Comparator;class Person &#123;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;name=&#39;&quot; + name + &quot;&#39;, age=&quot; + age + &quot;&#125;&quot;;    &#125;&#125;public class ObjectArraySortingComparator &#123;    public static void main(String[] args) &#123;        Person[] persons = &#123;                new Person(&quot;Alice&quot;, 20),                new Person(&quot;Bob&quot;, 18),                new Person(&quot;Charlie&quot;, 22)        &#125;;        // 按年龄降序排序        Arrays.sort(persons, new Comparator&lt;Person&gt;() &#123;            @Override            public int compare(Person p1, Person p2) &#123;                return Integer.compare(p2.age, p1.age);            &#125;        &#125;);        System.out.println(&quot;按年龄降序排序后的人员数组: &quot; + Arrays.toString(persons));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><code>Person</code> 类没有实现 <code>Comparable</code> 接口，在调用 <code>Arrays.sort()</code> 时传入了一个匿名的 <code>Comparator</code> 对象，重写了 <code>compare()</code> 方法，实现了按年龄降序排序。</li></ul><h4 id="3-对部分数组元素排序"><a href="#3-对部分数组元素排序" class="headerlink" title="3. 对部分数组元素排序"></a>3. 对部分数组元素排序</h4><p><code>Arrays.sort()</code> 还提供了对数组部分元素进行排序的重载方法，通过指定起始索引和结束索引来确定排序的范围。</p><pre><code class="java">import java.util.Arrays;public class PartialArraySorting &#123;    public static void main(String[] args) &#123;        int[] array = &#123;5, 3, 8, 1, 2, 7, 4, 6&#125;;        // 对索引从 1 到 4（不包括 4）的元素进行排序        Arrays.sort(array, 1, 4);        System.out.println(&quot;部分排序后的数组: &quot; + Arrays.toString(array));    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li><code>Arrays.sort(array, 1, 4)</code> 只对数组 <code>array</code> 中索引从 1 到 3 的元素进行排序，其他元素保持不变。</li></ul><h4 id="4-二分查找方法"><a href="#4-二分查找方法" class="headerlink" title="4. 二分查找方法"></a>4. 二分查找方法</h4><ul><li><code>binarySearch()</code>：在已排序的数组中使用二分查找算法查找指定元素，返回元素的索引，如果未找到则返回负数。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysBinarySearchExample &#123;    public static void main(String[] args) &#123;        int[] intArray = &#123;1, 2, 3, 5, 8&#125;;        int index = Arrays.binarySearch(intArray, 5);        System.out.println(&quot;元素 5 的索引是: &quot; + index);         // 输出: 元素 5 的索引是: 3    &#125;&#125;</code></pre><h4 id="5-数组填充方法"><a href="#5-数组填充方法" class="headerlink" title="5. 数组填充方法"></a>5. 数组填充方法</h4><ul><li><code>fill()</code>：用指定的值填充数组的所有元素或指定范围的元素。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysFillExample &#123;    public static void main(String[] args) &#123;        int[] intArray = new int[5];        Arrays.fill(intArray, 10);        System.out.println(Arrays.toString(intArray));         // 输出: [10, 10, 10, 10, 10]    &#125;&#125;</code></pre><h4 id="6-数组比较方法"><a href="#6-数组比较方法" class="headerlink" title="6. 数组比较方法"></a>6. 数组比较方法</h4><ul><li><code>equals()</code>：比较两个数组是否相等，会比较数组的长度和对应位置的元素。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysEqualsExample &#123;    public static void main(String[] args) &#123;        int[] array1 = &#123;1, 2, 3&#125;;        int[] array2 = &#123;1, 2, 3&#125;;        boolean isEqual = Arrays.equals(array1, array2);        System.out.println(&quot;两个数组是否相等: &quot; + isEqual);         // 输出: 两个数组是否相等: true    &#125;&#125;</code></pre><h4 id="7-数组转字符串方法"><a href="#7-数组转字符串方法" class="headerlink" title="7. 数组转字符串方法"></a>7. 数组转字符串方法</h4><ul><li><code>toString()</code>：返回数组的字符串表示形式，方便调试和输出。</li></ul><pre><code class="java">import java.util.Arrays;public class ArraysToStringExample &#123;    public static void main(String[] args) &#123;        int[] intArray = &#123;1, 2, 3&#125;;        String arrayString = Arrays.toString(intArray);        System.out.println(arrayString);         // 输出: [1, 2, 3]    &#125;&#125;</code></pre><h4 id="8-数组复制方法"><a href="#8-数组复制方法" class="headerlink" title="8.数组复制方法"></a>8.数组复制方法</h4><p><code>Arrays.copyOf</code> 有多个重载版本，常见的方法签名如下：</p><pre><code class="java">// 复制指定数组的指定长度部分到一个新数组中，元素类型为基本数据类型（以 int 为例）public static int[] copyOf(int[] original, int newLength)// 复制指定数组的指定长度部分到一个新数组中，元素类型为对象类型（以 String 为例）public static &lt;T&gt; T[] copyOf(T[] original, int newLength)</code></pre><ul><li><code>original</code>：要复制的原始数组。</li><li><code>newLength</code>：新数组的长度。</li><li>若 <code>newLength</code> 小于原始数组的长度，新数组将只包含原始数组的前 <code>newLength</code> 个元素；若 <code>newLength</code> 大于原始数组的长度，新数组中超出原始数组长度的部分会用对应类型的默认值填充（对于基本数据类型，如 <code>int</code> 是 0，<code>boolean</code> 是 <code>false</code>；对于对象类型是 <code>null</code>）。</li></ul><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p><img src="/../images/java/1741702473807.png" alt="1741702473807"></p><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><h5 id="1-System-in"><a href="#1-System-in" class="headerlink" title="1. System.in"></a>1. <code>System.in</code></h5><p>这是一个 <code>InputStream</code> 类型的静态属性，代表标准输入流，通常关联到键盘输入。在控制台程序中，可利用它从用户那里获取输入信息。</p><pre><code class="java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class SystemInExample &#123;    public static void main(String[] args) &#123;        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) &#123;            System.out.print(&quot;请输入一些内容: &quot;);            String input = reader.readLine();            System.out.println(&quot;你输入的内容是: &quot; + input);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h5 id="2-System-out"><a href="#2-System-out" class="headerlink" title="2. System.out"></a>2. <code>System.out</code></h5><p>它是一个 <code>PrintStream</code> 类型的静态属性，代表标准输出流，通常关联到控制台输出。借助它可以将信息输出到控制台。</p><pre><code class="java">public class SystemOutExample &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;这是一个输出示例。&quot;);    &#125;&#125;</code></pre><h5 id="3-System-err"><a href="#3-System-err" class="headerlink" title="3. System.err"></a>3. <code>System.err</code></h5><p>同样是 <code>PrintStream</code> 类型的静态属性，代表标准错误输出流，也关联到控制台。一般用于输出错误信息，与 <code>System.out</code> 不同的是，它输出的内容通常会以不同颜色显示（取决于控制台设置）。</p><pre><code class="java">public class SystemErrExample &#123;    public static void main(String[] args) &#123;        try &#123;            int result = 1 / 0;        &#125; catch (ArithmeticException e) &#123;            System.err.println(&quot;发生错误: &quot; + e.getMessage());        &#125;    &#125;&#125;</code></pre><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-System-currentTimeMillis"><a href="#1-System-currentTimeMillis" class="headerlink" title="1. System.currentTimeMillis()"></a>1. <code>System.currentTimeMillis()</code></h5><p>返回当前时间（从 1970 年 1 月 1 日 00:00:00 UTC 到现在的毫秒数），常用来计算代码的执行时间。</p><pre><code class="java">public class CurrentTimeMillisExample &#123;    public static void main(String[] args) &#123;        long startTime = System.currentTimeMillis();        // 模拟一段耗时操作        for (int i = 0; i &lt; 1000000; i++) &#123;            // 空循环        &#125;        long endTime = System.currentTimeMillis();        System.out.println(&quot;操作耗时: &quot; + (endTime - startTime) + &quot; 毫秒&quot;);    &#125;&#125;</code></pre><h5 id="2-System-arraycopy"><a href="#2-System-arraycopy" class="headerlink" title="2. System.arraycopy()"></a>2. <code>System.arraycopy()</code></h5><p>用于将一个数组的指定部分复制到另一个数组中，是一个高效的数组复制方法。</p><pre><code class="java">public class ArrayCopyExample &#123;    public static void main(String[] args) &#123;        int[] source = &#123;1, 2, 3, 4, 5&#125;;        int[] destination = new int[5];        System.arraycopy(source, 0, destination, 0, 5);        for (int num : destination) &#123;            System.out.print(num + &quot; &quot;);        &#125;    &#125;&#125;</code></pre><h5 id="3-System-getProperties"><a href="#3-System-getProperties" class="headerlink" title="3. System.getProperties()"></a>3. <code>System.getProperties()</code></h5><p>返回一个 <code>Properties</code> 对象，包含了当前系统的所有属性，如操作系统名称、Java 版本等。</p><pre><code class="java">import java.util.Properties;public class GetPropertiesExample &#123;    public static void main(String[] args) &#123;        Properties properties = System.getProperties();        properties.list(System.out);    &#125;&#125;</code></pre><h5 id="4-System-setProperty-String-key-String-value"><a href="#4-System-setProperty-String-key-String-value" class="headerlink" title="4. System.setProperty(String key, String value)"></a>4. <code>System.setProperty(String key, String value)</code></h5><p>用于设置系统属性，可在程序运行时动态修改系统属性。</p><pre><code class="java">public class SetPropertyExample &#123;    public static void main(String[] args) &#123;        System.setProperty(&quot;my.property&quot;, &quot;my value&quot;);        String value = System.getProperty(&quot;my.property&quot;);        System.out.println(&quot;自定义属性的值: &quot; + value);    &#125;&#125;</code></pre><h5 id="5-System-exit-int-status"><a href="#5-System-exit-int-status" class="headerlink" title="5. System.exit(int status)"></a>5. <code>System.exit(int status)</code></h5><p>用于终止当前正在运行的 Java 虚拟机。参数 <code>status</code> 为 0 表示正常退出，非 0 表示异常退出。</p><pre><code class="java">public class ExitExample &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;程序即将退出...&quot;);        System.exit(0);        System.out.println(&quot;这行代码不会执行。&quot;);    &#125;&#125;</code></pre><h3 id="BigInteger-BigDecimal的方法和它差不多）"><a href="#BigInteger-BigDecimal的方法和它差不多）" class="headerlink" title="BigInteger(BigDecimal的方法和它差不多）"></a>BigInteger(BigDecimal的方法和它差不多）</h3><p><img src="/../images/java-notes/1741785405658.png" alt="1741785405658"></p><h4 id="创建-BigInteger-对象"><a href="#创建-BigInteger-对象" class="headerlink" title="创建 BigInteger 对象"></a>创建 <code>BigInteger</code> 对象</h4><p><code>BigInteger</code> 提供了多种创建对象的方式：</p><ul><li><strong>使用字符串构造</strong>：可以将一个表示整数的字符串作为参数传递给 <code>BigInteger</code> 的构造函数。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerCreation &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;12345678901234567890&quot;);        System.out.println(&quot;num1: &quot; + num1);    &#125;&#125;</code></pre><ul><li><strong>使用基本数据类型转换</strong>：可以将 <code>int</code>、<code>long</code> 等基本数据类型转换为 <code>BigInteger</code> 对象。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerCreationFromPrimitive &#123;    public static void main(String[] args) &#123;        int intValue = 123;        BigInteger num2 = BigInteger.valueOf(intValue);        System.out.println(&quot;num2: &quot; + num2);    &#125;&#125;</code></pre><h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-基本运算方法"><a href="#1-基本运算方法" class="headerlink" title="1. 基本运算方法"></a>1. 基本运算方法</h5><ul><li><strong>加法</strong>：使用 <code>add()</code> 方法进行加法运算。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerAddition &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;10&quot;);        BigInteger num2 = new BigInteger(&quot;20&quot;);        BigInteger sum = num1.add(num2);        System.out.println(&quot;两数之和: &quot; + sum);    &#125;&#125;</code></pre><ul><li><strong>减法</strong>：使用 <code>subtract()</code> 方法进行减法运算。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerSubtraction &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;20&quot;);        BigInteger num2 = new BigInteger(&quot;10&quot;);        BigInteger difference = num1.subtract(num2);        System.out.println(&quot;两数之差: &quot; + difference);    &#125;&#125;</code></pre><ul><li><strong>乘法</strong>：使用 <code>multiply()</code> 方法进行乘法运算。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerMultiplication &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;5&quot;);        BigInteger num2 = new BigInteger(&quot;3&quot;);        BigInteger product = num1.multiply(num2);        System.out.println(&quot;两数之积: &quot; + product);    &#125;&#125;</code></pre><ul><li><strong>除法</strong>：使用 <code>divide()</code> 方法进行除法运算，只返回商。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerDivision &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;10&quot;);        BigInteger num2 = new BigInteger(&quot;3&quot;);        BigInteger quotient = num1.divide(num2);        System.out.println(&quot;两数之商: &quot; + quotient);    &#125;&#125;</code></pre><ul><li><strong>取模</strong>：使用 <code>mod()</code> 方法进行取模运算。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerModulus &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;10&quot;);        BigInteger num2 = new BigInteger(&quot;3&quot;);        BigInteger remainder = num1.mod(num2);        System.out.println(&quot;两数取模结果: &quot; + remainder);    &#125;&#125;</code></pre><h5 id="2-比较方法"><a href="#2-比较方法" class="headerlink" title="2. 比较方法"></a>2. 比较方法</h5><ul><li><strong><code>compareTo()</code> 方法</strong>：用于比较两个 <code>BigInteger</code> 对象的大小。如果当前对象小于参数对象，返回 -1；如果相等，返回 0；如果当前对象大于参数对象，返回 1。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerComparison &#123;    public static void main(String[] args) &#123;        BigInteger num1 = new BigInteger(&quot;10&quot;);        BigInteger num2 = new BigInteger(&quot;20&quot;);        int result = num1.compareTo(num2);        if (result &lt; 0) &#123;            System.out.println(&quot;num1 小于 num2&quot;);        &#125; else if (result == 0) &#123;            System.out.println(&quot;num1 等于 num2&quot;);        &#125; else &#123;            System.out.println(&quot;num1 大于 num2&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="3-转换方法"><a href="#3-转换方法" class="headerlink" title="3. 转换方法"></a>3. 转换方法</h5><ul><li><strong><code>intValue()</code>、<code>longValue()</code> 等</strong>：可以将 <code>BigInteger</code> 对象转换为基本数据类型，但要注意可能会丢失精度。</li></ul><pre><code class="java">import java.math.BigInteger;public class BigIntegerConversion &#123;    public static void main(String[] args) &#123;        BigInteger num = new BigInteger(&quot;123&quot;);        int intValue = num.intValue();        System.out.println(&quot;转换为 int 类型的值: &quot; + intValue);    &#125;&#125;</code></pre><h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>性能问题</strong>：由于 <code>BigInteger</code> 要处理任意精度的整数，其运算性能通常比基本数据类型的运算要低，因此在能使用基本数据类型的情况下，优先使用基本数据类型。</li><li><strong>精度丢失</strong>：在将 <code>BigInteger</code> 转换为基本数据类型时，如果 <code>BigInteger</code> 的值超出了基本数据类型的取值范围，会发生精度丢失。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/../images/java-notes/1741786653399.png" alt="1741786653399"></p><h3 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h3><p><strong>单列集合</strong></p><p><img src="/../images/java-notes/1741786573112.png" alt="1741786573112"></p><p><strong>双列集合</strong></p><p><img src="/../images/java-notes/1741786639451.png" alt="1741786639451"></p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="/../images/java-notes/1741787440825.png" alt="1741787440825"></p><p><code>Collection</code> 是 Java 集合框架中的根接口，它位于 <code>java.util</code> 包下，为各种集合类提供了通用的操作规范。以下将从概述、常用方法、子接口及实现类等方面详细介绍 <code>Collection</code>。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>Collection</code> 接口代表一组对象，这些对象被称为集合的元素。它是 Java 集合框架的基础，许多具体的集合类都实现了这个接口，不同的实现类有不同的数据存储和操作特性，但都遵循 <code>Collection</code> 接口定义的基本操作规则。</p><h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-元素添加方法"><a href="#1-元素添加方法" class="headerlink" title="1. 元素添加方法"></a>1. 元素添加方法</h5><ul><li><code>boolean add(E e)</code>：将指定的元素添加到集合中。如果集合因为此调用而发生改变，则返回 <code>true</code>；如果集合不允许重复元素且已经包含该元素，则返回 <code>false</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class AddExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        boolean result = collection.add(&quot;apple&quot;);        System.out.println(&quot;添加结果: &quot; + result);     &#125;&#125;</code></pre><ul><li><code>boolean addAll(Collection c)</code>：将指定集合中的所有元素添加到当前集合中。如果集合因为此调用而发生改变，则返回 <code>true</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class AddAllExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection1 = new ArrayList&lt;&gt;();        collection1.add(&quot;apple&quot;);        collection1.add(&quot;banana&quot;);        Collection&lt;String&gt; collection2 = new ArrayList&lt;&gt;();        collection2.add(&quot;cherry&quot;);        boolean result = collection1.addAll(collection2);        System.out.println(&quot;添加结果: &quot; + result);         System.out.println(collection1);     &#125;&#125;</code></pre><h5 id="2-元素删除方法"><a href="#2-元素删除方法" class="headerlink" title="2. 元素删除方法"></a>2. 元素删除方法</h5><ul><li><code>boolean remove(Object o)</code>：从集合中移除指定元素的单个实例（如果存在）。如果集合因为此调用而发生改变，则返回 <code>true</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class RemoveExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        collection.add(&quot;apple&quot;);        boolean result = collection.remove(&quot;apple&quot;);        System.out.println(&quot;删除结果: &quot; + result);     &#125;&#125;</code></pre><ul><li><code>boolean removeAll(Collection c)</code>：从当前集合中移除包含在指定集合中的所有元素。如果集合因为此调用而发生改变，则返回 <code>true</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class RemoveAllExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection1 = new ArrayList&lt;&gt;();        collection1.add(&quot;apple&quot;);        collection1.add(&quot;banana&quot;);        Collection&lt;String&gt; collection2 = new ArrayList&lt;&gt;();        collection2.add(&quot;apple&quot;);        boolean result = collection1.removeAll(collection2);        System.out.println(&quot;删除结果: &quot; + result);         System.out.println(collection1);     &#125;&#125;</code></pre><h5 id="3-元素查询方法"><a href="#3-元素查询方法" class="headerlink" title="3. 元素查询方法"></a>3. 元素查询方法</h5><ul><li><code>boolean contains(Object o)</code>：判断集合中是否包含指定元素。如果包含，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class ContainsExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        collection.add(&quot;apple&quot;);        boolean result = collection.contains(&quot;apple&quot;);        System.out.println(&quot;是否包含: &quot; + result);     &#125;&#125;</code></pre><ul><li><code>boolean containsAll(Collection c)</code>：判断当前集合是否包含指定集合中的所有元素。如果包含，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class ContainsAllExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection1 = new ArrayList&lt;&gt;();        collection1.add(&quot;apple&quot;);        collection1.add(&quot;banana&quot;);        Collection&lt;String&gt; collection2 = new ArrayList&lt;&gt;();        collection2.add(&quot;apple&quot;);        boolean result = collection1.containsAll(collection2);        System.out.println(&quot;是否包含所有: &quot; + result);     &#125;&#125;</code></pre><h5 id="4-其他常用方法"><a href="#4-其他常用方法" class="headerlink" title="4. 其他常用方法"></a>4. 其他常用方法</h5><ul><li><code>int size()</code>：返回集合中的元素个数。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class SizeExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        collection.add(&quot;apple&quot;);        int size = collection.size();        System.out.println(&quot;集合大小: &quot; + size);     &#125;&#125;</code></pre><ul><li><code>boolean isEmpty()</code>：判断集合是否为空。如果集合不包含任何元素，则返回 <code>true</code>；否则返回 <code>false</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class IsEmptyExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        boolean isEmpty = collection.isEmpty();        System.out.println(&quot;集合是否为空: &quot; + isEmpty);     &#125;&#125;</code></pre><ul><li><code>void clear()</code>：移除集合中的所有元素。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Collection;public class ClearExample &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();        collection.add(&quot;apple&quot;);        collection.clear();        System.out.println(&quot;集合大小: &quot; + collection.size());     &#125;&#125;</code></pre><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><img src="/../images/java-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-12%20220014.png"></p><p><img src="/../images/java-notes/1741788798038.png" alt="1741788798038"></p><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>List</code> 接口定义了一系列用于操作有序集合的方法，它继承自 <code>Collection</code> 接口，因此也拥有 <code>Collection</code> 接口提供的通用方法，如添加元素、删除元素、检查元素是否存在等。同时，<code>List</code> 接口还提供了基于索引的操作方法，使得可以方便地对集合中的元素进行定位和操作。</p><h4 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-元素添加方法-1"><a href="#1-元素添加方法-1" class="headerlink" title="1. 元素添加方法"></a>1. 元素添加方法</h5><ul><li><code>void add(int index, E element)</code>：在指定索引位置插入指定元素。</li><li><code>boolean add(E e)</code>：将指定元素添加到列表的末尾。</li></ul><h5 id="2-元素删除方法-1"><a href="#2-元素删除方法-1" class="headerlink" title="2. 元素删除方法"></a>2. 元素删除方法</h5><ul><li><code>E remove(int index)</code>：移除列表中指定索引位置的元素，并返回该元素。</li><li><code>boolean remove(Object o)</code>：从列表中移除指定元素的第一个出现项，如果列表包含该元素，则返回 <code>true</code>。</li></ul><h5 id="3-元素获取方法"><a href="#3-元素获取方法" class="headerlink" title="3. 元素获取方法"></a>3. 元素获取方法</h5><ul><li><code>E get(int index)</code>：返回列表中指定索引位置的元素。</li></ul><h5 id="4-元素修改方法"><a href="#4-元素修改方法" class="headerlink" title="4. 元素修改方法"></a>4. 元素修改方法</h5><ul><li><code>E set(int index, E element)</code>：用指定元素替换列表中指定索引位置的元素，并返回被替换的元素。</li></ul><h5 id="5-元素查找方法"><a href="#5-元素查找方法" class="headerlink" title="5. 元素查找方法"></a>5. 元素查找方法</h5><ul><li><code>int indexOf(Object o)</code>：返回指定元素在列表中第一次出现的索引，如果列表不包含该元素，则返回 -1。</li><li><code>int lastIndexOf(Object o)</code>：返回指定元素在列表中最后一次出现的索引，如果列表不包含该元素，则返回 -1。</li></ul><h4 id="遍历-List-的方式"><a href="#遍历-List-的方式" class="headerlink" title="遍历 List 的方式"></a>遍历 <code>List</code> 的方式</h4><h5 id="1-使用-for-each-循环"><a href="#1-使用-for-each-循环" class="headerlink" title="1. 使用 for-each 循环"></a>1. 使用 <code>for-each</code> 循环</h5><pre><code class="java">import java.util.ArrayList;import java.util.List;public class ListTraversalForEach &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;apple&quot;);        list.add(&quot;banana&quot;);        list.add(&quot;cherry&quot;);        for (String element : list) &#123;            System.out.println(element);        &#125;    &#125;&#125;</code></pre><h5 id="2-使用迭代器"><a href="#2-使用迭代器" class="headerlink" title="2. 使用迭代器"></a>2. 使用迭代器</h5><pre><code class="java">import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ListTraversalIterator &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;apple&quot;);        list.add(&quot;banana&quot;);        list.add(&quot;cherry&quot;);        Iterator&lt;String&gt; iterator = list.iterator();        while (iterator.hasNext()) &#123;            String element = iterator.next();            System.out.println(element);        &#125;    &#125;&#125;</code></pre><p><strong>注意！！！</strong></p><p><strong>迭代器初始位置</strong></p><p>迭代器的初始位置是在集合第一个元素之前，它起到一个游标或者指针的作用，用于控制对集合元素的访问顺序，但本身并不直接存储集合中的元素值。<code>iterator()</code> 方法创建的迭代器就像是一个站在集合元素队列 “入口外” 的引导者，还未进入队列开始引导访问元素。</p><h5 id="3-使用普通-for-循环"><a href="#3-使用普通-for-循环" class="headerlink" title="3. 使用普通 for 循环"></a>3. 使用普通 <code>for</code> 循环</h5><pre><code class="java">import java.util.ArrayList;import java.util.List;public class ListTraversalForLoop &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;apple&quot;);        list.add(&quot;banana&quot;);        list.add(&quot;cherry&quot;);        for (int i = 0; i &lt; list.size(); i++) &#123;            String element = list.get(i);            System.out.println(element);        &#125;    &#125;&#125;</code></pre><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><img src="/../images/java-notes/1741868896927.png" alt="1741868896927"></p><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>ArrayList</code> 是一个可调整大小的数组实现，用于存储对象元素。与传统的数组不同，<code>ArrayList</code> 的大小可以动态增长，当添加的元素超过当前容量时，它会自动进行扩容。<code>ArrayList</code> 允许存储重复元素，并且元素是有序的，每个元素都有一个对应的索引，可以通过索引快速访问元素。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**<code>ArrayList()</code>**：创建一个初始容量为 10 的空 <code>ArrayList</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.List;public class ArrayListConstructorExample &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        System.out.println(&quot;初始大小: &quot; + list.size());     &#125;&#125;</code></pre><ul><li>**<code>ArrayList(int initialCapacity)</code>**：创建一个具有指定初始容量的空 <code>ArrayList</code>。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.List;public class ArrayListConstructorWithCapacity &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(20);        System.out.println(&quot;初始容量: &quot; + ((ArrayList&lt;Integer&gt;) list).capacity());     &#125;&#125;</code></pre><ul><li>**<code>ArrayList(Collection c)</code>**：创建一个包含指定集合元素的 <code>ArrayList</code>，元素顺序与指定集合的迭代器返回顺序相同。</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class ArrayListConstructorWithCollection &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; sourceList = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;);        List&lt;String&gt; list = new ArrayList&lt;&gt;(sourceList);        System.out.println(list);     &#125;&#125;</code></pre><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p><code>ArrayList</code> 的底层是基于数组实现的，当添加元素时，如果当前数组容量不足，<code>ArrayList</code> 会进行扩容。默认情况下，初始容量为 10，当元素数量超过当前容量时，会创建一个新的数组，新数组的容量为原来的 1.5 倍（即 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>），然后将原数组中的元素复制到新数组中。</p><h4 id="性能特点"><a href="#性能特点" class="headerlink" title="性能特点"></a>性能特点</h4><ul><li><strong>随机访问性能好</strong>：由于 <code>ArrayList</code> 是基于数组实现的，通过索引可以直接访问数组中的元素，时间复杂度为 (O(1))，因此随机访问性能非常高。</li><li><strong>插入和删除性能较差</strong>：在数组中间插入或删除元素时，需要移动大量元素，时间复杂度为 (O(n))，性能相对较低。特别是在数组开头插入或删除元素时，性能开销更大。</li><li><strong>尾部添加元素性能较好</strong>：在数组末尾添加元素时，如果不需要扩容，时间复杂度为 (O(1))；如果需要扩容，虽然会有一定的性能开销，但平均情况下时间复杂度仍然接近 (O(1))。</li></ul><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p><img src="/../images/java-notes/1741870447441.png" alt="1741870447441"></p><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>Vector</code> 类是 <code>List</code> 接口的一个实现类，它可以存储任意类型的对象，并且允许存储重复元素。<code>Vector</code> 中的元素是有序的，每个元素都有一个对应的索引，通过索引可以访问和操作元素。与普通数组不同的是，<code>Vector</code> 的大小可以动态变化，当添加的元素超过当前容量时，<code>Vector</code> 会自动扩容。</p><h4 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h4><ul><li>**<code>Vector()</code>**：创建一个空的 <code>Vector</code> 对象，初始容量为 10。</li></ul><pre><code class="java">import java.util.Vector;public class VectorConstructorExample &#123;    public static void main(String[] args) &#123;        Vector&lt;String&gt; vector = new Vector&lt;&gt;();        System.out.println(&quot;初始容量: &quot; + vector.capacity());     &#125;&#125;</code></pre><ul><li>**<code>Vector(int initialCapacity)</code>**：创建一个具有指定初始容量的 <code>Vector</code> 对象。</li></ul><pre><code class="java">import java.util.Vector;public class VectorConstructorWithCapacity &#123;    public static void main(String[] args) &#123;        Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(20);        System.out.println(&quot;初始容量: &quot; + vector.capacity());     &#125;&#125;</code></pre><ul><li>**<code>Vector(int initialCapacity, int capacityIncrement)</code>**：创建一个具有指定初始容量和容量增量的 <code>Vector</code> 对象。当 <code>Vector</code> 需要扩容时，会按照指定的容量增量增加容量。</li></ul><pre><code class="java">import java.util.Vector;public class VectorConstructorWithIncrement &#123;    public static void main(String[] args) &#123;        Vector&lt;Double&gt; vector = new Vector&lt;&gt;(10, 5);        System.out.println(&quot;初始容量: &quot; + vector.capacity());     &#125;&#125;</code></pre><h4 id="线程安全性-1"><a href="#线程安全性-1" class="headerlink" title="线程安全性"></a>线程安全性</h4><p><code>Vector</code> 是线程安全的，它的大部分方法都使用了 <code>synchronized</code> 关键字进行同步，这意味着在多线程环境下，多个线程可以安全地访问和修改同一个 <code>Vector</code> 对象，不会出现数据不一致的问题。例如：</p><pre><code class="java">import java.util.Vector;public class VectorThreadSafetyExample &#123;    private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;();    public static void main(String[] args) throws InterruptedException &#123;        // 创建线程 1        Thread t1 = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 1000; i++) &#123;                vector.addElement(i);            &#125;        &#125;);        // 创建线程 2        Thread t2 = new Thread(() -&gt; &#123;            for (int i = 1000; i &lt; 2000; i++) &#123;                vector.addElement(i);            &#125;        &#125;);        // 启动线程        t1.start();        t2.start();        // 等待线程执行完毕        t1.join();        t2.join();        System.out.println(&quot;Vector 的大小: &quot; + vector.size());     &#125;&#125;</code></pre><p>在上述代码中，两个线程同时对 <code>Vector</code> 对象进行添加元素的操作，由于 <code>Vector</code> 是线程安全的，最终输出的 <code>Vector</code> 大小为 2000。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p><img src="/../images/java-notes/1741870992972.png" alt="1741870992972"></p><h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>LinkedList</code> 是一种基于双向链表实现的集合类，它可以存储任意类型的元素，并且允许存储重复元素。元素在 <code>LinkedList</code> 中以链表节点的形式存储，每个节点包含一个元素和指向前一个节点和后一个节点的引用。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>LinkedList</code> 采用双向链表的数据结构，每个节点（<code>Node</code>）包含三个部分：</p><ul><li><strong>元素（<code>item</code>）</strong>：存储实际的数据。</li><li><strong>指向前一个节点的引用（<code>prev</code>）</strong>：用于在链表中向前遍历。</li><li><strong>指向后一个节点的引用（<code>next</code>）</strong>：用于在链表中向后遍历。</li></ul><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**<code>LinkedList()</code>**：创建一个空的 <code>LinkedList</code>。</li></ul><pre><code class="java">import java.util.LinkedList;import java.util.List;public class LinkedListConstructorExample &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new LinkedList&lt;&gt;();        System.out.println(&quot;初始大小: &quot; + list.size());     &#125;&#125;</code></pre><ul><li>**<code>LinkedList(Collection c)</code>**：创建一个包含指定集合元素的 <code>LinkedList</code>，元素顺序与指定集合的迭代器返回顺序相同。</li></ul><pre><code class="java">import java.util.Arrays;import java.util.LinkedList;import java.util.List;public class LinkedListConstructorWithCollection &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; sourceList = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;);        List&lt;String&gt; list = new LinkedList&lt;&gt;(sourceList);        System.out.println(list);     &#125;&#125;</code></pre><h4 id="性能特点-1"><a href="#性能特点-1" class="headerlink" title="性能特点"></a>性能特点</h4><ul><li><strong>插入和删除性能好</strong>：在链表的任意位置插入或删除元素时，只需要修改相邻节点的引用，时间复杂度为 (O(1))。特别是在链表的头部和尾部进行插入和删除操作时，性能非常高。</li><li><strong>随机访问性能差</strong>：由于 <code>LinkedList</code> 是基于链表实现的，要访问指定索引位置的元素，需要从头或尾开始遍历链表，平均时间复杂度为 (O(n))，因此随机访问性能较差。</li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>频繁的插入和删除操作</strong>：如果需要在集合的任意位置频繁进行插入和删除操作，<code>LinkedList</code> 是一个不错的选择，例如实现栈、队列等数据结构。</li><li><strong>不需要频繁随机访问</strong>：当不需要频繁通过索引访问元素时，使用 <code>LinkedList</code> 可以避免因随机访问带来的性能开销。</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><img src="/../images/java-notes/1741873566977.png" alt="1741873566977"></p><h4 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>Set</code> 接口是 Java 集合框架的重要组成部分，它定义了一组不重复元素的集合规范。与 <code>List</code> 接口不同，<code>Set</code> 不保证元素的顺序，即元素在集合中的存储顺序和插入顺序可能不同。<code>Set</code> 接口不允许存储重复元素，当尝试添加重复元素时，添加操作会失败。</p><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>去重操作</strong>：由于 <code>Set</code> 不允许存储重复元素，因此可以很方便地对数据进行去重。例如，从一个包含重复元素的列表中提取不重复的元素：</li></ul><pre><code class="java">import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;public class SetForDuplicateRemoval &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; listWithDuplicates = new ArrayList&lt;&gt;();        listWithDuplicates.add(&quot;apple&quot;);        listWithDuplicates.add(&quot;banana&quot;);        listWithDuplicates.add(&quot;apple&quot;);        Set&lt;String&gt; set = new HashSet&lt;&gt;(listWithDuplicates);        System.out.println(set);     &#125;&#125;</code></pre><ul><li><strong>判断元素是否存在</strong>：<code>Set</code> 的查找操作性能通常较好，特别是 <code>HashSet</code>，可以快速判断一个元素是否存在于集合中。例如，判断一个单词是否在字典中：</li></ul><pre><code class="java">import java.util.HashSet;import java.util.Set;public class SetForExistenceCheck &#123;    public static void main(String[] args) &#123;        Set&lt;String&gt; dictionary = new HashSet&lt;&gt;();        dictionary.add(&quot;apple&quot;);        dictionary.add(&quot;banana&quot;);        boolean exists = dictionary.contains(&quot;apple&quot;);        System.out.println(&quot;单词 &#39;apple&#39; 是否存在: &quot; + exists);     &#125;&#125;</code></pre><ul><li><strong>需要有序且不重复的集合</strong>：如果需要元素既不重复又按照一定顺序排列，可以使用 <code>TreeSet</code>。例如，对一组整数进行排序并去重：</li></ul><pre><code class="java">import java.util.TreeSet;import java.util.Set;public class TreeSetForSortingAndDuplicateRemoval &#123;    public static void main(String[] args) &#123;        Set&lt;Integer&gt; numbers = new TreeSet&lt;&gt;();        numbers.add(3);        numbers.add(1);        numbers.add(2);        numbers.add(3);        System.out.println(numbers);     &#125;&#125;</code></pre><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><img src="/../images/java-notes/1741873990543.png" alt="1741873990543"></p><p><img src="/../images/java-notes/1741874777810.png" alt="1741874777810"></p><p><img src="/../images/java-notes/1741879623733.png" alt="1741879623733"></p><h4 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>HashSet</code> 是一个不允许存储重复元素的集合，它不保证元素的顺序，也就是说，元素在 <code>HashSet</code> 中的存储顺序和插入顺序可能不同。<code>HashSet</code> 允许存储 <code>null</code> 元素，但只能有一个 <code>null</code> 元素。</p><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>HashSet</code> 基于哈希表（实际上是 <code>HashMap</code>）实现。它使用元素的 <code>hashCode()</code> 方法来计算元素在哈希表中的存储位置，通过 <code>equals()</code> 方法来判断元素是否相等。当向 <code>HashSet</code> 中添加元素时，会先计算元素的哈希码，根据哈希码找到对应的存储位置，如果该位置已经有元素，会使用 <code>equals()</code> 方法比较元素是否相等，如果相等则不添加，如果不相等则以链表或红黑树（当链表长度超过一定阈值时会转换为红黑树）的形式存储在该位置。</p><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**<code>HashSet()</code>**：创建一个新的空 <code>HashSet</code>，默认初始容量为 16，加载因子为 0.75。</li></ul><pre><code class="java">import java.util.HashSet;import java.util.Set;public class HashSetConstructorExample &#123;    public static void main(String[] args) &#123;        Set&lt;String&gt; set = new HashSet&lt;&gt;();        System.out.println(&quot;初始大小: &quot; + set.size());     &#125;&#125;</code></pre><ul><li>**<code>HashSet(Collection c)</code>**：创建一个包含指定集合元素的 <code>HashSet</code>。</li></ul><pre><code class="java">import java.util.Arrays;import java.util.HashSet;import java.util.Set;public class HashSetConstructorWithCollection &#123;    public static void main(String[] args) &#123;        Set&lt;String&gt; sourceSet = new HashSet&lt;&gt;(Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;));        Set&lt;String&gt; set = new HashSet&lt;&gt;(sourceSet);        System.out.println(set);     &#125;&#125;</code></pre><ul><li>**<code>HashSet(int initialCapacity)</code>**：创建一个具有指定初始容量的新 <code>HashSet</code>，加载因子为 0.75。</li><li>**<code>HashSet(int initialCapacity, float loadFactor)</code>**：创建一个具有指定初始容量和加载因子的新 <code>HashSet</code>。</li></ul><h4 id="性能特点-2"><a href="#性能特点-2" class="headerlink" title="性能特点"></a>性能特点</h4><ul><li><strong>插入、删除和查找操作性能好</strong>：在理想情况下，<code>HashSet</code> 的插入、删除和查找操作的时间复杂度为 (O(1))，因为它是基于哈希表实现的，通过哈希码可以快速定位元素的存储位置。</li><li><strong>无序性</strong>：<code>HashSet</code> 不保证元素的顺序，元素的存储顺序取决于哈希码和哈希表的实现，因此不能依赖元素的顺序进行操作。</li></ul><h4 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h4><ul><li><strong>元素的 <code>hashCode()</code> 和 <code>equals()</code> 方法</strong>：为了确保 <code>HashSet</code> 能够正确判断元素是否相等，存储在 <code>HashSet</code> 中的元素必须正确重写 <code>hashCode()</code> 和 <code>equals()</code> 方法。如果两个元素通过 <code>equals()</code> 方法比较相等，那么它们的 <code>hashCode()</code> 值必须相同；如果两个元素的 <code>hashCode()</code> 值相同，它们不一定通过 <code>equals()</code> 方法比较相等。</li></ul><pre><code class="java">import java.util.HashSet;import java.util.Set;class Person &#123;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Person person = (Person) o;        return age == person.age &amp;&amp; name.equals(person.name);    &#125;    @Override    public int hashCode() &#123;        int result = name.hashCode();        result = 31 * result + age;        return result;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;name=&#39;&quot; + name + &quot;&#39;, age=&quot; + age + &quot;&#125;&quot;;    &#125;&#125;public class HashSetCustomObjectExample &#123;    public static void main(String[] args) &#123;        Set&lt;Person&gt; set = new HashSet&lt;&gt;();        set.add(new Person(&quot;Alice&quot;, 20));        set.add(new Person(&quot;Alice&quot;, 20));        System.out.println(set);     &#125;&#125;</code></pre><p>在上述代码中，<code>Person</code> 类重写了 <code>equals()</code> 和 <code>hashCode()</code> 方法，确保 <code>HashSet</code> 能够正确判断元素是否相等。</p><h4 id="元素添加、查找和删除过程"><a href="#元素添加、查找和删除过程" class="headerlink" title="元素添加、查找和删除过程"></a>元素添加、查找和删除过程</h4><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>当调用 <code>HashSet</code> 的 <code>add(E e)</code> 方法时，实际上是调用 <code>HashMap</code> 的 <code>put(K key, V value)</code> 方法，具体步骤如下：</p><ol><li>计算元素的哈希码（<code>hash</code>），通过 <code>hash</code> 函数对哈希码进行处理，得到一个更均匀分布的哈希值。</li><li>根据处理后的哈希值计算出在数组中的索引位置。</li><li>如果该索引位置为空，直接创建一个新的节点存储元素，并将其放入该位置。</li><li>如果该索引位置已经有元素（即发生哈希冲突），则遍历链表或红黑树：<ul><li>如果是链表，逐个比较元素的 <code>equals()</code> 方法，若找到相等的元素，则不添加；若遍历到链表末尾都没有找到相等的元素，则在链表尾部插入新节点。</li><li>如果是红黑树，按照红黑树的插入规则进行插入操作。</li></ul></li><li>如果链表长度达到 8 且数组长度达到 64，将链表转换为红黑树。</li></ol><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><p>当调用 <code>HashSet</code> 的 <code>contains(Object o)</code> 方法时，实际上是调用 <code>HashMap</code> 的 <code>containsKey(Object key)</code> 方法，具体步骤如下：</p><ol><li>计算元素的哈希码，通过 <code>hash</code> 函数处理得到哈希值。</li><li>根据哈希值计算出在数组中的索引位置。</li><li>如果该索引位置为空，直接返回 <code>false</code>。</li><li>如果该索引位置有元素，遍历链表或红黑树：<ul><li>如果是链表，逐个比较元素的 <code>equals()</code> 方法，若找到相等的元素，则返回 <code>true</code>；若遍历完链表都没有找到，则返回 <code>false</code>。</li><li>如果是红黑树，按照红黑树的查找规则进行查找，若找到则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li></ol><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p>当调用 <code>HashSet</code> 的 <code>remove(Object o)</code> 方法时，实际上是调用 <code>HashMap</code> 的 <code>remove(Object key)</code> 方法，具体步骤如下：</p><ol><li>计算元素的哈希码，通过 <code>hash</code> 函数处理得到哈希值。</li><li>根据哈希值计算出在数组中的索引位置。</li><li>如果该索引位置为空，直接返回 <code>false</code>。</li><li>如果该索引位置有元素，遍历链表或红黑树：<ul><li>如果是链表，逐个比较元素的 <code>equals()</code> 方法，若找到相等的元素，则将该节点从链表中移除；若遍历完链表都没有找到，则返回 <code>false</code>。</li><li>如果是红黑树，按照红黑树的删除规则进行删除操作。</li></ul></li><li>如果红黑树的节点数量减少到一定阈值（默认为 6），将红黑树转换为链表。</li></ol><h4 id="HashSet扩容机制"><a href="#HashSet扩容机制" class="headerlink" title="HashSet扩容机制"></a>HashSet扩容机制</h4><h5 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h5><p>在了解扩容机制之前，先明确几个关键参数：</p><ul><li><strong>容量（<code>capacity</code>）</strong>：指的是 <code>HashMap</code> 中哈希桶数组的大小，初始默认容量为 16。</li><li><strong>加载因子（<code>loadFactor</code>）</strong>：默认值是 0.75，它是一个衡量 <code>HashMap</code> 满的程度的指标。当 <code>HashMap</code> 中存储的元素数量达到 <code>容量 * 加载因子</code> 时，就会触发扩容操作。</li><li><strong>阈值（<code>threshold</code>）</strong>：<code>阈值 = 容量 * 加载因子</code>，当元素数量超过这个阈值时，<code>HashMap</code> 会进行扩容。</li></ul><h5 id="扩容触发条件"><a href="#扩容触发条件" class="headerlink" title="扩容触发条件"></a>扩容触发条件</h5><p>当向 <code>HashSet</code> 中添加元素时，<code>HashSet</code> 会调用 <code>HashMap</code> 的 <code>put</code> 方法。在 <code>put</code> 方法中，会检查当前元素数量是否超过阈值，如果超过则触发扩容操作。以下是 <code>HashMap</code> 中部分关键代码体现：</p><pre><code class="java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else &#123;        // 处理哈希冲突等情况    &#125;    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;&#125;</code></pre><p>在上述代码中，<code>size</code> 表示 <code>HashMap</code> 中存储的元素数量，<code>threshold</code> 是阈值。当 <code>++size &gt; threshold</code> 时，会调用 <code>resize()</code> 方法进行扩容。</p><h5 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h5><p><code>resize()</code> 方法是 <code>HashMap</code> 进行扩容的核心方法，其主要步骤如下：</p><h5 id="1-计算新的容量和阈值"><a href="#1-计算新的容量和阈值" class="headerlink" title="1. 计算新的容量和阈值"></a>1. 计算新的容量和阈值</h5><ul><li>如果当前容量已经达到最大容量（<code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30</code>），则将阈值设置为最大整数值，不再进行扩容。</li><li>否则，将容量扩大为原来的 2 倍，同时更新阈值。以下是部分代码：</li></ul><pre><code class="java">final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) &#123;        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            return oldTab;        &#125;        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    &#125;    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else &#123;               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    if (newThr == 0) &#123;        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    &#125;    threshold = newThr;    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    // 其他代码...&#125;</code></pre><h5 id="2-重新分配元素"><a href="#2-重新分配元素" class="headerlink" title="2. 重新分配元素"></a>2. 重新分配元素</h5><p>创建一个新的更大的哈希桶数组，然后将旧数组中的元素重新计算哈希值并分配到新数组中。在 Java 8 中，为了提高性能，采用了更优化的方式处理元素的迁移：</p><ul><li>对于链表节点，会根据节点的哈希值与旧容量进行按位与运算的结果，将链表拆分为两个链表，分别放入新数组的不同位置。</li><li>对于红黑树节点，如果树的节点数量减少到一定阈值（默认为 6），会将红黑树转换为链表，然后再进行迁移。以下是部分代码：</li></ul><pre><code class="java">if (oldTab != null) &#123;    for (int j = 0; j &lt; oldCap; ++j) &#123;        Node&lt;K,V&gt; e;        if ((e = oldTab[j]) != null) &#123;            oldTab[j] = null;            if (e.next == null)                newTab[e.hash &amp; (newCap - 1)] = e;            else if (e instanceof TreeNode)                ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);            else &#123; // preserve order                Node&lt;K,V&gt; loHead = null, loTail = null;                Node&lt;K,V&gt; hiHead = null, hiTail = null;                Node&lt;K,V&gt; next;                do &#123;                    next = e.next;                    if ((e.hash &amp; oldCap) == 0) &#123;                        if (loTail == null)                            loHead = e;                        else                            loTail.next = e;                        loTail = e;                    &#125;                    else &#123;                        if (hiTail == null)                            hiHead = e;                        else                            hiTail.next = e;                        hiTail = e;                    &#125;                &#125; while ((e = next) != null);                if (loTail != null) &#123;                    loTail.next = null;                    newTab[j] = loHead;                &#125;                if (hiTail != null) &#123;                    hiTail.next = null;                    newTab[j + oldCap] = hiHead;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>HashSet</code> 的扩容机制本质上是 <code>HashMap</code> 的扩容机制。当 <code>HashSet</code> 中存储的元素数量超过阈值（<code>容量 * 加载因子</code>）时，会触发扩容操作。扩容时，容量会扩大为原来的 2 倍，然后将旧数组中的元素重新分配到新数组中。扩容操作会带来一定的性能开销，因为需要重新计算哈希值和移动元素，所以在使用 <code>HashSet</code> 时，可以根据实际情况合理设置初始容量和加载因子，以减少扩容的次数。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p><img src="/../images/java-notes/1741954407841.png" alt="1741954407841"></p><p><img src="/../images/java-notes/1741954649922.png" alt="1741954649922"></p><h4 id="元素存储和顺序维护原理"><a href="#元素存储和顺序维护原理" class="headerlink" title="元素存储和顺序维护原理"></a>元素存储和顺序维护原理</h4><p>由于 <code>LinkeHashSet</code> 内部使用 <code>LinkedHashMap</code> 存储元素，其元素存储和顺序维护主要依赖于 <code>LinkedHashMap</code> 的实现。</p><h5 id="元素存储"><a href="#元素存储" class="headerlink" title="元素存储"></a>元素存储</h5><p><code>LinkedHashSet</code> 调用 <code>add</code> 方法添加元素时，实际上是调用 <code>LinkedHashMap</code> 的 <code>put</code> 方法。<code>LinkedHashMap</code> 会根据元素的哈希码计算存储位置，并处理哈希冲突，保证元素的唯一性。</p><h5 id="顺序维护"><a href="#顺序维护" class="headerlink" title="顺序维护"></a>顺序维护</h5><p><code>LinkedHashMap</code> 内部维护了一个双向链表，这个链表记录了元素的插入顺序（或访问顺序）。每次插入新元素时，会将该元素对应的节点添加到链表尾部；当进行迭代操作时，会按照链表的顺序依次访问元素，从而保证了 <code>LinkedHashSet</code> 中元素的顺序与插入顺序一致。</p><h3 id="Map-内容为HashMap"><a href="#Map-内容为HashMap" class="headerlink" title="Map(内容为HashMap)"></a>Map(内容为HashMap)</h3><p><img src="/../images/java-notes/1741957900213.png" alt="1741957900213"></p><p><img src="/../images/java-notes/1741958059707.png" alt="1741958059707"></p><p><img src="/../images/java-notes/1741957350791.png" alt="1741957350791"></p><h4 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>Map</code> 接口定义了一种将键映射到值的对象，其中每个键都是唯一的，一个键最多只能映射到一个值。可以通过键来快速查找对应的值，就像使用字典中的单词查找其释义一样。<code>Map</code> 不继承 <code>Collection</code> 接口，它是与 <code>Collection</code> 并列的集合接口。</p><h4 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-元素添加方法-2"><a href="#1-元素添加方法-2" class="headerlink" title="1. 元素添加方法"></a>1. 元素添加方法</h5><ul><li><code>V put(K key, V value)</code>：将指定的键值对插入到 <code>Map</code> 中。如果键已经存在，则会用新值替换旧值，并返回旧值；如果键不存在，则返回 <code>null</code>。</li></ul><pre><code class="java">import java.util.HashMap;import java.util.Map;public class MapPutExample &#123;    public static void main(String[] args) &#123;        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();        map.put(&quot;apple&quot;, 1);        Integer oldValue = map.put(&quot;apple&quot;, 2);        System.out.println(&quot;旧值: &quot; + oldValue);     &#125;&#125;</code></pre><h5 id="2-元素删除方法-2"><a href="#2-元素删除方法-2" class="headerlink" title="2. 元素删除方法"></a>2. 元素删除方法</h5><ul><li><code>V remove(Object key)</code>：移除指定键对应的键值对，并返回该键对应的值；如果键不存在，则返回 <code>null</code>。</li></ul><pre><code class="java">import java.util.HashMap;import java.util.Map;public class MapRemoveExample &#123;    public static void main(String[] args) &#123;        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();        map.put(&quot;apple&quot;, 1);        Integer removedValue = map.remove(&quot;apple&quot;);        System.out.println(&quot;移除的值: &quot; + removedValue);     &#125;&#125;</code></pre><h5 id="3-元素查询方法-1"><a href="#3-元素查询方法-1" class="headerlink" title="3. 元素查询方法"></a>3. 元素查询方法</h5><ul><li><code>V get(Object key)</code>：返回指定键对应的值；如果键不存在，则返回 <code>null</code>。</li></ul><pre><code class="java">import java.util.HashMap;import java.util.Map;public class MapGetExample &#123;    public static void main(String[] args) &#123;        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();        map.put(&quot;apple&quot;, 1);        Integer value = map.get(&quot;apple&quot;);        System.out.println(&quot;键 &#39;apple&#39; 对应的值: &quot; + value);     &#125;&#125;</code></pre><ul><li><code>boolean containsKey(Object key)</code>：判断 <code>Map</code> 中是否包含指定的键。</li><li><code>boolean containsValue(Object value)</code>：判断 <code>Map</code> 中是否包含指定的值。</li></ul><h5 id="4-其他常用方法-1"><a href="#4-其他常用方法-1" class="headerlink" title="4. 其他常用方法"></a>4. 其他常用方法</h5><ul><li><code>int size()</code>：返回 <code>Map</code> 中键值对的数量。</li><li><code>boolean isEmpty()</code>：判断 <code>Map</code> 是否为空。</li><li><code>void clear()</code>：移除 <code>Map</code> 中的所有键值对。</li></ul><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><h5 id="1-遍历键集"><a href="#1-遍历键集" class="headerlink" title="1. 遍历键集"></a>1. 遍历键集</h5><pre><code class="java">import java.util.HashMap;import java.util.Map;public class MapKeySetTraversal &#123;    public static void main(String[] args) &#123;        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();        map.put(&quot;apple&quot;, 1);        map.put(&quot;banana&quot;, 2);        for (String key : map.keySet()) &#123;            Integer value = map.get(key);            System.out.println(&quot;键: &quot; + key + &quot;, 值: &quot; + value);        &#125;    &#125;&#125;</code></pre><h5 id="2-遍历值集"><a href="#2-遍历值集" class="headerlink" title="2. 遍历值集"></a>2. 遍历值集</h5><pre><code class="java">import java.util.HashMap;import java.util.Map;public class MapValuesTraversal &#123;    public static void main(String[] args) &#123;        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();        map.put(&quot;apple&quot;, 1);        map.put(&quot;banana&quot;, 2);        for (Integer value : map.values()) &#123;            System.out.println(&quot;值: &quot; + value);        &#125;    &#125;&#125;</code></pre><h5 id="3-遍历键值对"><a href="#3-遍历键值对" class="headerlink" title="3. 遍历键值对"></a>3. 遍历键值对</h5><pre><code class="java">import java.util.HashMap;import java.util.Map;public class MapEntrySetTraversal &#123;    public static void main(String[] args) &#123;        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();        map.put(&quot;apple&quot;, 1);        map.put(&quot;banana&quot;, 2);        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;            String key = entry.getKey();            Integer value = entry.getValue();            System.out.println(&quot;键: &quot; + key + &quot;, 值: &quot; + value);        &#125;    &#125;&#125;</code></pre><h4 id="Key-和-Value-的存放位置"><a href="#Key-和-Value-的存放位置" class="headerlink" title="Key 和 Value 的存放位置"></a><code>Key</code> 和 <code>Value</code> 的存放位置</h4><p>在 Java 8 及以后版本中，<code>HashMap</code> 采用数组 + 链表 + 红黑树的数据结构来存储 <code>Key</code> 和 <code>Value</code>。</p><h4 id="EntrySet-集合"><a href="#EntrySet-集合" class="headerlink" title="EntrySet 集合"></a><code>EntrySet</code> 集合</h4><p><code>EntrySet</code> 是 <code>HashMap</code> 中的一个视图集合，它包含了 <code>HashMap</code> 中所有的键值对信息。<code>EntrySet</code> 中的每个元素都是一个 <code>Map.Entry</code> 对象，该对象封装了一个键值对，通过它可以同时访问 <code>Key</code> 和 <code>Value</code>。</p><h5 id="EntrySet-与-Key、Value-存放位置的关系"><a href="#EntrySet-与-Key、Value-存放位置的关系" class="headerlink" title="EntrySet 与 Key、Value 存放位置的关系"></a><code>EntrySet</code> 与 <code>Key</code>、<code>Value</code> 存放位置的关系</h5><ul><li><code>EntrySet</code> 是 <code>HashMap</code> 中键值对的一个视图，它并不实际存储 <code>Key</code> 和 <code>Value</code>，而是通过引用指向 <code>HashMap</code> 内部数组中的 <code>Node</code> 或 <code>TreeNode</code> 对象。</li><li>当调用 <code>entrySet()</code> 方法时，<code>HashMap</code> 会创建一个包含所有 <code>Map.Entry</code> 对象的集合，这些 <code>Map.Entry</code> 对象实际上是对 <code>Node</code> 或 <code>TreeNode</code> 的封装，通过它们可以方便地访问 <code>Key</code> 和 <code>Value</code>。</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><code>Map</code> 接口为 Java 开发者提供了一种方便的方式来存储和操作键值对。不同的实现类适用于不同的场景，开发者可以根据具体需求选择合适的 <code>Map</code> 实现类。在使用 <code>Map</code> 时，需要注意键的唯一性以及不同实现类对 <code>null</code> 键和 <code>null</code> 值的支持情况。</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p><img src="/../images/java-notes/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-14%20213053.png"></p><h4 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>Hashtable</code> 实现了 <code>Map</code> 接口，用于存储键值对（key - value），其中每个键都是唯一的，一个键最多只能映射到一个值。<code>Hashtable</code> 是线程安全的，这意味着在多线程环境下可以安全地使用它进行操作，不会出现数据不一致的问题。</p><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>Hashtable</code> 采用数组 + 链表的数据结构，类似于 Java 8 之前的 <code>HashMap</code>。它内部维护一个数组，数组的每个元素是一个链表的头节点。当向 <code>Hashtable</code> 中插入键值对时，会根据键的哈希码计算出在数组中的索引位置，如果该位置已经有元素（即发生哈希冲突），则将新的键值对插入到该位置对应的链表中。</p><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**<code>Hashtable()</code>**：创建一个新的空 <code>Hashtable</code>，初始容量为 11，加载因子为 0.75。</li></ul><pre><code class="java">import java.util.Hashtable;import java.util.Map;public class HashtableConstructorExample &#123;    public static void main(String[] args) &#123;        Map&lt;String, Integer&gt; hashtable = new Hashtable&lt;&gt;();        System.out.println(&quot;初始大小: &quot; + hashtable.size());     &#125;&#125;</code></pre><ul><li>**<code>Hashtable(int initialCapacity)</code>**：创建一个具有指定初始容量的新 <code>Hashtable</code>，加载因子为 0.75。</li><li>**<code>Hashtable(int initialCapacity, float loadFactor)</code>**：创建一个具有指定初始容量和加载因子的新 <code>Hashtable</code>。</li><li>**<code>Hashtable(Map t)</code>**：创建一个包含指定 <code>Map</code> 中所有键值对的新 <code>Hashtable</code>。</li></ul><h4 id="性能特点-3"><a href="#性能特点-3" class="headerlink" title="性能特点"></a>性能特点</h4><ul><li><strong>线程安全</strong>：<code>Hashtable</code> 的所有方法都是同步的，这意味着在多线程环境下可以安全地使用它，但同步操作会带来一定的性能开销，因此在单线程环境下，其性能通常不如 <code>HashMap</code>。</li><li><strong>插入、删除和查找操作</strong>：平均情况下，<code>Hashtable</code> 的插入、删除和查找操作的时间复杂度为 (O(1))，但在哈希冲突严重时，性能会下降。</li></ul><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>多线程环境</strong>：当需要在多线程环境下使用 <code>Map</code> 时，<code>Hashtable</code> 是一个选择，因为它的线程安全特性可以保证数据的一致性。</li><li><strong>不允许 <code>null</code> 键和 <code>null</code> 值</strong>：如果业务需求不允许使用 <code>null</code> 作为键或值，<code>Hashtable</code> 可以满足这一要求。</li></ul><h4 id="与其他类似类的比较"><a href="#与其他类似类的比较" class="headerlink" title="与其他类似类的比较"></a>与其他类似类的比较</h4><ul><li>与 <code>HashMap</code> 比较：<ul><li><strong>线程安全</strong>：<code>Hashtable</code> 是线程安全的，而 <code>HashMap</code> 是非线程安全的。在单线程环境下，<code>HashMap</code> 的性能通常比 <code>Hashtable</code> 好，因为 <code>Hashtable</code> 的同步机制会带来额外的开销。</li><li><strong>对 <code>null</code> 的支持</strong>：<code>Hashtable</code> 不允许使用 <code>null</code> 作为键或值，而 <code>HashMap</code> 允许使用 <code>null</code> 作为键（只能有一个 <code>null</code> 键）和值。</li></ul></li></ul><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><img src="/../images/java-notes/1741959328704.png" alt="1741959328704"></p><h4 id="基本概念-9"><a href="#基本概念-9" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>Properties</code> 类本质上是一个键值对的集合，其中键和值都是字符串类型。它可以从 <code>.properties</code> 文件中加载属性信息，也可以将属性信息保存到 <code>.properties</code> 文件中。<code>.properties</code> 文件是一种常见的配置文件格式，其内容通常采用 <code>key=value</code> 的形式，例如：</p><pre><code class="properties">database.url=jdbc:mysql://localhost:3306/mydbdatabase.username=rootdatabase.password=123456</code></pre><h4 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="1-加载属性文件"><a href="#1-加载属性文件" class="headerlink" title="1. 加载属性文件"></a>1. 加载属性文件</h5><ul><li>**<code>void load(InputStream inStream)</code>**：从输入流中读取属性列表（键和元素对）。</li></ul><pre><code class="java">import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;public class PropertiesLoadExample &#123;    public static void main(String[] args) &#123;        Properties properties = new Properties();        try (FileInputStream fis = new FileInputStream(&quot;config.properties&quot;)) &#123;            properties.load(fis);            System.out.println(properties.getProperty(&quot;database.url&quot;));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><ul><li>**<code>void load(Reader reader)</code>**：从输入字符流中读取属性列表。</li></ul><h5 id="2-保存属性到文件"><a href="#2-保存属性到文件" class="headerlink" title="2. 保存属性到文件"></a>2. 保存属性到文件</h5><ul><li>**<code>void store(OutputStream out, String comments)</code>**：将此 <code>Properties</code> 表中的属性列表（键和元素对）写入输出流，并可以添加注释。</li></ul><pre><code class="java">import java.io.FileOutputStream;import java.io.IOException;import java.util.Properties;public class PropertiesStoreExample &#123;    public static void main(String[] args) &#123;        Properties properties = new Properties();        properties.setProperty(&quot;app.name&quot;, &quot;MyApp&quot;);        properties.setProperty(&quot;app.version&quot;, &quot;1.0&quot;);        try (FileOutputStream fos = new FileOutputStream(&quot;app.properties&quot;)) &#123;            properties.store(fos, &quot;Application configuration&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><ul><li>**<code>void store(Writer writer, String comments)</code>**：将此 <code>Properties</code> 表中的属性列表（键和元素对）写入输出字符流。</li></ul><h5 id="3-获取属性值"><a href="#3-获取属性值" class="headerlink" title="3. 获取属性值"></a>3. 获取属性值</h5><ul><li>**<code>String getProperty(String key)</code>**：用指定的键在此属性列表中搜索属性。如果在此属性列表中未找到该键，则会继续在默认属性列表中搜索。如果仍未找到，则返回 <code>null</code>。</li><li>**<code>String getProperty(String key, String defaultValue)</code>**：用指定的键在此属性列表中搜索属性。如果在此属性列表中未找到该键，则会继续在默认属性列表中搜索。如果仍未找到，则返回默认值。</li></ul><h5 id="4-设置属性值"><a href="#4-设置属性值" class="headerlink" title="4. 设置属性值"></a>4. 设置属性值</h5><ul><li>**<code>Object setProperty(String key, String value)</code>**：调用 <code>Hashtable</code> 的方法 <code>put</code>，将键值对存储到 <code>Properties</code> 中。返回的是以前与 <code>key</code> 关联的值，如果没有则返回 <code>null</code>。</li></ul><h5 id="5-其他方法"><a href="#5-其他方法" class="headerlink" title="5. 其他方法"></a>5. 其他方法</h5><ul><li>**<code>void list(PrintStream out)</code>**：将属性列表输出到指定的输出流，主要用于调试。</li><li>**<code>void list(PrintWriter out)</code>**：将属性列表输出到指定的字符输出流。</li></ul><h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>配置管理</strong>：用于存储和读取应用程序的配置信息，如数据库连接信息、服务器端口、日志级别等。这样可以将配置信息与代码分离，方便修改和维护。</li><li><strong>国际化</strong>：在实现国际化功能时，可以使用不同语言的 <code>.properties</code> 文件来存储文本信息，根据用户的语言设置加载相应的属性文件。</li></ul><h4 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>键值类型</strong>：<code>Properties</code> 中的键和值都必须是字符串类型。如果需要存储其他类型的数据，需要进行额外的类型转换。</li><li><strong>编码问题</strong>：在使用 <code>load</code> 和 <code>store</code> 方法时，要注意字符编码的问题。默认情况下，<code>load</code> 方法使用 ISO 8859 - 1 编码读取文件，如果文件包含中文等非 ASCII 字符，可能会出现乱码。可以使用 <code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 来指定编码。</li></ul><pre><code class="java">import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.util.Properties;public class PropertiesEncodingExample &#123;    public static void main(String[] args) &#123;        Properties properties = new Properties();        try (FileInputStream fis = new FileInputStream(&quot;config.properties&quot;);             InputStreamReader isr = new InputStreamReader(fis, &quot;UTF-8&quot;)) &#123;            properties.load(isr);            System.out.println(properties.getProperty(&quot;key&quot;));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><img src="/../images/java-notes/1741959815832.png" alt="1741959815832"></p><p><code>TreeSet</code> 是 Java 集合框架中的一个重要类，它实现了 <code>NavigableSet</code> 接口，而 <code>NavigableSet</code> 继承自 <code>SortedSet</code> 接口。<code>TreeSet</code> 基于红黑树（一种自平衡的二叉搜索树）实现，用于存储有序且唯一的元素。以下从基本概念、数据结构、构造方法、常用方法、性能特点、使用场景等方面对 <code>TreeSet</code> 进行详细介绍。</p><h4 id="基本概念-10"><a href="#基本概念-10" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>TreeSet</code> 存储的元素会按照自然顺序（如果元素实现了 <code>Comparable</code> 接口）或者指定的比较器（<code>Comparator</code>）进行排序。同时，它不允许存储重复的元素，这是由 <code>Set</code> 接口的特性决定的。</p><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p><code>TreeSet</code> 底层使用红黑树实现。红黑树是一种自平衡的二叉搜索树，它在插入和删除元素时会自动调整树的结构，以保证树的高度始终保持在对数级别，从而使得插入、删除和查找操作的时间复杂度都为 (O(log n))。红黑树的每个节点包含一个元素，并且满足以下性质：</p><ul><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL 节点，空节点）是黑色。</li><li>如果一个节点是红色的，则它的子节点必须是黑色的。</li><li>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。</li></ul><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**<code>TreeSet()</code>**：创建一个新的空 <code>TreeSet</code>，元素将按照自然顺序进行排序。元素必须实现 <code>Comparable</code> 接口。</li></ul><pre><code class="java">import java.util.TreeSet;public class TreeSetConstructorExample &#123;    public static void main(String[] args) &#123;        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();        treeSet.add(3);        treeSet.add(1);        treeSet.add(2);        System.out.println(treeSet);     &#125;&#125;</code></pre><ul><li>**<code>TreeSet(Comparator comparator)</code>**：创建一个新的空 <code>TreeSet</code>，元素将按照指定的比较器进行排序。</li></ul><pre><code class="java">import java.util.Comparator;import java.util.TreeSet;class CustomComparator implements Comparator&lt;Integer&gt; &#123;    @Override    public int compare(Integer o1, Integer o2) &#123;        return o2 - o1;     &#125;&#125;public class TreeSetWithComparatorExample &#123;    public static void main(String[] args) &#123;        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;(new CustomComparator());        treeSet.add(3);        treeSet.add(1);        treeSet.add(2);        System.out.println(treeSet);     &#125;&#125;</code></pre><ul><li>**<code>TreeSet(Collection c)</code>**：创建一个包含指定集合元素的 <code>TreeSet</code>，元素将按照自然顺序进行排序。</li><li>**<code>TreeSet(SortedSet s)</code>**：创建一个包含指定有序集合元素的 <code>TreeSet</code>，元素将使用与指定有序集合相同的排序方式。</li></ul><h4 id="元素查询方法"><a href="#元素查询方法" class="headerlink" title="元素查询方法"></a>元素查询方法</h4><ul><li>**<code>E first()</code>**：返回集合中的第一个（最小的）元素。如果集合为空，则抛出 <code>NoSuchElementException</code> 异常。</li><li>**<code>E last()</code>**：返回集合中的最后一个（最大的）元素。如果集合为空，则抛出 <code>NoSuchElementException</code> 异常。</li><li>**<code>E lower(E e)</code>**：返回集合中小于给定元素的最大元素；如果不存在这样的元素，则返回 <code>null</code>。</li><li>**<code>E higher(E e)</code>**：返回集合中大于给定元素的最小元素；如果不存在这样的元素，则返回 <code>null</code>。</li><li>**<code>E floor(E e)</code>**：返回集合中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 <code>null</code>。</li><li>**<code>E ceiling(E e)</code>**：返回集合中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 <code>null</code>。</li></ul><h4 id="性能特点-4"><a href="#性能特点-4" class="headerlink" title="性能特点"></a>性能特点</h4><ul><li><strong>有序性</strong>：<code>TreeSet</code> 中的元素始终是有序的，这使得可以方便地进行范围查询和获取最大、最小元素等操作。</li><li><strong>插入、删除和查找操作</strong>：由于底层使用红黑树实现，插入、删除和查找操作的时间复杂度都为 (O(log n))，其中 n 是集合中元素的数量。</li><li><strong>不允许 <code>null</code> 元素</strong>：<code>TreeSet</code> 不允许存储 <code>null</code> 元素，因为在排序时需要调用元素的 <code>compareTo</code> 方法或使用比较器，而 <code>null</code> 无法进行比较。</li></ul><h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>需要有序集合的场景</strong>：当需要存储一组唯一的元素，并且希望这些元素按照自然顺序或指定顺序排列时，可以使用 <code>TreeSet</code>。例如，对一组整数进行排序并去重。</li><li><strong>范围查询场景</strong>：<code>TreeSet</code> 提供了 <code>lower</code>、<code>higher</code>、<code>floor</code>、<code>ceiling</code> 等方法，方便进行范围查询，如查找小于某个值的最大元素、大于某个值的最小元素等。</li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><img src="/../images/java-notes/1741960768209.png" alt="1741960768209"></p><h4 id="基本概念-11"><a href="#基本概念-11" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>TreeMap</code> 存储的键值对会根据键的顺序进行排序。如果键实现了 <code>Comparable</code> 接口，<code>TreeMap</code> 会按照键的自然顺序进行排序；如果在创建 <code>TreeMap</code> 时指定了比较器（<code>Comparator</code>），则会按照比较器的规则进行排序。同时，<code>TreeMap</code> 不允许键为 <code>null</code>，因为排序操作需要调用键的 <code>compareTo</code> 方法或使用比较器，而 <code>null</code> 无法进行比较，但值可以为 <code>null</code>。</p><h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li>**<code>TreeMap()</code>**：创建一个新的空 <code>TreeMap</code>，键将按照自然顺序进行排序。键必须实现 <code>Comparable</code> 接口。</li></ul><pre><code class="java">import java.util.TreeMap;public class TreeMapConstructorExample &#123;    public static void main(String[] args) &#123;        TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();        treeMap.put(3, &quot;Three&quot;);        treeMap.put(1, &quot;One&quot;);        treeMap.put(2, &quot;Two&quot;);        System.out.println(treeMap);     &#125;&#125;</code></pre><ul><li>**<code>TreeMap(Comparator comparator)</code>**：创建一个新的空 <code>TreeMap</code>，键将按照指定的比较器进行排序。</li></ul><pre><code class="java">import java.util.Comparator;import java.util.TreeMap;class CustomComparator implements Comparator&lt;Integer&gt; &#123;    @Override    public int compare(Integer o1, Integer o2) &#123;        return o2 - o1;     &#125;&#125;public class TreeMapWithComparatorExample &#123;    public static void main(String[] args) &#123;        TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(new CustomComparator());        treeMap.put(3, &quot;Three&quot;);        treeMap.put(1, &quot;One&quot;);        treeMap.put(2, &quot;Two&quot;);        System.out.println(treeMap);     &#125;&#125;</code></pre><ul><li>**<code>TreeMap(Map m)</code>**：创建一个包含指定 <code>Map</code> 中所有键值对的 <code>TreeMap</code>，键将按照自然顺序进行排序。</li><li>**<code>TreeMap(SortedMap m)</code>**：创建一个包含指定有序 <code>Map</code> 中所有键值对的 <code>TreeMap</code>，键将使用与指定有序 <code>Map</code> 相同的排序方式。</li></ul><h4 id="元素查询方法-1"><a href="#元素查询方法-1" class="headerlink" title="元素查询方法"></a>元素查询方法</h4><ul><li>**<code>V get(Object key)</code>**：返回指定键对应的值；如果键不存在，则返回 <code>null</code>。</li></ul><pre><code class="java">import java.util.TreeMap;public class TreeMapGetExample &#123;    public static void main(String[] args) &#123;        TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();        treeMap.put(1, &quot;One&quot;);        String value = treeMap.get(1);        System.out.println(&quot;键 &#39;1&#39; 对应的值: &quot; + value);     &#125;&#125;</code></pre><ul><li>**<code>K firstKey()</code>**：返回 <code>TreeMap</code> 中的第一个（最小的）键。如果 <code>TreeMap</code> 为空，则抛出 <code>NoSuchElementException</code> 异常。</li><li>**<code>K lastKey()</code>**：返回 <code>TreeMap</code> 中的最后一个（最大的）键。如果 <code>TreeMap</code> 为空，则抛出 <code>NoSuchElementException</code> 异常。</li><li>**<code>Map.Entry lowerEntry(K key)</code>**：返回 <code>TreeMap</code> 中键小于给定键的最大键值对；如果不存在这样的键值对，则返回 <code>null</code>。</li><li>**<code>Map.Entry higherEntry(K key)</code>**：返回 <code>TreeMap</code> 中键大于给定键的最小键值对；如果不存在这样的键值对，则返回 <code>null</code>。</li><li>**<code>Map.Entry floorEntry(K key)</code>**：返回 <code>TreeMap</code> 中键小于等于给定键的最大键值对；如果不存在这样的键值对，则返回 <code>null</code>。</li><li>**<code>Map.Entry ceilingEntry(K key)</code>**：返回 <code>TreeMap</code> 中键大于等于给定键的最小键值对；如果不存在这样的键值对，则返回 <code>null</code>。</li></ul><h4 id="性能特点-5"><a href="#性能特点-5" class="headerlink" title="性能特点"></a>性能特点</h4><ul><li><strong>有序性</strong>：<code>TreeMap</code> 中的键值对始终按照键的顺序排列，这使得可以方便地进行范围查询和获取最大、最小键值对等操作。</li><li><strong>插入、删除和查找操作</strong>：由于底层使用红黑树实现，插入、删除和查找操作的时间复杂度都为 (O(log n))，其中 n 是 <code>TreeMap</code> 中键值对的数量。</li><li><strong>不允许 <code>null</code> 键</strong>：<code>TreeMap</code> 不允许键为 <code>null</code>，但值可以为 <code>null</code>。</li></ul><h4 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>需要有序键的场景</strong>：当需要存储一组键值对，并且希望这些键按照自然顺序或指定顺序排列时，可以使用 <code>TreeMap</code>。例如，对一组学生成绩按照分数进行排序存储。</li><li><strong>范围查询场景</strong>：<code>TreeMap</code> 提供了 <code>lowerEntry</code>、<code>higherEntry</code>、<code>floorEntry</code>、<code>ceilingEntry</code> 等方法，方便进行范围查询，如查找分数小于某个值的最高成绩学生、分数大于某个值的最低成绩学生等。</li></ul><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p><img src="/../images/java-notes/1742020626789.png" alt="1742020626789"></p><p><code>Collections</code> 是 Java 集合框架中的一个实用工具类，位于 <code>java.util</code> 包下。它提供了一系列静态方法，用于对集合（如 <code>List</code>、<code>Set</code>、<code>Map</code> 等）进行各种操作，比如排序、查找、替换、同步控制等，大大简化了集合操作的代码编写。以下从常用方法分类详细介绍 <code>Collections</code> 工具类。</p><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><h5 id="1-sort-List-list"><a href="#1-sort-List-list" class="headerlink" title="1. sort(List list)"></a>1. <code>sort(List list)</code></h5><p>该方法用于对实现了 <code>Comparable</code> 接口的元素列表进行自然排序。</p><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;public class SortExample &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();        numbers.add(3);        numbers.add(1);        numbers.add(2);        Collections.sort(numbers);        System.out.println(numbers);     &#125;&#125;</code></pre><h5 id="2-sort-List-list-Comparator-c"><a href="#2-sort-List-list-Comparator-c" class="headerlink" title="2. sort(List list, Comparator c)"></a>2. <code>sort(List list, Comparator c)</code></h5><p>使用指定的比较器对列表进行排序。</p><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;class CustomComparator implements Comparator&lt;Integer&gt; &#123;    @Override    public int compare(Integer o1, Integer o2) &#123;        return o2 - o1;     &#125;&#125;public class SortWithComparatorExample &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();        numbers.add(3);        numbers.add(1);        numbers.add(2);        Collections.sort(numbers, new CustomComparator());        System.out.println(numbers);     &#125;&#125;</code></pre><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><h5 id="1-binarySearch-List-list-T-key"><a href="#1-binarySearch-List-list-T-key" class="headerlink" title="1. binarySearch(List&gt; list, T key)"></a>1. <code>binarySearch(List&gt; list, T key)</code></h5><p>使用二分查找算法在有序列表中查找指定元素的索引。列表必须是按照自然顺序排序的。</p><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;public class BinarySearchExample &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();        numbers.add(1);        numbers.add(2);        numbers.add(3);        int index = Collections.binarySearch(numbers, 2);        System.out.println(&quot;元素 2 的索引: &quot; + index);     &#125;&#125;</code></pre><h5 id="2-binarySearch-List-list-T-key-Comparator-c"><a href="#2-binarySearch-List-list-T-key-Comparator-c" class="headerlink" title="2. binarySearch(List list, T key, Comparator c)"></a>2. <code>binarySearch(List list, T key, Comparator c)</code></h5><p>使用二分查找算法在有序列表中查找指定元素的索引，列表按照指定的比较器排序。</p><h4 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h4><h5 id="1-replaceAll-List-list-T-oldVal-T-newVal"><a href="#1-replaceAll-List-list-T-oldVal-T-newVal" class="headerlink" title="1. replaceAll(List list, T oldVal, T newVal)"></a>1. <code>replaceAll(List list, T oldVal, T newVal)</code></h5><p>将列表中所有的旧元素替换为新元素。</p><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;public class ReplaceAllExample &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; fruits = new ArrayList&lt;&gt;();        fruits.add(&quot;apple&quot;);        fruits.add(&quot;banana&quot;);        fruits.add(&quot;apple&quot;);        Collections.replaceAll(fruits, &quot;apple&quot;, &quot;orange&quot;);        System.out.println(fruits);     &#125;&#125;</code></pre><h4 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h4><h5 id="1-synchronizedList-List-list"><a href="#1-synchronizedList-List-list" class="headerlink" title="1. synchronizedList(List list)"></a>1. <code>synchronizedList(List list)</code></h5><p>返回指定列表的同步（线程安全的）列表。</p><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;public class SynchronizedListExample &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        List&lt;String&gt; syncedList = Collections.synchronizedList(list);    &#125;&#125;</code></pre><h5 id="2-其他同步方法"><a href="#2-其他同步方法" class="headerlink" title="2. 其他同步方法"></a>2. 其他同步方法</h5><p>还有 <code>synchronizedSet</code>、<code>synchronizedMap</code> 等方法，分别用于返回同步的 <code>Set</code> 和 <code>Map</code>。</p><h4 id="反转、打乱等操作"><a href="#反转、打乱等操作" class="headerlink" title="反转、打乱等操作"></a>反转、打乱等操作</h4><h5 id="1-reverse-List-list"><a href="#1-reverse-List-list" class="headerlink" title="1. reverse(List list)"></a>1. <code>reverse(List list)</code></h5><p>反转列表中元素的顺序。</p><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;public class ReverseExample &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();        numbers.add(1);        numbers.add(2);        numbers.add(3);        Collections.reverse(numbers);        System.out.println(numbers);     &#125;&#125;</code></pre><h5 id="2-shuffle-List-list"><a href="#2-shuffle-List-list" class="headerlink" title="2. shuffle(List list)"></a>2. <code>shuffle(List list)</code></h5><p>随机打乱列表中元素的顺序。</p><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;public class ShuffleExample &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();        numbers.add(1);        numbers.add(2);        numbers.add(3);        Collections.shuffle(numbers);        System.out.println(numbers);     &#125;&#125;</code></pre><h4 id="不可变集合操作"><a href="#不可变集合操作" class="headerlink" title="不可变集合操作"></a>不可变集合操作</h4><h5 id="1-unmodifiableList-List-list"><a href="#1-unmodifiableList-List-list" class="headerlink" title="1. unmodifiableList(List list)"></a>1. <code>unmodifiableList(List list)</code></h5><p>返回指定列表的不可变视图，对返回的列表进行修改操作会抛出 <code>UnsupportedOperationException</code>。</p><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;public class UnmodifiableListExample &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;apple&quot;);        List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list);        try &#123;            unmodifiableList.add(&quot;banana&quot;);         &#125; catch (UnsupportedOperationException e) &#123;            System.out.println(&quot;不支持修改操作&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="2-其他不可变方法"><a href="#2-其他不可变方法" class="headerlink" title="2. 其他不可变方法"></a>2. 其他不可变方法</h5><p>还有 <code>unmodifiableSet</code>、<code>unmodifiableMap</code> 等方法，分别用于返回不可变的 <code>Set</code> 和 <code>Map</code>。</p><h4 id="复制操作"><a href="#复制操作" class="headerlink" title="复制操作"></a>复制操作</h4><h5 id="copy-List-dest-List-src"><a href="#copy-List-dest-List-src" class="headerlink" title="copy(List dest, List src)"></a><code>copy(List dest, List src)</code></h5><p>此方法用于将一个源列表（<code>src</code>）中的所有元素复制到目标列表（<code>dest</code>）中。目标列表的长度必须至少等于源列表的长度，如果目标列表长度小于源列表长度，会抛出 <code>IndexOutOfBoundsException</code> 异常。</p><p><strong>示例代码</strong></p><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;public class CollectionsCopyExample &#123;    public static void main(String[] args) &#123;        // 创建源列表        List&lt;String&gt; sourceList = new ArrayList&lt;&gt;();        sourceList.add(&quot;apple&quot;);        sourceList.add(&quot;banana&quot;);        sourceList.add(&quot;cherry&quot;);        // 创建目标列表，长度要至少和源列表一样        List&lt;String&gt; destinationList = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; sourceList.size(); i++) &#123;            destinationList.add(null);        &#125;        // 执行复制操作        Collections.copy(destinationList, sourceList);        // 输出目标列表        System.out.println(&quot;目标列表: &quot; + destinationList);    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ol><li><strong>创建源列表</strong>：首先创建了一个源列表 <code>sourceList</code>，并向其中添加了几个元素。</li><li><strong>创建目标列表</strong>：接着创建目标列表 <code>destinationList</code>，为了满足 <code>Collections.copy</code> 方法的要求，需要确保目标列表的长度至少和源列表长度相等，这里通过循环添加 <code>null</code> 元素来达到这个目的。</li><li><strong>执行复制操作</strong>：调用 <code>Collections.copy</code> 方法将源列表的元素复制到目标列表中。</li><li><strong>输出结果</strong>：最后打印目标列表，可以看到目标列表已经包含了源列表的所有元素。</li></ol><p><strong>注意事项</strong></p><ul><li><strong>目标列表长度</strong>：目标列表的长度必须至少等于源列表的长度，否则会抛出 <code>IndexOutOfBoundsException</code> 异常。</li><li><strong>元素引用</strong>：该方法只是复制元素的引用，而不是创建元素的副本。也就是说，如果源列表中的元素是可变对象，修改源列表或目标列表中对应元素的属性，会影响到另一个列表中的元素。</li></ul><h3 id="集合使用的选择"><a href="#集合使用的选择" class="headerlink" title="集合使用的选择"></a>集合使用的选择</h3><p><img src="/../images/java-notes/1742022453845.png" alt="1742022453845"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><img src="/../images/java-notes/1742022912923.png" alt="1742022912923"></p><p><img src="/../images/java-notes/1742024033181.png" alt="1742024033181"></p><h3 id="基本概念-12"><a href="#基本概念-12" class="headerlink" title="基本概念"></a>基本概念</h3><p>泛型，即 “参数化类型”，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用 &#x2F; 调用时传入具体的类型（类型实参）。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类是在定义类时使用泛型。通过在类名后面添加 &#96;&#96;（<code>T</code> 是类型参数，可以是任意标识符，通常使用 <code>T</code> 表示 Type），可以在类中使用这个类型参数来定义成员变量、方法的参数类型和返回值类型等。</p><p><img src="/../images/java-notes/1742040606357.png" alt="1742040606357"></p><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>自定义泛型类是在定义类时使用泛型类型参数。通过在类名后面添加 <code>&lt;T&gt;</code> 是类型参数，可根据习惯使用不同标识符，常见的有 <code>T</code> 代表 Type，<code>E</code> 代表Element，<code>K</code> 代表 Key，<code>V</code> 代表 Value 等），可以在类中使用这个类型参数来定义成员变量、方法的参数类型和返回值类型等。</p><h4 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><strong>数据容器类</strong>：当创建一个用于存储数据的类，且希望这个类可以存储不同类型的数据时，就可以使用泛型类。例如，自定义一个简单的容器类，它可以存储整数、字符串等各种类型的数据。</li><li><strong>算法类</strong>：在实现一些通用算法时，使用泛型类可以让算法适用于不同类型的数据。比如实现一个排序算法，使用泛型可以让该算法对不同类型的数组进行排序。</li></ul><pre><code class="java">// 定义一个泛型类class Box&lt;T&gt; &#123;    private T item;    public void setItem(T item) &#123;        this.item = item;    &#125;    public T getItem() &#123;        return item;    &#125;&#125;// 使用泛型类public class GenericClassExample &#123;    public static void main(String[] args) &#123;        // 创建一个存储 Integer 类型的 Box 对象        Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();        integerBox.setItem(10);        Integer integerItem = integerBox.getItem();        System.out.println(&quot;Integer 类型的项: &quot; + integerItem);        // 创建一个存储 String 类型的 Box 对象        Box&lt;String&gt; stringBox = new Box&lt;&gt;();        stringBox.setItem(&quot;Hello, World!&quot;);        String stringItem = stringBox.getItem();        System.out.println(&quot;String 类型的项: &quot; + stringItem);    &#125;&#125;</code></pre><h4 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="1-类型参数命名规范"><a href="#1-类型参数命名规范" class="headerlink" title="1. 类型参数命名规范"></a>1. 类型参数命名规范</h5><ul><li><strong>常用命名约定</strong>：类型参数通常使用单个大写字母来命名，以提高代码的可读性。常见的命名有 <code>T</code>（Type）、<code>E</code>（Element）、<code>K</code>（Key）、<code>V</code>（Value）等。例如：</li></ul><pre><code class="java">class Container&lt;T&gt; &#123;    private T item;    // ...&#125;</code></pre><ul><li><strong>避免使用易混淆的名称</strong>：不要使用与 Java 内置类名或常用变量名相同的名称作为类型参数，以免造成混淆。</li></ul><h5 id="2-类型参数的作用域"><a href="#2-类型参数的作用域" class="headerlink" title="2. 类型参数的作用域"></a>2. 类型参数的作用域</h5><ul><li><strong>仅限于类定义内部</strong>：类型参数的作用域仅限于泛型类的定义内部，它可以用于定义成员变量、方法的参数类型、返回值类型等，但<strong>不能用于静态成员</strong>。因为静态成员属于类本身，在类加载时就已经确定，而类型参数是在创建对象时才确定具体类型的。例如：</li></ul><pre><code class="java">class GenericClass&lt;T&gt; &#123;    private T instanceField; // 可以使用类型参数定义实例字段    public static final T staticField; // 错误，静态字段不能使用类型参数    public void instanceMethod(T param) &#123; // 可以使用类型参数定义方法参数        // ...    &#125;    public static void staticMethod(T param) &#123; // 错误，静态方法不能使用类型参数        // ...    &#125;&#125;</code></pre><h5 id="3-类型擦除"><a href="#3-类型擦除" class="headerlink" title="3. 类型擦除"></a>3. 类型擦除</h5><ul><li><strong>运行时类型信息丢失</strong>：Java 的泛型是通过类型擦除实现的，这意味着在编译后，泛型类型信息会被擦除，替换为原始类型（通常是 <code>Object</code> 类型，如果有上界则替换为上界类型）。例如：</li></ul><pre><code class="java">class Container&lt;T&gt; &#123;    private T item;    public Container(T item) &#123;        this.item = item;    &#125;    public T getItem() &#123;        return item;    &#125;&#125;</code></pre><p>编译后，<code>Container</code> 类的字节码中 <code>T</code> 会被替换为 <code>Object</code> 类型。因此，在运行时无法获取泛型的具体类型信息。</p><ul><li><strong>不能使用基本数据类型</strong>：由于类型擦除后泛型类型会被替换为引用类型，所以不能直接使用基本数据类型作为类型参数，需要使用对应的包装类。例如：</li></ul><pre><code class="java">Container&lt;int&gt; intContainer; // 错误Container&lt;Integer&gt; integerContainer; // 正确</code></pre><h5 id="4-泛型类的继承和实现"><a href="#4-泛型类的继承和实现" class="headerlink" title="4. 泛型类的继承和实现"></a>4. 泛型类的继承和实现</h5><ul><li><strong>子类可以指定具体类型</strong>：在继承泛型类时，子类可以指定具体的类型实参。例如：</li></ul><pre><code class="java">class GenericClass&lt;T&gt; &#123;    // ...&#125;class SubClass extends GenericClass&lt;String&gt; &#123;    // ...&#125;</code></pre><ul><li><strong>子类也可以继续使用泛型</strong>：子类也可以继续使用泛型，在创建子类对象时再指定具体类型。例如：</li></ul><pre><code class="java">class GenericClass&lt;T&gt; &#123;    // ...&#125;class SubClass&lt;T&gt; extends GenericClass&lt;T&gt; &#123;    // ...&#125;</code></pre><h5 id="5-泛型类中的方法重载"><a href="#5-泛型类中的方法重载" class="headerlink" title="5. 泛型类中的方法重载"></a>5. 泛型类中的方法重载</h5><ul><li><strong>类型参数不参与方法重载判断</strong>：在泛型类中，方法的重载是基于方法的参数列表来判断的，类型参数不参与重载判断。例如：</li></ul><pre><code class="java">class GenericClass&lt;T&gt; &#123;    public void method(T param) &#123;        // ...    &#125;    public void method(T param1, T param2) &#123; // 正确，参数列表不同        // ...    &#125;    public void method(String param) &#123; // 正确，参数类型不同        // ...    &#125;    public &lt;U&gt; void method(U param) &#123; // 错误，类型参数不参与重载判断，会导致编译错误        // ...    &#125;&#125;</code></pre><h5 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h5><ul><li><strong>不能捕获泛型类型的异常</strong>：由于类型擦除，在 <code>catch</code> 块中不能使用泛型类型作为异常类型。例如：</li></ul><pre><code class="java">class GenericClass&lt;T extends Throwable&gt; &#123;    public void doSomething() &#123;        try &#123;            // ...        &#125; catch (T e) &#123; // 错误，不能捕获泛型类型的异常            // ...        &#125;    &#125;&#125;</code></pre><h5 id="7-泛型数组"><a href="#7-泛型数组" class="headerlink" title="7. 泛型数组"></a>7. 泛型数组</h5><ul><li><strong>不能直接创建泛型数组</strong>：由于类型擦除，不能直接创建泛型数组。例如：</li></ul><pre><code class="java">T[] array = new T[10]; // 错误</code></pre><p>可以通过创建 <code>Object</code> 数组并进行类型转换来实现类似的功能，但需要注意类型转换可能会引发 <code>ClassCastException</code>。例如：</p><pre><code class="java">class GenericClass&lt;T&gt; &#123;    private T[] array;    @SuppressWarnings(&quot;unchecked&quot;)    public GenericClass(int size) &#123;        array = (T[]) new Object[size]; // 进行类型转换    &#125;    public T get(int index) &#123;        return array[index];    &#125;    public void set(int index, T item) &#123;        array[index] = item;    &#125;&#125;</code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><img src="/../images/java-notes/1742042463395.png" alt="1742042463395"></p><h4 id="定义泛型方法"><a href="#定义泛型方法" class="headerlink" title="定义泛型方法"></a>定义泛型方法</h4><p>定义泛型方法的语法格式如下：</p><pre><code class="java">修饰符 &lt;类型参数列表&gt; 返回值类型 方法名(参数列表) &#123;    // 方法体&#125;</code></pre><p>以下是几个不同场景下自定义泛型方法的示例：</p><h5 id="简单的泛型方法"><a href="#简单的泛型方法" class="headerlink" title="简单的泛型方法"></a>简单的泛型方法</h5><pre><code class="java">public class GenericMethodExample &#123;    // 定义一个泛型方法，用于打印数组元素    public static &lt;T&gt; void printArray(T[] array) &#123;        for (T element : array) &#123;            System.out.print(element + &quot; &quot;);        &#125;        System.out.println();    &#125;    public static void main(String[] args) &#123;        // 创建一个 Integer 类型的数组        Integer[] intArray = &#123;1, 2, 3, 4, 5&#125;;        // 调用泛型方法打印 Integer 数组        printArray(intArray);        // 创建一个 String 类型的数组        String[] stringArray = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;;        // 调用泛型方法打印 String 数组        printArray(stringArray);    &#125;&#125;</code></pre><p>在上述代码中，<code>printArray</code> 是一个泛型方法，&#96;&#96; 表示类型参数，<code>T[] array</code> 表示参数是一个类型为 <code>T</code> 的数组。在 <code>main</code> 方法中，我们分别传入了 <code>Integer</code> 数组和 <code>String</code> 数组来调用该方法。</p><h5 id="泛型方法返回值为泛型类型"><a href="#泛型方法返回值为泛型类型" class="headerlink" title="泛型方法返回值为泛型类型"></a>泛型方法返回值为泛型类型</h5><pre><code class="java">public class ReturnGenericMethod &#123;    // 定义一个泛型方法，返回传入的参数    public static &lt;T&gt; T getValue(T value) &#123;        return value;    &#125;    public static void main(String[] args) &#123;        // 调用泛型方法，传入 Integer 类型的值        Integer intValue = getValue(10);        System.out.println(&quot;Integer 值: &quot; + intValue);        // 调用泛型方法，传入 String 类型的值        String stringValue = getValue(&quot;Hello&quot;);        System.out.println(&quot;String 值: &quot; + stringValue);    &#125;&#125;</code></pre><p>此代码中的 <code>getValue</code> 方法是一个泛型方法，它接受一个类型为 <code>T</code> 的参数，并返回该参数。在 <code>main</code> 方法中，我们分别传入了 <code>Integer</code> 类型和 <code>String</code> 类型的值来调用该方法。</p><h5 id="在泛型类中定义泛型方法"><a href="#在泛型类中定义泛型方法" class="headerlink" title="在泛型类中定义泛型方法"></a>在泛型类中定义泛型方法</h5><pre><code class="java">class GenericClass&lt;T&gt; &#123;    private T value;    public GenericClass(T value) &#123;        this.value = value;    &#125;    // 泛型类中的泛型方法    public &lt;U&gt; void printBoth(T t, U u) &#123;        System.out.println(&quot;T 类型的值: &quot; + t);        System.out.println(&quot;U 类型的值: &quot; + u);    &#125;    public static void main(String[] args) &#123;        GenericClass&lt;Integer&gt; genericObj = new GenericClass&lt;&gt;(10);        genericObj.printBoth(10, &quot;Hello&quot;);    &#125;&#125;</code></pre><p>在 <code>GenericClass</code> 这个泛型类中，<code>printBoth</code> 是一个泛型方法，它除了使用类的泛型类型参数 <code>T</code> 外，还定义了自己的泛型类型参数 <code>U</code>。</p><h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>类型参数的作用域</strong>：泛型方法的类型参数作用域仅限于该方法内部，不同的泛型方法可以使用相同的类型参数名，它们彼此独立。</li><li><strong>类型推断</strong>：在调用泛型方法时，编译器通常可以根据传入的参数类型自动推断出类型参数的具体类型。例如在上述 <code>printArray</code> 方法中，传入 <code>Integer</code> 数组时，编译器会自动将 <code>T</code> 推断为 <code>Integer</code>。</li><li><strong>静态泛型方法</strong>：静态泛型方法只能使用自己定义的泛型类型参数，不能使用类的泛型类型参数，因为静态成员属于类本身，在类加载时就已经确定，而类的泛型类型参数是在创建对象时才确定具体类型的。</li></ul><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p><img src="/../images/java-notes/1742041282218.png" alt="1742041282218"></p><h4 id="定义泛型接口"><a href="#定义泛型接口" class="headerlink" title="定义泛型接口"></a>定义泛型接口</h4><p>定义泛型接口的语法格式如下：</p><pre><code class="java">interface 接口名&lt;类型参数列表&gt; &#123;    // 抽象方法定义，可使用类型参数    返回值类型 方法名(参数列表);    // 其他抽象方法...&#125;</code></pre><p>以下是一个简单的泛型接口示例，定义一个生成器接口，该接口可以生成不同类型的对象：</p><pre><code class="java">// 定义一个泛型接口 Generatorinterface Generator&lt;T&gt; &#123;    // 定义一个抽象方法，返回类型为 T    T generate();&#125;</code></pre><h4 id="实现泛型接口"><a href="#实现泛型接口" class="headerlink" title="实现泛型接口"></a>实现泛型接口</h4><p>实现泛型接口有两种方式：指定具体类型和继续使用泛型。</p><h5 id="1-指定具体类型"><a href="#1-指定具体类型" class="headerlink" title="1. 指定具体类型"></a>1. 指定具体类型</h5><p>在实现泛型接口时，可以指定具体的类型实参，这样实现类中的泛型类型就被确定下来。</p><pre><code class="java">// 实现 Generator 接口并指定具体类型为 Integerclass IntegerGenerator implements Generator&lt;Integer&gt; &#123;    @Override    public Integer generate() &#123;        // 生成一个 0 到 99 之间的随机整数        return (int) (Math.random() * 100);    &#125;&#125;</code></pre><h5 id="2-继续使用泛型"><a href="#2-继续使用泛型" class="headerlink" title="2. 继续使用泛型"></a>2. 继续使用泛型</h5><p>实现类也可以继续使用泛型，在创建实现类对象时再指定具体类型。</p><pre><code class="java">// 实现 Generator 接口并继续使用泛型class GenericGenerator&lt;T&gt; implements Generator&lt;T&gt; &#123;    private T item;    public GenericGenerator(T item) &#123;        this.item = item;    &#125;    @Override    public T generate() &#123;        return item;    &#125;&#125;</code></pre><p>以下是使用上述泛型接口及其实现类的示例代码：</p><pre><code class="java">public class GenericInterfaceExample &#123;    public static void main(String[] args) &#123;        // 使用指定具体类型的实现类        IntegerGenerator integerGenerator = new IntegerGenerator();        Integer randomInteger = integerGenerator.generate();        System.out.println(&quot;随机整数: &quot; + randomInteger);        // 使用继续使用泛型的实现类        GenericGenerator&lt;String&gt; stringGenerator = new GenericGenerator&lt;&gt;(&quot;Hello&quot;);        String stringItem = stringGenerator.generate();        System.out.println(&quot;字符串项: &quot; + stringItem);    &#125;&#125;</code></pre><p><strong>代码解释</strong></p><ul><li>**泛型接口 <code>Generator</code>**：定义了一个抽象方法 <code>generate()</code>，返回类型为 <code>T</code>，表示该接口可以生成任意类型的对象。</li><li><strong><code>IntegerGenerator</code> 类</strong>：实现了 <code>Generator</code> 接口，指定了具体类型为 <code>Integer</code>，在 <code>generate()</code> 方法中生成一个随机整数。</li><li><strong><code>GenericGenerator</code> 类</strong>：继续使用泛型，在创建对象时可以指定具体类型。构造方法接收一个类型为 <code>T</code> 的参数，<code>generate()</code> 方法返回该参数。</li><li><strong><code>GenericInterfaceExample</code> 类</strong>：在 <code>main</code> 方法中分别创建了 <code>IntegerGenerator</code> 和 <code>GenericGenerator</code> 对象，并调用 <code>generate()</code> 方法获取生成的对象。</li></ul><h4 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>类型参数作用域</strong>：类型参数的作用域仅限于泛型接口的定义内部，可用于定义方法的参数类型、返回值类型等，但不能用于静态成员。</li><li><strong>类型擦除</strong>：Java 的泛型是通过类型擦除实现的，</li></ul><h3 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h3><p><img src="/../images/java-notes/1742042779427.png" alt="1742042779427"></p><p>泛型通配符用于在使用泛型时表示未知类型。常见的通配符有 <code>?</code>（无界通配符）、<code>? extends T</code>（上界通配符）和 <code>? super T</code>（下界通配符）。</p><h4 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符 ?"></a>无界通配符 <code>?</code></h4><p>无界通配符表示未知类型，通常用于当你不关心泛型的具体类型时。</p><pre><code class="java">import java.util.ArrayList;import java.util.List;public class UnboundedWildcardExample &#123;    public static void printList(List&lt;?&gt; list) &#123;        for (Object element : list) &#123;            System.out.print(element + &quot; &quot;);        &#125;        System.out.println();    &#125;    public static void main(String[] args) &#123;        List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();        integerList.add(1);        integerList.add(2);        integerList.add(3);        printList(integerList);        List&lt;String&gt; stringList = new ArrayList&lt;&gt;();        stringList.add(&quot;apple&quot;);        stringList.add(&quot;banana&quot;);        printList(stringList);    &#125;&#125;</code></pre><h4 id="上界通配符-extends-T"><a href="#上界通配符-extends-T" class="headerlink" title="上界通配符 ? extends T"></a>上界通配符 <code>? extends T</code></h4><p>上界通配符表示该类型是 <code>T</code> 或 <code>T</code> 的子类。</p><pre><code class="java">import java.util.ArrayList;import java.util.List;class Animal &#123;    public void eat() &#123;        System.out.println(&quot;Animal is eating.&quot;);    &#125;&#125;class Dog extends Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;Dog is eating.&quot;);    &#125;&#125;public class UpperBoundedWildcardExample &#123;    public static void printAnimals(List&lt;? extends Animal&gt; animals) &#123;        for (Animal animal : animals) &#123;            animal.eat();        &#125;    &#125;    public static void main(String[] args) &#123;        List&lt;Dog&gt; dogList = new ArrayList&lt;&gt;();        dogList.add(new Dog());        printAnimals(dogList);    &#125;&#125;</code></pre><h4 id="下界通配符-super-T"><a href="#下界通配符-super-T" class="headerlink" title="下界通配符 ? super T"></a>下界通配符 <code>? super T</code></h4><p>下界通配符表示该类型是 <code>T</code> 或 <code>T</code> 的父类。</p><pre><code class="java">import java.util.ArrayList;import java.util.List;class Animal &#123;    public void eat() &#123;        System.out.println(&quot;Animal is eating.&quot;);    &#125;&#125;class Dog extends Animal &#123;    @Override    public void eat() &#123;        System.out.println(&quot;Dog is eating.&quot;);    &#125;&#125;public class LowerBoundedWildcardExample &#123;    public static void addDogs(List&lt;? super Dog&gt; dogs) &#123;        dogs.add(new Dog());    &#125;    public static void main(String[] args) &#123;        List&lt;Animal&gt; animalList = new ArrayList&lt;&gt;();        addDogs(animalList);    &#125;&#125;</code></pre><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><img src="/../images/java-notes/1742043918319.png" alt="1742043918319"></p><h3 id="Class类的方法"><a href="#Class类的方法" class="headerlink" title="Class类的方法"></a>Class类的方法</h3><p><img src="/../images/java-notes/1742044540707.png" alt="1742044540707"></p><p><img src="/../images/java-notes/1742372570707.png" alt="1742372570707"></p><h3 id="Class类的获取方式"><a href="#Class类的获取方式" class="headerlink" title="Class类的获取方式"></a>Class类的获取方式</h3><h4 id="基本概念-13"><a href="#基本概念-13" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><strong>对应关系</strong>：每一个类、接口（包括注解类型和枚举类型）、基本数据类型（boolean、byte、char、short、int、long、float、double）、关键字 void 以及数组，在运行时都有一个对应的 Class 对象 ，用于封装它们在运行时的状态和类型信息。比如，定义一个<code>class Person&#123;&#125;</code>，编译后就会有一个表示<code>Person</code>类的 Class 对象。</li><li><strong>唯一性</strong>：JVM 中对于每种类型只会存在一个对应的 Class 对象。无论一个类实例化出多少个对象，这些对象对应的 Class 对象都是同一个。</li></ul><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><p>Class 类没有公共构造方法，它的对象由 JVM 在类加载时自动创建，或通过类加载器中的 defineClass 方法生成，无法像普通类一样通过<code>new</code>关键字创建。</p><h4 id="获取途径"><a href="#获取途径" class="headerlink" title="获取途径"></a>获取途径</h4><ul><li><strong>对象的<code>getClass()</code>方法</strong>：当一个类被实例化后，可通过对象调用<code>getClass()</code>方法获取该对象所属类的 Class 实例。例如：</li></ul><pre><code class="java">public class Main &#123;    public static void main(String[] args) &#123;        String str = &quot;hello&quot;;        Class&lt;?&gt; clazz = str.getClass();        System.out.println(clazz);    &#125;&#125;</code></pre><ul><li><strong>类字面常量（<code>.class</code>方式）</strong>：直接使用<code>类名.class</code>的形式获取对应的 Class 对象，基本数据类型的封装类还可以采用<code>.TYPE</code>获取相对应基本数据类型的 Class 实例。例如：</li></ul><pre><code class="java">Class&lt;String&gt; stringClass = String.class;Class&lt;Integer&gt; integerClass = Integer.class;Class&lt;int[]&gt; intArrayClass = int[].class;Class&lt;Void&gt; voidClass = void.class;Class&lt;Integer.TYPE&gt; primitiveIntClass = Integer.TYPE;</code></pre><ul><li><strong><code>Class.forName()</code>方法</strong>：通过传入类的全限定名（包名。类名）获取对应的 Class 对象，该方法常用于动态加载类。例如：</li></ul><pre><code class="java">try &#123;    Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.String&quot;);    System.out.println(clazz);&#125; catch (ClassNotFoundException e) &#123;    e.printStackTrace();&#125;</code></pre><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><strong>反射机制</strong>：通过 Class 对象，可在运行时获取类的构造函数、方法、字段等信息，动态创建对象、调用方法、访问和修改字段。例如，获取类的所有公共方法：</li></ul><pre><code class="java">import java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) &#123;        try &#123;            Class&lt;?&gt; clazz = String.class;            Method[] methods = clazz.getMethods();            for (Method method : methods) &#123;                System.out.println(method.getName());            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><ul><li><strong>类加载机制</strong>：JVM 在加载类时会创建对应的 Class 对象，可利用这一特性实现自定义类加载器，扩展类加载功能。</li><li><strong>泛型</strong>：在泛型编程中，借助 Class 类获取泛型类型的实际类型信息，增强代码的灵活性和通用性。</li></ul><h4 id="Class类的对象"><a href="#Class类的对象" class="headerlink" title="Class类的对象"></a>Class类的对象</h4><p><img src="/../images/java-notes/1742373691163.png" alt="1742373691163"></p><h3 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h3><p><img src="/../images/java-notes/1742374305770.png" alt="1742374305770"></p><h4 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h4><p>获取 Class 对象是反射创建对象的基础，有以下三种常见方式：</p><ul><li><strong>使用<code>class.forname(&quot;类的全限定名&quot;)</code>方法</strong>：该方法会动态加载指定类，最常用于在运行时根据配置文件或用户输入来确定要加载的类。例如<code>Class clazz = Class.forName(&quot;com.example.MyClass&quot;);</code>，如果类不存在会抛出<code>ClassNotFoundException</code>异常。</li><li><strong>使用类的<code>.class</code>语法</strong>：适用于在编译时就已知具体类的情况。比如<code>Class clazz = String.class;</code> ，这种方式不会导致类的初始化（静态代码块不会执行），仅表示获取该类的 Class 对象。</li><li><strong>使用对象的<code>getclass()</code>方法</strong>：当已经有一个类的对象实例时，可以通过调用该对象的<code>getClass()</code>方法获取其对应的 Class 对象。例如<code>MyClass obj = new MyClass(); Class clazz = obj.getClass();</code> 。</li></ul><h4 id="反射创建对象的具体方式"><a href="#反射创建对象的具体方式" class="headerlink" title="反射创建对象的具体方式"></a>反射创建对象的具体方式</h4><ul><li><strong>使用 Class 对象的<code>newinstance()</code>方法（已过时）</strong> ：在 Java 9 及之后，该方法已被标记为过时。它的使用前提是目标类必须有无参构造函数，并且构造函数的访问权限足够（通常是<code>public</code>） 。示例代码如下：</li></ul><pre><code class="java">try &#123;    Class&lt;?&gt; clazz = MyClass.class;    Object obj = clazz.newInstance();    // 如果需要，可将obj强制转换为MyClass类型    MyClass myObj = (MyClass) obj; &#125; catch (InstantiationException | IllegalAccessException e) &#123;    e.printStackTrace();&#125;</code></pre><ul><li><p>使用<code>Constructor</code>类的<code>newinstance()</code>方法：</p><p>这种方式更为灵活，可以调用类的无参构造函数，也可以调用有参构造函数。步骤如下：</p><ol><li><strong>获取<code>Constructor</code>对象</strong>：通过 Class 对象的<code>getConstructor()</code>（获取公共无参构造函数） 、<code>getDeclaredConstructor()</code>（获取类中声明的指定参数类型的构造函数，包括私有构造函数）等方法获取<code>Constructor</code>对象。例如，获取一个带有<code>String</code>和<code>int</code>类型参数的构造函数：<code>Constructor constructor = MyClass.class.getDeclaredConstructor(String.class, int.class);</code> 。</li><li><strong>设置访问权限（若需要）</strong> ：如果构造函数是私有的，需要调用<code>setAccessible(true)</code>来绕过访问权限检查，使其可访问。如<code>constructor.setAccessible(true);</code> 。</li><li><strong>创建对象实例</strong>：调用<code>Constructor</code>对象的<code>newInstance()</code>方法创建对象，并传入构造函数所需的参数。例如<code>MyClass obj = constructor.newInstance(&quot;example&quot;, 123);</code> 。</li></ol></li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code class="java">import java.lang.reflect.InvocationTargetException;class MyClass &#123;    public MyClass() &#123;        System.out.println(&quot;MyClass 的无参构造函数被调用&quot;);    &#125;&#125;public class ReflectionExample &#123;    public static void main(String[] args) &#123;        try &#123;            // 获取 MyClass 的 Class 对象            Class&lt;?&gt; clazz = MyClass.class;            // 使用 newInstance() 方法创建对象实例            Object obj = clazz.newInstance();            // 将 Object 类型的对象强制转换为 MyClass 类型            MyClass myObj = (MyClass) obj;        &#125; catch (InstantiationException | IllegalAccessException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="代码详细解释"><a href="#代码详细解释" class="headerlink" title="代码详细解释"></a>代码详细解释</h4><ul><li>**<code>clazz</code>**：这是一个 <code>Class</code> 类型的对象，它代表了某个类的运行时类型信息。在 Java 中，每个类在运行时都会有一个对应的 <code>Class</code> 对象，可通过多种方式获取，例如 <code>Class.forName(&quot;com.example.MyClass&quot;)</code>、<code>MyClass.class</code> 或者 <code>myObject.getClass()</code>。</li><li>**<code>newInstance()</code>**：这是 <code>Class</code> 类中的一个方法，其作用是尝试创建该 <code>Class</code> 对象所代表类的一个新实例。它会调用该类的无参构造函数来创建对象。</li><li>**<code>Object obj</code>**：声明了一个 <code>Object</code> 类型的变量 <code>obj</code>，用于接收 <code>newInstance()</code> 方法返回的对象实例。由于 Java 中的所有类都继承自 <code>Object</code> 类，所以可以用 <code>Object</code> 类型的变量来引用任何类的实例。</li></ul><h3 id="反射操作属性"><a href="#反射操作属性" class="headerlink" title="反射操作属性"></a>反射操作属性</h3><p><img src="/../images/java-notes/1742375125779.png" alt="1742375125779"></p><h4 id="a-、获取属性（四种方式）"><a href="#a-、获取属性（四种方式）" class="headerlink" title="a)、获取属性（四种方式）"></a>a)、获取属性（四种方式）</h4><ul><li><strong>获取公共属性</strong>：使用<code>Class</code>类的<code>getField(String name)</code>方法，参数<code>name</code>为属性名，能获取类中声明的指定公共属性。比如有类<code>public class Student &#123; public String name; &#125;</code>，获取<code>name</code>属性的代码如下：</li></ul><pre><code class="java">Class&lt;?&gt; clazz = Student.class;Field field = clazz.getField(&quot;name&quot;);</code></pre><ul><li><strong>获取所有公共属性</strong>：通过<code>getFields()</code>方法，可获取类中所有公共属性，返回值是<code>Field</code>数组。例如：</li></ul><pre><code class="java">Class&lt;?&gt; clazz = Student.class;Field[] fields = clazz.getFields();for (Field f : fields) &#123;    System.out.println(f.getName());&#125;</code></pre><ul><li><strong>获取指定声明属性</strong>：不管属性的访问修饰符（私有、保护、默认等），<code>getDeclaredField(String name)</code>方法能获取类中声明的指定属性。若有类<code>class Person &#123; private int age; &#125;</code> ，获取<code>age</code>属性的方式为：</li></ul><pre><code class="java">Class&lt;?&gt; clazz = Person.class;Field field = clazz.getDeclaredField(&quot;age&quot;);</code></pre><ul><li><strong>获取所有声明属性</strong>：<code>getDeclaredFields()</code>方法可获取类中声明的所有属性（包含私有、保护、默认），返回<code>Field</code>数组。示例代码：</li></ul><pre><code class="java">Class&lt;?&gt; clazz = Person.class;Field[] fields = clazz.getDeclaredFields();for (Field f : fields) &#123;    System.out.println(f.getName());&#125;</code></pre><h4 id="b-、设置属性"><a href="#b-、设置属性" class="headerlink" title="b)、设置属性"></a>b)、设置属性</h4><p>利用<code>Field</code>类的<code>set(Object obj, Object value)</code>方法设置属性值。第一个参数<code>obj</code>是要操作属性的对象实例；第二个参数<code>value</code>是要设置的新值。例如：</p><pre><code class="java">class Book &#123;    public String title;&#125;public class Main &#123;    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;        Book book = new Book();        Class&lt;?&gt; clazz = book.getClass();        Field field = clazz.getField(&quot;title&quot;);        field.set(book, &quot;Java编程思想&quot;);        System.out.println(book.title);     &#125;&#125;</code></pre><h4 id="c-、私有属性处理"><a href="#c-、私有属性处理" class="headerlink" title="c)、私有属性处理"></a>c)、私有属性处理</h4><p>对于私有属性，使用<code>getDeclaredField(String name)</code>获取属性后，默认无法直接访问，需调用<code>setAccessible(true)</code>来绕过访问权限检查。比如：</p><pre><code class="java">class Car &#123;    private String brand;&#125;public class Main &#123;    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;        Car car = new Car();        Class&lt;?&gt; clazz = car.getClass();        Field field = clazz.getDeclaredField(&quot;brand&quot;);        field.setAccessible(true);        field.set(car, &quot;BMW&quot;);        System.out.println(field.get(car));     &#125;&#125;</code></pre><h4 id="d-、静态属性处理"><a href="#d-、静态属性处理" class="headerlink" title="d)、静态属性处理"></a>d)、静态属性处理</h4><p>静态属性属于类而非对象实例，当使用<code>set(Object obj, Object value)</code>或<code>get(Object obj)</code>操作静态属性时，若属性是静态的，第一个参数<code>obj</code>可以为<code>null</code>。示例如下：</p><pre><code class="java">class Company &#123;    public static String companyName;&#125;public class Main &#123;    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;        Class&lt;?&gt; clazz = Company.class;        Field field = clazz.getField(&quot;companyName&quot;);        field.set(null, &quot;Google&quot;);         System.out.println(field.get(null));     &#125;&#125;</code></pre><h3 id="反射操作方法"><a href="#反射操作方法" class="headerlink" title="反射操作方法"></a>反射操作方法</h3><p><img src="/../images/java-notes/1742379209494.png" alt="1742379209494"></p><h4 id="a-获取方法-四种"><a href="#a-获取方法-四种" class="headerlink" title="a) 获取方法 (四种)"></a>a) 获取方法 (四种)</h4><ul><li><strong>获取类及其父类的所有公共方法</strong>：使用<code>Class</code>类的<code>getMethods()</code>方法，该方法返回一个包含<code>Method</code>对象的数组，每个<code>Method</code>对象代表一个公共方法。例如：</li></ul><pre><code class="java">Class&lt;?&gt; clazz = MyClass.class;Method[] allPublicMethods = clazz.getMethods();for (Method method : allPublicMethods) &#123;    System.out.println(method.getName());&#125;</code></pre><ul><li><strong>获取类中指定的公共方法</strong>：通过<code>getMethod(String name, Class... parameterTypes)</code>方法，<code>name</code>为方法名，后面的可变参数指定方法的参数类型。如获取一个名为<code>printInfo</code>且接收一个<code>String</code>参数的公共方法：</li></ul><pre><code class="java">Method specificPublicMethod = clazz.getMethod(&quot;printInfo&quot;, String.class);</code></pre><ul><li><strong>获取类中声明的所有方法</strong>：调用<code>getDeclaredMethods()</code>方法，它会返回类中声明的所有方法，包括私有、保护和默认访问修饰符的方法，但不包含从父类继承的方法。示例如下：</li></ul><pre><code class="java">Method[] allDeclaredMethods = clazz.getDeclaredMethods();for (Method method : allDeclaredMethods) &#123;    System.out.println(method.getName());&#125;</code></pre><ul><li><strong>获取类中指定声明的方法</strong>：使用<code>getDeclaredMethod(String name, Class... parameterTypes)</code>，可以获取指定名称和参数类型的类中声明的方法（包括私有方法）。比如获取一个私有方法<code>privateMethod</code>：</li></ul><pre><code class="java">Method specificDeclaredMethod = clazz.getDeclaredMethod(&quot;privateMethod&quot;);</code></pre><h4 id="b-调用方法"><a href="#b-调用方法" class="headerlink" title="b) 调用方法"></a>b) 调用方法</h4><p>获取到<code>Method</code>对象后，使用<code>invoke()</code>方法来调用。对于实例方法，<code>invoke(Object obj, Object... args)</code>中第一个参数<code>obj</code>是要调用方法的对象实例，<code>args</code>是方法的参数；对于静态方法，<code>obj</code>可以为<code>null</code>。例如：</p><pre><code class="java">class MyService &#123;    public void sayHello(String name) &#123;        System.out.println(&quot;Hello, &quot; + name);    &#125;&#125;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        MyService service = new MyService();        Class&lt;?&gt; clazz = service.getClass();        Method method = clazz.getMethod(&quot;sayHello&quot;, String.class);        method.invoke(service, &quot;Alice&quot;);     &#125;&#125;</code></pre><h4 id="c-私有方法"><a href="#c-私有方法" class="headerlink" title="c) 私有方法"></a>c) 私有方法</h4><p>调用私有方法时，由于访问限制，不能直接调用。需先通过<code>setAccessible(true)</code>方法设置可访问性，绕过访问控制检查。示例如下：</p><pre><code class="java">class SecretUtils &#123;    private void secretOperation() &#123;        System.out.println(&quot;Performing secret operation&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        SecretUtils utils = new SecretUtils();        Class&lt;?&gt; clazz = utils.getClass();        Method method = clazz.getDeclaredMethod(&quot;secretOperation&quot;);        method.setAccessible(true);        method.invoke(utils);     &#125;&#125;</code></pre><h4 id="d-如果是静态方法，第一个参数可以给-null"><a href="#d-如果是静态方法，第一个参数可以给-null" class="headerlink" title="d) 如果是静态方法，第一个参数可以给 null"></a>d) 如果是静态方法，第一个参数可以给 null</h4><p>静态方法属于类本身，而非类的实例。在使用<code>invoke()</code>调用静态方法时，第一个参数可以传入<code>null</code>，后续参数按方法定义传递。比如：</p><pre><code class="java">class MathUtils &#123;    public static int add(int a, int b) &#123;        return a + b;    &#125;&#125;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class&lt;?&gt; clazz = MathUtils.class;        Method method = clazz.getMethod(&quot;add&quot;, int.class, int.class);        int result = (int) method.invoke(null, 3, 5);         System.out.println(&quot;Result: &quot; + result);    &#125;&#125;</code></pre><h3 id="Class类的其他方法"><a href="#Class类的其他方法" class="headerlink" title="Class类的其他方法"></a>Class类的其他方法</h3><p><img src="/../images/java-notes/1742380015764.png" alt="1742380015764"></p><h4 id="a-获取内部类"><a href="#a-获取内部类" class="headerlink" title="a) 获取内部类"></a>a) 获取内部类</h4><p>在 Java 中，可以使用<code>getDeclaredClasses()</code>方法来获取一个类中声明的所有内部类，返回值是一个<code>Class</code>数组，每个元素代表一个内部类的<code>Class</code>对象。示例代码如下：</p><pre><code class="java">class OuterClass &#123;    class InnerClass &#123;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Class&lt;?&gt; outerClass = OuterClass.class;        Class&lt;?&gt;[] declaredClasses = outerClass.getDeclaredClasses();        for (Class&lt;?&gt; inner : declaredClasses) &#123;            System.out.println(inner.getName());        &#125;    &#125;&#125;</code></pre><h4 id="b-获取父类"><a href="#b-获取父类" class="headerlink" title="b) 获取父类"></a>b) 获取父类</h4><p>使用<code>getSuperclass()</code>方法可以获取一个类的直接父类，返回值是一个<code>Class</code>对象。如果一个类直接继承自<code>Object</code>类，或者该类是<code>Object</code>类本身，此方法返回<code>java.lang.Object.class</code>。示例如下：</p><pre><code class="java">class ParentClass &#123;&#125;class ChildClass extends ParentClass &#123;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Class&lt;?&gt; childClass = ChildClass.class;        Class&lt;?&gt; superclass = childClass.getSuperclass();        System.out.println(superclass.getName());    &#125;&#125;</code></pre><h4 id="c-获取接口"><a href="#c-获取接口" class="headerlink" title="c) 获取接口"></a>c) 获取接口</h4><p>通过<code>getInterfaces()</code>方法可以获取一个类实现的所有接口，返回值是一个<code>Class</code>数组，数组中的每个元素代表一个接口的<code>Class</code>对象。示例代码：</p><pre><code class="java">interface MyInterface &#123;&#125;class ImplementClass implements MyInterface &#123;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Class&lt;?&gt; implementClass = ImplementClass.class;        Class&lt;?&gt;[] interfaces = implementClass.getInterfaces();        for (Class&lt;?&gt; interfaceClass : interfaces) &#123;            System.out.println(interfaceClass.getName());        &#125;    &#125;&#125;</code></pre><h3 id="反射打印类的结构信息"><a href="#反射打印类的结构信息" class="headerlink" title="反射打印类的结构信息"></a>反射打印类的结构信息</h3><p><img src="/../images/java-notes/1742380952092.png" alt="1742380952092"></p><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code class="java">import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class PrintClassStructure &#123;    public static void printClassStructure(Class&lt;?&gt; clazz) &#123;        // 打印类的基本信息        System.out.println(&quot;类的基本信息：&quot;);        System.out.println(&quot;类名: &quot; + clazz.getName());        System.out.println(&quot;简单类名: &quot; + clazz.getSimpleName());        System.out.println(&quot;修饰符: &quot; + Modifier.toString(clazz.getModifiers()));        // 打印父类信息        Class&lt;?&gt; superclass = clazz.getSuperclass();        if (superclass != null) &#123;            System.out.println(&quot;父类: &quot; + superclass.getName());        &#125; else &#123;            System.out.println(&quot;父类: 无&quot;);        &#125;        // 打印实现的接口信息        Class&lt;?&gt;[] interfaces = clazz.getInterfaces();        if (interfaces.length &gt; 0) &#123;            System.out.print(&quot;实现的接口: &quot;);            for (Class&lt;?&gt; inter : interfaces) &#123;                System.out.print(inter.getName() + &quot; &quot;);            &#125;            System.out.println();        &#125; else &#123;            System.out.println(&quot;实现的接口: 无&quot;);        &#125;        // 打印字段信息        System.out.println(&quot;\n字段信息：&quot;);        Field[] fields = clazz.getDeclaredFields();        for (Field field : fields) &#123;            System.out.println(&quot;  字段名: &quot; + field.getName());            System.out.println(&quot;    类型: &quot; + field.getType().getName());            System.out.println(&quot;    修饰符: &quot; + Modifier.toString(field.getModifiers()));        &#125;        // 打印构造函数信息        System.out.println(&quot;\n构造函数信息：&quot;);        Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();        for (Constructor&lt;?&gt; constructor : constructors) &#123;            System.out.println(&quot;  构造函数名: &quot; + constructor.getName());            System.out.print(&quot;    参数类型: &quot;);            Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();            for (Class&lt;?&gt; paramType : parameterTypes) &#123;                System.out.print(paramType.getName() + &quot; &quot;);            &#125;            System.out.println();            System.out.println(&quot;    修饰符: &quot; + Modifier.toString(constructor.getModifiers()));        &#125;        // 打印方法信息        System.out.println(&quot;\n方法信息：&quot;);        Method[] methods = clazz.getDeclaredMethods();        for (Method method : methods) &#123;            System.out.println(&quot;  方法名: &quot; + method.getName());            System.out.println(&quot;    返回类型: &quot; + method.getReturnType().getName());            System.out.print(&quot;    参数类型: &quot;);            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();            for (Class&lt;?&gt; paramType : parameterTypes) &#123;                System.out.print(paramType.getName() + &quot; &quot;);            &#125;            System.out.println();            System.out.println(&quot;    修饰符: &quot; + Modifier.toString(method.getModifiers()));        &#125;    &#125;    public static void main(String[] args) &#123;        // 示例：打印 String 类的结构信息        printClassStructure(String.class);    &#125;&#125;    </code></pre><ul><li><strong>类的基本信息</strong>：使用 <code>getName()</code>、<code>getSimpleName()</code> 和 <code>getModifiers()</code> 方法获取类的名称、简单名称和修饰符。</li><li><strong>父类信息</strong>：使用 <code>getSuperclass()</code> 方法获取类的父类。</li><li><strong>实现的接口信息</strong>：使用 <code>getInterfaces()</code> 方法获取类实现的所有接口。</li><li><strong>字段信息</strong>：使用 <code>getDeclaredFields()</code> 方法获取类中声明的所有字段，并打印字段的名称、类型和修饰符。</li><li><strong>构造函数信息</strong>：使用 <code>getDeclaredConstructors()</code> 方法获取类的所有构造函数，并打印构造函数的名称、参数类型和修饰符。</li><li><strong>方法信息</strong>：使用 <code>getDeclaredMethods()</code> 方法获取类中声明的所有方法，并打印方法的名称、返回类型、参数类型和修饰符。</li></ul><h4 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h4><h5 id="1-导入必要的类"><a href="#1-导入必要的类" class="headerlink" title="1. 导入必要的类"></a>1. 导入必要的类</h5><pre><code class="java">import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;</code></pre><p>这里导入了 Java 反射机制相关的类，具体如下：</p><ul><li><code>Constructor</code>：用于获取类的构造函数信息。</li><li><code>Field</code>：用于获取类的字段（成员变量）信息。</li><li><code>Method</code>：用于获取类的方法信息。</li><li><code>Modifier</code>：用于获取和处理类、方法、字段等的修饰符（如 <code>public</code>、<code>private</code>、<code>static</code> 等）。</li></ul><h5 id="2-定义主类"><a href="#2-定义主类" class="headerlink" title="2. 定义主类"></a>2. 定义主类</h5><pre><code class="java">public class PrintClassStructure &#123;</code></pre><p>定义了一个名为 <code>PrintClassStructure</code> 的公共类，该类包含一个静态方法 <code>printClassStructure</code> 用于打印类的结构信息，以及一个 <code>main</code> 方法作为程序的入口。</p><h5 id="3-定义打印类结构信息的方法"><a href="#3-定义打印类结构信息的方法" class="headerlink" title="3. 定义打印类结构信息的方法"></a>3. 定义打印类结构信息的方法</h5><pre><code class="java">public static void printClassStructure(Class&lt;?&gt; clazz) &#123;</code></pre><p>定义了一个静态方法 <code>printClassStructure</code>，它接受一个 <code>Class</code> 类型的参数 <code>clazz</code>，表示要打印结构信息的类。</p><h6 id="打印类的基本信息"><a href="#打印类的基本信息" class="headerlink" title="打印类的基本信息"></a>打印类的基本信息</h6><pre><code class="java">// 打印类的基本信息System.out.println(&quot;类的基本信息：&quot;);System.out.println(&quot;类名: &quot; + clazz.getName());System.out.println(&quot;简单类名: &quot; + clazz.getSimpleName());System.out.println(&quot;修饰符: &quot; + Modifier.toString(clazz.getModifiers()));</code></pre><ul><li><code>clazz.getName()</code>：返回类的全限定名，包含包名。</li><li><code>clazz.getSimpleName()</code>：返回类的简单名称，不包含包名。</li><li><code>Modifier.toString(clazz.getModifiers())</code>：将类的修饰符转换为字符串表示，如 <code>public</code>、<code>final</code> 等。</li></ul><h6 id="打印父类信息"><a href="#打印父类信息" class="headerlink" title="打印父类信息"></a>打印父类信息</h6><pre><code class="java">// 打印父类信息Class&lt;?&gt; superclass = clazz.getSuperclass();if (superclass != null) &#123;    System.out.println(&quot;父类: &quot; + superclass.getName());&#125; else &#123;    System.out.println(&quot;父类: 无&quot;);&#125;</code></pre><ul><li><code>clazz.getSuperclass()</code>：获取该类的直接父类的 <code>Class</code> 对象。如果该类没有父类（即 <code>Object</code> 类），则返回 <code>null</code>。</li></ul><h6 id="打印实现的接口信息"><a href="#打印实现的接口信息" class="headerlink" title="打印实现的接口信息"></a>打印实现的接口信息</h6><pre><code class="java">// 打印实现的接口信息Class&lt;?&gt;[] interfaces = clazz.getInterfaces();if (interfaces.length &gt; 0) &#123;    System.out.print(&quot;实现的接口: &quot;);    for (Class&lt;?&gt; inter : interfaces) &#123;        System.out.print(inter.getName() + &quot; &quot;);    &#125;    System.out.println();&#125; else &#123;    System.out.println(&quot;实现的接口: 无&quot;);&#125;</code></pre><ul><li><code>clazz.getInterfaces()</code>：获取该类实现的所有接口的 <code>Class</code> 对象数组。如果该类没有实现任何接口，则数组长度为 0。</li></ul><h6 id="打印字段信息"><a href="#打印字段信息" class="headerlink" title="打印字段信息"></a>打印字段信息</h6><pre><code class="java">// 打印字段信息System.out.println(&quot;\n字段信息：&quot;);Field[] fields = clazz.getDeclaredFields();for (Field field : fields) &#123;    System.out.println(&quot;  字段名: &quot; + field.getName());    System.out.println(&quot;    类型: &quot; + field.getType().getName());    System.out.println(&quot;    修饰符: &quot; + Modifier.toString(field.getModifiers()));&#125;</code></pre><ul><li><code>clazz.getDeclaredFields()</code>：获取该类声明的所有字段（包括私有、受保护和公共字段）的 <code>Field</code> 对象数组。</li><li><code>field.getName()</code>：返回字段的名称。</li><li><code>field.getType().getName()</code>：返回字段的类型的全限定名。</li><li><code>Modifier.toString(field.getModifiers())</code>：返回字段的修饰符的字符串表示。</li></ul><h6 id="打印构造函数信息"><a href="#打印构造函数信息" class="headerlink" title="打印构造函数信息"></a>打印构造函数信息</h6><pre><code class="java">// 打印构造函数信息System.out.println(&quot;\n构造函数信息：&quot;);Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();for (Constructor&lt;?&gt; constructor : constructors) &#123;    System.out.println(&quot;  构造函数名: &quot; + constructor.getName());    System.out.print(&quot;    参数类型: &quot;);    Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();    for (Class&lt;?&gt; paramType : parameterTypes) &#123;        System.out.print(paramType.getName() + &quot; &quot;);    &#125;    System.out.println();    System.out.println(&quot;    修饰符: &quot; + Modifier.toString(constructor.getModifiers()));&#125;</code></pre><ul><li><code>clazz.getDeclaredConstructors()</code>：获取该类声明的所有构造函数的 <code>Constructor</code> 对象数组。</li><li><code>constructor.getName()</code>：返回构造函数的名称，通常与类名相同。</li><li><code>constructor.getParameterTypes()</code>：返回构造函数的参数类型的 <code>Class</code> 对象数组。</li><li><code>Modifier.toString(constructor.getModifiers())</code>：返回构造函数的修饰符的字符串表示。</li></ul><h6 id="打印方法信息"><a href="#打印方法信息" class="headerlink" title="打印方法信息"></a>打印方法信息</h6><pre><code class="java">// 打印方法信息System.out.println(&quot;\n方法信息：&quot;);Method[] methods = clazz.getDeclaredMethods();for (Method method : methods) &#123;    System.out.println(&quot;  方法名: &quot; + method.getName());    System.out.println(&quot;    返回类型: &quot; + method.getReturnType().getName());    System.out.print(&quot;    参数类型: &quot;);    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();    for (Class&lt;?&gt; paramType : parameterTypes) &#123;        System.out.print(paramType.getName() + &quot; &quot;);    &#125;    System.out.println();    System.out.println(&quot;    修饰符: &quot; + Modifier.toString(method.getModifiers()));&#125;</code></pre><ul><li><code>clazz.getDeclaredMethods()</code>：获取该类声明的所有方法的 <code>Method</code> 对象数组。</li><li><code>method.getName()</code>：返回方法的名称。</li><li><code>method.getReturnType().getName()</code>：返回方法的返回类型的全限定名。</li><li><code>method.getParameterTypes()</code>：返回方法的参数类型的 <code>Class</code> 对象数组。</li><li><code>Modifier.toString(method.getModifiers())</code>：返回方法的修饰符的字符串表示。</li></ul><h5 id="4-定义主方法"><a href="#4-定义主方法" class="headerlink" title="4. 定义主方法"></a>4. 定义主方法</h5><pre><code class="java">public static void main(String[] args) &#123;    // 示例：打印 String 类的结构信息    printClassStructure(String.class);&#125;</code></pre><p>这是程序的入口方法，调用 <code>printClassStructure</code> 方法并传入 <code>String.class</code> 作为参数，打印 <code>String</code> 类的结构信息。你可以将 <code>String.class</code> 替换为其他类的 <code>Class</code> 对象，以打印不同类的结构信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;安卓逆向基础&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
