<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NaoJianghh</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-09-13T07:25:22.641Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>脑浆糊</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优雅的序列</title>
    <link href="http://example.com/2025/09/13/%E4%BC%98%E9%9B%85%E7%9A%84%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2025/09/13/%E4%BC%98%E9%9B%85%E7%9A%84%E5%BA%8F%E5%88%97/</id>
    <published>2025-09-13T07:03:48.000Z</published>
    <updated>2025-09-13T07:25:22.641Z</updated>
    
    <content type="html"><![CDATA[<p> 利用<strong>异或运算的性质</strong>设计高效的查询方案 。</p><span id="more"></span><h1 id="优雅的序列"><a href="#优雅的序列" class="headerlink" title="优雅的序列"></a>优雅的序列</h1><p>算法与数据结构实验题 1.13 优雅的序列</p><p>★实验任务</p><p>如果一个序列的元素的异或和等于 1，我们称这个序列为优雅的序列。现在给你一个01序列，和m次询问。对于每次询问，给出l,r。请你输出子序列a[l…r]的异或和。</p><p>★数据输入</p><p>输入第一行为正整数 n，m。</p><p>第二行为 n 个正整数 a[1…n]。</p><p>接下来的 m 行，每行两个数 l,r。(1&lt;&#x3D;l&lt;&#x3D;r&lt;&#x3D;n)</p><p>80%的数据 1&lt;&#x3D;n,m&lt;&#x3D;1000.</p><p>100%的数据1&lt;&#x3D;n,m&lt;&#x3D;100000.</p><h2 id="一、暴力求解法"><a href="#一、暴力求解法" class="headerlink" title="一、暴力求解法"></a>一、暴力求解法</h2><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int n, m;int num[100000 + 5];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; num[i];    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        int l, r;        int sum;        cin &gt;&gt; l &gt;&gt; r;        sum = num[l];        for (int i = l + 1; i &lt;= r; i++) &#123;            sum ^= num[i];        &#125;        cout &lt;&lt; sum &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><h2 id="二、前缀异或和"><a href="#二、前缀异或和" class="headerlink" title="二、前缀异或和"></a>二、前缀异或和</h2><p><strong>思路</strong>：</p><p>​设sum[i]为num前i项的异或和，则<code>sum[i] = num[1]^num[2]^......^num[i]</code>。</p><p>当要求区间[l,r]的异或和时，则<code>sum[r] = num[1]^num[2]^......^num[r] = num[1]^......^num[l-1]^num[l]^......^num[r]</code>。其中<code>num[l]^......^num[r]</code>为所求内容，再根据异或运算的特性两边同时异或上<code>sum[l-1]</code>，可得：<code>num[l]^......^num[r] = sum[r] ^ sum[l - 1]</code>。</p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int n, m;int num[100000 + 5];int sum[100000 + 5];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; num[i];        if (i == 1) &#123;            sum[i] = num[i];        &#125;        else &#123;            sum[i] = sum[i - 1] ^ num[i];        &#125;    &#125;    for (int i = 1; i &lt;= m; i++) &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        cout &lt;&lt; (sum[r] ^ sum[l - 1]) &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt; 利用&lt;strong&gt;异或运算的性质&lt;/strong&gt;设计高效的查询方案 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最大子列和</title>
    <link href="http://example.com/2025/09/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/"/>
    <id>http://example.com/2025/09/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/</id>
    <published>2025-09-12T14:16:39.000Z</published>
    <updated>2025-09-12T14:55:20.221Z</updated>
    
    <content type="html"><![CDATA[<p>最大子列和问题详解（分治法和动态规划）。</p><span id="more"></span><h1 id="最大子列和问题"><a href="#最大子列和问题" class="headerlink" title="最大子列和问题"></a>最大子列和问题</h1><p><img src="/../images/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/1757687533219.png" alt="1757687533219"></p><h2 id="一、暴力求解法"><a href="#一、暴力求解法" class="headerlink" title="一、暴力求解法"></a>一、暴力求解法</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int num[100000 + 5];int k;int main ()&#123;    int ans = 0;    cin &gt;&gt; k;    for (int i = 0;i &lt; k;i ++)&#123;        cin &gt;&gt; num[i];    &#125;    for (int i = 0;i &lt; k;i ++)&#123;        int sum = 0;        for (int j = i;j &lt; k;j ++)&#123;            sum += num[j];            if (sum &gt; ans)&#123;                ans = sum;            &#125;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;</code></pre><ul><li><strong>思路</strong>：以<code>i</code>作为每个子列的起点，枚举到以该起点的子列最大值。</li><li><strong>步骤</strong>：<ol><li>外层循环控制起始索引 <code>i</code>，初始化当前和 <code>sum = 0</code>；</li><li>内层循环控制结束索引 <code>j</code>（从 <code>i</code> 开始），<code>sum += num[j]</code>，同步更新最大和。</li></ol></li><li><strong>时间复杂度</strong>：<code>O(n²)</code>，不适合大规模数据。</li></ul><h2 id="二、分治法"><a href="#二、分治法" class="headerlink" title="二、分治法"></a>二、分治法</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int num[100000 + 5];int k;int Max(int l,int r)&#123;    int maxL = 0;    int maxR = 0;    int sumL = 0;    int sumR = 0;    if (l == r)&#123;        return num[l];    &#125;    int m = (l + r)/2;    for (int i = m;i &gt;= l; i--)&#123;        sumL += num[i];        if (sumL &gt; maxL)&#123;            maxL = sumL;        &#125;    &#125;    for (int i = m + 1;i &lt;= r;i ++)&#123;        sumR += num[i];        if (sumR &gt; maxR)&#123;            maxR = sumR;        &#125;    &#125;    int maxMid = maxL + maxR;    return max(max(Max(l,m),Max(m+1,r)),maxMid);&#125;int main() &#123;    cin &gt;&gt; k;    for (int i = 0;i &lt; k;i ++)&#123;        cin &gt;&gt; num[i];    &#125;    cout &lt;&lt; Max(0,k-1) &lt;&lt; endl;        return 0;&#125;</code></pre><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a><strong>核心思路</strong></h3><p>分治法的核心思想是<strong>将问题分解为更小的子问题</strong>，求解子问题后<strong>合并结果</strong>：</p><ol><li><strong>分解</strong>：将数组从中间分为左半部分和右半部分。</li><li><strong>求解子问题</strong>：递归求解左半部分的最大子数组和、右半部分的最大子数组和。</li><li><strong>合并</strong>：计算跨越左右两部分的最大子数组和（即包含中间元素的最大子数组），最终结果为这三者中的最大值。</li></ol><h3 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a><strong>步骤解析</strong></h3><p>以函数<code>Max(l, r)</code>为例（表示求解数组<code>num</code>中从索引<code>l</code>到<code>r</code>的最大子数组和）：</p><ol><li><strong>递归终止条件</strong>：<ul><li>当<code>l == r</code>（子数组只有一个元素），直接返回该元素的值（单个元素的最大子数组就是它本身）。</li></ul></li><li><strong>分解数组</strong>：<ul><li>计算中间索引<code>m = (l + r) / 2</code>，将数组分为<code>[l, m]</code>（左半部分）和<code>[m+1, r]</code>（右半部分）。</li></ul></li><li><strong>求解左、右子数组的最大和</strong>：<ul><li>递归计算左半部分：<code>Max(l, m)</code></li><li>递归计算右半部分：<code>Max(m+1, r)</code></li></ul></li><li><strong>计算跨越中间的最大子数组和</strong>：<ul><li><strong>左半部分延伸</strong>：从中间<code>m</code>向左遍历（<code>i = m</code>到<code>l</code>），累加元素并记录最大和<code>maxL</code>（包含<code>m</code>的左侧最大子数组）。</li><li><strong>右半部分延伸</strong>：从中间<code>m+1</code>向右遍历（<code>i = m+1</code>到<code>r</code>），累加元素并记录最大和<code>maxR</code>（包含<code>m+1</code>的右侧最大子数组）。</li><li>跨越中间的最大和为<code>maxMid = maxL + maxR</code>（左右两部分连接形成的子数组）。</li></ul></li><li><strong>合并结果</strong>：<ul><li>最终结果为左半部分最大和、右半部分最大和、跨越中间最大和中的最大值，即<code>max(max(Max(l,m), Max(m+1,r)), maxMid)</code>。</li></ul></li></ol><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a><strong>时间复杂度分析</strong></h3><ul><li><strong>分解</strong>：每次将数组分为两半，递归深度为<code>O(log n)</code>（<code>n</code>为数组长度）。</li><li><strong>合并</strong>：每次计算跨越中间的最大子数组和时，需要遍历左半部分和右半部分，总遍历次数为<code>O(n)</code>（每次递归处理的子数组长度之和为<code>n</code>）。</li><li><strong>总时间复杂度</strong>：<code>O(n log n)</code>，其中<code>n</code>是数组的长度（代码中为<code>k</code>）。</li></ul><h2 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h2><pre><code class="c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int num[100000 + 5];int dp[100000 + 5];int k;int ans;int main() &#123;    ans = 0;    cin &gt;&gt; k;    for (int i = 0;i &lt; k;i ++)&#123;        cin &gt;&gt; num[i];    &#125;    dp[0] = num[0];    for (int i = 1;i &lt; k;i ++)&#123;        dp[i] = max(num[i],dp[i-1] + num[i]);        if (dp[i] &gt; ans)&#123;            ans = dp[i];        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;        return 0;&#125;</code></pre><h3 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a><strong>核心思路</strong></h3><p>动态规划的核心思想是<strong>通过求解子问题的最优解来推导整个问题的最优解</strong>，并利用中间结果避免重复计算。</p><p>对于最大子数组和问题，定义<code>dp[i]</code>表示：以数组第<code>i</code>个元素（<code>num[i]</code>）为结尾的最大子数组的和。</p><p>关键逻辑是：</p><ul><li>对于每个元素<code>num[i]</code>，有两种选择：<ol><li>单独作为一个子数组（此时和为<code>num[i]</code>）</li><li>加入以<code>num[i-1]</code>为结尾的最大子数组（此时和为<code>dp[i-1] + num[i]</code>）</li></ol></li><li>取两种选择中的最大值作为<code>dp[i]</code>，即<code>dp[i] = max(num[i], dp[i-1] + num[i])</code></li><li>整个数组的最大子数组和，就是所有<code>dp[i]</code>中的最大值</li></ul><h3 id="步骤解析-1"><a href="#步骤解析-1" class="headerlink" title="步骤解析"></a><strong>步骤解析</strong></h3><ol><li><p><strong>初始化</strong>：</p><ul><li><code>dp[0] = num[0]</code>：第一个元素的最大子数组就是它本身</li><li><code>ans = 0</code>：用于记录全局最大子数组和（后续会更新）</li></ul></li><li><p><strong>遍历数组计算 dp 数组</strong>：</p><ul><li><p>从第二个元素（<code>i = 1</code>）开始遍历到最后一个元素（<code>i = k-1</code>）</p></li><li><p>对每个</p><pre><code>i</code></pre><p>，计算</p><pre><code>dp[i] = max(num[i], dp[i-1] + num[i])</code></pre><p>：</p><ul><li>若<code>dp[i-1] + num[i]</code>更大，说明将<code>num[i]</code>加入前一个子数组能得到更大和</li><li>若<code>num[i]</code>更大，说明从<code>num[i]</code>开始重新计算子数组更优</li></ul></li><li><p>每次计算<code>dp[i]</code>后，更新<code>ans</code>为<code>ans</code>和<code>dp[i]</code>中的最大值</p></li></ul></li><li><p><strong>输出结果</strong>：</p><ul><li>最终<code>ans</code>即为整个数组的最大子数组和</li></ul></li></ol><h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a><strong>时间复杂度分析</strong></h3><ul><li>代码中只有一次对数组的遍历（从<code>i = 1</code>到<code>i = k-1</code>），共执行<code>k-1</code>次操作</li><li>每次操作（计算<code>dp[i]</code>和更新<code>ans</code>）都是常数时间<code>O(1)</code></li><li>因此，<strong>总时间复杂度为</strong><code>O(k)</code>（<code>k</code>为数组长度）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最大子列和问题详解（分治法和动态规划）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android信息传递详解</title>
    <link href="http://example.com/2025/09/10/Android%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/09/10/Android%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-09-10T07:12:14.000Z</published>
    <updated>2025-09-10T07:15:03.757Z</updated>
    
    <content type="html"><![CDATA[<p> 在 Android 开发中，信息传递（数据传递）是组件间通信的核心，常见场景包括 Activity 之间、Activity 与 Fragment 之间、线程之间等。 </p><span id="more"></span><h3 id="一、Activity-之间的数据传递"><a href="#一、Activity-之间的数据传递" class="headerlink" title="一、Activity 之间的数据传递"></a>一、Activity 之间的数据传递</h3><p>最常用的是通过<code>Intent</code>携带数据，配合<code>startActivity()</code>或<code>startActivityForResult()</code>（已过时，推荐<code>Activity Result API</code>）。</p><h4 id="1-基础数据传递（Intent-putExtra-）"><a href="#1-基础数据传递（Intent-putExtra-）" class="headerlink" title="1. 基础数据传递（Intent.putExtra ()）"></a>1. 基础数据传递（Intent.putExtra ()）</h4><p><strong>发送方 Activity</strong>：</p><pre><code class="java">// 发送数据到目标ActivityIntent intent = new Intent(SenderActivity.this, ReceiverActivity.class);// 传递基本类型数据intent.putExtra(&quot;key_string&quot;, &quot;Hello Receiver&quot;);intent.putExtra(&quot;key_int&quot;, 123);intent.putExtra(&quot;key_boolean&quot;, true);// 传递自定义对象（需实现Serializable或Parcelable）User user = new User(&quot;Tom&quot;, 20);intent.putExtra(&quot;key_user&quot;, user); // User需实现SerializablestartActivity(intent);</code></pre><p><strong>接收方 Activity</strong>：</p><pre><code class="java">// 在onCreate中接收数据@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_receiver);        Intent intent = getIntent();    // 获取基本类型数据    String str = intent.getStringExtra(&quot;key_string&quot;);    int num = intent.getIntExtra(&quot;key_int&quot;, 0); // 第二个参数为默认值    boolean flag = intent.getBooleanExtra(&quot;key_boolean&quot;, false);        // 获取自定义对象    User user = (User) intent.getSerializableExtra(&quot;key_user&quot;);&#125;// 自定义对象（实现Serializable）public class User implements Serializable &#123;    private String name;    private int age;        // 构造方法、getter、setter    public User(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    // ... getter和setter&#125;</code></pre><h4 id="2-回传数据（Activity-Result-API）"><a href="#2-回传数据（Activity-Result-API）" class="headerlink" title="2. 回传数据（Activity Result API）"></a>2. 回传数据（Activity Result API）</h4><p>替代已过时的<code>startActivityForResult()</code>，用于需要从目标 Activity 返回数据的场景。</p><p><strong>发送方 Activity</strong>：</p><pre><code class="java">import androidx.activity.result.ActivityResultLauncher;import androidx.activity.result.contract.ActivityResultContracts;public class SenderActivity extends AppCompatActivity &#123;    // 注册回调    private ActivityResultLauncher&lt;Intent&gt; resultLauncher = registerForActivityResult(        new ActivityResultContracts.StartActivityForResult(),        result -&gt; &#123;            // 处理返回结果            if (result.getResultCode() == RESULT_OK) &#123;                Intent data = result.getData();                if (data != null) &#123;                    String returnStr = data.getStringExtra(&quot;return_key&quot;);                    // 更新UI                &#125;            &#125;        &#125;    );    // 触发跳转并等待返回    public void sendAndWaitResult(View view) &#123;        Intent intent = new Intent(this, ReceiverActivity.class);        intent.putExtra(&quot;request_key&quot;, &quot;请处理数据&quot;);        resultLauncher.launch(intent);    &#125;&#125;</code></pre><p><strong>接收方 Activity</strong>：</p><pre><code class="java">// 处理数据并返回结果public class ReceiverActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_receiver);                // 获取请求数据        String requestData = getIntent().getStringExtra(&quot;request_key&quot;);                // 处理后返回结果        findViewById(R.id.btn_return).setOnClickListener(v -&gt; &#123;            Intent returnIntent = new Intent();            returnIntent.putExtra(&quot;return_key&quot;, &quot;处理完成：&quot; + requestData);            setResult(RESULT_OK, returnIntent);            finish(); // 关闭当前Activity        &#125;);    &#125;&#125;</code></pre><h3 id="二、Activity-与-Fragment-之间的数据传递"><a href="#二、Activity-与-Fragment-之间的数据传递" class="headerlink" title="二、Activity 与 Fragment 之间的数据传递"></a>二、Activity 与 Fragment 之间的数据传递</h3><h4 id="1-Activity-向-Fragment-传递数据"><a href="#1-Activity-向-Fragment-传递数据" class="headerlink" title="1. Activity 向 Fragment 传递数据"></a>1. Activity 向 Fragment 传递数据</h4><p>通过<code>Fragment.setArguments(Bundle)</code>传递：</p><p><strong>Activity 中</strong>：</p><pre><code class="java">// 创建Fragment并传递数据MyFragment fragment = new MyFragment();Bundle bundle = new Bundle();bundle.putString(&quot;fragment_key&quot;, &quot;来自Activity的数据&quot;);bundle.putInt(&quot;fragment_num&quot;, 456);fragment.setArguments(bundle);// 加载FragmentgetSupportFragmentManager().beginTransaction()    .replace(R.id.container, fragment)    .commit();</code></pre><p><strong>Fragment 中</strong>：</p><pre><code class="java">@Overridepublic void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    // 接收数据    if (getArguments() != null) &#123;        String str = getArguments().getString(&quot;fragment_key&quot;);        int num = getArguments().getInt(&quot;fragment_num&quot;);    &#125;&#125;</code></pre><h4 id="2-Fragment-向-Activity-传递数据"><a href="#2-Fragment-向-Activity-传递数据" class="headerlink" title="2. Fragment 向 Activity 传递数据"></a>2. Fragment 向 Activity 传递数据</h4><p>通过接口回调实现：</p><p><strong>定义回调接口（在 Fragment 中）</strong>：</p><pre><code class="java">public class MyFragment extends Fragment &#123;    // 定义回调接口    public interface OnDataPassListener &#123;        void onDataPass(String data);    &#125;        private OnDataPassListener listener;        // 绑定Activity时初始化接口    @Override    public void onAttach(@NonNull Context context) &#123;        super.onAttach(context);        if (context instanceof OnDataPassListener) &#123;            listener = (OnDataPassListener) context;        &#125; else &#123;            throw new RuntimeException(&quot;Activity需实现OnDataPassListener接口&quot;);        &#125;    &#125;        // 发送数据到Activity    private void sendDataToActivity() &#123;        String data = &quot;来自Fragment的数据&quot;;        listener.onDataPass(data); // 调用接口方法    &#125;&#125;</code></pre><p><strong>Activity 实现接口</strong>：</p><pre><code class="java">public class MainActivity extends AppCompatActivity implements MyFragment.OnDataPassListener &#123;    @Override    public void onDataPass(String data) &#123;        // 接收Fragment传递的数据        Log.d(&quot;MainActivity&quot;, &quot;收到数据：&quot; + data);    &#125;&#125;</code></pre><h3 id="三、全局数据传递（Application-单例模式）"><a href="#三、全局数据传递（Application-单例模式）" class="headerlink" title="三、全局数据传递（Application &#x2F; 单例模式）"></a>三、全局数据传递（Application &#x2F; 单例模式）</h3><p>适合需要在整个应用中共享的数据（如用户信息、配置参数）。</p><h4 id="1-自定义-Application-类"><a href="#1-自定义-Application-类" class="headerlink" title="1. 自定义 Application 类"></a>1. 自定义 Application 类</h4><pre><code class="java">public class MyApplication extends Application &#123;    private String globalData; // 全局共享数据        public static MyApplication getInstance(Context context) &#123;        return (MyApplication) context.getApplicationContext();    &#125;        // getter和setter    public String getGlobalData() &#123;        return globalData;    &#125;        public void setGlobalData(String data) &#123;        this.globalData = data;    &#125;&#125;</code></pre><p><strong>在 AndroidManifest.xml 中注册</strong>：</p><pre><code class="xml">&lt;application    android:name=&quot;.MyApplication&quot;    &lt;!-- 其他配置 --&gt;&lt;/application&gt;</code></pre><p><strong>使用方式</strong>：</p><pre><code class="java">// 保存数据MyApplication.getInstance(this).setGlobalData(&quot;全局共享内容&quot;);// 读取数据String data = MyApplication.getInstance(this).getGlobalData();</code></pre><h4 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h4><pre><code class="java">public class DataManager &#123;    // 单例实例    private static DataManager instance;    private String sharedData;        // 私有构造方法    private DataManager() &#123;&#125;        // 获取单例    public static synchronized DataManager getInstance() &#123;        if (instance == null) &#123;            instance = new DataManager();        &#125;        return instance;    &#125;        // getter和setter    public String getSharedData() &#123;        return sharedData;    &#125;        public void setSharedData(String data) &#123;        this.sharedData = data;    &#125;&#125;</code></pre><p><strong>使用方式</strong>：</p><pre><code class="java">// 保存数据DataManager.getInstance().setSharedData(&quot;单例共享数据&quot;);// 读取数据String data = DataManager.getInstance().getSharedData();</code></pre><h3 id="四、线程间的数据传递"><a href="#四、线程间的数据传递" class="headerlink" title="四、线程间的数据传递"></a>四、线程间的数据传递</h3><p>子线程向主线程传递数据（更新 UI），主要通过<code>Handler</code>实现。</p><pre><code class="java">public class MainActivity extends AppCompatActivity &#123;    private TextView textView;    // 主线程的Handler    private Handler mainHandler = new Handler(Looper.getMainLooper()) &#123;        @Override        public void handleMessage(@NonNull Message msg) &#123;            super.handleMessage(msg);            // 主线程中处理消息（更新UI）            if (msg.what == 1) &#123;                String result = (String) msg.obj;                textView.setText(result);            &#125;        &#125;    &#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        textView = findViewById(R.id.text_view);                // 启动子线程执行耗时操作        new Thread(() -&gt; &#123;            // 模拟耗时操作            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;                        // 子线程发送数据到主线程            Message message = Message.obtain();            message.what = 1; // 消息标识            message.obj = &quot;子线程处理完成的数据&quot;; // 传递的数据            mainHandler.sendMessage(message);        &#125;).start();    &#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不同场景适合的传递方式：</p><ul><li><strong>组件间临时数据</strong>：优先使用<code>Intent</code> + <code>Bundle</code></li><li><strong>Activity 与 Fragment 通信</strong>：推荐接口回调或<code>ViewModel</code>（Jetpack 组件）</li><li><strong>全局共享数据</strong>：使用自定义<code>Application</code>或单例模式</li><li><strong>线程间通信</strong>：通过<code>Handler</code>或<code>runOnUiThread()</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; 在 Android 开发中，信息传递（数据传递）是组件间通信的核心，常见场景包括 Activity 之间、Activity 与 Fragment 之间、线程之间等。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android异步任务与多线程详解</title>
    <link href="http://example.com/2025/09/10/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/09/10/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-09-10T06:42:48.000Z</published>
    <updated>2025-09-10T07:24:42.732Z</updated>
    
    <content type="html"><![CDATA[<p> 在 Android 开发中，多线程是处理耗时操作（如网络请求、文件读写、复杂计算等）的核心技术，能有效避免主线程（UI 线程）阻塞，保证应用的流畅性。 </p><span id="more"></span><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><h3 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h3><h4 id="1-同步任务（Synchronous）"><a href="#1-同步任务（Synchronous）" class="headerlink" title="1. 同步任务（Synchronous）"></a>1. 同步任务（Synchronous）</h4><ul><li><strong>执行方式</strong>：任务按顺序执行，前一个任务完成后，才会开始下一个任务。</li><li><strong>阻塞特性</strong>：当前线程会被阻塞，等待任务完成后再继续执行后续代码。</li><li><strong>形象比喻</strong>：类似打电话，必须等对方说完，你才能开始说，中间不能做其他事。</li></ul><h4 id="2-异步任务（Asynchronous）"><a href="#2-异步任务（Asynchronous）" class="headerlink" title="2. 异步任务（Asynchronous）"></a>2. 异步任务（Asynchronous）</h4><ul><li><strong>执行方式</strong>：任务启动后，不等待其完成，直接执行后续代码，任务在后台独立运行。</li><li><strong>非阻塞特性</strong>：当前线程不会被阻塞，可以继续处理其他任务。</li><li><strong>结果处理</strong>：任务完成后，通常通过回调（Callback）、事件通知等方式返回结果。</li><li><strong>形象比喻</strong>：类似发邮件，发送后不必等待对方回复，可以继续做其他事，对方回复时会收到通知。</li></ul><h3 id="二、代码示例对比"><a href="#二、代码示例对比" class="headerlink" title="二、代码示例对比"></a>二、代码示例对比</h3><h4 id="1-同步任务示例（Android-中主线程执行耗时操作的错误示范）"><a href="#1-同步任务示例（Android-中主线程执行耗时操作的错误示范）" class="headerlink" title="1. 同步任务示例（Android 中主线程执行耗时操作的错误示范）"></a>1. 同步任务示例（Android 中主线程执行耗时操作的错误示范）</h4><pre><code class="kotlin">// 主线程中执行同步任务（错误示例！会导致ANR）fun syncTask() &#123;    println(&quot;任务1开始&quot;)    // 模拟耗时操作（如网络请求）    Thread.sleep(3000) // 主线程被阻塞3秒    println(&quot;任务1完成&quot;)        println(&quot;任务2开始&quot;) // 必须等任务1完成才执行    Thread.sleep(2000)    println(&quot;任务2完成&quot;)&#125;</code></pre><p><strong>问题</strong>：主线程被阻塞，界面会冻结，超过 5 秒触发 ANR。</p><h4 id="2-异步任务示例（使用-Kotlin-协程）"><a href="#2-异步任务示例（使用-Kotlin-协程）" class="headerlink" title="2. 异步任务示例（使用 Kotlin 协程）"></a>2. 异步任务示例（使用 Kotlin 协程）</h4><pre><code class="kotlin">// 异步执行任务（推荐方式）fun asyncTask() &#123;    println(&quot;主线程继续执行其他操作&quot;)        // 启动异步任务（在IO线程执行）    lifecycleScope.launch(Dispatchers.IO) &#123;        println(&quot;异步任务1开始&quot;)        delay(3000) // 模拟耗时，不阻塞主线程        println(&quot;异步任务1完成&quot;)                // 切换到主线程更新UI        withContext(Dispatchers.Main) &#123;            textView.text = &quot;任务1完成&quot;        &#125;    &#125;        // 无需等待任务1，直接执行后续代码    println(&quot;任务2开始（主线程）&quot;)    // 主线程可以继续处理用户交互等操作&#125;</code></pre><p><strong>特点</strong>：异步任务在后台执行，主线程不阻塞，界面保持流畅。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="一、Android-线程基础"><a href="#一、Android-线程基础" class="headerlink" title="一、Android 线程基础"></a>一、Android 线程基础</h3><ol><li><strong>主线程（UI 线程）</strong><ul><li>负责处理 UI 渲染和用户交互，不能执行耗时操作（超过 5 秒会触发 ANR - Application Not Responding）。</li><li>所有 UI 操作必须在主线程执行，子线程不能直接更新 UI。</li></ul></li><li><strong>子线程（工作线程）</strong><ul><li>用于执行耗时操作，避免阻塞主线程。</li><li>不能直接操作 UI，需通过特定机制通知主线程更新 UI。</li></ul></li></ol><h3 id="二、多线程实现方式"><a href="#二、多线程实现方式" class="headerlink" title="二、多线程实现方式"></a>二、多线程实现方式</h3><h4 id="1-Thread-Handler（传统方式）"><a href="#1-Thread-Handler（传统方式）" class="headerlink" title="1. Thread + Handler（传统方式）"></a>1. Thread + Handler（传统方式）</h4><p>通过<code>Thread</code>执行耗时操作，<code>Handler</code>实现线程间通信（子线程通知主线程更新 UI）。</p><p><strong>示例代码</strong>：</p><pre><code class="kotlin">// 主线程中定义Handler（用于接收子线程消息）private val mHandler = object : Handler(Looper.getMainLooper()) &#123;    override fun handleMessage(msg: Message) &#123;        super.handleMessage(msg)        // 在主线程更新UI        when (msg.what) &#123;            1 -&gt; textView.text = &quot;耗时操作完成&quot;        &#125;    &#125;&#125;// 启动子线程执行耗时操作fun startTask() &#123;    Thread &#123;        // 模拟耗时操作（如网络请求）        Thread.sleep(3000)                // 发送消息到主线程        val msg = Message.obtain()        msg.what = 1 // 消息标识        mHandler.sendMessage(msg)    &#125;.start()&#125;</code></pre><h4 id="2-AsyncTask（已过时，了解即可）"><a href="#2-AsyncTask（已过时，了解即可）" class="headerlink" title="2. AsyncTask（已过时，了解即可）"></a>2. AsyncTask（已过时，了解即可）</h4><p>封装了<code>Thread</code>和<code>Handler</code>，简化异步操作，但在 Android 11 中已被标记为过时，推荐使用<code>Coroutine</code>或<code>Executor</code>替代。</p><p><strong>示例代码</strong>：</p><pre><code class="kotlin">// 泛型参数：Params（输入参数）、Progress（进度）、Result（结果）class MyAsyncTask : AsyncTask&lt;Void, Int, String&gt;() &#123;    // 子线程中执行耗时操作    override fun doInBackground(vararg params: Void?): String &#123;        for (i in 0..100) &#123;            Thread.sleep(50)            publishProgress(i) // 发布进度        &#125;        return &quot;任务完成&quot;    &#125;    // 主线程中更新进度（在publishProgress后调用）    override fun onProgressUpdate(vararg values: Int?) &#123;        super.onProgressUpdate(*values)        progressBar.progress = values[0] ?: 0    &#125;    // 主线程中处理结果（任务完成后调用）    override fun onPostExecute(result: String?) &#123;        super.onPostExecute(result)        textView.text = result    &#125;&#125;// 启动任务MyAsyncTask().execute()</code></pre><h4 id="3-ThreadPoolExecutor（线程池）"><a href="#3-ThreadPoolExecutor（线程池）" class="headerlink" title="3. ThreadPoolExecutor（线程池）"></a>3. ThreadPoolExecutor（线程池）</h4><p>通过线程池管理线程，避免频繁创建 &#x2F; 销毁线程的开销，提高性能。Android 推荐使用<code>Executors</code>工具类创建线程池。</p><p><strong>示例代码</strong>：</p><pre><code class="kotlin">// 创建线程池（核心线程数3，最大线程数5，空闲时间10秒）private val executor = ThreadPoolExecutor(    3, 5, 10, TimeUnit.SECONDS,    LinkedBlockingQueue(),    Executors.defaultThreadFactory(),    ThreadPoolExecutor.AbortPolicy() // 拒绝策略)// 执行任务fun executeTask() &#123;    executor.execute &#123;        // 子线程执行耗时操作        Thread.sleep(3000)                // 切换到主线程更新UI        runOnUiThread &#123;            textView.text = &quot;线程池任务完成&quot;        &#125;    &#125;&#125;// 页面销毁时关闭线程池override fun onDestroy() &#123;    super.onDestroy()    executor.shutdown()&#125;</code></pre><h4 id="4-Kotlin-Coroutine（推荐）"><a href="#4-Kotlin-Coroutine（推荐）" class="headerlink" title="4. Kotlin Coroutine（推荐）"></a>4. Kotlin Coroutine（推荐）</h4><p>Kotlin 协程是轻量级线程，语法简洁，通过<code>Dispatchers</code>指定线程类型，轻松实现线程切换。</p><p><strong>使用步骤</strong>：</p><ol><li>添加依赖（AndroidX 项目默认包含）：</li></ol><pre><code class="gradle">dependencies &#123;    implementation &#39;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4&#39;&#125;</code></pre><ol><li><strong>示例代码</strong>：</li></ol><pre><code class="kotlin">// 启动协程（ lifecycleScope 是AndroidX提供的生命周期感知协程作用域）fun startCoroutineTask() &#123;    lifecycleScope.launch &#123;        // 切换到IO线程执行耗时操作        val result = withContext(Dispatchers.IO) &#123;            // 模拟网络请求            Thread.sleep(3000)            &quot;协程任务结果&quot;        &#125;                // 自动切换回主线程更新UI        textView.text = result    &#125;&#125;</code></pre><p><strong>核心优势</strong>：</p><ul><li>语法简洁，避免回调嵌套（“回调地狱”）。</li><li>自动绑定生命周期（<code>lifecycleScope</code>），防止内存泄漏。</li><li>通过<code>Dispatchers</code>灵活切换线程（<code>Main</code>主线程、<code>IO</code>输入输出、<code>Default</code>计算密集型）。</li></ul><h3 id="三、线程通信核心机制"><a href="#三、线程通信核心机制" class="headerlink" title="三、线程通信核心机制"></a>三、线程通信核心机制</h3><ol><li><p><strong>Handler + Looper + MessageQueue</strong></p><ul><li><code>MessageQueue</code>：消息队列，存储子线程发送的消息。</li><li><code>Looper</code>：循环读取<code>MessageQueue</code>中的消息，分发给对应<code>Handler</code>。</li><li><code>Handler</code>：发送和处理消息，实现线程间通信。</li></ul></li><li><p><strong>runOnUiThread</strong><br>Activity 提供的方法，简化子线程切换到主线程更新 UI：</p><pre><code class="kotlin">Thread &#123;    // 耗时操作    runOnUiThread &#123;        textView.text = &quot;更新UI&quot;    &#125;&#125;.start()</code></pre></li><li><p><strong>View.post()</strong><br>视图提供的方法，将任务 post 到主线程执行：</p><pre><code class="kotlin">textView.post &#123;    textView.text = &quot;主线程更新&quot;&#125;</code></pre></li></ol><h3 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h3><ol><li><strong>避免内存泄漏</strong><ul><li>子线程持有 Activity 引用时，需在页面销毁时停止线程。</li><li>使用<code>lifecycleScope</code>（协程）或<code>WeakReference</code>（弱引用）管理生命周期。</li></ul></li><li><strong>UI 操作限制</strong><ul><li>所有 UI 更新必须在主线程执行，子线程直接操作会抛出异常。</li></ul></li><li><strong>线程池管理</strong><ul><li>避免创建大量线程，优先使用线程池复用线程。</li><li>不再使用时需调用<code>shutdown()</code>关闭线程池。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>简单场景：使用<code>Thread + Handler</code>或<code>View.post()</code>。</li><li>复杂异步任务：推荐<code>Kotlin Coroutine</code>（简洁、安全）。</li><li>多任务并发：使用<code>ThreadPoolExecutor</code>管理线程资源。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt; 在 Android 开发中，多线程是处理耗时操作（如网络请求、文件读写、复杂计算等）的核心技术，能有效避免主线程（UI 线程）阻塞，保证应用的流畅性。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android动画</title>
    <link href="http://example.com/2025/09/10/Android%E5%8A%A8%E7%94%BB/"/>
    <id>http://example.com/2025/09/10/Android%E5%8A%A8%E7%94%BB/</id>
    <published>2025-09-10T03:09:41.000Z</published>
    <updated>2025-09-10T07:34:38.852Z</updated>
    
    <content type="html"><![CDATA[<p> 在 Android Studio 中，常用的动画类型有逐帧动画、补间动画和属性动画，该文将详细介绍 </p><span id="more"></span><h3 id="逐帧动画（frame-by-frame-animation）"><a href="#逐帧动画（frame-by-frame-animation）" class="headerlink" title="逐帧动画（frame-by-frame animation）"></a>逐帧动画（frame-by-frame animation）</h3><ul><li><strong>原理</strong>：通过按顺序连续播放一系列预先定义好的图片（帧），从而形成动画效果，类似于传统的胶片动画 。</li><li><strong>实现方式</strong>：通常使用 XML 资源文件定义。在项目的<code>res/anim/</code>目录下创建 XML 文件，根元素为<code>animation-list</code> ，通过子节点定义每一帧的图片资源以及显示时长。例如：</li></ul><pre><code class="xml">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:oneshot=&quot;false&quot;&gt;    &lt;item        android:drawable=&quot;@drawable/frame1&quot;        android:duration=&quot;100&quot; /&gt;    &lt;item        android:drawable=&quot;@drawable/frame2&quot;        android:duration=&quot;100&quot; /&gt;&lt;/animation-list&gt;</code></pre><p>其中<code>android:oneshot</code>设为<code>false</code>表示循环播放，设为<code>true</code>则只播放一次。在代码中可以这样加载并应用逐帧动画：</p><pre><code class="kotlin">val frameAnimation = AnimationUtils.loadAnimation(context, R.anim.frame_animation)</code></pre><ul><li><strong>应用场景</strong>：适合表现复杂、变化丰富的动画，比如游戏中的角色动作、Loading 动画等。但由于需要准备较多的图片资源，文件体积可能会较大，使用不当会占用较多内存。</li></ul><h3 id="补间动画（tweened-animation）"><a href="#补间动画（tweened-animation）" class="headerlink" title="补间动画（tweened animation）"></a>补间动画（tweened animation）</h3><ul><li><p><strong>原理</strong>：也被称为 View 视图动画，由系统根据两个关键帧定义的起始和结束状态，自动在中间插入额外的帧，生成平滑过渡效果。不过，补间动画只是改变了视图在视觉上的呈现效果，并不会改变视图的实际属性（比如点击事件的响应区域不会因为动画而改变 ），所以不太适合有事件交互的场景。</p></li><li><p>实现方式</p><p>：可以通过 Java 代码或者 XML 文件来实现，定义动画的 XML 文件通常存放在</p><pre><code>res/anim</code></pre><p>目录下，通过</p><pre><code>AnimationUtils#loadAnimation</code></pre><p>加载文件。补间动画可以实现以下几种常见的变换效果：</p><ul><li><strong>平移（Translate）</strong>：改变视图的位置，可通过指定<code>fromXDelta</code>、<code>toXDelta</code> 、<code>fromYDelta</code>、<code>toYDelta</code>等属性来设置在 X 轴和 Y 轴方向上的起始和结束位置。</li><li><strong>缩放（Scale）</strong>：改变视图的尺寸大小，能指定缩放中心点（<code>pivotX</code>、<code>pivotY</code> ）以及 X 和 Y 方向上的缩放比例（<code>fromXScale</code>、<code>toXScale</code>、<code>fromYScale</code>、<code>toYScale</code> ）。</li><li><strong>旋转（Rotate）</strong>：指定旋转中心点（<code>pivotX</code>、<code>pivotY</code> ）以及旋转的起始角度（<code>fromDegrees</code> ）和结束角度（<code>toDegrees</code> ）。</li><li><strong>透明度变化（Alpha）</strong>：控制视图的透明度从一个值变化到另一个值，通过<code>fromAlpha</code>和<code>toAlpha</code>设置起始和结束透明度 。</li></ul></li><li><p>插值器（Interpolator）</p><p>：用于控制动画的播放速度，比如：</p><ul><li><strong>AccelerateDecelerateInterpolator</strong>：先加速后减速，这是默认插值器。</li><li><strong>LinearInterpolator</strong>：线性插值器，使动画匀速播放。</li><li><strong>AccelerateInterpolator</strong>：加速插值器，动画开始时速度较慢，随后逐渐加快。</li><li><strong>DecelerateInterpolator</strong>：减速插值器，动画开始时速度较快，之后逐渐减慢。</li></ul></li><li><p><strong>应用场景</strong>：常用于实现一些简单的界面元素过渡效果，如元素的淡入淡出、位置移动、放大缩小等。</p></li></ul><h3 id="属性动画（property-animation）"><a href="#属性动画（property-animation）" class="headerlink" title="属性动画（property animation）"></a>属性动画（property animation）</h3><ul><li><p><strong>原理</strong>：是一个功能强大的框架，允许对几乎任何对象的属性进行动画操作，可以定义动画在指定时间内改变对象的任意属性值，无论该属性是否会绘制到屏幕上。例如，不仅可以对视图的位置、颜色等属性进行动画处理，还能对自定义对象的属性进行动画变化 。</p></li><li><p>实现方式</p><p>：一般通过</p><pre><code>ObjectAnimator</code></pre><p>或</p><pre><code>ValueAnimator</code></pre><p>来创建属性动画，也可以使用</p><pre><code>AnimatorSet</code></pre><p>将多个动画组合在一起，按一定顺序或同时播放。属性动画系统还可以定义以下特性：</p><ul><li><strong>持续时间（duration）</strong>：可以指定动画的持续时长，默认长度是 300 毫秒。</li><li><strong>时间插值（time interpolation）</strong>：可以选择系统提供的插值器，也能自定义插值器，来指定属性值如何根据动画当前经过的时间进行计算。</li><li><strong>重复次数和行为（repeat count and behavior）</strong>：可以设置动画在到达持续时间结束时是否重复，以及重复的次数，还能指定动画是否反向播放 。</li><li><strong>动画集（animator sets）</strong>：将多个动画组合成逻辑组，这些动画可以一起播放、按顺序播放，或者在指定延迟后播放。</li><li><strong>帧刷新延迟（frame refresh delay）</strong>：指定动画帧刷新的频率，默认设置为每 10 毫秒刷新一次，但实际刷新速度取决于系统的繁忙程度以及底层定时器的服务速度。</li></ul></li><li><p><strong>应用场景</strong>：适用于各种复杂的动画需求，比如动态改变控件的大小、位置、颜色等属性，实现更加流畅和自然的交互效果。同时，在一些自定义视图的动画实现中，属性动画也非常常用。</p></li></ul><h3 id="逐帧动画实例"><a href="#逐帧动画实例" class="headerlink" title="逐帧动画实例"></a>逐帧动画实例</h3><ol><li><strong>创建 XML 文件</strong>：在<code>res/anim</code>目录下创建<code>frame_animation.xml</code>文件，定义逐帧动画。</li></ol><pre><code class="xml">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:oneshot=&quot;false&quot;&gt;    &lt;!-- 假设已经在drawable目录下准备好frame1.png、frame2.png等图片 --&gt;    &lt;item        android:drawable=&quot;@drawable/frame1&quot;        android:duration=&quot;100&quot; /&gt;    &lt;item        android:drawable=&quot;@drawable/frame2&quot;        android:duration=&quot;100&quot; /&gt;&lt;/animation-list&gt;</code></pre><ol><li><strong>在布局文件中添加 ImageView</strong>：在<code>activity_main.xml</code>中添加一个<code>ImageView</code>用于展示逐帧动画。</li></ol><pre><code class="xml">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;ImageView        android:id=&quot;@+id/imageView&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_centerInParent=&quot;true&quot;/&gt;&lt;/RelativeLayout&gt;</code></pre><ol><li><strong>在代码中加载并播放动画</strong>：在<code>MainActivity.kt</code>中加载并播放逐帧动画。</li></ol><pre><code class="kotlin">import android.graphics.drawable.AnimationDrawableimport android.os.Bundleimport androidx.appcompat.app.AppCompatActivityimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        val imageView = imageView        val frameAnimation = imageView.drawable as AnimationDrawable        frameAnimation.start()    &#125;&#125;</code></pre><h3 id="补间动画实例"><a href="#补间动画实例" class="headerlink" title="补间动画实例"></a>补间动画实例</h3><ol><li><strong>创建平移动画的 XML 文件</strong>：在<code>res/anim</code>目录下创建<code>translate_animation.xml</code>文件，定义平移动画。</li></ol><pre><code class="xml">&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:fromXDelta=&quot;0&quot;    android:toXDelta=&quot;300&quot;    android:fromYDelta=&quot;0&quot;    android:toYDelta=&quot;0&quot;    android:duration=&quot;1000&quot;    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;/&gt;</code></pre><ol><li><strong>在布局文件中添加 Button</strong>：在<code>activity_main.xml</code>中添加一个<code>Button</code>，用于触发动画。</li></ol><pre><code class="xml">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;Button        android:id=&quot;@+id/button&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;点击触发动画&quot;        android:layout_centerInParent=&quot;true&quot;/&gt;&lt;/RelativeLayout&gt;</code></pre><ol><li><strong>在代码中加载并播放动画</strong>：在<code>MainActivity.kt</code>中加载并播放补间动画。</li></ol><pre><code class="kotlin">import android.os.Bundleimport android.view.Viewimport android.view.animation.AnimationUtilsimport androidx.appcompat.app.AppCompatActivityimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        button.setOnClickListener &#123;            val animation = AnimationUtils.loadAnimation(this, R.anim.translate_animation)            button.startAnimation(animation)        &#125;    &#125;&#125;</code></pre><h3 id="属性动画实例"><a href="#属性动画实例" class="headerlink" title="属性动画实例"></a>属性动画实例</h3><ol><li><strong>在布局文件中添加 Button</strong>：在<code>activity_main.xml</code>中添加一个<code>Button</code>，用于触发属性动画。</li></ol><pre><code class="xml">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;Button        android:id=&quot;@+id/button&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;点击触发动画&quot;        android:layout_centerInParent=&quot;true&quot;/&gt;&lt;/RelativeLayout&gt;</code></pre><ol><li><strong>在代码中创建并播放属性动画</strong>：在<code>MainActivity.kt</code>中使用<code>ObjectAnimator</code>创建属性动画，实现按钮的缩放效果。</li></ol><pre><code class="kotlin">import android.animation.ObjectAnimatorimport android.os.Bundleimport android.view.Viewimport androidx.appcompat.app.AppCompatActivityimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        button.setOnClickListener &#123;            val scaleXAnimator = ObjectAnimator.ofFloat(button, &quot;scaleX&quot;, 1f, 2f)            val scaleYAnimator = ObjectAnimator.ofFloat(button, &quot;scaleY&quot;, 1f, 2f)            scaleXAnimator.duration = 1000            scaleYAnimator.duration = 1000            val animatorSet = android.animation.AnimatorSet()            animatorSet.play(scaleXAnimator).with(scaleYAnimator)            animatorSet.start()        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt; 在 Android Studio 中，常用的动画类型有逐帧动画、补间动画和属性动画，该文将详细介绍 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>页面展示与交互（进阶）</title>
    <link href="http://example.com/2025/09/06/RecyclerView%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2025/09/06/RecyclerView%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</id>
    <published>2025-09-06T04:25:56.000Z</published>
    <updated>2025-09-06T04:29:00.491Z</updated>
    
    <content type="html"><![CDATA[<p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="仿哔哩哔哩哔哩项目收藏夹的展示与交互设计"><a href="#仿哔哩哔哩哔哩项目收藏夹的展示与交互设计" class="headerlink" title="仿哔哩哔哩哔哩项目收藏夹的展示与交互设计"></a>仿哔哩哔哩哔哩项目收藏夹的展示与交互设计</h1><p>收藏夹的展示与交互是仿哔哩哔哩项目中用户体验的重要组成部分，主要体现在收藏夹列表展示、收藏操作流程和收藏内容管理三个方面。以下从 UI 设计、交互逻辑和核心实现三个维度进行详细说明：</p><h2 id="一、收藏夹的层级展示设计"><a href="#一、收藏夹的层级展示设计" class="headerlink" title="一、收藏夹的层级展示设计"></a>一、收藏夹的层级展示设计</h2><h3 id="1-收藏夹列表页（MyFavoritesActivity）"><a href="#1-收藏夹列表页（MyFavoritesActivity）" class="headerlink" title="1. 收藏夹列表页（MyFavoritesActivity）"></a>1. 收藏夹列表页（MyFavoritesActivity）</h3><p>采用分组式列表展示结构，将收藏夹分为 “默认收藏夹” 和自定义收藏夹两类，通过 RecyclerView 实现多级级列表展示：</p><pre><code class="java">// 构建收藏夹与视频的映射关系folderMap = new HashMap&lt;&gt;();List&lt;FavoriteData&gt; defaultFolderFavorites = new ArrayList&lt;&gt;();for (FavoriteData favorite : favorites) &#123;    if (favorite.getFolderName().equals(DEFAULT_FOLDER_NAME)) &#123;        defaultFolderFavorites.add(favorite);    &#125;&#125;folderMap.put(DEFAULT_FOLDER_NAME, defaultFolderFavorites);</code></pre><p>界面布局采用自定义 RecyclerView 适配器，通过多类型视图区分不同的展示元素：</p><ul><li>头部视图（TYPE_HEADER）：展示默认收藏夹</li><li>内容项（TYPE_ITEM）：展示收藏的视频缩略图</li><li>自定义收藏夹（TYPE_CREATED_FOLDERS）：展示用户创建的收藏夹</li></ul><h3 id="2-收藏夹详情页（FolderActivity）"><a href="#2-收藏夹详情页（FolderActivity）" class="headerlink" title="2. 收藏夹详情页（FolderActivity）"></a>2. 收藏夹详情页（FolderActivity）</h3><p>单收藏夹内容展示采用采用 “标题栏 + 功能区 + 视频列表” 的布局结构：</p><ul><li>顶部显示收藏夹名称和返回按钮</li><li>支持设置收藏夹封面图（相机拍摄或相册选择）</li><li>列表展示该收藏夹下所有视频，点击可跳转至视频播放页</li></ul><p>核心代码实现：</p><pre><code class="java">// 加载收藏夹封面图String coverPath = databaseHelper.getFolderCover(folderName);if (coverPath != null &amp;&amp; !coverPath.isEmpty()) &#123;    setPicture.setVisibility(View.VISIBLE);    // 区分封面类型：路径（相机图）/ Uri字符串（相册图）    if (coverPath.startsWith(&quot;/&quot;)) &#123;        // 相机图：通过路径加载图片（压缩避免OOM）        Bitmap compressedBitmap = decodeCompressedBitmap(coverPath, 80, 80);        setPicture.setImageBitmap(compressedBitmap);    &#125; else if (coverPath.startsWith(&quot;content://&quot;)) &#123;        // 相册图：通过Uri加载        Uri coverUri = Uri.parse(coverPath.split(&quot;\\|&quot;)[0]);        setPicture.setImageURI(coverUri);    &#125;&#125;</code></pre><h2 id="二、核心交互流程"><a href="#二、核心交互流程" class="headerlink" title="二、核心交互流程"></a>二、核心交互流程</h2><h3 id="1-视频收藏操作流程"><a href="#1-视频收藏操作流程" class="headerlink" title="1. 视频收藏操作流程"></a>1. 视频收藏操作流程</h3><p><strong>触发入口</strong>：视频详情页的收藏按钮（item_video_function.xml 中的 collect ImageView）</p><p><strong>交互流程</strong>：</p><ol><li>点击收藏按钮，弹出底部夹弹窗（FavoriteDialogFragment）</li><li>弹窗展示现有有收藏夹列表，支持创建新收藏夹</li><li>选择目标收藏夹后，通过数据库 DatabaseHelper 将视频添加到对应收藏夹</li><li>收藏成功后实时新 UI 状态，更新收藏按钮样式</li></ol><p>弹窗交互核心代码：</p><pre><code class="java">saveFavoriteButton.setOnClickListener(v -&gt; &#123;    FavoriteDialogDialogFragment dialog = new FavoriteDialogFragment(currentVideoData);    dialog.show(getSupportFragmentManager(), &quot;favorite_dialog&quot;);    // 监听收藏结果    getSupportFragmentManager().setFragmentResultListener(&quot;request_key&quot;, this,         (requestKey, result) -&gt; &#123;            String folderName = result.getString(&quot;selected_folder_name&quot;);            if (folderName != null) &#123;                // 更新UI显示收藏状态                updateFavoriteButtonState(true);            &#125;        &#125;);&#125;);</code></pre><h3 id="2-收藏夹管理交互"><a href="#2-收藏夹管理交互" class="headerlink" title="2. 收藏夹管理交互"></a>2. 收藏夹管理交互</h3><p><strong>创建收藏夹</strong>：</p><ul><li>通过 MyFavoritesActivity 中的 “创建收藏夹” 按钮触发</li><li>跳转至 CreateFolderActivity 输入收藏夹名称</li><li>创建成功后自动新收藏夹列表</li></ul><p><strong>删除收藏夹</strong>：</p><ul><li>长按收藏夹或点击更多按钮弹出删除确认</li><li>通过 FolderMoreDialogFragment 实现删除确认交互</li><li>删除时同步删除该收藏夹下所有视频</li></ul><pre><code class="java">folderMoreDialogFragment.setListener(new FolderMoreDialogFragment.OnDeleteButtonClickListener() &#123;    @Override    public void onDeleteButtonClick() &#123;        databaseHelperHelper.deleteFolder(folderName);        updateFavoriteList(); // 刷新列表        folderMoreDialogFragment.dismiss();    &#125;&#125;);</code></pre><p><strong>收藏夹封面设置</strong>：</p><ul><li>支持从相机拍摄或相册选择图片作为封面</li><li>通过图片压缩处理避免 OOM：</li></ul><pre><code class="java">private Bitmap private decodeCompressedBitmap(String imagePath, int reqWidthDp, int reqHeightDp) &#123;    int reqWidth = dp2px(reqWidthDp);    int reqHeight = dp2px(reqHeightDp);        // 先获取图片原始尺寸（不加载完整图片）    BitmapFactory.Options options = new BitmapFactory.Options();    options.inJustDecodeBounds = true;    BitmapFactory.decodeFile(imagePath, options);        // 计算压缩比例    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);        // 加载压缩后的图片    options.inJustDecodeBounds = false;    return BitmapFactoryFactory.decodeFile(imagePath, options);&#125;</code></pre><h2 id="三、UI-组件与交互细节"><a href="#三、UI-组件与交互细节" class="headerlink" title="三、UI 组件与交互细节"></a>三、UI 组件与交互细节</h2><h3 id="1-底部弹窗（FavoriteDialogFragment）"><a href="#1-底部弹窗（FavoriteDialogFragment）" class="headerlink" title="1. 底部弹窗（FavoriteDialogFragment）"></a>1. 底部弹窗（FavoriteDialogFragment）</h3><p>采用 BottomSheetDialogFragment 实现，支持：</p><ul><li>上下滑动关闭</li><li>收藏夹列表选择</li><li>新建收藏夹创建入口</li></ul><p>滑动关闭实现：</p><pre><code class="java">View dragHandle = view.findViewById(R.id.drag_handle);dragHandle.setOnTouchListener(new SwipeDismissTouchListener(dragHandle, null,     new SwipeDismissTouchListener.OnDismissCallback() &#123;        @Override        public void onDismiss(View view) &#123;            dismiss();        &#125;    &#125;));</code></pre><h3 id="2-收藏状态视觉反馈"><a href="#2-收藏状态视觉反馈" class="headerlink" title="2. 收藏状态视觉反馈"></a>2. 收藏状态视觉反馈</h3><ul><li>未收藏状态：显示灰色收藏图标</li><li>已收藏状态：显示红色填充图标</li><li>收藏数量实时更新（item_video_function.xml 中的 collect_text）</li></ul><h3 id="3-空状态处理"><a href="#3-空状态处理" class="headerlink" title="3. 空状态处理"></a>3. 空状态处理</h3><p>当收藏夹为空时，通过 FavoritesAdapter 控制列表展示：</p><pre><code class="java">@Overridepublic int getItemCount() &#123;    if (favorites.size() == 0) &#123;        return 0; // 不显示任何内容或显示空状态提示    &#125; else &#123;        return favorites.size() + 1; // +1 用于显示功能区    &#125;&#125;</code></pre><h2 id="四、数据流转与状态同步"><a href="#四、数据流转与状态同步" class="headerlink" title="四、数据流转与状态同步"></a>四、数据流转与状态同步</h2><ol><li><strong>收藏状态同步</strong>：<ul><li>视频详情页通过<code>isFavoriteExists()</code>方法检查收藏状态</li><li>收藏 &#x2F; 取消收藏操作后通过接口回调更新 UI</li></ul></li><li><strong>列表刷新机制</strong>：<ul><li>所有收藏操作后调用<code>updateFavoriteList()</code>刷新列表</li><li>使用<code>notifyDataSetChanged()</code>更新适配器数据</li></ul></li><li><strong>跨页面数据传递</strong>：<ul><li>通过 Intent 传递收藏夹名称和视频 ID</li><li>使用 ActivityResultLauncher 处理封面设置等交互结果</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>自定义视频播放界面</title>
    <link href="http://example.com/2025/09/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E7%95%8C%E9%9D%A2/"/>
    <id>http://example.com/2025/09/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E7%95%8C%E9%9D%A2/</id>
    <published>2025-09-06T04:16:43.000Z</published>
    <updated>2025-09-06T08:22:32.641Z</updated>
    
    <content type="html"><![CDATA[<p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="VideoActivity-的视频播放设计详解"><a href="#VideoActivity-的视频播放设计详解" class="headerlink" title="VideoActivity 的视频播放设计详解"></a>VideoActivity 的视频播放设计详解</h1><p>VideoActivity 是仿哔哩哔哩项目中负责视频详情展示与播放控制的核心组件，其设计围绕视频播放体验优化，实现了完整的播放控制功能。以下是具体设计细节：</p><h2 id="一、核心功能架构"><a href="#一、核心功能架构" class="headerlink" title="一、核心功能架构"></a>一、核心功能架构</h2><p>VideoActivity 主要实现了四大核心功能模块：</p><ul><li>视频播放控制（播放 &#x2F; 暂停、进度调整）</li><li>全屏切换与状态保持</li><li>控制栏交互（自动隐藏 &#x2F; 显示）</li><li>推荐视频列表展示</li></ul><p>核心组件关系：</p><pre><code class="plaintext">VideoActivity├── VideoView（视频播放核心）├── 控制栏组件（顶部+底部）│   ├── 播放/暂停按钮│   ├── 进度条（SeekBar）│   ├── 时间显示（TextView）│   └── 全屏切换按钮├── Handler（进度更新与UI控制）└── RecyclerView（推荐视频列表）</code></pre><h2 id="二、布局设计（activity-video-xml）"><a href="#二、布局设计（activity-video-xml）" class="headerlink" title="二、布局设计（activity_video.xml）"></a>二、布局设计（activity_video.xml）</h2><p>采用 LinearLayout 作为根布局，分为视频播放区和推荐列表区两部分：</p><ol><li><strong>视频播放区</strong>：<ul><li>使用 ConstraintLayout 实现视频容器，包含 VideoView 和控制栏</li><li>顶部控制栏（videoTopController）：返回按钮和主页跳转按钮，背景使用渐变透明效果</li><li>底部控制栏（videoBottomController）：播放 &#x2F; 暂停按钮、进度条、时间显示和全屏按钮</li></ul></li><li><strong>布局关键代码</strong>：</li></ol><pre><code class="xml">&lt;!-- 视频播放核心组件 --&gt;&lt;VideoView    android:id=&quot;@+id/video&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintEnd_toEndOf=&quot;parent&quot;    app:layout_constraintStart_toStartOf=&quot;parent&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    android:clickable=&quot;true&quot;/&gt;&lt;!-- 底部控制栏 --&gt;&lt;LinearLayout    android:id=&quot;@+id/videoBottomController&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintBottom_toBottomOf=&quot;@id/video&quot;    android:background=&quot;@drawable/gradient_transparent&quot;    android:visibility=&quot;gone&quot;&gt;        &lt;ImageView        android:id=&quot;@+id/pause_or_start&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_weight=&quot;148&quot;        android:src=&quot;@drawable/start&quot;/&gt;    &lt;LinearLayout        android:id=&quot;@+id/schedule&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;match_parent&quot;        android:layout_weight=&quot;812&quot;&gt;                &lt;SeekBar            android:id=&quot;@+id/seek_bar&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_weight=&quot;540&quot;            android:progressDrawable=&quot;@drawable/custom_seekbar&quot;            android:thumb=&quot;@drawable/custom_cursor&quot;/&gt;        &lt;TextView            android:id=&quot;@id/video_time&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot;            android:layout_weight=&quot;272&quot;            android:textColor=&quot;@color/white&quot;/&gt;    &lt;/LinearLayout&gt;    &lt;ImageView        android:id=&quot;@+id/full_screen&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_weight=&quot;300&quot;        android:src=&quot;@drawable/full_screen&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="三、核心播放逻辑实现"><a href="#三、核心播放逻辑实现" class="headerlink" title="三、核心播放逻辑实现"></a>三、核心播放逻辑实现</h2><h3 id="1-视频初始化流程"><a href="#1-视频初始化流程" class="headerlink" title="1. 视频初始化流程"></a>1. 视频初始化流程</h3><pre><code class="java">private void initVideoPlayLogic() &#123;    // 设置视频源（默认使用raw目录下的视频）    Uri videoUri = Uri.parse(&quot;android.resource://&quot; + getPackageName() + &quot;/&quot; + R.raw.video);    videoView.setVideoURI(videoUri);    videoView.setMediaController(null); // 禁用系统默认控制器    videoView.requestFocus();    videoView.start();    btnPlayPause.setImageResource(R.drawable.pause);    // 视频准备完成监听    videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123;        @Override        public void onPrepared(MediaPlayer mp) &#123;            totalDuration = mp.getDuration(); // 获取总时长            seekBar.setMax(totalDuration);            startProgressUpdate(); // 启动进度更新            videoTime.setText(convertTime(0));        &#125;    &#125;);    // 播放完成监听    videoView.setOnCompletionListener(mp -&gt; &#123;        seekBar.setProgress(0);        videoTime.setText(convertTime(0));        btnPlayPause.setImageResource(R.drawable.start);        stopProgressUpdate();    &#125;);&#125;</code></pre><h3 id="2-进度更新机制"><a href="#2-进度更新机制" class="headerlink" title="2. 进度更新机制"></a>2. 进度更新机制</h3><p>使用 Handler 实现每秒更新一次进度：</p><pre><code class="java">private void initRunnables() &#123;    // 进度更新Runnable    progressRunnable = new Runnable() &#123;        @Override        public void run() &#123;            if (!isFinishing() &amp;&amp; !isDragging) &#123;                int currentPosition = videoView.getCurrentPosition();                seekBar.setProgress(currentPosition);                videoTime.setText(convertTime(currentPosition));                handler.postDelayed(this, 1000); // 每秒更新一次            &#125;        &#125;    &#125;;    // 控制栏自动隐藏Runnable    controlHideRunnable = new Runnable() &#123;        @Override        public void run() &#123;            if (isControlVisible &amp;&amp; !isFinishing() &amp;&amp; !isDragging) &#123;                topController.setVisibility(View.GONE);                bottomController.setVisibility(View.GONE);                isControlVisible = false;            &#125;        &#125;    &#125;;&#125;</code></pre><h3 id="3-进度条拖动处理"><a href="#3-进度条拖动处理" class="headerlink" title="3. 进度条拖动处理"></a>3. 进度条拖动处理</h3><p>解决进度条拖动与视频同步问题：</p><pre><code class="java">seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123;    @Override    public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123;        if (fromUser &amp;&amp; isDragging) &#123;            videoView.seekTo(progress);            // 延迟更新时间显示，确保跳转完成            handler.postDelayed(() -&gt; &#123;                int actualPosition = videoView.getCurrentPosition();                videoTime.setText(convertTime(actualPosition));            &#125;, 50);        &#125;    &#125;    @Override    public void onStartTrackingTouch(SeekBar seekBar) &#123;        isDragging = true;        wasPlayingBeforeDrag = videoView.isPlaying();        videoView.pause(); // 拖动时暂停播放        stopProgressUpdate();        refreshControlHideTime(); // 延长控制栏显示时间    &#125;    @Override    public void onStopTrackingTouch(SeekBar seekBar) &#123;        isDragging = false;        // 延迟获取实际位置，确保seekTo完成        handler.postDelayed(() -&gt; &#123;            int finalActualPosition = videoView.getCurrentPosition();            seekBar.setProgress(finalActualPosition);            videoTime.setText(convertTime(finalActualPosition));        &#125;, 100);        // 恢复播放状态        if (wasPlayingBeforeDrag) &#123;            videoView.start();            btnPlayPause.setImageResource(R.drawable.pause);        &#125; else &#123;            btnPlayPause.setImageResource(R.drawable.start);        &#125;        startProgressUpdate();        refreshControlHideTime();    &#125;&#125;);</code></pre><h2 id="四、全屏切换功能"><a href="#四、全屏切换功能" class="headerlink" title="四、全屏切换功能"></a>四、全屏切换功能</h2><p>实现 VideoActivity 与 FullScreenActivity 之间的无缝切换：</p><h3 id="1-跳转至全屏"><a href="#1-跳转至全屏" class="headerlink" title="1. 跳转至全屏"></a>1. 跳转至全屏</h3><pre><code class="java">// 全屏按钮点击事件btnFullScreen.setOnClickListener(v -&gt; &#123;    Intent intent = new Intent(VideoActivity.this, FullScreenActivity.class);    // 传递当前播放状态    intent.putExtra(&quot;current_position&quot;, videoView.getCurrentPosition());    intent.putExtra(&quot;is_playing&quot;, videoView.isPlaying());    intent.putExtra(&quot;video_path&quot;, getVideoPath()); // 传递视频路径    fullScreenResultLauncher.launch(intent);&#125;);</code></pre><h3 id="2-从全屏返回恢复状态"><a href="#2-从全屏返回恢复状态" class="headerlink" title="2. 从全屏返回恢复状态"></a>2. 从全屏返回恢复状态</h3><pre><code class="java">private void initFullScreenResultLauncher() &#123;    fullScreenResultLauncher = registerForActivityResult(            new ActivityResultContracts.StartActivityForResult(),            new ActivityResultCallback&lt;ActivityResult&gt;() &#123;                @Override                public void onActivityResult(ActivityResult result) &#123;                    if (result.getResultCode() == RESULT_OK &amp;&amp; result.getData() != null) &#123;                        Intent data = result.getData();                        int returnPosition = data.getIntExtra(&quot;current_position&quot;, 0);                        boolean returnIsPlaying = data.getBooleanExtra(&quot;is_playing&quot;, false);                        restoreVideoState(returnPosition, returnIsPlaying);                    &#125;                &#125;            &#125;    );&#125;// 恢复视频播放状态private void restoreVideoState(int targetPosition, boolean isPlaying) &#123;    if (videoView != null &amp;&amp; totalDuration &gt; 0) &#123;        stopProgressUpdate();        videoView.seekTo(targetPosition);                if (isPlaying) &#123;            videoView.start();            btnPlayPause.setImageResource(R.drawable.pause);            startProgressUpdate();        &#125; else &#123;            videoView.pause();            btnPlayPause.setImageResource(R.drawable.start);        &#125;                seekBar.setProgress(targetPosition);        videoTime.setText(convertTime(targetPosition));        if (!isControlVisible) &#123;            toggleControlVisibility(); // 显示控制栏        &#125;    &#125;&#125;</code></pre><h2 id="五、控制栏交互设计"><a href="#五、控制栏交互设计" class="headerlink" title="五、控制栏交互设计"></a>五、控制栏交互设计</h2><ol><li><strong>触摸显示 &#x2F; 隐藏控制栏</strong>：</li></ol><pre><code class="java">videoView.setOnTouchListener(new View.OnTouchListener() &#123;    @Override    public boolean onTouch(View v, MotionEvent event) &#123;        if (event.getAction() == MotionEvent.ACTION_UP) &#123;            toggleControlVisibility(); // 切换控制栏可见性            return true;        &#125;        return false;    &#125;&#125;);</code></pre><ol><li><strong>自动隐藏逻辑</strong>：</li></ol><pre><code class="java">private void startControlHideTimer() &#123;    handler.removeCallbacks(controlHideRunnable);    handler.postDelayed(controlHideRunnable, 3000); // 3秒后自动隐藏&#125;private void refreshControlHideTime() &#123;    handler.removeCallbacks(controlHideRunnable);    handler.postDelayed(controlHideRunnable, 3000); // 刷新隐藏倒计时&#125;</code></pre><h2 id="六、时间格式转换工具"><a href="#六、时间格式转换工具" class="headerlink" title="六、时间格式转换工具"></a>六、时间格式转换工具</h2><p>将毫秒转换为 “分：秒 &#x2F; 总时长” 格式：</p><pre><code class="java">private String convertTime(int currentTimeMs) &#123;    if (totalDuration &lt;= 0) return &quot;00:00/00:00&quot;;    int currentSec = currentTimeMs / 1000;    int currentMin = currentSec / 60;    currentSec = currentSec % 60;    int totalSec = totalDuration / 1000;    int totalMin = totalSec / 60;    totalSec = totalSec % 60;    return String.format(&quot;%02d:%02d/%02d:%02d&quot;, currentMin, currentSec, totalMin, totalSec);&#125;</code></pre><h2 id="七、关键技术亮点"><a href="#七、关键技术亮点" class="headerlink" title="七、关键技术亮点"></a>七、关键技术亮点</h2><ol><li><strong>状态保持机制</strong>：通过 Intent 传递播放进度和状态，实现全屏切换时的无缝衔接</li><li><strong>进度同步优化</strong>：使用延迟更新解决 SeekBar 拖动与视频实际进度不同步问题</li><li><strong>用户体验优化</strong>：控制栏自动隐藏 &#x2F; 显示，触摸交互响应及时</li><li><strong>模块化设计</strong>：将初始化、播放逻辑、控制逻辑分离，便于维护</li></ol><h1 id="FullScreenActivity-视频播放设计详解"><a href="#FullScreenActivity-视频播放设计详解" class="headerlink" title="FullScreenActivity 视频播放设计详解"></a>FullScreenActivity 视频播放设计详解</h1><p>FullScreenActivity 是仿哔哩哔哩项目中负责负责视频全屏播放的核心组件，专注于提供沉浸式视频观看体验，其设计围绕全屏场景下的播放控制优化，实现了与竖屏播放状态的无缝衔接。</p><h2 id="一、核心功能定位"><a href="#一、核心功能定位" class="headerlink" title="一、核心功能定位"></a>一、核心功能定位</h2><p>FullScreenActivity 作为 VideoActivity 的补充，主要解决以下核心问题：</p><ul><li>提供沉浸式全屏播放体验</li><li>保持与竖屏播放状态的完全同步（进度、播放状态）</li><li>优化横屏场景下的控制栏布局与交互</li><li>解决全屏 &#x2F; 窗口模式切换时的状态一致性问题</li></ul><h2 id="二、布局设计（activity-full-screen-xml）"><a href="#二、布局设计（activity-full-screen-xml）" class="headerlink" title="二、布局设计（activity_full_screen.xml）"></a>二、布局设计（activity_full_screen.xml）</h2><p>采用 ConstraintLayout 作为根布局，专为横屏优化：</p><ol><li><strong>视频播放区</strong>：<ul><li>VideoView 占据整个屏幕空间，确保全屏显示</li><li>背景设置为黑色，消除边缘色差</li></ul></li><li><strong>控制栏设计</strong>：<ul><li>顶部控制栏（top_controller）：仅保留返回按钮，最小化干扰</li><li>底部控制栏（bottom_controller）：包含播放 &#x2F; 暂停按钮、进度条、时间显示</li><li>控制栏背景使用渐变透明效果，既影响视频内容观看</li></ul></li></ol><pre><code class="xml">&lt;!-- 全屏视频核心布局 --&gt;&lt;VideoView    android:id=&quot;@+id/videoView&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;match_parent&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;    app:layout_constraintEnd_toEndOf=&quot;parent&quot;    app:layout_constraintStart_toStartOf=&quot;parent&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    android:clickable=&quot;true&quot;/&gt;&lt;!-- 底部控制栏 --&gt;&lt;LinearLayout    android:id=&quot;@+id/bottom_controller&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;    android:background=&quot;@drawable/gradient_transparent&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;TextView        android:id=&quot;@+id/video_time&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:textColor=&quot;@color/white&quot;        android:textSize=&quot;12dp&quot;/&gt;    &lt;SeekBar        android:id=&quot;@+id/seek_bar&quot;        android:layout_width=&quot;match_parent&quot;        android:progressDrawable=&quot;@drawable/custom_seekbar&quot;        android:thumb=&quot;@drawable/custom_cursor2&quot;/&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;horizontal&quot;&gt;        &lt;ImageView            android:id=&quot;@+id/play_or_pause&quot;            android:layout_width=&quot;0dp&quot;            android:layout_weight=&quot;460&quot;            android:src=&quot;@drawable/video_controller_bottom_left_pause&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="三、核心播放逻辑实现-1"><a href="#三、核心播放逻辑实现-1" class="headerlink" title="三、核心播放逻辑实现"></a>三、核心播放逻辑实现</h2><h3 id="1-状态传递与初始化"><a href="#1-状态传递与初始化" class="headerlink" title="1. 状态传递与初始化"></a>1. 状态传递与初始化</h3><p>全屏 Activity 通过 Intent 接收来自 VideoActivity 的播放状态：</p><pre><code class="java">private void getVideoStateFromIntent() &#123;    Intent intent = getIntent();    currentPosition = intent.getIntExtra(&quot;current_position&quot;, 0);    isPlaying = intent.getBooleanExtra(&quot;is_playing&quot;, false);    videoPath = intent.getStringExtra(&quot;video_path&quot;);&#125;</code></pre><p>初始化时恢复播放状态：</p><pre><code class="java">videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123;    @Override    public void onPrepared(MediaPlayer mp) &#123;        // 设置seek完成监听，解决进度同步问题        mp.setOnSeekCompleteListener(mp1 -&gt; &#123;            int newPos = videoView.getCurrentPosition();            seekBar.setProgress(newPos);            videoTime.setText(convertTime(newPos));        &#125;);        totalDuration = mp.getDuration();        seekBar.setMax(totalDuration);        videoView.seekTo(currentPosition); // 恢复到竖屏时的进度        // 恢复播放状态        if (isPlaying) &#123;            videoView.start();            playOrPause.setImageResource(R.drawable.video_controller_controller_bottom_left_pause);            startProgressUpdate();        &#125; else &#123;            playOrPause.setImageResource(R.drawable.video_controller_bottom_left_play);        &#125;    &#125;&#125;);</code></pre><h3 id="2-进度同步优化"><a href="#2-进度同步优化" class="headerlink" title="2. 进度同步优化"></a>2. 进度同步优化</h3><p>针对视频 seek 操作延迟问题，引入目标位置跟踪机制：</p><pre><code class="java">// 进度更新Runnable优化progressRunnable = new Runnable() &#123;    @Override    public void run() &#123;        if (!isFinishing() &amp;&amp; !isDragging) &#123;            int currentPos = videoView.getCurrentPosition();            // 处理seek操作的进度同步            if (targetSeekPosition != -1) &#123;                // 当实际位置接近目标位置时，视为seek完成                if (Math.abs.abs(currentPos - targetSeekPosition) &lt; 500) &#123;                    targetSeekPosition = -1;                &#125;            &#125;            seekBar.setProgress(currentPos);            videoTime.setText(convertTime(currentPos));            handler.postDelayed(this, 1000);        &#125;    &#125;&#125;;</code></pre><h3 id="3-进度条拖动处理-1"><a href="#3-进度条拖动处理-1" class="headerlink" title="3. 进度条拖动处理"></a>3. 进度条拖动处理</h3><p>优化拖动体验，避免 UI 与实际进度不同步：</p><pre><code class="java">seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123;    @Override    public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123;        if (fromUser &amp;&amp; isDragging) &#123;            // 拖动时先更新时间显示，不立即同步到视频            videoTime.setText(convertTime(progress));            targetSeekPosition = progress; // 记录目标位置        &#125;    &#125;    @Override    public void onStartTrackingTouch(SeekBar seekBar) &#123;        isDragging = true;        wasPlayingBeforeDrag = videoView.isPlaying();        videoView.pause(); // 拖动时暂停        stopProgressUpdate();    &#125;    @Override    public void onStopTrackingTouch(SeekBar seekBar) &#123;        isDragging = false;        // 执行seek操作，等待完成后更新UI        if (targetSeekPosition != -1) &#123;            videoView.seekTo(targetSeekPosition);        &#125;        // 恢复播放状态        if (wasPlayingBeforeDrag) &#123;            videoView.start();            startProgressUpdate();        &#125;    &#125;&#125;);</code></pre><h2 id="四、控制栏交互设计"><a href="#四、控制栏交互设计" class="headerlink" title="四、控制栏交互设计"></a>四、控制栏交互设计</h2><ol><li><strong>自动隐藏机制</strong>：</li></ol><pre><code class="java">controlHideRunnable = new Runnable() &#123;    @Override    public void run() &#123;        if (isControlVisible &amp;&amp; !isFinishing() &amp;&amp; !isDragging &amp;&amp; videoView.isPlaying()) &#123;            hideControls(); // 播放状态下自动隐藏控制栏        &#125;    &#125;&#125;;</code></pre><ol><li><strong>触摸交互</strong>：</li></ol><pre><code class="java">videoView.setOnTouchListener(new View.OnTouchListener() &#123;    private long lastTouchTime = 0;    private static final long DOUBLE_TAP_THRESHOLD = 300;    @Override    public boolean onTouch(View v, MotionEvent event) &#123;        if (event.getAction() == MotionEvent.ACTION_UP) &#123;            long currentTime = System.currentTimeMillis();            // 处理双击事件（预留扩展）            if (currentTime - lastTouchTime &lt; DOUBLE_TAP_THRESHOLD) &#123;                lastTouchTime = 0;                return true;            &#125;            lastTouchTime = currentTime;                        toggleControlVisibility(); // 单击切换控制栏显示状态            return true;        &#125;        return false;    &#125;&#125;);</code></pre><h2 id="五、返回竖屏状态处理"><a href="#五、返回竖屏状态处理" class="headerlink" title="五、返回竖屏状态处理"></a>五、返回竖屏状态处理</h2><p>实现全屏到窗口模式的无缝切换：</p><pre><code class="java">private void returnToVideoActivity() &#123;    // 准备返回数据    Intent intent = new Intent();    intent.putExtra(&quot;current_position&quot;, videoView.getCurrentPosition());    intent.putExtra(&quot;is_playing&quot;, videoView.isPlaying());    setResult(RESULT_OK, intent);    finish();    // 添加转场动画    overridePendingTransition(R.anim.fade_in, R.anim.fade_out);&#125;</code></pre><h2 id="六、技术亮点"><a href="#六、技术亮点" class="headerlink" title="六、技术亮点"></a>六、技术亮点</h2><ol><li><strong>状态无缝衔接</strong>：通过 Intent 精确传递播放进度和状态，实现两种模式平滑切换</li><li><strong>进度同步优化</strong>：使用目标位置跟踪和 seek 完成监听，解决视频进度更新延迟问题</li><li><strong>沉浸式体验</strong>：隐藏系统 UI，控制栏自动隐藏，最大化视频观看区域</li><li><strong>交互一致性</strong>：保持与竖屏模式相同的操作逻辑，降低用户学习成本</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>相机和相册的对接</title>
    <link href="http://example.com/2025/09/06/%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9B%B8%E5%86%8C%E7%9A%84%E5%AF%B9%E6%8E%A5/"/>
    <id>http://example.com/2025/09/06/%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9B%B8%E5%86%8C%E7%9A%84%E5%AF%B9%E6%8E%A5/</id>
    <published>2025-09-06T04:13:07.000Z</published>
    <updated>2025-09-06T08:22:39.032Z</updated>
    
    <content type="html"><![CDATA[<p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="照相和相册的-API-对接实现详解"><a href="#照相和相册的-API-对接实现详解" class="headerlink" title="照相和相册的 API 对接实现详解"></a>照相和相册的 API 对接实现详解</h1><p>在仿哔哩哔哩项目中，用户可以通过相机拍摄或从相册选择图片来设置收藏夹封面，这一功能主要通过 Android 系统提供的相机和相册 API 实现，核心代码集中在<code>CreateFolderActivity</code>中。以下是具体实现细节：</p><h2 id="一、权限配置"><a href="#一、权限配置" class="headerlink" title="一、权限配置"></a>一、权限配置</h2><p>使用相机和相册功能需要在AndroidManifest.xml中声明相关权限：</p><pre><code class="xml">&lt;!-- 相机权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&lt;!-- 存储权限（针对Android 10以下） --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 声明明显式使用相机硬件 --&gt;&lt;uses-feature    android:name=&quot;android.hardware.camera&quot;    android:required=&quot;true&quot; /&gt;</code></pre><p>同时在<code>application</code>标签中添加文件提供者配置，用于安全地共享相机拍摄的图片：</p><pre><code class="xml">&lt;application ...&gt;    &lt;!-- 文件提供者配置，用于相机照片的安全访问 --&gt;    &lt;provider        android:name=&quot;androidx.core.content.FileProvider&quot;        android:authorities=&quot;com.naojianghh.bilibili3&quot;        android:exported=&quot;false&quot;        android:grantUriPermissions=&quot;true&quot;&gt;        &lt;meta-data            android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;            android:resource=&quot;@xml/file_paths&quot; /&gt;    &lt;/provider&gt;&lt;/application&gt;</code></pre><h2 id="二、UI-交互入口"><a href="#二、UI-交互入口" class="headerlink" title="二、UI 交互入口"></a>二、UI 交互入口</h2><p>通过底部弹窗 (<code>BottomSheetDialog</code>) 提供相机和相册选择入口，布局文件为dialog_picture.xml：</p><pre><code class="xml">&lt;!-- 相机选择按钮 --&gt;&lt;Button    android:id=&quot;@+id/btn_camera&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;60dp&quot;    android:backgroundTint=&quot;@android:color/transparent&quot;    android:text=&quot;拍照&quot;    android:textColor=&quot;@color/black&quot;    android:textSize=&quot;16sp&quot;    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;    app:layout_constraintTop_toBottomOf=&quot;@+id/btn_gallery&quot;/&gt;&lt;!-- 相册选择按钮 --&gt;&lt;Button    android:id=&quot;@+id/btn_gallery&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;60dp&quot;    android:backgroundTint=&quot;@android:color/transparent&quot;    android:text=&quot;从相册选择&quot;    android:textColor=&quot;@color/black&quot;    android:textSize=&quot;16sp&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot;    app:layout_constraintBottom_toTopOf=&quot;@+id/btn_camera&quot;/&gt;</code></pre><p>在<code>CreateFolderActivity</code>中初始化弹窗并设置点击事件：</p><pre><code class="java">private void showImagePickerBottomSheet() &#123;    // 初始化BottomSheetDialog    bottomSheetDialog = new BottomSheetDialog(this);    // 加载布局    View view = LayoutInflater.from(this).inflate(R.layout.dialog_picture, null);    bottomSheetDialog.setContentView(view);    // 相机按钮点击事件    view.findViewById(R.id.btn_camera).setOnClickListener(v -&gt; &#123;        checkPermissionsAndOpenCamera(); // 检查权限后打开相机        bottomSheetDialog.dismiss();    &#125;);    // 相册按钮点击事件    view.findViewById(R.id.btn_gallery).setOnClickListener(v -&gt; &#123;        openGallery(); // 打开相册        bottomSheetDialog.dismiss();    &#125;);    // 显示对话框    bottomSheetDialog.show();&#125;</code></pre><h2 id="三、相机-API-对接"><a href="#三、相机-API-对接" class="headerlink" title="三、相机 API 对接"></a>三、相机 API 对接</h2><h3 id="1-权限检查"><a href="#1-权限检查" class="headerlink" title="1. 权限检查"></a>1. 权限检查</h3><p>在打开相机前检查并请求必要权限：</p><pre><code class="java">private void checkPermissionsAndOpenCamera() &#123;    // 检查相机和存储权限    if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)            != PackageManager.PERMISSION_GRANTED ||        ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)            != PackageManager.PERMISSION_GRANTED) &#123;        // 请求权限        ActivityCompat.requestPermissions(this,                new String[]&#123;Manifest.permission.CAMERA,                            Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,                REQUEST_PERMISSIONS);    &#125; else &#123;        // 权限已授予，直接打开相机        openCamera();    &#125;&#125;</code></pre><h3 id="2-打开相机"><a href="#2-打开相机" class="headerlink" title="2. 打开相机"></a>2. 打开相机</h3><p>使用<code>MediaStore.ACTION_IMAGE_CAPTURE</code>意图打开系统相机：</p><pre><code class="java">private void openCamera() &#123;    Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);    // 检查是否有相机应用可以响应    if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123;        File photoFile = null;        try &#123;            // 创建临时图片文件            photoFile = createImageFile();        &#125; catch (IOException ex) &#123;            ex.printStackTrace();        &#125;        if (photoFile != null) &#123;            // 通过FileProvider获取安全的Uri            Uri photoURI = FileProvider.getUriForFile(this,                    &quot;com.naojianghh.bilibili3&quot;, // 与Manifest中配置的authorities一致                    photoFile);            // 设置图片保存路径            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);            // 启动相机，等待返回结果            startActivityForResult(takePictureIntent, REQUEST_CAMERA);        &#125;    &#125;&#125;</code></pre><h3 id="3-创建图片文件"><a href="#3-创建图片文件" class="headerlink" title="3. 创建图片文件"></a>3. 创建图片文件</h3><pre><code class="java">private File createImageFile() throws IOException &#123;    // 生成唯一文件名（基于时间戳）    String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;, Locale.getDefault()).format(new Date());    String imageFileName = &quot;JPEG_&quot; + timeStamp + &quot;_&quot;;    // 获取应用私有图片目录    File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);    // 创建临时文件    File image = File.createTempFile(            imageFileName,  // 文件名前缀            &quot;.jpg&quot;,         // 文件后缀            storageDir      // 存储目录    );    // 保存图片路径用于后续处理    currentPhotoPath = image.getAbsolutePath();    return image;&#125;</code></pre><h2 id="四、相册-API-对接"><a href="#四、相册-API-对接" class="headerlink" title="四、相册 API 对接"></a>四、相册 API 对接</h2><p>使用<code>ACTION_OPEN_DOCUMENT</code>意图打开系统相册，支持持久化访问权限：</p><pre><code class="java">private void openGallery() &#123;    Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);    intent.setType(&quot;image/*&quot;); // 只显示图片类型    // 请求持久化访问权限    intent.addFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);    // 启动相册，等待返回结果    startActivityForResult(intent, REQUEST_GALLERY);&#125;</code></pre><h2 id="五、处理返回结果"><a href="#五、处理返回结果" class="headerlink" title="五、处理返回结果"></a>五、处理返回结果</h2><p>在<code>onActivityResult</code>中处理相机和相册返回的图片：</p><pre><code class="java">@Overrideprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;    super.onActivityResult(requestCode, resultCode, data);        // 处理相机返回结果    if (requestCode == REQUEST_CAMERA &amp;&amp; resultCode == RESULT_OK) &#123;        // 通过路径加载图片        Bitmap bitmap = BitmapFactory.decodeFile(currentPhotoPath);        ivSelectedImage.setImageBitmap(bitmap);        // 保存图片路径用于后续存储        selectedImageIdentifier = currentPhotoPath;    &#125;    // 处理相册返回结果    else if (requestCode == REQUEST_GALLERY &amp;&amp; resultCode == RESULT_OK &amp;&amp; data != null) &#123;        Uri selectedImageUri = data.getData();        if (selectedImageUri != null) &#123;            // 显示选中的图片            ivSelectedImage.setImageURI(selectedImageUri);                        try &#123;                // 获取持久化访问权限                int takeFlags = data.getFlags() &amp; (Intent.FLAG_GRANT_READ_URI_PERMISSION |                                                   Intent.FLAG_GRANT_WRITE_URI_PERMISSION);                getContentResolver().takePersistableUriPermission(selectedImageUri, takeFlags);                // 保存带权限标记的Uri                selectedImageIdentifier = selectedImageUri.toString() + &quot;|with_permission&quot;;            &#125; catch (SecurityException e) &#123;                Log.e(&quot;PermissionError&quot;, &quot;无法获取持久化权限: &quot; + e.getMessage());                selectedImageIdentifier = selectedImageUri.toString();                Toast.makeText(this, &quot;无法永久访问该图片，仅本次有效&quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="六、图片展示与存储"><a href="#六、图片展示与存储" class="headerlink" title="六、图片展示与存储"></a>六、图片展示与存储</h2><p>在<code>FolderActivity</code>中加载并展示选中的图片（区分相机图片和相册图片）：</p><pre><code class="java">// 获取数据库中存储的封面路径String coverPath = databaseHelper.getFolderCover(folderName);if (coverPath != null &amp;&amp; !coverPath.isEmpty()) &#123;    setPicture.setVisibility(View.VISIBLE);    // 区分封面类型：路径（相机图）/ Uri字符串（相册图）    if (coverPath.startsWith(&quot;/&quot;)) &#123;        // 相机图：通过路径加载图片（压缩避免OOM）        Bitmap compressedBitmap = decodeCompressedBitmap(coverPath, 80, 80);        setPicture.setImageBitmap(compressedBitmap);    &#125; else if (coverPath.startsWith(&quot;content://&quot;)) &#123;        // 相册图：通过Uri加载        String[] coverParts = coverPath.split(&quot;\\|&quot;);        Uri coverUri = Uri.parse(coverParts[0]);                try &#123;            setPicture.setImageURI(coverUri);        &#125; catch (SecurityException e) &#123;            // 权限不足时的备选方案            try (InputStream inputStream = getContentResolver().openInputStream(coverUri)) &#123;                Bitmap bitmap = BitmapFactory.decodeStream(inputStream);                setPicture.setImageBitmap(bitmap);            &#125; catch (Exception ex) &#123;                ex.printStackTrace();                setPicture.setVisibility(View.GONE);            &#125;        &#125;    &#125;&#125; else &#123;    setPicture.setVisibility(View.GONE);&#125;</code></pre><h2 id="七、关键技术点"><a href="#七、关键技术点" class="headerlink" title="七、关键技术点"></a>七、关键技术点</h2><ol><li><strong>权限管理</strong>：<ul><li>动态请求相机和存储权限</li><li>使用<code>takePersistableUriPermission</code>获取相册图片的持久化访问权</li></ul></li><li><strong>安全机制</strong>：<ul><li>通过<code>FileProvider</code>生成 content:&#x2F;&#x2F; 类型的 Uri，避免暴露文件路径</li><li>对相机拍摄的图片进行压缩处理，防止 OOM</li></ul></li><li><strong>兼容性处理</strong>：<ul><li>区分相机图片（文件路径）和相册图片（Uri）的不同处理方式</li><li>处理权限获取失败的异常情况</li></ul></li><li><strong>数据存储</strong>：<ul><li>相机图片存储在应用私有目录，避免权限问题</li><li>相册图片存储 Uri 字符串，配合权限标记实现持久访问</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>数据库搭建</title>
    <link href="http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA/</id>
    <published>2025-09-06T04:07:14.000Z</published>
    <updated>2025-09-06T08:22:46.537Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SQLite</strong>的使用</p><p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="项目数据库搭建详解"><a href="#项目数据库搭建详解" class="headerlink" title="项目数据库搭建详解"></a>项目数据库搭建详解</h1><p>该仿哔哩哔哩项目采用 <strong>SQLite</strong> 作为本地数据库，主要用于存储用户收藏相关数据，通过 <code>FavoriteDatabaseHelper</code> 类实现数据库的创建、升级及数据 CRUD 操作，以下是具体实现细节：</p><h2 id="一、数据库核心设计"><a href="#一、数据库核心设计" class="headerlink" title="一、数据库核心设计"></a>一、数据库核心设计</h2><h3 id="1-数据库与表结构"><a href="#1-数据库与表结构" class="headerlink" title="1. 数据库与表结构"></a>1. 数据库与表结构</h3><p>项目包含两个核心表，分别用于存储收藏内容和收藏夹信息：</p><table><thead><tr><th>表名</th><th>作用</th><th>核心字段</th></tr></thead><tbody><tr><td><code>favorites</code></td><td>存储用户收藏的视频数据</td><td>自增 ID、原始视频 ID、所属文件夹名、视频描述、资源 ID 等</td></tr><tr><td><code>folders</code></td><td>存储收藏夹信息</td><td>收藏夹 ID、显示名称、封面图路径</td></tr></tbody></table><h3 id="2-核心常量定义"><a href="#2-核心常量定义" class="headerlink" title="2. 核心常量定义"></a>2. 核心常量定义</h3><p>在 <code>FavoriteDatabaseHelper</code> 中定义数据库名称、版本及表结构常量：</p><pre><code class="java">// 数据库名称和版本private static final String DATABASE_NAME = &quot;favorite.db&quot;;private static final int DATABASE_VERSION = 4; // 版本号随结构变更递增// 收藏内容表（favorites）private static final String TABLE_FAVORITES = &quot;favorites&quot;;private static final String COLUMN_ID = &quot;id&quot;; // 数据库自增主键private static final String COLUMN_ORIGINAL_ID = &quot;original_id&quot;; // 视频原始ID（关联源数据）private static final String COLUMN_FOLDER_NAME = &quot;title&quot;; // 所属文件夹名称private static final String COLUMN_DESCRIPTION = &quot;description&quot;; // 视频描述private static final String COLUMN_IMAGE_VIDEO_LIST_ID = &quot;image_video_list_id&quot;; // 列表封面资源ID// 其他资源ID字段...// 收藏夹表（folders）private static final String TABLE_FOLDERS = &quot;folders&quot;;private static final String COLUMN_FOLDER_ID = &quot;folder_id&quot;; // 收藏夹自增IDprivate static final String COLUMN_FOLDER_DISPLAY_NAME = &quot;folder_display_name&quot;; // 显示名称private static final String COLUMN_FOLDER_COVER = &quot;folder_cover&quot;; // 封面图路径</code></pre><h2 id="二、数据库创建与升级"><a href="#二、数据库创建与升级" class="headerlink" title="二、数据库创建与升级"></a>二、数据库创建与升级</h2><h3 id="1-表创建-SQL-语句"><a href="#1-表创建-SQL-语句" class="headerlink" title="1. 表创建 SQL 语句"></a>1. 表创建 SQL 语句</h3><p>通过 <code>CREATE TABLE</code> 语句定义表结构，包含字段类型和约束：</p><pre><code class="java">// 创建收藏内容表（包含原始视频ID字段，用于关联源数据）private static final String CREATE_TABLE_FAVORITES = &quot;CREATE TABLE &quot; + TABLE_FAVORITES + &quot; (&quot; +        COLUMN_ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; +        COLUMN_ORIGINAL_ID + &quot; INTEGER, &quot; + // 关联视频原始ID        COLUMN_FOLDER_NAME + &quot; TEXT, &quot; +        COLUMN_DESCRIPTION + &quot; TEXT, &quot; +        COLUMN_IMAGE_ID + &quot; INTEGER, &quot; +        COLUMN_IMAGE_VIDEO_ID + &quot; INTEGER, &quot; +        COLUMN_IMAGE_VIDEO_LIST_ID + &quot; INTEGER);&quot;;// 创建收藏夹表（包含封面图字段）private static final String CREATE_TABLE_FOLDERS = &quot;CREATE TABLE &quot; + TABLE_FOLDERS + &quot; (&quot; +        COLUMN_FOLDER_ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; +        COLUMN_FOLDER_DISPLAY_NAME + &quot; TEXT, &quot; +        COLUMN_FOLDER_COVER + &quot; TEXT);&quot;;</code></pre><h3 id="2-初始化数据库"><a href="#2-初始化数据库" class="headerlink" title="2. 初始化数据库"></a>2. 初始化数据库</h3><p>在 <code>onCreate</code> 中执行表创建，并初始化默认收藏夹：</p><pre><code class="java">@Overridepublic void onCreate(SQLiteDatabase db) &#123;    // 创建两个核心表    db.execSQL(CREATE_TABLE_FAVORITES);    db.execSQL(CREATE_TABLE_FOLDERS);        // 初始化默认收藏夹    ContentValues values = new ContentValues();    values.put(COLUMN_FOLDER_DISPLAY_NAME, &quot;默认收藏夹&quot;);    values.put(COLUMN_FOLDER_COVER, (String) null); // 初始无封面    db.insert(TABLE_FOLDERS, null, values);&#125;</code></pre><h3 id="3-数据库升级策略"><a href="#3-数据库升级策略" class="headerlink" title="3. 数据库升级策略"></a>3. 数据库升级策略</h3><p>通过 <code>onUpgrade</code> 处理版本变更，支持新增字段或表结构调整：</p><pre><code class="java">@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;    // 版本3→4：为收藏表新增original_id字段（兼容旧数据）    if (oldVersion &lt; 4) &#123;        db.execSQL(&quot;ALTER TABLE &quot; + TABLE_FAVORITES +                &quot; ADD COLUMN &quot; + COLUMN_ORIGINAL_ID + &quot; INTEGER DEFAULT -1;&quot;);    &#125;    // 版本2→3：为收藏夹表新增封面字段    if (oldVersion &lt; 3) &#123;        db.execSQL(&quot;ALTER TABLE &quot; + TABLE_FOLDERS +                &quot; ADD COLUMN &quot; + COLUMN_FOLDER_COVER + &quot; TEXT DEFAULT NULL;&quot;);    &#125;&#125;</code></pre><h2 id="三、核心数据操作（CRUD）"><a href="#三、核心数据操作（CRUD）" class="headerlink" title="三、核心数据操作（CRUD）"></a>三、核心数据操作（CRUD）</h2><h3 id="1-收藏内容管理"><a href="#1-收藏内容管理" class="headerlink" title="1. 收藏内容管理"></a>1. 收藏内容管理</h3><h4 id="（1）添加收藏"><a href="#（1）添加收藏" class="headerlink" title="（1）添加收藏"></a>（1）添加收藏</h4><pre><code class="java">public void addFavorite(FavoriteData favorite) &#123;    SQLiteDatabase db = this.getWritableDatabase();    // 构建插入SQL（处理特殊字符转义，如单引号）    String insertQuery = &quot;INSERT INTO &quot; + TABLE_FAVORITES + &quot; (&quot; +            COLUMN_ORIGINAL_ID + &quot;, &quot; + // 关联视频原始ID            COLUMN_FOLDER_NAME + &quot;, &quot; +            COLUMN_DESCRIPTION + &quot;, &quot; +            COLUMN_IMAGE_ID + &quot;, &quot; +            COLUMN_IMAGE_VIDEO_ID + &quot;, &quot; +            COLUMN_IMAGE_VIDEO_LIST_ID + &quot;) VALUES (&quot; +            favorite.getOriginalId() + &quot;, &#39;&quot; +             favorite.getFolderName().replace(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;) + &quot;&#39;, &#39;&quot; + // 转义单引号            favorite.getDescription().replace(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;) + &quot;&#39;, &quot; +            favorite.getImageResourceId() + &quot;, &quot; +            favorite.getVideoImageResourceId() + &quot;, &quot; +            favorite.getVideoListImageResourceId() + &quot;);&quot;;    db.execSQL(insertQuery);    db.close();&#125;</code></pre><h4 id="（2）查询所有收藏"><a href="#（2）查询所有收藏" class="headerlink" title="（2）查询所有收藏"></a>（2）查询所有收藏</h4><pre><code class="java">public List&lt;FavoriteData&gt; getALLFavorites() &#123;    List&lt;FavoriteData&gt; favorites = new ArrayList&lt;&gt;();    SQLiteDatabase db = this.getReadableDatabase();    Cursor cursor = db.query(TABLE_FAVORITES, null, null, null, null, null, null);        if (cursor.moveToFirst()) &#123;        do &#123;            int id = cursor.getInt(cursor.getColumnIndex(COLUMN_ID));            int originalId = cursor.getInt(cursor.getColumnIndex(COLUMN_ORIGINAL_ID)); // 读取原始ID            String title = cursor.getString(cursor.getColumnIndex(COLUMN_FOLDER_NAME));            // 其他字段读取...            favorites.add(new FavoriteData(description, imageId, videoImageId, videoListImageId, title, id, originalId));        &#125; while (cursor.moveToNext());    &#125;    cursor.close();    db.close();    return favorites;&#125;</code></pre><h4 id="（3）删除收藏"><a href="#（3）删除收藏" class="headerlink" title="（3）删除收藏"></a>（3）删除收藏</h4><pre><code class="java">// 根据视频原始ID删除（更高效的关联删除）public void deleteFavorite(Data data) &#123;    SQLiteDatabase db = getWritableDatabase();    db.delete(            TABLE_FAVORITES,            COLUMN_ORIGINAL_ID + &quot; = ?&quot;, // 条件：原始ID匹配            new String[]&#123;String.valueOf(data.getId())&#125;    );&#125;</code></pre><h4 id="（4）判断是否已收藏"><a href="#（4）判断是否已收藏" class="headerlink" title="（4）判断是否已收藏"></a>（4）判断是否已收藏</h4><pre><code class="java">public boolean isFavoriteExists(Data data) &#123;    SQLiteDatabase db = this.getReadableDatabase();    // 通过原始ID查询，避免重复收藏    String query = &quot;SELECT * FROM &quot; + TABLE_FAVORITES            + &quot; WHERE &quot; + COLUMN_ORIGINAL_ID + &quot; = ?&quot;;    Cursor cursor = db.rawQuery(query, new String[]&#123;String.valueOf(data.getId())&#125;);    boolean exists = cursor.getCount() &gt; 0;    cursor.close();    return exists;&#125;</code></pre><h3 id="2-收藏夹管理"><a href="#2-收藏夹管理" class="headerlink" title="2. 收藏夹管理"></a>2. 收藏夹管理</h3><h4 id="（1）添加收藏夹"><a href="#（1）添加收藏夹" class="headerlink" title="（1）添加收藏夹"></a>（1）添加收藏夹</h4><pre><code class="java">public void addFolder(String folderName) &#123;    try (SQLiteDatabase db = this.getWritableDatabase()) &#123;        ContentValues values = new ContentValues();        values.put(COLUMN_FOLDER_DISPLAY_NAME, folderName);        values.put(COLUMN_FOLDER_COVER, (String) null); // 初始无封面        db.insert(TABLE_FOLDERS, null, values);    &#125;&#125;</code></pre><h4 id="（2）查询所有收藏夹"><a href="#（2）查询所有收藏夹" class="headerlink" title="（2）查询所有收藏夹"></a>（2）查询所有收藏夹</h4><pre><code class="java">public List&lt;Folder&gt; getAllFolders() &#123;    List&lt;Folder&gt; folders = new ArrayList&lt;&gt;();    try (SQLiteDatabase db = this.getReadableDatabase()) &#123;        Cursor cursor = db.query(                TABLE_FOLDERS,                new String[]&#123;COLUMN_FOLDER_DISPLAY_NAME, COLUMN_FOLDER_COVER&#125;,                null, null, null, null, null        );        if (cursor.moveToFirst()) &#123;            do &#123;                String folderName = cursor.getString(cursor.getColumnIndex(COLUMN_FOLDER_DISPLAY_NAME));                String folderCover = cursor.getString(cursor.getColumnIndex(COLUMN_FOLDER_COVER));                folders.add(new Folder(folderName, folderCover));            &#125; while (cursor.moveToNext());        &#125;        cursor.close();    &#125;    return folders;&#125;</code></pre><h4 id="（3）删除收藏夹（级联删除下属收藏）"><a href="#（3）删除收藏夹（级联删除下属收藏）" class="headerlink" title="（3）删除收藏夹（级联删除下属收藏）"></a>（3）删除收藏夹（级联删除下属收藏）</h4><pre><code class="java">public void deleteFolder(String folderName) &#123;    try (SQLiteDatabase db = this.getWritableDatabase()) &#123;        // 1. 删除收藏夹本身        String whereClause = COLUMN_FOLDER_DISPLAY_NAME + &quot; =?&quot;;        String[] whereArgs = &#123;folderName&#125;;        db.delete(TABLE_FOLDERS, whereClause, whereArgs);                // 2. 级联删除该收藏夹下的所有收藏        whereClause = COLUMN_FOLDER_NAME + &quot; =?&quot;;        db.delete(TABLE_FAVORITES, whereClause, whereArgs);    &#125;&#125;</code></pre><h4 id="（4）更新收藏夹封面"><a href="#（4）更新收藏夹封面" class="headerlink" title="（4）更新收藏夹封面"></a>（4）更新收藏夹封面</h4><pre><code class="java">public void setFolderCover(String folderName, String coverPathOrUri) &#123;    try (SQLiteDatabase db = this.getWritableDatabase()) &#123;        ContentValues values = new ContentValues();        values.put(COLUMN_FOLDER_COVER, coverPathOrUri); // 存储封面路径或URI        String whereClause = COLUMN_FOLDER_DISPLAY_NAME + &quot; = ?&quot;;        String[] whereArgs = &#123;folderName&#125;;        db.update(TABLE_FOLDERS, values, whereClause, whereArgs);    &#125;&#125;</code></pre><h2 id="四、数据模型设计"><a href="#四、数据模型设计" class="headerlink" title="四、数据模型设计"></a>四、数据模型设计</h2><h3 id="1-收藏数据模型（FavoriteData-java）"><a href="#1-收藏数据模型（FavoriteData-java）" class="headerlink" title="1. 收藏数据模型（FavoriteData.java）"></a>1. 收藏数据模型（FavoriteData.java）</h3><pre><code class="java">public class FavoriteData &#123;    private String description; // 视频描述    private int imageResourceId; // 图片资源ID    private int videoImageResourceId; // 视频封面资源ID    private int videoListImageResourceId; // 列表封面资源ID    private String folderName; // 所属文件夹名称    private int id; // 数据库自增ID    private int originalId; // 关联的原始视频ID（核心关联字段）    // 构造方法（包含originalId）    public FavoriteData(String description, int imageResourceId, int videoImageResourceId,                        int videoListImageResourceId, String folderName, int id, int originalId) &#123;        this.description = description;        this.imageResourceId = imageResourceId;        this.videoImageResourceId = videoImageResourceId;        this.videoListImageResourceId = videoListImageResourceId;        this.folderName = folderName;        this.id = id;        this.originalId = originalId; // 关联原始视频    &#125;    // Getter和Setter...&#125;</code></pre><h3 id="2-收藏夹模型（内部类）"><a href="#2-收藏夹模型（内部类）" class="headerlink" title="2. 收藏夹模型（内部类）"></a>2. 收藏夹模型（内部类）</h3><pre><code class="java">public static class Folder &#123;    private String folderName; // 收藏夹名称    private String folderCover; // 封面路径    public Folder(String folderName, String folderCover) &#123;        this.folderName = folderName;        this.folderCover = folderCover;    &#125;    // Getter和Setter...&#125;</code></pre><h2 id="五、数据库使用场景"><a href="#五、数据库使用场景" class="headerlink" title="五、数据库使用场景"></a>五、数据库使用场景</h2><ol><li><strong>视频收藏</strong>：在视频详情页（<code>VideoActivity</code>）中，通过 <code>isFavoriteExists</code> 检查状态，调用 <code>addFavorite</code> 或 <code>deleteFavorite</code> 切换收藏状态。</li><li><strong>收藏夹管理</strong>：在 <code>CreateFolderActivity</code> 中调用 <code>addFolder</code> 创建新收藏夹，支持设置封面图（<code>setFolderCover</code>）。</li><li><strong>数据展示</strong>：收藏页通过 <code>getAllFolders</code> 和 <code>getALLFavorites</code> 加载数据，展示收藏夹列表及下属视频。</li><li><strong>状态同步</strong>：收藏操作后通过接口回调更新 UI，确保本地数据库状态与 UI 展示一致。</li></ol><h2 id="六、数据库设计亮点"><a href="#六、数据库设计亮点" class="headerlink" title="六、数据库设计亮点"></a>六、数据库设计亮点</h2><ol><li><strong>关联设计</strong>：通过 <code>original_id</code> 关联视频原始数据（<code>Data</code> 类的 <code>id</code>），避免收藏数据与源数据脱节。</li><li><strong>版本兼容</strong>：通过 <code>onUpgrade</code> 实现平滑升级，新增字段时保留旧数据（如 <code>DEFAULT -1</code>）。</li><li><strong>安全性</strong>：插入数据时对特殊字符（如单引号）进行转义，避免 SQL 注入风险。</li><li><strong>资源优化</strong>：使用 <code>try-with-resources</code> 自动关闭数据库连接，避免资源泄漏。</li><li><strong>级联操作</strong>：删除收藏夹时自动删除下属所有收藏，保证数据一致性。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;SQLite&lt;/strong&gt;的使用&lt;/p&gt;
&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>后端对接(Retrofit + OkHttp)</title>
    <link href="http://example.com/2025/09/06/%E5%90%8E%E7%AB%AF%E5%AF%B9%E6%8E%A5/"/>
    <id>http://example.com/2025/09/06/%E5%90%8E%E7%AB%AF%E5%AF%B9%E6%8E%A5/</id>
    <published>2025-09-06T04:02:30.000Z</published>
    <updated>2025-09-10T07:28:49.133Z</updated>
    
    <content type="html"><![CDATA[<p>通过 <strong>Retrofit + OkHttp</strong> 实现与后端服务的通信</p><p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="项目的后端对接方案详解"><a href="#项目的后端对接方案详解" class="headerlink" title="项目的后端对接方案详解"></a>项目的后端对接方案详解</h1><p>该仿哔哩哔哩项目通过 <strong>Retrofit + OkHttp</strong> 实现与后端服务的通信，主要涉及用户认证、视频数据获取等核心功能的接口对接，以下是具体实现细节：</p><h2 id="一、网络请求框架搭建"><a href="#一、网络请求框架搭建" class="headerlink" title="一、网络请求框架搭建"></a>一、网络请求框架搭建</h2><h3 id="1-核心依赖"><a href="#1-核心依赖" class="headerlink" title="1. 核心依赖"></a>1. 核心依赖</h3><p>项目使用 <code>Retrofit</code> 作为网络请求核心框架，配合 <code>OkHttp</code> 处理底层网络通信，相关依赖在 build.gradle.kts 中声明：</p><pre><code class="kotlin">// 网络请求相关依赖implementation(&quot;com.squareup.okhttp3:okhttp:4.12.0&quot;)implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;) // Gson解析implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;) // 日志拦截器</code></pre><h3 id="2-后端基础配置（Url-java）"><a href="#2-后端基础配置（Url-java）" class="headerlink" title="2. 后端基础配置（Url.java）"></a>2. 后端基础配置（Url.java）</h3><p>统一管理后端服务的主机地址和基础路径：</p><pre><code class="java">public class Url &#123;    // 后端服务IP和端口（示例为本地测试地址）    public static String host = &quot;192.168.136.9:4523&quot;;    // 接口基础URL    public static String url = &quot;http://&quot; + host + &quot;/m1/6993757-6712033-default/&quot;;&#125;</code></pre><h2 id="二、Retrofit-客户端配置（ApiClient-java）"><a href="#二、Retrofit-客户端配置（ApiClient-java）" class="headerlink" title="二、Retrofit 客户端配置（ApiClient.java）"></a>二、Retrofit 客户端配置（ApiClient.java）</h2><h3 id="1-单例模式创建-Retrofit-实例"><a href="#1-单例模式创建-Retrofit-实例" class="headerlink" title="1. 单例模式创建 Retrofit 实例"></a>1. 单例模式创建 Retrofit 实例</h3><p>通过单例模式确保 Retrofit 实例唯一，减少资源消耗：</p><pre><code class="java">public class ApiClient &#123;    private static final String BASE_URL = Url.url;    private static Retrofit retrofit = null;    // 固定Token（实际项目中应通过登录动态获取）    private static final String TOKEN = &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...&quot;;    // 获取Retrofit实例    public static Retrofit getRetrofit() &#123;        if (retrofit == null) &#123;            // 日志拦截器：打印请求和响应信息（调试用）            HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();            loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);            // 配置OkHttp客户端，添加请求头和拦截器            OkHttpClient client = new OkHttpClient.Builder()                    .addInterceptor(chain -&gt; &#123;                        // 构建新请求并添加统一请求头                        Request newRequest = chain.request().newBuilder()                                .header(&quot;Authorization&quot;, TOKEN) // 认证Token                                .header(&quot;User-Agent&quot;, &quot;Apifox/1.0.0&quot;)                                .header(&quot;Accept&quot;, &quot;*/*&quot;)                                .header(&quot;Host&quot;, Url.host)                                .build();                        return chain.proceed(newRequest);                    &#125;)                    .addInterceptor(loggingInterceptor) // 添加日志拦截器                    .build();            // 初始化Retrofit            retrofit = new Retrofit.Builder()                    .baseUrl(BASE_URL)                    .client(client)                    .addConverterFactory(GsonConverterFactory.create()) // Gson解析                    .build();        &#125;        return retrofit;    &#125;    // 获取API服务接口实例    public static ApiService getApiService() &#123;        return getRetrofit().create(ApiService.class);    &#125;&#125;</code></pre><h2 id="三、API-接口定义（ApiService-java）"><a href="#三、API-接口定义（ApiService-java）" class="headerlink" title="三、API 接口定义（ApiService.java）"></a>三、API 接口定义（ApiService.java）</h2><p>通过 Retrofit 注解定义后端接口，目前主要实现视频推荐数据的获取：</p><pre><code class="java">public interface ApiService &#123;    /**     * 获取推荐视频数据     * @param page 页码（分页参数）     * @param pageSize 每页数量     * @return 视频数据响应     */    @GET(&quot;user/video/recommend&quot;) // 接口路径（拼接在BASE_URL后）    Call&lt;VideoResponse&gt; getVideoData(            @Query(&quot;page&quot;) int page,            @Query(&quot;pagesize&quot;) int pageSize    );&#125;</code></pre><h2 id="四、数据模型设计"><a href="#四、数据模型设计" class="headerlink" title="四、数据模型设计"></a>四、数据模型设计</h2><h3 id="1-响应体结构（VideoResponse-java）"><a href="#1-响应体结构（VideoResponse-java）" class="headerlink" title="1. 响应体结构（VideoResponse.java）"></a>1. 响应体结构（VideoResponse.java）</h3><p>对应后端返回的 JSON 结构，使用 <code>@SerializedName</code> 注解映射字段：</p><pre><code class="java">public class VideoResponse &#123;    @SerializedName(&quot;code&quot;) // 状态码（200表示成功）    private int code;    @SerializedName(&quot;msg&quot;) // 提示信息    private String msg;    @SerializedName(&quot;data&quot;) // 视频数据列表    private List&lt;VideoData&gt; data;    // Getter和Setter方法&#125;</code></pre><h3 id="2-视频数据模型（VideoData-java）"><a href="#2-视频数据模型（VideoData-java）" class="headerlink" title="2. 视频数据模型（VideoData.java）"></a>2. 视频数据模型（VideoData.java）</h3><p>存储单个视频的详细信息：</p><pre><code class="java">public class VideoData implements Serializable &#123;    @SerializedName(&quot;id&quot;) // 视频ID    private String id;    @SerializedName(&quot;title&quot;) // 视频标题    private String title;    @SerializedName(&quot;thumbPhoto&quot;) // 视频封面图URL    private String thumbPhoto;    @SerializedName(&quot;isLike&quot;) // 是否点赞    private boolean isLike;    @SerializedName(&quot;isCollect&quot;) // 是否收藏    private boolean isCollect;    @SerializedName(&quot;upData&quot;) // 上传者信息（嵌套对象）    private UpData upData;    // 其他字段（点赞数、收藏数等）及Getter/Setter&#125;</code></pre><h3 id="3-上传者信息模型（UpData-java）"><a href="#3-上传者信息模型（UpData-java）" class="headerlink" title="3. 上传者信息模型（UpData.java）"></a>3. 上传者信息模型（UpData.java）</h3><p>嵌套在 <code>VideoData</code> 中，存储 UP 主信息：</p><pre><code class="java">public class UpData implements Serializable &#123;    @SerializedName(&quot;name&quot;) // 用户名    private String name;    @SerializedName(&quot;fans&quot;) // 粉丝数    private int fans;    @SerializedName(&quot;avator&quot;) // 头像URL    private String avator;    // 其他字段及Getter/Setter&#125;</code></pre><h2 id="五、接口调用示例（以视频数据获取为例）"><a href="#五、接口调用示例（以视频数据获取为例）" class="headerlink" title="五、接口调用示例（以视频数据获取为例）"></a>五、接口调用示例（以视频数据获取为例）</h2><p>在 <code>Tab2Fragment</code> 中调用推荐视频接口，实现数据加载：</p><pre><code class="java">private void fetchData(int page, int pageSize, boolean isRefresh) &#123;    // 调用ApiClient获取服务实例    ApiService apiService = ApiClient.getApiService();    // 构建请求（传入分页参数）    Call&lt;VideoResponse&gt; call = apiService.getVideoData(page, pageSize);    // 异步执行请求    call.enqueue(new Callback&lt;VideoResponse&gt;() &#123;        @Override        public void onResponse(Call&lt;VideoResponse&gt; call, Response&lt;VideoResponse&gt; response) &#123;            if (response.isSuccessful() &amp;&amp; response.body() != null) &#123;                VideoResponse videoResponse = response.body();                if (videoResponse.getCode() == 200) &#123; // 后端约定200为成功                    List&lt;VideoData&gt; newData = videoResponse.getData();                    // 处理数据（刷新或加载更多）                    if (isRefresh) &#123;                        videoList.clear(); // 下拉刷新时清空旧数据                    &#125;                    videoList.addAll(newData); // 添加新数据                    adapter.notifyDataSetChanged(); // 更新列表                &#125; else &#123;                    // 处理业务错误（如参数错误）                    Toast.makeText(requireContext(), videoResponse.getMsg(), Toast.LENGTH_SHORT).show();                &#125;            &#125; else &#123;                // 处理HTTP错误（如404、500）                Toast.makeText(requireContext(), &quot;请求失败&quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;        @Override        public void onFailure(Call&lt;VideoResponse&gt; call, Throwable t) &#123;            // 处理网络错误（如无网络、连接超时）            Toast.makeText(requireContext(), &quot;网络错误: &quot; + t.getMessage(), Toast.LENGTH_SHORT).show();        &#125;    &#125;);&#125;</code></pre><h2 id="六、用户认证对接（登录功能）"><a href="#六、用户认证对接（登录功能）" class="headerlink" title="六、用户认证对接（登录功能）"></a>六、用户认证对接（登录功能）</h2><p>登录功能通过 <code>OkHttp</code> 直接发送 POST 请求（未使用 Retrofit，保持与后端登录接口的灵活性）：</p><pre><code class="java">private void loginRequest(String username, String password) &#123;    // 构建JSON请求体（与后端约定的格式一致）    MediaType mediaType = MediaType.parse(&quot;application/json; charset=utf-8&quot;);    RequestBody body = RequestBody.create(mediaType,            &quot;&#123;\&quot;username\&quot;:\&quot;&quot; + username + &quot;\&quot;,\&quot;password\&quot;:\&quot;&quot; + password + &quot;\&quot;&#125;&quot;    );    // 构建登录请求    Request request = new Request.Builder()            .url(LOGIN_URL) // 登录接口URL（单独配置，未使用BASE_URL）            .post(body)            .build();    // 发送异步请求    client.newCall(request).enqueue(new okhttp3.Callback() &#123;        @Override        public void onResponse(okhttp3.Call call, Response response) throws IOException &#123;            if (response.isSuccessful()) &#123;                String responseData = response.body().string();                JSONObject jsonObject = new JSONObject(responseData);                if (jsonObject.optInt(&quot;code&quot;) == 200) &#123;                    // 登录成功：保存Token到本地（使用SpUtils）                    String token = jsonObject.optString(&quot;data&quot;);                    SpUtils.saveToken(LoginActivity.this, token);                    // 跳转至主页                    startActivity(new Intent(LoginActivity.this, MainActivity.class));                &#125;            &#125;        &#125;        @Override        public void onFailure(okhttp3.Call call, IOException e) &#123;            // 处理登录失败        &#125;    &#125;);&#125;</code></pre><h2 id="七、后端对接的核心特点"><a href="#七、后端对接的核心特点" class="headerlink" title="七、后端对接的核心特点"></a>七、后端对接的核心特点</h2><ol><li><strong>统一请求头管理</strong>：通过 OkHttp 拦截器统一添加 <code>Authorization</code>（Token）、<code>Host</code> 等请求头，避免重复代码。</li><li><strong>数据解析自动化</strong>：使用 <code>GsonConverterFactory</code> 自动将 JSON 响应转换为 Java 对象，减少手动解析成本。</li><li><strong>日志调试</strong>：添加 <code>HttpLoggingInterceptor</code> 打印请求详情（URL、参数、响应体），方便调试接口。</li><li><strong>错误处理</strong>：区分网络错误（<code>onFailure</code>）、HTTP 错误（如 401 未授权）和业务错误（如 code 非 200），分别处理。</li><li><strong>Token 管理</strong>：登录成功后将 Token 保存到本地（<code>SpUtils</code>），作为后续请求的认证凭证。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过 &lt;strong&gt;Retrofit + OkHttp&lt;/strong&gt; 实现与后端服务的通信&lt;/p&gt;
&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Activity和Fragment的多级嵌套</title>
    <link href="http://example.com/2025/09/06/Activity%E5%92%8CFragment%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B5%8C%E5%A5%97/"/>
    <id>http://example.com/2025/09/06/Activity%E5%92%8CFragment%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B5%8C%E5%A5%97/</id>
    <published>2025-09-06T02:58:44.000Z</published>
    <updated>2025-09-06T08:22:22.659Z</updated>
    
    <content type="html"><![CDATA[<p>复刻bilibiliUI项目学习<br>Github项目链接： <a href="https://github.com/naojianghh/bilibili">naojianghh&#x2F;bilibili</a> </p><span id="more"></span><h1 id="项目中嵌套结构详解：MainActivity-→-HomeFragment-→-子-TabFragment"><a href="#项目中嵌套结构详解：MainActivity-→-HomeFragment-→-子-TabFragment" class="headerlink" title="项目中嵌套结构详解：MainActivity → HomeFragment → 子 TabFragment"></a>项目中嵌套结构详解：MainActivity → HomeFragment → 子 TabFragment</h1><h2 id="一、整体架构概述"><a href="#一、整体架构概述" class="headerlink" title="一、整体架构概述"></a>一、整体架构概述</h2><p>该项目采用了 “Activity + Fragment” 的多层嵌套架构，核心嵌套关系为：<br><code>MainActivity</code>（主活动）→ <code>HomeFragment</code>（一级碎片）→ <code>Tab1Fragment</code>至<code>Tab6Fragment</code>（二级碎片）</p><p>这种架构的优势在于：</p><ul><li>实现底部导航与顶部内容区的分离管理</li><li>支持单 Activity 多 Fragment 的轻量切换</li><li>便于维护和扩展不同功能模块</li></ul><h2 id="二、各层级实现细节"><a href="#二、各层级实现细节" class="headerlink" title="二、各层级实现细节"></a>二、各层级实现细节</h2><h3 id="1-最外层：MainActivity（主活动）"><a href="#1-最外层：MainActivity（主活动）" class="headerlink" title="1. 最外层：MainActivity（主活动）"></a>1. 最外层：MainActivity（主活动）</h3><p><strong>核心作用</strong>：作为应用容器，管理底部导航和一级 Fragment 切换</p><pre><code class="java">// MainActivity.java 关键代码fragments = new Fragment[]&#123;    new HomeFragment(),    // 首页Fragment（核心）    new FocusFragment(),   // 关注Fragment    new CreateFragment(),  // 创建Fragment    new ShoppingFragment(),// 购物Fragment    new MineFragment()     // 我的Fragment&#125;;// 初始化时默认显示HomeFragmentgetSupportFragmentManager().beginTransaction()    .add(R.id.main_frame,fragments[0])    .commit();</code></pre><p><strong>布局容器</strong>：<br>通过activity_main.xml中的<code>FrameLayout</code>（<code>@+id/main_frame</code>）作为一级 Fragment 的容器，底部通过<code>BottomNavigationView</code>实现导航切换。</p><p><strong>切换逻辑</strong>：<br>通过<code>switchFragment()</code>方法管理 Fragment 的显示 &#x2F; 隐藏，避免重复创建：</p><pre><code class="java">private void switchFragment(int to)&#123;    if (lastFragmentIndex == to) return;    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();    if (!fragments[to].isAdded()) &#123;        transaction.add(R.id.main_frame,fragments[to]);    &#125; else &#123;        transaction.show(fragments[to]);    &#125;    transaction.hide(fragments[lastFragmentIndex]).commitAllowingStateLoss();    lastFragmentIndex = to;&#125;</code></pre><h3 id="2-中间层：HomeFragment（一级碎片）"><a href="#2-中间层：HomeFragment（一级碎片）" class="headerlink" title="2. 中间层：HomeFragment（一级碎片）"></a>2. 中间层：HomeFragment（一级碎片）</h3><p><strong>核心作用</strong>：作为首页容器，管理顶部导航栏和二级 TabFragment 切换</p><p><strong>布局结构</strong>（fragment_home.xml）：</p><ul><li>顶部导航栏（包含头像、搜索框等）</li><li>TabLayout（标签栏，<code>@+id/tab_layout</code>）</li><li>右侧固定 Tab（<code>@+id/tab_layout_fixed</code>）</li><li>ViewPager（<code>@+id/vp</code>，用于承载二级 Fragment）</li></ul><p><strong>Tab 与 ViewPager 绑定</strong>：<br>通过<code>HomeFragmentAdapter</code>将 Tab 与二级 Fragment 关联：</p><pre><code class="java">// HomeFragment.java 关键代码homeFragmentAdapter = new HomeFragmentAdapter(getChildFragmentManager());homeFragmentAdapter.setmBean(beans); // 设置Tab标题数据viewPager.setAdapter(homeFragmentAdapter);tabLayout.setupWithViewPager(viewPager); // 绑定TabLayout和ViewPagerviewPager.setCurrentItem(1); // 默认显示第2个Tab（推荐）</code></pre><p>**为什么使用 getChildFragmentManager ()**：<br>在 Fragment 中嵌套子 Fragment 时，必须使用<code>getChildFragmentManager()</code>而非<code>getFragmentManager()</code>，否则会导致子 Fragment 状态管理异常。</p><h3 id="3-最内层：Tab1Fragment-至-Tab6Fragment（二级碎片）"><a href="#3-最内层：Tab1Fragment-至-Tab6Fragment（二级碎片）" class="headerlink" title="3. 最内层：Tab1Fragment 至 Tab6Fragment（二级碎片）"></a>3. 最内层：Tab1Fragment 至 Tab6Fragment（二级碎片）</h3><p><strong>核心作用</strong>：各自承载不同的首页内容（直播、推荐、热门等）</p><p><strong>实现方式</strong>：<br>所有二级 Fragment 均继承自<code>BaseFragment</code>，统一实现布局加载和视图初始化：</p><pre><code class="java">// 以Tab1Fragment为例public class Tab1Fragment extends BaseFragment &#123;    @Override    protected void initViews() &#123;        // 初始化当前Tab的视图    &#125;    @Override    protected int getLayoutId() &#123;        return R.layout.tab1_fragment; // 返回对应布局    &#125;&#125;</code></pre><p><strong>特殊实现：Tab2Fragment</strong><br>作为 “推荐” 标签页，实现了更复杂的功能：</p><ul><li>下拉刷新（<code>SwipeRefreshLayout</code>）</li><li>上拉加载更多（RecyclerView 滚动监听）</li><li>网络数据请求（通过<code>ApiService</code>获取视频数据）</li><li>混合布局（Banner 轮播 + 本地数据 + 网络视频数据）</li></ul><h2 id="三、嵌套关系的关键技术点"><a href="#三、嵌套关系的关键技术点" class="headerlink" title="三、嵌套关系的关键技术点"></a>三、嵌套关系的关键技术点</h2><ol><li><p><strong>FragmentManager 层级关系</strong>：</p><ul><li>MainActivity 使用<code>getSupportFragmentManager()</code>管理一级 Fragment</li><li>HomeFragment 使用<code>getChildFragmentManager()</code>管理二级 Fragment</li><li>确保 Fragment 的添加 &#x2F; 移除操作在正确的管理器中执行</li></ul></li><li><p><strong>ViewPager 与 FragmentPagerAdapter</strong>：</p><pre><code class="java">// HomeFragmentAdapter.java 关键代码@NonNull@Overridepublic Fragment getItem(int position) &#123;    switch (position) &#123;        case 0: return new Tab1Fragment();        case 1: return new Tab2Fragment();        // ... 其他Tab对应的Fragment        default: return new Tab2Fragment();    &#125;&#125;</code></pre></li><li><p><strong>生命周期管理</strong>：</p><ul><li>当 MainActivity 切换到 HomeFragment 时，HomeFragment 执行<code>onResume()</code></li><li>当 ViewPager 切换 Tab 时，对应的子 Fragment 会执行<code>onResume()</code>&#x2F;<code>onPause()</code></li><li>通过<code>ViewPager.setOffscreenPageLimit(n)</code>控制预加载的子 Fragment 数量（默认预加载左右各 1 个）</li></ul></li><li><p><strong>数据通信</strong>：</p><ul><li>子 Fragment 与 HomeFragment 通信：可通过接口回调（如之前优化方案中提到的<code>OnTabFragmentInteractionListener</code>）</li><li>跨层级通信：可使用 ViewModel 或 EventBus 实现 MainActivity 与子 Fragment 的数据传递</li></ul></li></ol><h2 id="四、布局嵌套关系可视化"><a href="#四、布局嵌套关系可视化" class="headerlink" title="四、布局嵌套关系可视化"></a>四、布局嵌套关系可视化</h2><pre><code class="plaintext">MainActivity（activity_main.xml）├─ FrameLayout（@+id/main_frame）  // 一级Fragment容器│  └─ HomeFragment（fragment_home.xml）│     ├─ 顶部导航栏（LinearLayout）│     ├─ TabLayout（@+id/tab_layout）  // 标签栏│     ├─ 右侧固定Tab（@+id/tab_layout_fixed）│     └─ ViewPager（@+id/vp）  // 二级Fragment容器│        ├─ Tab1Fragment（tab1_fragment.xml）  // 直播│        ├─ Tab2Fragment（tab2_fragment.xml）  // 推荐│        ├─ Tab3Fragment（tab3_fragment.xml）  // 热门│        ├─ Tab4Fragment（tab4_fragment.xml）  // 动画│        ├─ Tab5Fragment（tab5_fragment.xml）  // 影视│        └─ Tab6Fragment（tab6_fragment.xml）  // 新征程└─ BottomNavigationView（底部导航）</code></pre><h2 id="五、这种嵌套结构的优缺点"><a href="#五、这种嵌套结构的优缺点" class="headerlink" title="五、这种嵌套结构的优缺点"></a>五、这种嵌套结构的优缺点</h2><p><strong>优点</strong>：</p><ol><li>功能模块清晰分离，便于团队协作开发</li><li>单个页面内容过多时，可拆分到不同子 Fragment 中管理</li><li>利用 ViewPager 的缓存机制，提升 Tab 切换的流畅度</li><li>底部导航切换时，HomeFragment 中的子 Tab 状态可保留</li></ol><p><strong>缺点</strong>：</p><ol><li>层级较深时，Fragment 生命周期管理复杂</li><li>子 Fragment 与 Activity 通信需要通过中间层（HomeFragment）转发</li><li>过度嵌套可能导致内存占用增加</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;复刻bilibiliUI项目学习&lt;br&gt;Github项目链接： &lt;a href=&quot;https://github.com/naojianghh/bilibili&quot;&gt;naojianghh&amp;#x2F;bilibili&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>框架</title>
    <link href="http://example.com/2025/04/23/%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2025/04/23/%E6%A1%86%E6%9E%B6/</id>
    <published>2025-04-23T15:05:04.000Z</published>
    <updated>2025-05-01T08:54:43.788Z</updated>
    
    <content type="html"><![CDATA[<p>不知道写什么 QAQ</p><span id="more"></span><h1 id="框架意义"><a href="#框架意义" class="headerlink" title="框架意义"></a>框架意义</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745420756417.png" alt="1745420756417"></p><h1 id="框架优缺点"><a href="#框架优缺点" class="headerlink" title="框架优缺点"></a>框架优缺点</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745420790853.png" alt="1745420790853"></p><h1 id="常见java框架"><a href="#常见java框架" class="headerlink" title="常见java框架"></a>常见java框架</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745420896871.png" alt="1745420896871"></p><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="一种持久层框架"><a href="#一种持久层框架" class="headerlink" title="一种持久层框架"></a>一种持久层框架</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745421039699.png" alt="1745421039699"></p><h2 id="一种ORM框架"><a href="#一种ORM框架" class="headerlink" title="一种ORM框架"></a>一种ORM框架</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745421323953.png" alt="1745421323953"></p><h2 id="搭建MyBatis框架"><a href="#搭建MyBatis框架" class="headerlink" title="搭建MyBatis框架"></a>搭建MyBatis框架</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745421520937.png" alt="1745421520937"></p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在pom.xml中</p><pre><code class="xml">&lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.30&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.11&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h3 id="创建MyBatis的配置文件"><a href="#创建MyBatis的配置文件" class="headerlink" title="创建MyBatis的配置文件"></a>创建MyBatis的配置文件</h3><p>（可以去阅读MyBatis的入门文档）</p><p>将文件创建在resources的目录下</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/zxy?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;mapper/BookMapper.xml&quot;&gt;&lt;/mapper&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>创建实体类（一般创建在pojo的包下）</p><pre><code class="java">package com.zxy.pojo;public class Book &#123;    private int id;    private String name;    private String author;    private double price;    public Book(int id, String name, String author, double price) &#123;        this.id = id;        this.name = name;        this.author = author;        this.price = price;    &#125;    public Book() &#123;    &#125;    public double getPrice() &#123;        return price;    &#125;    public int getId() &#123;        return id;    &#125;    public String getAuthor() &#123;        return author;    &#125;    public String getName() &#123;        return name;    &#125;&#125;</code></pre><p>创建映射文件（一般在resources下创建个mapper包，在mapper包下创建各种映射文件）</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;zxy&quot;&gt;    &lt;select id=&quot;selectAllBooks&quot; resultType=&quot;com.zxy.pojo.Book&quot;&gt;        select * from t_book    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>在这个文件中可以写各种SQL语言</p><h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><pre><code class="java">package com.zxy.test;import com.zxy.pojo.Book;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123;    public static void main(String[] args) throws IOException &#123;        String resource = &quot;Mybatis.xml&quot;;//配置文件        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        List&lt;Book&gt; selectAllBooks = sqlSession.selectList(&quot;zxy.selectAllBooks&quot;);        for (Book book: selectAllBooks) &#123;            System.out.println(book.getAuthor() + &quot;---&quot; + book.getName() + &quot;----&quot; + book.getPrice());        &#125;    &#125;&#125;</code></pre><h2 id="别名设置、内置别名"><a href="#别名设置、内置别名" class="headerlink" title="别名设置、内置别名"></a>别名设置、内置别名</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745504154207.png" alt="1745504154207"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745504495531.png" alt="1745504495531"></p><h2 id="属性文件配置"><a href="#属性文件配置" class="headerlink" title="属性文件配置"></a>属性文件配置</h2><p>在resources目录下创建db.properties文件</p><pre><code class="properties">url=jdbc:mysql://localhost/zxy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=truedriver=com.mysql.cj.jdbc.Driverusername=rootpassword=root</code></pre><p>使用属性文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;                 &lt;!-- $&#123;driver&#125;中的内容要与属性文件的一一对应 --&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;mapper/BookMapper.xml&quot;&gt;&lt;/mapper&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h2 id="MyBatis启动日志功能"><a href="#MyBatis启动日志功能" class="headerlink" title="MyBatis启动日志功能"></a>MyBatis启动日志功能</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745505302231.png" alt="1745505302231"></p><h2 id="接口绑定方案"><a href="#接口绑定方案" class="headerlink" title="接口绑定方案"></a>接口绑定方案</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745557468921.png" alt="1745557468921"></p><h3 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h3><p>一般创建在java下的com.zxy（公司名）.mapper下</p><pre><code class="java">package com.zxy.mapper;import java.util.List;public interface BookMapper &#123;    List selectAllBooks();&#125;</code></pre><h3 id="创建映射文件"><a href="#创建映射文件" class="headerlink" title="创建映射文件"></a>创建映射文件</h3><p>路径与java下的mapper相同，只不过是创建在resources目录下</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.zxy.mapper.BookMapper&quot;&gt;    &lt;select id=&quot;selectAllBooks&quot; resultType=&quot;com.zxy.pojo.Book&quot;&gt;        select * from t_book    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>注意mapper的命名空间</p><h3 id="编写测试类-1"><a href="#编写测试类-1" class="headerlink" title="编写测试类"></a>编写测试类</h3><pre><code class="java">package com.zxy.test;import com.zxy.mapper.BookMapper;import com.zxy.pojo.Book;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123;    public static void main(String[] args) throws IOException &#123;        String resource = &quot;Mybatis.xml&quot;;        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();                //相当于BookMapper mapper = BookMapper实现类        BookMapper mapper = sqlSession.getMapper(BookMapper.class);        List&lt;Book&gt; selectAllBooks = mapper.selectAllBooks();        for (Book book: selectAllBooks) &#123;            System.out.println(book.getAuthor() + &quot;---&quot; + book.getName() + &quot;----&quot; + book.getPrice());        &#125;        sqlSession.close();        inputStream.close();    &#125;&#125;</code></pre><h2 id="参数传递问题"><a href="#参数传递问题" class="headerlink" title="参数传递问题"></a>参数传递问题</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745557255483.png" alt="1745557255483"></p><h2 id="获取数据方式"><a href="#获取数据方式" class="headerlink" title="获取数据方式"></a>获取数据方式</h2><h3 id="通过内置名称"><a href="#通过内置名称" class="headerlink" title="通过内置名称"></a>通过内置名称</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745559435932.png" alt="1745559435932"></p><pre><code class="xml">    &lt;select id=&quot;selectOneBook&quot; resultType=&quot;com.zxy.pojo.Book&quot;&gt;        select * from t_book where name =#&#123;arg0&#125; and author = #&#123;arg1&#125;    &lt;/select&gt;</code></pre><pre><code class="java">BookMapper mapper = sqlSession.getMapper(BookMapper.class);        Book book1 = mapper.selectOneBook(&quot;小红书&quot;, &quot;郑晓羽&quot;);        System.out.println(book1.getAuthor() + &quot;---&quot; + book1.getName() + &quot;----&quot; + book1.getPrice());</code></pre><h3 id="通过封装成具体对象"><a href="#通过封装成具体对象" class="headerlink" title="通过封装成具体对象"></a>通过封装成具体对象</h3><pre><code class="xml">    &lt;select id=&quot;selectOneBook2&quot; resultType=&quot;com.zxy.pojo.Book&quot;&gt;        select * from t_book where name =#&#123;name&#125; and author = #&#123;author&#125;    &lt;/select&gt;</code></pre><pre><code class="java">Book b = new Book();        b.setAuthor(&quot;脑浆糊&quot;);        b.setName(&quot;你啊&quot;);        Book book2 = mapper.selectOneBook2(b);        System.out.println(book2.getAuthor() + &quot;---&quot; + book2.getName() + &quot;----&quot; + book2.getPrice());</code></pre><h3 id="多个参数且参数有对象，获取参数如何处理呢？"><a href="#多个参数且参数有对象，获取参数如何处理呢？" class="headerlink" title="多个参数且参数有对象，获取参数如何处理呢？"></a>多个参数且参数有对象，获取参数如何处理呢？</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745560032761.png" alt="1745560032761"></p><pre><code class="xml">    &lt;select id=&quot;selectOneBook3&quot; resultType=&quot;com.zxy.pojo.Book&quot;&gt;        select * from t_book where name =#&#123;param1&#125; and author = #&#123;param2.author&#125;    &lt;/select&gt;</code></pre><pre><code class="java">Book b1 = new Book();        b1.setAuthor(&quot;郑晓羽&quot;);        Book book3 = mapper.selectOneBook3(&quot;小黄书&quot;,b1);        System.out.println(book3.getAuthor() + &quot;---&quot; + book3.getName() + &quot;----&quot; + book3.getPrice());</code></pre><h2 id="增删改操作"><a href="#增删改操作" class="headerlink" title="增删改操作"></a>增删改操作</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745563311291.png" alt="1745563311291"></p><p>注意：要记得提交事务。</p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745593753781.png" alt="1745593753781"></p><h2 id="Spring-Ioc-DI"><a href="#Spring-Ioc-DI" class="headerlink" title="Spring  Ioc&#x2F;DI"></a>Spring  Ioc&#x2F;DI</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745594488686.png" alt="1745594488686"></p><h3 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745595604487.png" alt="1745595604487"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745595635465.png" alt="1745595635465"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745595653205.png" alt="1745595653205"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745596022401.png" alt="1745596022401"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745656605563.png" alt="1745656605563"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745656826437.png" alt="1745656826437"></p><p><strong>applicationContext.xml文件</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;book&quot; class=&quot;com.zxy.pojo.Book&quot;/&gt;&lt;/beans&gt;</code></pre><p><strong>测试类</strong></p><pre><code class="java">package com.zxy.test;import com.zxy.pojo.Book;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        Book book = (Book) context.getBean(&quot;book&quot;);    &#125;&#125;</code></pre><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745657978917.png" alt="1745657978917"></p><p>在创建容器的时候对象就已经存在了。</p><h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><pre><code class="xml">    &lt;bean id=&quot;book&quot; class=&quot;com.zxy.pojo.Book&quot;&gt;        &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;name&quot; value=&quot;小红书&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><p>底层调用的是实例类的set函数。</p><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><pre><code class="xml">    &lt;bean id=&quot;book2&quot; class=&quot;com.zxy.pojo.Book&quot;&gt;        &lt;constructor-arg name=&quot;id&quot; value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;小黄书&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;</code></pre><p>要保证实例类有相应参数的构造函数。</p><h4 id="引用数据类型属性注入"><a href="#引用数据类型属性注入" class="headerlink" title="引用数据类型属性注入"></a>引用数据类型属性注入</h4><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745677996755.png" alt="1745677996755"></p><pre><code class="xml">    &lt;bean id=&quot;boy&quot; class=&quot;com.zxy.pojo.Boy&quot;&gt;        &lt;property name=&quot;age&quot; value=&quot;25&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;name&quot; value=&quot;小明&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;girl&quot; class=&quot;com.zxy.pojo.Girl&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;丽丽&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;25&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;boyfriend&quot; ref=&quot;boy&quot; &gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><h4 id="IoC-DI的相关注解"><a href="#IoC-DI的相关注解" class="headerlink" title="IoC&#x2F;DI的相关注解"></a>IoC&#x2F;DI的相关注解</h4><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745678438972.png" alt="1745678438972"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745678540319.png" alt="1745678540319"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745678961355.png" alt="1745678961355"></p><h5 id="注解创建对象的属性注入"><a href="#注解创建对象的属性注入" class="headerlink" title="注解创建对象的属性注入"></a>注解创建对象的属性注入</h5><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745679023806.png" alt="1745679023806"></p><p>不需要依赖set方法。</p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745679195959.png" alt="1745679195959"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745679177941.png" alt="1745679177941"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745679209803.png" alt="1745679209803"></p><h1 id="通过Maven搭建web项目"><a href="#通过Maven搭建web项目" class="headerlink" title="通过Maven搭建web项目"></a>通过Maven搭建web项目</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-27%20215520.png"></p><h2 id="配置自带的tomcat插件"><a href="#配置自带的tomcat插件" class="headerlink" title="配置自带的tomcat插件"></a>配置自带的tomcat插件</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745763790032.png" alt="1745763790032"></p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745764311944.png" alt="1745764311944"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745840399954.png" alt="1745840399954"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745764329847.png" alt="1745764329847"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745840359763.png" alt="1745840359763"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745841674569.png" alt="1745841674569"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745842882514.png" alt="1745842882514"></p><p><strong>TestController</strong></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745843515539.png" alt="1745843515539"></p><pre><code class="java">package com.zxy.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestController &#123;    @RequestMapping(&quot;/test1&quot;)    public String text1()&#123;        //响应给浏览器index.jsp页面        return &quot;index.jsp&quot;;        //这里返回的为文件的名称，在web-app包下    &#125;&#125;</code></pre><p><strong>springmvc.xml</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.zxy.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt;</code></pre><p><strong>web.xml</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee        http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;        version=&quot;4.0&quot;         metadata-complete=&quot;true&quot;&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h2 id="前后端参数交互"><a href="#前后端参数交互" class="headerlink" title="前后端参数交互"></a>前后端参数交互</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844485538.png" alt="1745844485538"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844227203.png" alt="1745844227203"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844244237.png" alt="1745844244237"></p><pre><code class="java">@RequestMapping(&quot;/testParam&quot;)public String testParam(String name,int age)&#123;    System.out.println(name + &quot;----&quot; + age);    return &quot;index2.jsp&quot;;&#125;</code></pre><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844497524.png" alt="1745844497524"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844475960.png" alt="1745844475960"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844787181.png" alt="1745844787181"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1745844802635.png" alt="1745844802635"></p><pre><code class="java">    @RequestMapping(&quot;/testParam2&quot;)    public String testParam2(Person person)&#123;        System.out.println(person.getName() + &quot;----&quot; + person.getAge() + &quot;----&quot; + person.getScore());        return &quot;index2.jsp&quot;;    &#125;</code></pre><h1 id="springBoot"><a href="#springBoot" class="headerlink" title="springBoot"></a>springBoot</h1><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746086414531.png" alt="1746086414531"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746086469782.png" alt="1746086469782"></p><h2 id="SpringBoot项目搭建"><a href="#SpringBoot项目搭建" class="headerlink" title="SpringBoot项目搭建"></a>SpringBoot项目搭建</h2><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746087743658.png" alt="1746087743658"></p><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746087910275.png" alt="1746087910275"></p><h3 id="启动器、启动类"><a href="#启动器、启动类" class="headerlink" title="启动器、启动类"></a>启动器、启动类</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746088018955.png" alt="1746088018955"></p><pre><code class="xml">    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;version&gt;2.7.6&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746088464267.png" alt="1746088464267"></p><h2 id="SpringBoot的相关配置"><a href="#SpringBoot的相关配置" class="headerlink" title="SpringBoot的相关配置"></a>SpringBoot的相关配置</h2><p>用application.properties配置</p><pre><code class="properties">server.port=8888server.servlet.context-path=/springboot01</code></pre><p>用application.yml配置</p><h3 id="yml配置文件介绍"><a href="#yml配置文件介绍" class="headerlink" title="yml配置文件介绍"></a>yml配置文件介绍</h3><p><img src="/../images/%E6%A1%86%E6%9E%B6/1746089643476.png" alt="1746089643476"></p><pre><code class="yml">server:  port: 9999  servlet:    context-path: /sb01</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知道写什么 QAQ&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HTML,CSS and JS</title>
    <link href="http://example.com/2025/04/22/HTML/"/>
    <id>http://example.com/2025/04/22/HTML/</id>
    <published>2025-04-22T12:53:41.000Z</published>
    <updated>2025-04-22T13:51:22.494Z</updated>
    
    <content type="html"><![CDATA[<p>速通 web前端</p><span id="more"></span><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><img src="/../images/HTML/1745326536644.png" alt="1745326536644"></p><p>要展示的内容写在body标签内部。</p><p>写中文时要把编码格式改成<code>UTF-8</code></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p><img src="/../images/HTML/1745326875856.png" alt="1745326875856"></p><h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><p><img src="/../images/HTML/1745327426564.png" alt="1745327426564"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;速通 web前端&lt;/p&gt;</summary>
    
    
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="http://example.com/2025/04/22/JDBC/"/>
    <id>http://example.com/2025/04/22/JDBC/</id>
    <published>2025-04-22T11:53:46.000Z</published>
    <updated>2025-04-24T15:42:19.930Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/JDBC/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-22%20195308.png"></p><span id="more"></span><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><img src="/../images/JDBC/1745322888409.png" alt="1745322888409"></p><h1 id="JDBC访问数据库步骤"><a href="#JDBC访问数据库步骤" class="headerlink" title="JDBC访问数据库步骤"></a>JDBC访问数据库步骤</h1><p><img src="/../images/JDBC/1745323351334.png" alt="1745323351334"></p><h2 id="getConnection方法参数"><a href="#getConnection方法参数" class="headerlink" title="getConnection方法参数"></a>getConnection方法参数</h2><p><img src="/../images/JDBC/1745324040778.png" alt="1745324040778"></p><h2 id="增删改操作"><a href="#增删改操作" class="headerlink" title="增删改操作"></a>增删改操作</h2><pre><code class="java">package com.naojianghh;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class Test &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        //加载驱动        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);        //获取数据库连接        String url = &quot;jdbc:mysql://localhost/zxy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;        String usrName = &quot;root&quot;;        String passWord = &quot;root&quot;;        Connection connection = DriverManager.getConnection(url,usrName,passWord);        //创建会话        Statement statement = connection.createStatement();        //发送SQL        int i = statement.executeUpdate(&quot;insert into t_book (id,name,author,price) values (3,&#39;小黄书&#39;,&#39;郑晓羽&#39;,28)&quot;);        //处理结果        if (i &gt; 0)&#123;//证明对数据库的数据条数有影响            System.out.println(&quot;插入成功！&quot;);        &#125; else &#123;            System.out.println(&quot;插入失败！&quot;);        &#125;        //关闭资源        statement.close();        connection.close();    &#125;&#125;</code></pre><p>url : “jdbc:mysql:&#x2F;&#x2F;<code>localhost</code>（本机IP地址）&#x2F;<code>zxy</code>（数据库名）?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai&amp;allowPublicKeyRetrieval&#x3D;true”</p><p><img src="/../images/JDBC/1745324495029.png" alt="1745324495029"></p><p><img src="/../images/JDBC/1745324451974.png" alt="1745324451974"></p><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><pre><code class="java">package com.naojianghh;import java.sql.*;public class Test &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        //加载驱动        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);        //获取数据库连接        String url = &quot;jdbc:mysql://localhost/zxy?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;        String usrName = &quot;root&quot;;        String passWord = &quot;root&quot;;        Connection connection = DriverManager.getConnection(url,usrName,passWord);        //创建会话        Statement statement = connection.createStatement();        //发送SQL//        int i = statement.executeUpdate(&quot;insert into t_book (id,name,author,price) values (3,&#39;小黄书&#39;,&#39;郑晓羽&#39;,28)&quot;);        ResultSet resultSet = statement.executeQuery(&quot;select * from t_book&quot;); // 返回值为结果的一个集合        //处理结果        while (resultSet.next())&#123;            System.out.println(resultSet.getInt(&quot;id&quot;) + &quot;---&quot; + resultSet.getString(&quot;name&quot;)            + &quot;---&quot; + resultSet.getString(&quot;author&quot;) + &quot;---&quot; + resultSet.getDouble(&quot;price&quot;));        &#125;//        if (i &gt; 0)&#123;//证明对数据库的数据条数有影响//            System.out.println(&quot;插入成功！&quot;);//        &#125; else &#123;//            System.out.println(&quot;插入失败！&quot;);//        &#125;        //关闭资源        statement.close();        connection.close();    &#125;&#125;</code></pre><p><img src="/../images/JDBC/1745325214314.png" alt="1745325214314"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/JDBC/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-22%20195308.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2025/04/22/MYSQL/"/>
    <id>http://example.com/2025/04/22/MYSQL/</id>
    <published>2025-04-22T04:20:34.000Z</published>
    <updated>2025-04-22T11:52:16.347Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/MYSQL/1745295711714.png" alt="1745295711714"></p><span id="more"></span><h1 id="程序交互过程"><a href="#程序交互过程" class="headerlink" title="程序交互过程"></a>程序交互过程</h1><p><img src="/../images/MYSQL/1745295733913.png" alt="1745295733913"></p><p>浏览器表示前端，后端即是服务器。</p><h1 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h1><p><img src="/../images/MYSQL/1745296002463.png" alt="1745296002463"></p><p><img src="/../images/MYSQL/1745321008374.png" alt="1745321008374"></p><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p><img src="/../images/MYSQL/1745321042517.png" alt="1745321042517"></p><h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p><img src="/../images/MYSQL/1745321138707.png" alt="1745321138707"></p><h1 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h1><p><img src="/../images/MYSQL/1745321204981.png" alt="1745321204981"></p><p><img src="/../images/MYSQL/1745321549032.png" alt="1745321549032"></p><p><img src="/../images/MYSQL/1745321597382.png" alt="1745321597382"></p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p><img src="/../images/MYSQL/1745321695915.png" alt="1745321695915"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/MYSQL/1745295711714.png&quot; alt=&quot;1745295711714&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="http://example.com/2025/04/20/XML/"/>
    <id>http://example.com/2025/04/20/XML/</id>
    <published>2025-04-20T14:09:23.000Z</published>
    <updated>2025-04-20T15:41:20.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/XML/1745158509549.png" alt="1745158509549"></p><span id="more"></span><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><img src="/../images/XML/1745158546980.png" alt="1745158546980"></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><img src="/../images/XML/1745158795883.png" alt="1745158795883"></p><h1 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h1><p>下载dom4j，并导入</p><p><img src="/../images/XML/1745162013410.png" alt="1745162013410"></p><p><img src="/../images/XML/1745161961040.png" alt="1745161961040"></p><pre><code class="java">package com.zxy.text02;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.File;import java.util.Iterator;import java.util.List;public class test &#123;    public static void main(String[] args) throws DocumentException &#123;        SAXReader sr = new SAXReader();        Document dom = sr.read(new File(&quot;src/com/zxy/text02/students.xml&quot;));        System.out.println(dom);        Element studentsEle = dom.getRootElement();        Iterator&lt;Element&gt; it1 = studentsEle.elementIterator();        while(it1.hasNext())&#123;            Element studentEle = it1.next();            List&lt;Attribute&gt; atts = studentEle.attributes();            for (Attribute a : atts)&#123;                System.out.println(&quot;该子节点的属性&quot; + a.getName() + &quot;---&quot; + a.getText());            &#125;            Iterator&lt;Element&gt; it2 = studentEle.elementIterator();            while (it2.hasNext())&#123;                Element eles = it2.next();                System.out.println(&quot;节点&quot; + eles.getName() + &quot;---&quot; + eles.getText());            &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre><p><img src="/../images/XML/1745163654986.png" alt="1745163654986"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/XML/1745158509549.png&quot; alt=&quot;1745158509549&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="xml" scheme="http://example.com/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://example.com/2025/04/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2025/04/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2025-04-20T13:13:26.000Z</published>
    <updated>2025-04-20T14:15:27.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155002448.png" alt="1745155002448"></p><span id="more"></span><h1 id="网络编程概念明晰"><a href="#网络编程概念明晰" class="headerlink" title="网络编程概念明晰"></a>网络编程概念明晰</h1><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155026178.png" alt="1745155026178"></p><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155210799.png" alt="1745155210799"></p><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155257072.png" alt="1745155257072"></p><h2 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h2><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155520221.png" alt="1745155520221"></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="java">package com.zxy.test01;import java.io.DataOutputStream;import java.io.IOException;import java.io.OutputStream;import java.net.Socket;import java.util.Arrays;public class TestClient &#123;    public static void main(String[] args) throws IOException &#123;        System.out.println(&quot;客户端启动&quot;);        //套接字：指定服务器的ip和端口号        Socket s = new Socket(&quot;10.134.42.56&quot;,8888);        //利用输出流传送数据        OutputStream os = s.getOutputStream();        DataOutputStream dos = new DataOutputStream(os);        //传送数据        dos.writeUTF(&quot;你好，服务器，我是客户端&quot;);        //流、网络资源关闭        dos.close();        os.close();        s.close();    &#125;&#125;</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre><code class="java">package com.zxy.test01;import java.io.DataInputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class TestServer &#123;    public static void main(String[] args) throws IOException &#123;        //套接字        ServerSocket ss = new ServerSocket(8888);        //等待客户端发送数据        Socket s = ss.accept();        //服务器端感受到的输入流        InputStream is = s.getInputStream();        DataInputStream dis = new DataInputStream(is);        //接收客户端发送的数据        String str = dis.readUTF();        System.out.println(str);        //流、网络资源关闭        dis.close();        is.close();        s.close();        ss.close();    &#125;&#125;</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><p>要先启动服务器，再启动客户端。</p></li><li><p>流、网络资源关闭要自下而上的关闭（先创建后关闭）。</p></li></ol><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745157361901.png" alt="1745157361901"></p><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745157375822.png" alt="1745157375822"></p><h3 id="客户端与服务器双向通信"><a href="#客户端与服务器双向通信" class="headerlink" title="客户端与服务器双向通信"></a>客户端与服务器双向通信</h3><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="java">//对服务器返回的数据做处理        InputStream is = s.getInputStream();        DataInputStream dis = new DataInputStream(is);        String str = dis.readUTF();        System.out.println(&quot;服务器对我说&quot; + str);</code></pre><h3 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h3><pre><code class="java">//服务器发送数据给客户端        OutputStream os = s.getOutputStream();        DataOutputStream dos = new DataOutputStream(os);        dos.writeUTF(&quot;你好，客户端，我接收到你的信息了&quot;);</code></pre><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745158011137.png" alt="1745158011137"></p><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745158025293.png" alt="1745158025293"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../images/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1745155002448.png&quot; alt=&quot;1745155002448&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库SQLite</title>
    <link href="http://example.com/2025/03/28/SQLite/"/>
    <id>http://example.com/2025/03/28/SQLite/</id>
    <published>2025-03-28T12:48:35.000Z</published>
    <updated>2025-04-04T14:55:43.090Z</updated>
    
    <content type="html"><![CDATA[<p>SQLite 数据库存储</p><span id="more"></span><h1 id="SQL基础语法"><a href="#SQL基础语法" class="headerlink" title="SQL基础语法"></a>SQL基础语法</h1><h2 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1. 数据库操作"></a>1. 数据库操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><pre><code class="sql">CREATE DATABASE database_name;</code></pre><p>示例：</p><pre><code class="sql">CREATE DATABASE testdb;</code></pre><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre><code class="sql">DROP DATABASE database_name;</code></pre><p>示例：</p><pre><code class="sql">DROP DATABASE testdb;</code></pre><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><pre><code class="sql">USE database_name;</code></pre><p>示例：</p><pre><code class="sql">USE testdb;</code></pre><h2 id="2-表操作"><a href="#2-表操作" class="headerlink" title="2. 表操作"></a>2. 表操作</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code class="sql">CREATE TABLE table_name (    column1 datatype,    column2 datatype,    column3 datatype,    ...);</code></pre><p>示例：</p><pre><code class="sql">CREATE TABLE customers (    id INT PRIMARY KEY,    name VARCHAR(255),    age INT,    email VARCHAR(255));</code></pre><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre><code class="sql">DROP TABLE table_name;</code></pre><p>示例：</p><pre><code class="sql">DROP TABLE customers;</code></pre><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><ul><li><strong>添加列</strong></li></ul><pre><code class="sql">ALTER TABLE table_nameADD column_name datatype;</code></pre><p>示例：</p><pre><code class="sql">ALTER TABLE customersADD address VARCHAR(255);</code></pre><ul><li><strong>删除列</strong></li></ul><pre><code class="sql">ALTER TABLE table_nameDROP COLUMN column_name;</code></pre><p>示例：</p><pre><code class="sql">ALTER TABLE customersDROP COLUMN address;</code></pre><h2 id="3-数据操作"><a href="#3-数据操作" class="headerlink" title="3. 数据操作"></a>3. 数据操作</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><pre><code class="sql">INSERT INTO table_name (column1, column2, column3, ...)VALUES (value1, value2, value3, ...);</code></pre><p>示例：</p><pre><code class="sql">INSERT INTO customers (id, name, age, email)VALUES (1, &#39;John Doe&#39;, 30, &#39;john@example.com&#39;);</code></pre><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><pre><code class="sql">SELECT column1, column2, ...FROM table_name;</code></pre><p>示例：</p><pre><code class="sql">SELECT id, name, ageFROM customers;</code></pre><ul><li><strong>查询所有列</strong></li></ul><pre><code class="sql">SELECT * FROM table_name;</code></pre><p>示例：</p><pre><code class="sql">SELECT * FROM customers;</code></pre><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><pre><code class="sql">UPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition;</code></pre><p>示例：</p><pre><code class="sql">UPDATE customersSET age = 31WHERE id = 1;</code></pre><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><pre><code class="sql">DELETE FROM table_nameWHERE condition;</code></pre><p>示例：</p><pre><code class="sql">DELETE FROM customersWHERE id = 1;</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/../images/SQLite/1743167022146.png" alt="1743167022146"></p><h1 id="SQLiteDatabase"><a href="#SQLiteDatabase" class="headerlink" title="SQLiteDatabase"></a>SQLiteDatabase</h1><pre><code class="java">package com.example.practice;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.database.sqlite.SQLiteDatabase;import android.os.Build;import android.os.Bundle;import android.view.View;import android.widget.TextView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import java.sql.SQLData;public class MainActivity extends AppCompatActivity &#123;    private String mDatabaseName;    private String desc = null;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        mDatabaseName = getFilesDir() + &quot;/test.db&quot;;        TextView tv = findViewById(R.id.tv);        //创建数据库        findViewById(R.id.bt1).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                SQLiteDatabase db =  openOrCreateDatabase(mDatabaseName,Context.MODE_PRIVATE,null);                desc = String.format(&quot;数据库%s创建%s&quot;,db.getPath(),(db != null) ? &quot;成功&quot;:&quot;失败&quot;);                tv.setText(desc);            &#125;        &#125;);        //删除数据库        findViewById(R.id.bt2).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                boolean result = deleteDatabase(mDatabaseName);                desc = String.format(&quot;数据库删除%s&quot;,result ? &quot;成功&quot;:&quot;失败&quot;);                tv.setText(desc);            &#125;        &#125;);    &#125;&#125;</code></pre><p><img src="/../images/SQLite/1743169364403.png" alt="1743169364403"></p><p><img src="/../images/SQLite/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-28%20214126.png"></p><p><img src="/../images/SQLite/1743169533489.png" alt="1743169533489"></p><p><img src="/../images/SQLite/1743169571765.png" alt="1743169571765"></p><h1 id="SQLiteOpenHelper"><a href="#SQLiteOpenHelper" class="headerlink" title="SQLiteOpenHelper"></a>SQLiteOpenHelper</h1><p><img src="/../images/SQLite/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-28%20214638.png"></p><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>SQLiteOpenHelper:</p><pre><code class="java">package com.example.practice.database;import android.content.ContentValues;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import androidx.annotation.NonNull;import androidx.annotation.Nullable;public class UserDataHelper extends SQLiteOpenHelper &#123;    private static final String TABLE_NAME = &quot;user_info&quot;;    private static final String DB_NAME = &quot;user.db&quot;;    private static final int DB_VERSION = 3;    private static UserDataHelper mHelper = null;    private SQLiteDatabase mRDB = null;    private SQLiteDatabase mWDB = null;   private UserDataHelper(Context context)&#123;       super(context,DB_NAME,null,DB_VERSION);   &#125;   public static UserDataHelper getInstance(Context context)&#123;       if (mHelper == null)&#123;           mHelper = new UserDataHelper(context);       &#125;       return mHelper;   &#125;   public SQLiteDatabase openReadLink()&#123;       if (mRDB == null || !mRDB.isOpen())&#123;           mRDB = mHelper.getReadableDatabase();       &#125;       return mRDB;   &#125;    public SQLiteDatabase openWriteLink()&#123;        if (mWDB == null || !mWDB.isOpen())&#123;            mWDB = mHelper.getWritableDatabase();        &#125;        return mWDB;    &#125;    public void closeLink()&#123;       if(mRDB != null &amp;&amp; mRDB.isOpen())&#123;           mRDB.close();           mRDB = null;       &#125;        if(mWDB != null &amp;&amp; mWDB.isOpen())&#123;            mWDB.close();            mWDB = null;        &#125;    &#125;    @Override    //构建一个包含name属性的表    public void onCreate(@NonNull SQLiteDatabase db) &#123;        String sql = &quot;CREATE TABLE &quot; + TABLE_NAME + &quot; (&quot; +                &quot;id INTEGER PRIMARY KEY AUTOINCREMENT, &quot; +                &quot;name TEXT);&quot;;        db.execSQL(sql);    &#125;    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;        db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_NAME);        onCreate(db);    &#125;    //添加数据    public long insert(@NonNull User user)&#123;        ContentValues values = new ContentValues();        values.put(&quot;name&quot;,user.name);        return mWDB.insert(TABLE_NAME,null,values);    &#125;&#125;</code></pre><p>SQLiteActivity</p><pre><code class="java">package com.example.practice;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.EditText;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import com.example.practice.database.User;import com.example.practice.database.UserDataHelper;public class SQLiteOpenHelperActivity extends AppCompatActivity &#123;    private EditText et_name;    private UserDataHelper mHelper;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_sqlite_open_helper);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        et_name = findViewById(R.id.et1);        //添加数据        findViewById(R.id.bt_add).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String name = et_name.getText().toString();                User user = new User(name);                if (mHelper.insert(user) &gt; 0)&#123;                    Log.d(&quot;Data&quot;, &quot;onClick: &quot; + &quot;添加成功&quot;);                &#125;            &#125;        &#125;);    &#125;    @Override    protected void onStart() &#123;        super.onStart();        mHelper = UserDataHelper.getInstance(this);        mHelper.openWriteLink();        mHelper.openReadLink();    &#125;    @Override    protected void onStop() &#123;        super.onStop();        mHelper.closeLink();    &#125;&#125;</code></pre><p><img src="/../images/SQLite/1743691657504.png" alt="1743691657504"></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><img src="/../images/SQLite/1743692517822.png" alt="1743692517822"></p><h3 id="根据名字来删除"><a href="#根据名字来删除" class="headerlink" title="根据名字来删除"></a>根据名字来删除</h3><p>SQLiteOpenHelper</p><pre><code class="java"> public long deleteByName(String name)&#123;       return mWDB.delete(TABLE_NAME,&quot;name=?&quot;,new String[]&#123;name&#125;);   &#125;</code></pre><p>Activity</p><pre><code class="java">        findViewById(R.id.bt_delete).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String name = et_name.getText().toString();                if (mHelper.deleteByName(name) &gt; 0)&#123;                    Log.d(&quot;Data&quot;, &quot;onClick: &quot; + &quot;删除成功&quot;);                &#125;            &#125;        &#125;);</code></pre><p>若要根据多个属性来删除，在<code>delete</code>的第二个参数后加上<code>and</code>，并在第三个的字符串数组参数加上相应的属性。</p><p>例如：<code>name = ? and age = ?</code></p><p>​<code>new String[]&#123;name ,age&#125;</code></p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>Activity</p><pre><code class="java">        findViewById(R.id.bt_update).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String name = et_name.getText().toString();                User user = new User(name);                if (mHelper.update(user) &gt; 0)&#123;                    Log.d(&quot;Data&quot;, &quot;onClick: &quot; + &quot;修改成功&quot;);                &#125;            &#125;        &#125;);</code></pre><p>Helper</p><pre><code class="java">   public long update(User user)&#123;       ContentValues values = new ContentValues();       values.put(&quot;name&quot;,user.name);       return mWDB.update(TABLE_NAME,values,&quot;name=?&quot;,new String[]&#123;user.name&#125;);   &#125;</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>Helper</p><pre><code class="java">   public List&lt;User&gt; queryAll()&#123;       List&lt;User&gt; userList = new ArrayList&lt;&gt;();       Cursor cursor = mRDB.query(TABLE_NAME,null,null,null,null,null,null,null);       while (cursor.moveToNext())&#123;           User user = new User();           user.name = cursor.getString(1);           userList.add(user);       &#125;       return userList;   &#125;</code></pre><p><img src="/../images/SQLite/1743694689283.png" alt="1743694689283"></p><p><img src="/../images/SQLite/1743694706444.png" alt="1743694706444"></p><p>Avtivity</p><pre><code class="java">findViewById(R.id.bt_find).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                List&lt;User&gt; list = mHelper.queryAll();                for (User u : list)&#123;                    Log.d(&quot;Data&quot;, &quot;onClick: &quot; + u.toString());                &#125;            &#125;        &#125;);</code></pre><h2 id="事务管理相关方法"><a href="#事务管理相关方法" class="headerlink" title="事务管理相关方法"></a>事务管理相关方法</h2><p><img src="/../images/SQLite/1743169560978.png" alt="1743169560978"></p><ol><li>**<code>beginTransaction()</code>**：用于开始一个事务。调用该方法后，后续对数据库的操作都将作为事务的一部分，直到事务结束。</li><li>**<code>setTransactionSuccessful()</code>**：设置事务的成功标志。在事务执行过程中，当所有操作都正确完成后，调用此方法标记事务成功。若未调用该方法，事务会在结束时自动回滚。</li><li>**<code>endTransaction()</code>**：结束事务。执行该方法时，会检查事务是否已通过<code>setTransactionSuccessful()</code>设置为成功。如果已设置成功标志，则提交事务，将事务内的操作结果持久化到数据库；若未设置成功标志，则回滚事务，撤销事务内的所有操作。</li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设在一个简单的记账应用中，有两个账户（账户 A 和账户 B），要实现从账户 A 向账户 B 转账的操作，且这两个操作需作为一个事务来确保数据一致性。代码如下：</p><pre><code class="java">// 假设已获取SQLiteDatabase实例，名为dbdb.beginTransaction(); // 开启事务try &#123;    // 从账户A扣除转账金额，假设账户A的表名为account，id为1，金额字段为balance，转账金额为transferAmount    db.execSQL(&quot;UPDATE account SET balance = balance -? WHERE id = 1&quot;, new String[]&#123;String.valueOf(transferAmount)&#125;);    // 向账户B增加转账金额，假设账户B的id为2    db.execSQL(&quot;UPDATE account SET balance = balance +? WHERE id = 2&quot;, new String[]&#123;String.valueOf(transferAmount)&#125;);    db.setTransactionSuccessful(); // 设置事务成功标志&#125; catch (Exception e) &#123;    e.printStackTrace();&#125; finally &#123;    db.endTransaction(); // 结束事务，若设置了成功标志则提交，否则回滚&#125;</code></pre><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>异常处理</strong>：在事务执行代码块中，要妥善处理可能出现的异常。一旦出现异常，通常不希望事务继续执行，避免数据不一致，如上述示例中在<code>catch</code>块捕获异常并打印堆栈信息。</li><li><strong>操作顺序</strong>：<code>setTransactionSuccessful()</code>方法需在事务执行的关键操作完成且都正确时调用，并且要在<code>endTransaction()</code>之前调用。</li><li><strong>自动提交模式</strong>：在 SQLite 中，默认情况下每个 SQL 语句都是一个自动提交的事务。但通过显式调用<code>beginTransaction()</code>等方法，可将多个 SQL 语句组合成一个事务进行处理 。</li></ul><h2 id="数据库版本升级"><a href="#数据库版本升级" class="headerlink" title="数据库版本升级"></a>数据库版本升级</h2><p>首先修改版本号</p><p>然后在<code>onUpgrade</code>中写上升级内容，例：增加两个字段</p><p><img src="/../images/SQLite/1743742365252.png" alt="1743742365252"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQLite 数据库存储&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android基础组件</title>
    <link href="http://example.com/2025/03/23/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2025/03/23/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/</id>
    <published>2025-03-23T14:12:20.000Z</published>
    <updated>2025-03-28T07:30:41.855Z</updated>
    
    <content type="html"><![CDATA[<p>Activity，Service等等。</p><span id="more"></span><h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="Activity的创建"><a href="#Activity的创建" class="headerlink" title="Activity的创建"></a>Activity的创建</h2><p>创建一个Activity需要在<code>AndroidManifest</code>里进行注册</p><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1742742015579.png" alt="1742742015579"></p><p>然后在新建的java代码页面中继承<code>AppCompatActivity</code>，并重写<code>onCreate</code>代码，</p><p>设置布局页面。</p><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1742741952400.png" alt="1742741952400"></p><h2 id="Activity的跳转"><a href="#Activity的跳转" class="headerlink" title="Activity的跳转"></a>Activity的跳转</h2><p>在布局中设置按钮并通过点击事件实现跳转。</p><pre><code class="java">public void ac1(View view) &#123;        startActivity(new Intent(this,MainActivity.class));    &#125;</code></pre><p>其中，<code>this</code>为当前页面，<code>MainActivity.class</code>为需要跳转的页面。</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><p>MainActivity</p><pre><code class="java">package com.example.practice;import android.content.Intent;import android.os.Bundle;import android.view.View;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);    &#125;    public void ac2(View view) &#123;        startActivity(new Intent(this,MainActivity2.class));    &#125;&#125;</code></pre><p>MainActivity2</p><pre><code class="java">package com.example.practice;import android.content.Intent;import android.os.Bundle;import android.view.View;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;public class MainActivity2 extends AppCompatActivity &#123;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main2);    &#125;    public void ac1(View view) &#123;        startActivity(new Intent(this,MainActivity.class));    &#125;&#125;</code></pre><p>activity_main</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;       &lt;TextView           android:layout_gravity=&quot;center_horizontal&quot;           android:gravity=&quot;center_horizontal&quot;           android:layout_width=&quot;wrap_content&quot;           android:layout_height=&quot;wrap_content&quot;           android:textSize=&quot;50dp&quot;           android:text=&quot;我是第一个Activity&quot;/&gt;        &lt;Button            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_gravity=&quot;center&quot;            android:onClick=&quot;ac2&quot;            android:text=&quot;进入&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p>activity_main2</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;我是第二个Activity&quot;            android:layout_gravity=&quot;center_horizontal&quot;            android:gravity=&quot;center_horizontal&quot;            android:textSize=&quot;50dp&quot;/&gt;        &lt;Button            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_gravity=&quot;center&quot;            android:onClick=&quot;ac1&quot;            android:text=&quot;返回&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><ol><li>启动阶段<ul><li>**onCreate()**：Activity 第一次被创建时调用，是生命周期的起点。在这个方法中，通常进行一些初始化操作，如设置布局文件（<code>setContentView</code>）、初始化成员变量、绑定事件监听器等。但要注意避免在此处执行耗时操作，否则会导致应用启动缓慢甚至卡顿。</li><li>**onStart()**：在<code>onCreate</code>之后调用，此时 Activity 对用户来说已经可见，但还未出现在前台与用户交互。可进行一些准备显示的操作，比如开始动画的准备工作。</li><li>**onResume()**：Activity 进入前台，获取到焦点，此时可以与用户进行交互。像开启传感器监听、启动动画等操作可在此处进行。</li></ul></li><li>运行阶段<ul><li>当 Activity 处于前台并与用户交互时，它处于运行状态，此时<code>onResume</code>方法已执行完毕，系统会保持其运行，直到有其他 Activity 切入或其他事件发生。</li></ul></li><li>暂停阶段<ul><li>**onPause()**：当 Activity 失去焦点，比如有新的 Activity 部分遮挡它（如弹出一个对话框）或者切换到其他应用时，该方法被调用。在这个方法中，通常要保存一些重要的状态数据，停止动画、释放一些系统资源（如关闭传感器监听）等，但不能执行耗时操作，因为只有当<code>onPause</code>执行完，新的 Activity 才会完全显示。</li></ul></li><li>停止阶段<ul><li>**onStop()**：当 Activity 完全被其他 Activity 遮挡，对用户不可见时调用。相比<code>onPause</code>，此时 Activity 对用户来说已经不可见，可执行一些更重量级的资源释放操作，如停止后台线程、关闭数据库连接等。</li></ul></li><li>销毁阶段<ul><li>**onDestroy()**：Activity 被销毁前调用，这是生命周期的终点。通常在 Activity 不再需要，或者应用退出等情况下触发。在此方法中，要确保释放所有的资源，避免内存泄漏，比如取消所有的监听器绑定、关闭文件流等。</li></ul></li><li>恢复阶段<ul><li>**onRestart()**：当 Activity 由停止状态再次启动时调用，比如用户从其他应用切换回该应用。在这个方法之后，会依次调用<code>onStart()</code>和<code>onResume()</code>，使 Activity 重新回到前台可交互状态。</li></ul></li></ol><h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><ul><li><strong>基本概念</strong>：Fragment 有自己的生命周期，可包含布局和实现逻辑，能让开发者在一个 Activity 中构建灵活多变的用户界面，实现界面模块化，提高代码复用性。比如在一个新闻类 App 中，可将文章列表、文章详情分别用不同的 Fragment 展示。</li><li><strong>生命周期</strong>：与 Activity 类似，有创建（<code>onCreate</code>）、创建视图（<code>onCreateView</code>）、视图创建完成（<code>onViewCreated</code>）、可见（<code>onResume</code>）、不可见（<code>onPause</code>）、销毁视图（<code>onDestroyView</code>）、销毁（<code>onDestroy</code>）等阶段，开发者可在这些阶段处理不同任务。</li><li><strong>与 Activity 的关系</strong>：依赖于 Activity 存在，可通过<code>getActivity()</code>获取关联的 Activity。Activity 可管理 Fragment 的添加、移除、替换等事务，使用<code>FragmentManager</code>和<code>FragmentTransaction</code>类来实现。</li><li><strong>通信方式</strong>：Fragment 之间通信可通过 Activity 作为中介、接口回调、共享 ViewModel 等方式；Fragment 与 Activity 通信则可在 Fragment 中调用 Activity 的公共方法，或通过接口让 Activity 实现相应逻辑 。</li><li><strong>使用场景</strong>：常用于开发响应式界面，在平板等大屏设备上可同时展示多个 Fragment；也适用于 Tab 布局、导航抽屉等，每个 Tab 或导航项对应一个 Fragment 。</li></ul><h2 id="在一个Activity页面中添加多个fragment"><a href="#在一个Activity页面中添加多个fragment" class="headerlink" title="在一个Activity页面中添加多个fragment"></a>在一个Activity页面中添加多个fragment</h2><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1743054636292.png" alt="1743054636292"></p><h2 id="Fragment的动态添加与管理"><a href="#Fragment的动态添加与管理" class="headerlink" title="Fragment的动态添加与管理"></a>Fragment的动态添加与管理</h2><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1743058276500.png" alt="1743058276500"></p><ul><li><strong>添加碎片</strong>：<code>add(int containerViewId, Fragment fragment)</code>，第一个参数是容器的<code>id</code>，碎片将被添加到这个容器中；第二个参数是要添加的<code>Fragment</code>实例。比如<code>transaction.add(R.id.fragment_container, new MyFragment());</code> 。</li><li><strong>替换碎片</strong>：<code>replace(int containerViewId, Fragment fragment)</code>，同样第一个参数是容器<code>id</code>，第二个是新的<code>Fragment</code>实例。它会先移除容器中已有的碎片，再添加新的碎片，如<code>transaction.replace(R.id.fragment_container, new AnotherFragment());</code> 。</li><li><strong>移除碎片</strong>：<code>remove(Fragment fragment)</code>，参数是要移除的<code>Fragment</code>实例，例如<code>transaction.remove(myFragment);</code> 。</li><li><strong>隐藏碎片</strong>：<code>hide(Fragment fragment)</code>，将指定的<code>Fragment</code>隐藏，不销毁，只是从视图中移除，<code>transaction.hide(myFragment);</code> 。</li><li><strong>显示碎片</strong>：<code>show(Fragment fragment)</code>，和<code>hide</code>对应，用于显示之前隐藏的<code>Fragment</code>，<code>transaction.show(myFragment);</code> 。</li><li><strong>提交事务</strong>：<code>commit()</code>，在完成一系列<code>Fragment</code>操作后，必须调用该方法来提交事务，让前面的操作生效。不过要注意，<code>commit()</code>必须在<code>Activity</code>的<code>onSaveInstanceState()</code>方法调用之前调用，否则可能会抛出异常。如果希望事务在未来某个时间点提交，可以使用<code>commitAllowingStateLoss()</code> 。</li><li>**addToBackStack(String name)**：将当前事务添加到返回栈中，参数<code>name</code>是给这个事务在返回栈中的命名，可<code>null</code>。添加后，用户按下返回键时，可以回退到之前的<code>Fragment</code>状态。如<code>transaction.addToBackStack(&quot;myFragmentTransaction&quot;);</code> 。</li></ul><h3 id="Fragment页面切换"><a href="#Fragment页面切换" class="headerlink" title="Fragment页面切换"></a>Fragment页面切换</h3><p>在主布局中添加Framelayout</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;FrameLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:id=&quot;@+id/framelayout&quot;/&gt;    &lt;include layout=&quot;@layout/bottom_layout&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>在相应java代码中</p><pre><code class="java">package com.example.practice;import android.os.Bundle;import android.view.View;import android.widget.Button;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentTransaction;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        Button bt1 = findViewById(R.id.bt1);        Button bt2 = findViewById(R.id.bt2);        bt1.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                replaceFragment(new BlankFragment2());            &#125;        &#125;);        bt2.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                replaceFragment(new BlankFragment1());            &#125;        &#125;);    &#125;    private void replaceFragment(Fragment fragment)&#123;        FragmentManager fragmentManager = getSupportFragmentManager();        FragmentTransaction transaction = fragmentManager.beginTransaction();        transaction.replace(R.id.framelayout,fragment);        transaction.commit();    &#125;&#125;</code></pre><h2 id="Activity与Fragment通信"><a href="#Activity与Fragment通信" class="headerlink" title="Activity与Fragment通信"></a>Activity与Fragment通信</h2><h3 id="原生方案：Bundle"><a href="#原生方案：Bundle" class="headerlink" title="原生方案：Bundle"></a>原生方案：Bundle</h3><p>在Activity相关java代码中</p><pre><code class="java">@Override            public void onClick(View v) &#123;                Bundle bundle = new Bundle();                bundle.putString(&quot;message&quot;,&quot;今天天气不错&quot;);                BlankFragment2 bf2 = new BlankFragment2();                bf2.setArguments(bundle);                replaceFragment(bf2);            &#125;</code></pre><p>在Fragment相关代码中</p><pre><code class="java"> @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        Bundle bundle = getArguments();        String string = bundle.getString(&quot;message&quot;);        Log.d(TAG, &quot;onCreate: &quot; + string);        if (getArguments() != null) &#123;            mParam1 = getArguments().getString(ARG_PARAM1);            mParam2 = getArguments().getString(ARG_PARAM2);        &#125;    &#125;</code></pre><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1743058108620.png" alt="1743058108620"></p><h3 id="java接口方案"><a href="#java接口方案" class="headerlink" title="java接口方案"></a>java接口方案</h3><p>首先定义一个接口</p><pre><code class="java">package com.example.practice;public interface IFragmentCallback &#123;    void sendMsgToActivity(String msg);    String getMsgFromActivity(String msg);&#125;</code></pre><p>在Activity实现匿名接口，并接受，发送信息</p><pre><code class="java">            public void onClick(View v) &#123;                BlankFragment2 bf2 = new BlankFragment2();                bf2.setFragmentCallback(new IFragmentCallback() &#123;                    @Override                    public void sendMsgToActivity(String msg) &#123;                        Toast.makeText(MainActivity.this,msg,Toast.LENGTH_SHORT).show();                    &#125;                    @Override                    public String getMsgFromActivity(String msg) &#123;                        return &quot;Hello,I&#39;m From Activity&quot;;                    &#125;                &#125;);                replaceFragment(bf2);            &#125;</code></pre><p>在Fragment定义一个接口</p><pre><code class="java">private IFragmentCallback fragmentCallback;</code></pre><p>在Fragment的onCreateView中接收，发出信息</p><pre><code class="java">@Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        if (root == null) &#123;            root = inflater.inflate(R.layout.fragment_blank2, container, false);        &#125;        bt3 = root.findViewById(R.id.bt3);        bt3.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                //fragmentCallback.sendMsgToActivity(&quot;Hello,I&#39;m from Fragment&quot;);                String string = fragmentCallback.getMsgFromActivity(&quot;null&quot;);                Toast.makeText(BlankFragment2.this.getContext(),string,Toast.LENGTH_SHORT).show();            &#125;        &#125;);        return root;    &#125;</code></pre><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1743070940126.png" alt="1743070940126"></p><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-27%20182931.png"></p><h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><p>eventBus，LiveData …</p><h2 id="Fragment生命周期"><a href="#Fragment生命周期" class="headerlink" title="Fragment生命周期"></a>Fragment生命周期</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/1743081017653.png" alt="1743081017653"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/1743081713305.png" alt="1743081713305"></p><ol><li><strong>关联阶段</strong>：<code>onAttach()</code>，当 Fragment 被添加到 Activity 时调用，表明 Fragment 已依附到 Activity 上，可在此接收 Activity 传递的参数并做初始化操作，比如获取 Activity 中的数据 。</li><li>创建阶段：<ul><li><code>onCreate()</code>，Fragment 被创建时调用，用于初始化一些资源，像开启线程、读取文件等，但不适合进行与 UI 相关的操作。</li><li><code>onCreateView()</code>，创建 Fragment 的布局 UI，返回一个 View 对象用于在 Activity 中显示该 Fragment。例如，通过 LayoutInflater 将布局文件转换为 View 视图并返回。</li><li><code>onViewCreated()</code>，在视图创建完成后调用，可进行与视图相关的初始化，如给视图中的控件设置监听器等。</li><li><code>onActivityCreated()</code>，在 Activity 的<code>onCreate()</code>方法执行完毕后调用，意味着 Fragment 所依附的 Activity 已初始化完成，此时可进行与 Activity 交互的 UI 操作。</li></ul></li><li>可见阶段：<ul><li><code>onStart()</code>，当 Fragment 可见时调用，此时 Fragment 已和 Activity 关联，但还未处于前台与用户交互。</li><li><code>onResume()</code>，Fragment 处于前台，能与用户交互时调用，可在此执行一些耗时操作或与用户交互相关的逻辑。</li></ul></li><li>不可见阶段：<ul><li><code>onPause()</code>，Fragment 失去焦点，即将暂停时调用，一般用于保存数据、停止动画等，不能进行耗时操作。</li><li><code>onStop()</code>，Fragment 不可见时调用，比如所在 Activity 进入停止状态或 Fragment 被移除并加入后退栈，此时可停止一些较消耗资源的操作。</li></ul></li><li>销毁阶段：<ul><li><code>onDestroyView()</code>，从 Fragment 中删除相应的 UI 界面，此时 Fragment 还未完全销毁。</li><li><code>onDestroy()</code>，Fragment 被销毁时调用，用于释放资源，如关闭线程、释放内存等。</li><li><code>onDetach()</code>，Fragment 和 Activity 解除关联时调用，表明 Fragment 已从 Activity 上分离。</li></ul></li></ol><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p><code>Service</code>是组件，需要在<code>AndroidManifest</code>中注册</p><h2 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h2><p>startService是不与Activity挂钩的，即使Activity关闭，startService也可在后台运行</p><h3 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h3><p>MainActivity3</p><pre><code class="java">package com.example.practice;import android.content.Intent;import android.os.Bundle;import android.view.View;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity3 extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main3);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);    &#125;    public void startService(View view) &#123;        startService(new Intent(this,MyService.class));    &#125;    public void stopService(View view) &#123;        stopService(new Intent(this,MyService.class));    &#125;&#125;</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity3&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        &gt;        &lt;Button            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;startService&quot;            android:onClick=&quot;startService&quot;            /&gt;        &lt;Button            android:text=&quot;stopService&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:onClick=&quot;stopService&quot;            /&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>通过 <code>startService</code> 启动服务时，其生命周期方法调用顺序为：</p><ul><li>**<code>onCreate</code>**：当服务第一次被创建时调用，用于执行一些一次性的初始化操作，比如初始化成员变量、注册广播接收器等。如果服务已经处于运行状态，再次通过 <code>startService</code> 启动时，该方法不会被重复调用。</li><li>**<code>onStartCommand</code>**：每次客户端调用 <code>startService</code> 方法启动服务时都会回调此方法。在这个方法中可以根据传入的 <code>Intent</code> 来确定服务要执行的具体任务，并且可以返回不同的结果来指示系统在服务被系统销毁后如何重启服务 。</li><li>**<code>onDestroy</code>**：当服务不再被使用且需要销毁时调用，比如调用了 <code>stopService</code> 方法，或者所在应用被完全终止等情况。在该方法中，应该释放服务持有的所有资源，如停止线程、注销监听器等。</li></ul><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1742878501499.png" alt="1742878501499"></p><h2 id="bindService"><a href="#bindService" class="headerlink" title="bindService"></a>bindService</h2><p>bindService是与Activity相挂钩的</p><h3 id="生命周期方法调用流程"><a href="#生命周期方法调用流程" class="headerlink" title="生命周期方法调用流程"></a>生命周期方法调用流程</h3><ul><li><strong>首次绑定</strong>：当客户端（如 Activity）通过<code>bindService</code>方法绑定服务时，如果服务尚未创建，系统会先调用服务的<code>onCreate</code>方法进行初始化，比如初始化成员变量、建立数据库连接等；接着调用<code>onBind</code>方法，该方法需返回一个<code>IBinder</code>接口实例，以便客户端与服务进行通信，如获取服务的运行状态或调用服务内的方法 。例如，在音乐播放服务中，可通过返回的<code>IBinder</code>获取播放控制方法。</li><li><strong>多次绑定</strong>：若同一个客户端多次调用<code>bindService</code>绑定同一个服务，<code>onCreate</code>和<code>onBind</code>方法不会再次调用，因为服务已经存在且绑定关系已建立。</li><li><strong>解除绑定</strong>：当客户端调用<code>unbindService</code>方法解除与服务的绑定时，会触发服务的<code>onUnbind</code>方法。该方法可用于处理解绑时的清理工作，如停止一些与客户端交互相关的操作。若此时没有其他客户端与该服务绑定（即所有绑定都已解除），系统会进一步调用<code>onDestroy</code>方法，标志着服务生命周期结束，在这个方法中应释放服务占用的所有资源，如停止线程、关闭文件句柄等。</li><li><strong>特殊情况（允许重绑定）</strong>：如果在<code>onUnbind</code>方法中返回<code>true</code>，表示允许服务被重绑定。当有新的客户端尝试绑定时，服务的<code>onRebind</code>方法会被调用，而不是再次调用<code>onBind</code>方法 。</li></ul><h3 id="与调用者的关系"><a href="#与调用者的关系" class="headerlink" title="与调用者的关系"></a>与调用者的关系</h3><p>绑定的服务与调用它的客户端（如 Activity）关联紧密。当客户端（如 Activity）被销毁（例如用户返回或切换应用） ，若没有解除与服务的绑定，可能会导致内存泄漏等问题。因此，通常在客户端的<code>onDestroy</code>方法中调用<code>unbindService</code>方法来解除绑定，以确保服务能正常结束生命周期。而且，若绑定服务的客户端进程意外终止（如被系统杀死），服务的<code>onUnbind</code>和<code>onDestroy</code>方法也会被调用，以清理服务资源。</p><h3 id="与startService启动方式的结合"><a href="#与startService启动方式的结合" class="headerlink" title="与startService启动方式的结合"></a>与<code>startService</code>启动方式的结合</h3><p>一个服务可以同时被<code>startService</code>和<code>bindService</code>启动。在这种情况下：</p><ul><li>服务的<code>onCreate</code>方法只会在服务首次创建时调用一次；<code>onStartCommand</code>方法会在每次通过<code>startService</code>启动服务时被调用。</li><li>服务的终止需要<code>stopService</code>和所有客户端的<code>unbindService</code>都被调用。即如果先调用<code>unbindService</code>，服务不会立即终止，直到<code>stopService</code>被调用；反之，先调用<code>stopService</code>，服务也不会终止，直到所有绑定都被解除（所有客户端调用<code>unbindService</code>或客户端进程终止） 。</li></ul><h3 id="代码实例-2"><a href="#代码实例-2" class="headerlink" title="代码实例"></a>代码实例</h3><p>Mainactivity3</p><pre><code class="java">package com.example.practice;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.view.View;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity3 extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main3);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);    &#125;    public void bindService(View view) &#123;        bindService(new Intent(this,MyService.class),connection, Context.BIND_AUTO_CREATE);    &#125;    public void unbindService(View view) &#123;        unbindService(connection);    &#125;    private ServiceConnection connection = new ServiceConnection() &#123;        @Override        public void onServiceConnected(ComponentName name, IBinder service) &#123;        &#125;        @Override        public void onServiceDisconnected(ComponentName name) &#123;        &#125;    &#125;;&#125;</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity3&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        &gt;        &lt;Button            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;bindService&quot;            android:onClick=&quot;bindService&quot;            /&gt;        &lt;Button            android:text=&quot;unbindService&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:onClick=&quot;unbindService&quot;            /&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p><img src="/../images/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/1742897635388.png" alt="1742897635388"></p><h1 id="Receiver"><a href="#Receiver" class="headerlink" title="Receiver"></a>Receiver</h1><h2 id="静态注册接收广播"><a href="#静态注册接收广播" class="headerlink" title="静态注册接收广播"></a>静态注册接收广播</h2><p>定义一个广播接收者类</p><pre><code class="java">package com.example.practice;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.util.Log;public class CustomReceiver extends BroadcastReceiver &#123;    public String TAG = &quot;CustomReceiver&quot;;    @Override    public void onReceive(Context context, Intent intent) &#123;        if (intent.getAction() == null) &#123;            Log.d(TAG, &quot;onReceive: 未接收&quot;);        &#125;        else &#123;            Log.d(TAG, &quot;onReceive: 已接收&quot;);        &#125;    &#125;&#125;</code></pre><p>在Manifest中注册广播接收者</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;        android:fullBackupContent=&quot;@xml/backup_rules&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/Theme.Practice&quot;        tools:targetApi=&quot;31&quot;&gt;        &lt;activity            android:name=&quot;.MainActivity&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;receiver            android:exported=&quot;false&quot;            android:name=&quot;.CustomReceiver&quot;&gt;            &lt;intent-filter &gt;                &lt;action android:name=&quot;com.example.practice.receiver_flag_&quot;/&gt;            &lt;/intent-filter&gt;        &lt;/receiver&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>在MainActivity中传入Action，传入的Action要与注册的Action保持一致</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/1743140594734.png" alt="1743140594734"></p><pre><code class="java">package com.example.practice;import android.content.ComponentName;import android.content.Intent;import android.os.Bundle;import android.view.View;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);    &#125;    public void sendAction(View view) &#123;        Intent intent = new Intent();        intent.setAction(ActionUtils.ACTION_FLAG);        ComponentName componentName = new ComponentName(MainActivity.this, CustomReceiver.class);        intent.setComponent(componentName);        sendBroadcast(intent);    &#125;&#125;</code></pre><p>将其设置为显式广播</p><pre><code class="java">ComponentName componentName = new ComponentName(MainActivity.this, CustomReceiver.class);        intent.setComponent(componentName);</code></pre><h3 id="显隐式广播区别"><a href="#显隐式广播区别" class="headerlink" title="显隐式广播区别"></a>显隐式广播区别</h3><ul><li><strong>显式广播</strong>：发送广播时明确指定接收者，通过<code>Intent</code>的<code>setComponent()</code>或<code>setClass()</code>方法指定具体的组件（广播接收器类）。系统会直接将广播消息传递给指定接收者 。比如，<code>Intent intent = new Intent(); intent.setComponent(new ComponentName(&quot;com.example&quot;, &quot;com.example.MyReceiver&quot;)); sendBroadcast(intent);</code> ，这里就明确告知系统该广播由<code>com.example.MyReceiver</code>接收。</li><li><strong>隐式广播</strong>：发送广播时不指定特定接收者，而是设置广播动作（action）等信息。系统根据接收者在<code>AndroidManifest.xml</code>中注册的<code>intent - filter</code>（包含<code>action</code>等过滤条件 ），自动匹配符合条件的广播接收器来传递消息。像<code>Intent intent = new Intent(); intent.setAction(&quot;com.example.MY_ACTION&quot;); sendBroadcast(intent);</code> ，任何注册了<code>com.example.MY_ACTION</code>动作的接收器都可能收到此广播。</li></ul><h3 id="隐式广播版本限制"><a href="#隐式广播版本限制" class="headerlink" title="隐式广播版本限制"></a>隐式广播版本限制</h3><ul><li><strong>Android 8.0（API 级别 26）及以上</strong>：为提升性能和节省电量，系统对隐式广播做了诸多限制。大部分隐式广播无法被静态注册的广播接收器接收 ，仅部分系统白名单内（如<code>ACTION_BOOT_COMPLETED</code> 等少数特定广播 ）或设置特定标志的隐式广播除外。若使用静态注册方式且发送的不是此类特殊隐式广播，就会接收失败。比如，监听网络连接变化的隐式广播，在静态注册下，Android 8.0 及以上系统中可能无法被接收 。</li><li><strong>Android 12 及以上</strong>：对动态注册的广播接收器接收隐式广播进一步限制。当应用处于后台等不活跃状态时，部分隐式广播会被系统筛选掉，以增强安全性和提升性能。例如，动态注册一个监听系统事件的隐式广播接收器，在应用后台时，可能无法接收到相关广播。</li><li><strong>Android 14（API 级别 34）及以上</strong>：如果应用的<code>targetSdkVersion</code>设置为 34 及以上，隐式广播行为有更多限制。隐式<code>Intent</code>只会发送给外部组件（<code>android:exported</code>为<code>true</code> ），若广播接收器所在组件为内部组件（<code>android:exported</code>为<code>false</code> ），则无法接收隐式广播 。</li></ul><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/1743144551187.png" alt="1743144551187"></p><h2 id="动态注册接收广播"><a href="#动态注册接收广播" class="headerlink" title="动态注册接收广播"></a>动态注册接收广播</h2><pre><code class="java">UpdateIpSelectCity updateIpSelectCity = new UpdateIpSelectCity();IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(ActionUtils.ACTION_EQUES_UPDATE_IP);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) &#123;    registerReceiver(updateIpSelectCity, intentFilter, Context.RECEIVER_NOT_EXPORTED);&#125; else &#123;    registerReceiver(updateIpSelectCity, intentFilter);&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Activity，Service等等。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android基础控件</title>
    <link href="http://example.com/2025/03/21/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/"/>
    <id>http://example.com/2025/03/21/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/</id>
    <published>2025-03-21T12:39:10.000Z</published>
    <updated>2025-03-27T15:19:08.901Z</updated>
    
    <content type="html"><![CDATA[<p>TextView，Button，EditText，ImageView，listview，viewpage 等等</p><span id="more"></span><h1 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742483840121.png" alt="1742483840121"></p><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><ul><li><strong>text</strong>：用于设置 TextView 中显示的文本内容。例如：<code>android:text=&quot;Hello World&quot;</code>。</li><li><strong>textSize</strong>：设置文本的大小。可以使用<code>sp</code>（scale-independent pixel）作为单位，如<code>android:textSize=&quot;16sp&quot;</code>。</li><li><strong>textColor</strong>：用于指定文本的颜色。可以使用颜色值或颜色资源，如<code>android:textColor=&quot;#FF0000&quot;</code>表示红色。</li><li><strong>gravity</strong>：设置文本在 TextView 中的对齐方式。常见的值有<code>center</code>（居中）、<code>left</code>（左对齐）、<code>right</code>（右对齐）、<code>top</code>（顶部对齐）、<code>bottom</code>（底部对齐）等。例如：<code>android:gravity=&quot;center&quot;</code>。</li><li><strong>background</strong>：设置 TextView 的背景颜色或背景图片。如<code>android:background=&quot;#CCCCCC&quot;</code>设置背景为灰色。</li></ul><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><code>setText(CharSequence text)</code>：动态设置 TextView 的文本内容。例如：<code>textView.setText(&quot;New Text&quot;);</code>。</li><li><code>getText()</code>：获取 TextView 中当前显示的文本内容。</li><li><code>setTextColor(int color)</code>：动态设置文本的颜色。例如：<code>textView.setTextColor(Color.BLUE);</code>。</li><li><code>setTextSize(float size)</code>：动态设置文本的大小。单位是<code>sp</code>，例如：<code>textView.setTextSize(18);</code>。</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>在布局文件中定义一个 TextView：</p><pre><code class="xml">&lt;TextView    android:id=&quot;@+id/textView&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;This is a TextView&quot;    android:textSize=&quot;20sp&quot;    android:textColor=&quot;#000000&quot;    android:gravity=&quot;center&quot;/&gt;</code></pre><p><strong>java获取控件对象：</strong></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742483655602.png" alt="1742483655602"></p><p>java设置的文本内容会覆盖xml设置的文本内容。</p><p>正规开发需要把文本内容，颜色写在<code>values</code>里，然后在布局中引用。</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484175236.png" alt="1742484175236"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484133492.png" alt="1742484133492"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484233819.png" alt="1742484233819"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484244902.png" alt="1742484244902"></p><h2 id="设置带阴影的TextView"><a href="#设置带阴影的TextView" class="headerlink" title="设置带阴影的TextView"></a>设置带阴影的TextView</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484345432.png" alt="1742484345432"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742484487161.png" alt="1742484487161"></p><pre><code class="xml">&lt;LinearLayout       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;match_parent&quot;       android:gravity=&quot;center&quot;&gt;       &lt;TextView           android:layout_width=&quot;200dp&quot;           android:layout_height=&quot;200dp&quot;           android:gravity=&quot;center_horizontal&quot;           android:text=&quot;hello world&quot;           android:textSize=&quot;30sp&quot;           android:shadowColor=&quot;#FFFF0000&quot;           android:shadowRadius=&quot;3.0&quot;           android:shadowDx=&quot;20&quot;           android:shadowDy=&quot;20&quot;           /&gt;   &lt;/LinearLayout&gt;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742485090166.png" alt="1742485090166"></p><h2 id="实现跑马灯效果的TextView"><a href="#实现跑马灯效果的TextView" class="headerlink" title="实现跑马灯效果的TextView"></a>实现跑马灯效果的TextView</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742485123868.png" alt="1742485123868"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742486325822.png" alt="1742486325822"></p><p>java重写textview，让文本框时刻保持点击</p><pre><code class="java">package mytextview;import android.content.Context;import android.util.AttributeSet;import android.widget.TextView;import androidx.annotation.Nullable;public class MyTextView extends TextView &#123;    public MyTextView(Context context) &#123;        super(context);    &#125;    public MyTextView(Context context, @Nullable AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    @Override    public boolean isFocused() &#123;        return true;    &#125;&#125;</code></pre><p>在Layout中引用</p><pre><code class="xml"> &lt;LinearLayout       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;match_parent&quot;       android:gravity=&quot;center&quot;&gt;       &lt;mytextview.MyTextView           android:layout_width=&quot;match_parent&quot;           android:layout_height=&quot;200dp&quot;           android:gravity=&quot;center&quot;           android:text=&quot;@string/TV_one&quot;           android:textSize=&quot;30sp&quot;           android:shadowColor=&quot;#FFFF0000&quot;           android:shadowRadius=&quot;3.0&quot;           android:shadowDx=&quot;20&quot;           android:singleLine=&quot;true&quot;           android:focusable=&quot;true&quot;           android:focusableInTouchMode=&quot;true&quot;           android:ellipsize=&quot;marquee&quot;           android:marqueeRepeatLimit=&quot;marquee_forever&quot;           android:shadowDy=&quot;20&quot;           /&gt;   &lt;/LinearLayout&gt;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-21%20000059.png"></p><h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><h2 id="一、根据按钮状态改变背景形状和背景颜色"><a href="#一、根据按钮状态改变背景形状和背景颜色" class="headerlink" title="一、根据按钮状态改变背景形状和背景颜色"></a>一、根据按钮状态改变背景形状和背景颜色</h2><h3 id="1-在drawable目录下新建一个xml文件"><a href="#1-在drawable目录下新建一个xml文件" class="headerlink" title="1. 在drawable目录下新建一个xml文件"></a>1. 在drawable目录下新建一个xml文件</h3><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742562172701.png" alt="1742562172701"></p><h3 id="2-在item中设置不同的图片效果"><a href="#2-在item中设置不同的图片效果" class="headerlink" title="2. 在item中设置不同的图片效果"></a>2. 在<code>item</code>中设置不同的图片效果</h3><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742561025494.png" alt="1742561025494"></p><pre><code class="xml">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:drawable=&quot;@drawable/baseline_airplanemode_active_24&quot; android:state_pressed=&quot;true&quot;/&gt;    &lt;item android:drawable=&quot;@drawable/baseline_airport_shuttle_24&quot; /&gt;&lt;/selector&gt;</code></pre><h3 id="3-设置Button的背景属性"><a href="#3-设置Button的背景属性" class="headerlink" title="3. 设置Button的背景属性"></a>3. 设置Button的背景属性</h3><pre><code class="xml">&lt;LinearLayout       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;match_parent&quot;       android:gravity=&quot;center&quot;&gt;       &lt;Button           android:layout_width=&quot;200dp&quot;           android:layout_height=&quot;200dp&quot;           android:background=&quot;@drawable/btn_selector&quot;           &gt;       &lt;/Button&gt;   &lt;/LinearLayout&gt;</code></pre><p>未点击</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563002757.png" alt="1742563002757"></p><p>点击且未松开</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563034429.png" alt="1742563034429"></p><h2 id="二、Button事件处理"><a href="#二、Button事件处理" class="headerlink" title="二、Button事件处理"></a>二、Button事件处理</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563266418.png" alt="1742563266418"></p><h3 id="1-在Layout中给Button取个id"><a href="#1-在Layout中给Button取个id" class="headerlink" title="1. 在Layout中给Button取个id"></a>1. 在Layout中给Button取个id</h3><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563433482.png" alt="1742563433482"></p><h3 id="2-在java中获取该Button"><a href="#2-在java中获取该Button" class="headerlink" title="2. 在java中获取该Button"></a>2. 在java中获取该Button</h3><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563447999.png" alt="1742563447999"></p><h3 id="3-设置事件"><a href="#3-设置事件" class="headerlink" title="3. 设置事件"></a>3. 设置事件</h3><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563497142.png" alt="1742563497142"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563512360.png" alt="1742563512360"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742563533043.png" alt="1742563533043"></p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><code>setOnClickListener(View.OnClickListener listener)</code>：为按钮设置点击事件监听器，当按钮被点击时，会触发监听器中的<code>onClick</code>方法。例如：</li></ul><pre><code class="java">button.setOnClickListener(new View.OnClickListener() &#123;    @Override    public void onClick(View v) &#123;        // 在这里编写按钮点击后的逻辑代码    &#125;&#125;);</code></pre><ul><li><code>setText(CharSequence text)</code>：动态设置按钮上显示的文本内容，如<code>button.setText(&quot;新的文本&quot;)</code>。</li><li><code>setEnabled(boolean enabled)</code>：设置按钮是否可用，<code>true</code>表示可用，<code>false</code>表示不可用。例如<code>button.setEnabled(false)</code>会使按钮变灰且无法点击。</li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><p>在布局文件中定义一个 Button：</p><pre><code class="xml">&lt;Button    android:id=&quot;@+id/button&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;点击我&quot;    android:textSize=&quot;20sp&quot;    android:textColor=&quot;#FFFFFF&quot;    android:background=&quot;#007BFF&quot; /&gt;</code></pre><p>在 Java 或 Kotlin 代码中获取并操作 Button：</p><pre><code class="java">public class MainActivity extends AppCompatActivity &#123;    private Button button;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        button = findViewById(R.id.button);        button.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                // 弹出一个Toast提示                Toast.makeText(MainActivity.this, &quot;按钮被点击了&quot;, Toast.LENGTH_SHORT).show();            &#125;        &#125;);    &#125;&#125;</code></pre><h1 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742564582585.png" alt="1742564582585"></p><h2 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h2><ol><li><strong>hint</strong>：设置输入框内的提示文本，当输入框没有内容时显示，提示用户应该输入的内容，例如<code>android:hint=&quot;请输入用户名&quot;</code>。</li><li><strong>textSize</strong>：指定输入文本的大小，单位一般为<code>sp</code>，如<code>android:textSize=&quot;16sp&quot;</code>。</li><li><strong>textColor</strong>：设置输入文本的颜色，例如<code>android:textColor=&quot;#333333&quot;</code>。</li><li><strong>background</strong>：用于设置 EditText 的背景，既可以是颜色值，也可以是一张图片。默认情况下，EditText 有一个带有边框的背景样式。如果想去掉默认背景，可以设置为<code>android:background=&quot;@null&quot;</code>。</li><li><strong>inputType</strong>：规定输入的类型，如文本、数字、密码等。例如，<code>android:inputType=&quot;textPassword&quot;</code>用于输入密码，会隐藏输入的内容；<code>android:inputType=&quot;number&quot;</code>限制只能输入数字。</li><li><strong>maxLength</strong>：限制输入的最大长度，如<code>android:maxLength=&quot;10&quot;</code>表示最多能输入 10 个字符。</li><li><strong>imeOptions</strong>：设置软键盘的一些选项，如<code>android:imeOptions=&quot;actionDone&quot;</code>，会将软键盘的 “完成” 按钮显示为 “Done”，用户点击该按钮可以完成输入。</li></ol><h2 id="EditText实例操作"><a href="#EditText实例操作" class="headerlink" title="EditText实例操作"></a>EditText实例操作</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742567980479.png" alt="1742567980479"></p><pre><code class="xml">&lt;LinearLayout       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;match_parent&quot;       android:orientation=&quot;vertical&quot;       android:gravity=&quot;center&quot;       &gt;       &lt;EditText           android:id=&quot;@+id/User&quot;           android:layout_width=&quot;350dp&quot;           android:layout_height=&quot;75dp&quot;           android:hint=&quot;请输入用户名&quot;           android:drawablePadding=&quot;10dp&quot;           android:paddingLeft=&quot;20dp&quot;           android:drawableLeft=&quot;@drawable/baseline_account_circle_24&quot;           android:background=&quot;@color/material_dynamic_secondary80&quot;/&gt;       &lt;TextView           android:layout_width=&quot;30dp&quot;           android:layout_height=&quot;30dp&quot;/&gt;       &lt;EditText           android:id=&quot;@+id/Password&quot;           android:layout_width=&quot;350dp&quot;           android:layout_height=&quot;75dp&quot;           android:hint=&quot;请输入密码&quot;           android:drawableLeft=&quot;@drawable/baseline_lock_24&quot;           android:paddingLeft=&quot;20dp&quot;           android:inputType=&quot;numberPassword&quot;           android:drawablePadding=&quot;10dp&quot;           android:background=&quot;@color/material_dynamic_secondary80&quot;/&gt;       &lt;TextView           android:layout_width=&quot;20dp&quot;           android:layout_height=&quot;20dp&quot;/&gt;       &lt;Button           android:text=&quot;登入&quot;           android:layout_width=&quot;100dp&quot;           android:layout_height=&quot;50dp&quot;           android:id=&quot;@+id/bt&quot;/&gt;   &lt;/LinearLayout&gt;</code></pre><pre><code class="kotlin">package com.example.myapplicationimport android.os.Bundleimport android.util.Logimport android.util.LogPrinterimport android.widget.Buttonimport android.widget.EditTextimport androidx.activity.enableEdgeToEdgeimport androidx.appcompat.app.AppCompatActivityimport androidx.core.view.ViewCompatimport androidx.core.view.WindowInsetsCompatimport java.util.logging.Loggerclass MainActivity : AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        enableEdgeToEdge()        setContentView(R.layout.activity_main)        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) &#123; v, insets -&gt;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        &#125;        val et1 = findViewById&lt;EditText&gt;(R.id.User)        val et2 = findViewById&lt;EditText&gt;(R.id.Password)        val bt1 = findViewById&lt;Button&gt;(R.id.bt)        bt1.setOnClickListener &#123;            Log.e(&quot;leo&quot;,&quot;账号&quot; + et1.getText().toString())            Log.e(&quot;leo&quot;,&quot;密码&quot; + et2.getText().toString())            Log.e(&quot;leo&quot;,&quot;hhhh,你的号被我盗了&quot;)        &#125;    &#125;&#125;</code></pre><h1 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742568167500.png" alt="1742568167500"></p><h2 id="缩放类型"><a href="#缩放类型" class="headerlink" title="缩放类型"></a>缩放类型</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742568189407.png" alt="1742568189407"></p><h1 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742627014974.png" alt="1742627014974"></p><pre><code class="java">package com.example.practice;import android.os.Bundle;import android.view.View;import android.widget.ProgressBar;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    private ProgressBar pb1;    private ProgressBar pb2;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        pb1 = findViewById(R.id.pb1);        pb2 = findViewById(R.id.pb2);    &#125;    public void LeoClick(View view) &#123;        if (pb1.getVisibility() == View.GONE)&#123;            pb1.setVisibility(View.VISIBLE);        &#125;        else &#123;            pb1.setVisibility(View.GONE);        &#125;    &#125;    public void LeoClick2(View view) &#123;        int progress = pb2.getProgress();        progress += 10;        pb2.setProgress(progress);    &#125;&#125;</code></pre><pre><code class="xml">&lt;ProgressBar            android:id=&quot;@+id/pb1&quot;            android:layout_width=&quot;50dp&quot;            android:layout_height=&quot;50dp&quot;            /&gt;        &lt;Button            android:id=&quot;@+id/bt1&quot;            android:text=&quot;显示隐藏进度条&quot;            android:textSize=&quot;10dp&quot;            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot;            android:onClick=&quot;LeoClick&quot;             /&gt;        &lt;ProgressBar            android:id=&quot;@+id/pb2&quot;            android:layout_width=&quot;200dp&quot;            android:layout_height=&quot;30dp&quot;            android:max=&quot;100&quot;            style=&quot;@style/Widget.AppCompat.ProgressBar.Horizontal&quot;/&gt;        &lt;Button            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot;            android:text=&quot;模拟下载&quot;            android:textSize=&quot;10dp&quot;            android:onClick=&quot;LeoClick2&quot;/&gt;</code></pre><p><strong>代码解释</strong> ：</p><p>xml中</p><ol><li>第一个 <code>ProgressBar</code>（<code>pb1</code>）：<ul><li><code>android:id=&quot;@+id/pb1&quot;</code>：为这个进度条组件定义了一个唯一的标识符 <code>pb1</code>，方便在 Java 代码中通过这个 ID 来引用它。</li><li><code>android:layout_width=&quot;50dp&quot;</code> 和 <code>android:layout_height=&quot;50dp&quot;</code>：设置了进度条的宽度和高度都为 50 密度像素（dp）。这个进度条默认是圆形的不确定模式（因为没有设置特定的样式来改变它），用于显示操作正在进行但不明确具体进度的情况。</li></ul></li><li>第一个 <code>Button</code>（<code>bt1</code>）：<ul><li><code>android:id=&quot;@+id/bt1&quot;</code>：给按钮定义了 ID 为 <code>bt1</code>。</li><li><code>android:text=&quot;显示隐藏进度条&quot;</code>：设置按钮上显示的文本内容为 “显示隐藏进度条”。</li><li><code>android:textSize=&quot;10dp&quot;</code>：指定按钮上文本的大小为 10 密度像素。</li><li><code>android:layout_width=&quot;100dp&quot;</code> 和 <code>android:layout_height=&quot;50dp&quot;</code>：设置按钮的宽度为 100 密度像素，高度为 50 密度像素。</li><li><code>android:onClick=&quot;LeoClick&quot;</code>：指定当按钮被点击时，会调用在 <code>MainActivity</code> 中定义的名为 <code>LeoClick</code> 的方法。</li></ul></li><li>第二个 <code>ProgressBar</code>（<code>pb2</code>）：<ul><li><code>android:id=&quot;@+id/pb2&quot;</code>：定义了进度条的 ID 为 <code>pb2</code>。</li><li><code>android:layout_width=&quot;200dp&quot;</code> 和 <code>android:layout_height=&quot;30dp&quot;</code>：设置进度条的宽度为 200 密度像素，高度为 30 密度像素。</li><li><code>android:max=&quot;100&quot;</code>：设置这个进度条的最大值为 100，用于表示进度的范围。</li><li><code>style=&quot;@style/Widget.AppCompat.ProgressBar.Horizontal&quot;</code>：应用了 <code>AppCompat</code> 库中定义的水平进度条样式，使进度条以水平的形式展示进度。</li></ul></li><li>第二个 <code>Button</code>（<code>bt2</code>）：<ul><li><code>android:layout_width=&quot;100dp&quot;</code> 和 <code>android:layout_height=&quot;50dp&quot;</code>：设置按钮的宽度为 100 密度像素，高度为 50 密度像素。</li><li><code>android:text=&quot;模拟下载&quot;</code>：设置按钮上显示的文本为 “模拟下载”。</li><li><code>android:textSize=&quot;10dp&quot;</code>：指定按钮文本的大小为 10 密度像素。</li><li><code>android:onClick=&quot;LeoClick2&quot;</code>：表示当按钮被点击时，会调用 <code>MainActivity</code> 中的 <code>LeoClick2</code> 方法。</li></ul></li></ol><p>Java代码中</p><ol><li>成员变量声明：</li></ol><ul><li><code>private ProgressBar pb1;</code> 和 <code>private ProgressBar pb2;</code>：声明了两个私有类型的 <code>ProgressBar</code> 变量 <code>pb1</code> 和 <code>pb2</code>，用于在整个活动类中引用布局文件中的两个进度条组件。</li></ul><ol start="2"><li><code>LeoClick</code> 方法：</li></ol><ul><li><code>public void LeoClick(View view)</code>：定义了一个公共的方法 <code>LeoClick</code>，它接受一个 <code>View</code> 参数（这个参数通常是触发该方法的视图，在这里就是点击的按钮 <code>bt1</code>）。</li><li>方法体内部通过 <code>if-else</code> 语句判断 <code>pb1</code> 的可见性状态：如果 <code>pb1</code> 是隐藏的（<code>View.GONE</code>），就将其设置为可见（<code>View.VISIBLE</code>）；否则，将其设置为隐藏。</li></ul><ol start="3"><li><code>LeoClick2</code> 方法：</li></ol><ul><li><code>public void LeoClick2(View view)</code>：定义了一个公共的方法 <code>LeoClick2</code>，接受一个 <code>View</code> 参数（点击的按钮 <code>bt2</code>）。</li><li>在方法体中，首先获取 <code>pb2</code> 的当前进度值（<code>int progress = pb2.getProgress();</code>），然后将进度值增加 10（<code>progress += 10;</code>），最后通过 <code>pb2.setProgress(progress);</code> 将更新后的进度值设置到 <code>pb2</code> 进度条上，从而实现模拟下载进度增加的效果。</li></ul><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742628984801.png" alt="1742628984801"></p><h1 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742629608998.png" alt="1742629608998"></p><h2 id="NotificationChannel"><a href="#NotificationChannel" class="headerlink" title="NotificationChannel"></a>NotificationChannel</h2><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742631039499.png" alt="1742631039499"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742631226236.png" alt="1742631226236"></p><h3 id="创建通知的步骤"><a href="#创建通知的步骤" class="headerlink" title="创建通知的步骤"></a>创建通知的步骤</h3><h4 id="1-创建通知渠道（Android-8-0-及以上）"><a href="#1-创建通知渠道（Android-8-0-及以上）" class="headerlink" title="1. 创建通知渠道（Android 8.0 及以上）"></a>1. 创建通知渠道（Android 8.0 及以上）</h4><p>从 Android 8.0（API 级别 26）开始，必须为通知创建渠道，以便用户对通知进行分类管理。</p><pre><code class="java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;    CharSequence name = &quot;渠道名称&quot;;    String description = &quot;渠道描述&quot;;    int importance = NotificationManager.IMPORTANCE_DEFAULT;    NotificationChannel channel = new NotificationChannel(&quot;channel_id&quot;, name, importance);    channel.setDescription(description);    NotificationManager notificationManager = getSystemService(NotificationManager.class);    notificationManager.createNotificationChannel(channel);&#125;</code></pre><h4 id="2-创建通知构建器"><a href="#2-创建通知构建器" class="headerlink" title="2. 创建通知构建器"></a>2. 创建通知构建器</h4><p>使用 <code>NotificationCompat.Builder</code> 来构建通知内容。</p><pre><code class="java">NotificationCompat.Builder builder = new NotificationCompat.Builder(this, &quot;channel_id&quot;)        .setSmallIcon(R.drawable.notification_icon)        .setContentTitle(&quot;通知标题&quot;)        .setContentText(&quot;通知内容&quot;)        .setPriority(NotificationCompat.PRIORITY_DEFAULT);</code></pre><h4 id="3-创建通知意图（可选）"><a href="#3-创建通知意图（可选）" class="headerlink" title="3. 创建通知意图（可选）"></a>3. 创建通知意图（可选）</h4><p>若希望用户点击通知后打开特定的界面，需创建 <code>PendingIntent</code>。</p><pre><code class="java">Intent intent = new Intent(this, MainActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);builder.setContentIntent(pendingIntent);</code></pre><h4 id="4-发送通知"><a href="#4-发送通知" class="headerlink" title="4. 发送通知"></a>4. 发送通知</h4><p>借助 <code>NotificationManager</code> 发送通知。</p><pre><code class="java">NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);int notificationId = 1;notificationManager.notify(notificationId, builder.build());</code></pre><h3 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h3><ul><li><strong>普通通知</strong>：显示标题、内容和小图标，是最常见的通知类型。</li><li><strong>进度通知</strong>：可显示操作进度，如文件下载进度。</li></ul><pre><code class="java">NotificationCompat.Builder builder = new NotificationCompat.Builder(this, &quot;channel_id&quot;)        .setContentTitle(&quot;文件下载&quot;)        .setContentText(&quot;正在下载...&quot;)        .setSmallIcon(R.drawable.download_icon)        .setPriority(NotificationCompat.PRIORITY_LOW)        .setProgress(100, 0, false);// 更新进度builder.setProgress(100, progress, false);notificationManager.notify(notificationId, builder.build());</code></pre><ul><li><strong>大视图通知</strong>：能显示更多内容，如长文本、图片等。</li></ul><pre><code class="java">NotificationCompat.BigTextStyle bigTextStyle = new NotificationCompat.BigTextStyle();bigTextStyle.bigText(&quot;这是一段很长的文本内容...&quot;);builder.setStyle(bigTextStyle);</code></pre><h3 id="管理通知"><a href="#管理通知" class="headerlink" title="管理通知"></a>管理通知</h3><ul><li><strong>取消通知</strong>：使用 <code>NotificationManager</code> 的 <code>cancel</code> 方法取消单个通知，或使用 <code>cancelAll</code> 方法取消所有通知。</li></ul><pre><code class="java">notificationManager.cancel(notificationId);</code></pre><ul><li><strong>更新通知</strong>：再次调用 <code>notify</code> 方法，使用相同的通知 ID 即可更新通知内容。</li></ul><pre><code class="java">builder.setContentText(&quot;更新后的通知内容&quot;);notificationManager.notify(notificationId, builder.build());</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>要实现一个通知必须要设置的三个通知内容：</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742638186444.png" alt="1742638186444"></p><p>其中小图标格式：</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-22%20180800.png"></p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><pre><code class="java">package com.example.practice;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.os.Build;import android.os.Bundle;import android.view.View;import android.widget.ProgressBar;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.NotificationCompat;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    private NotificationManager manager;    private Notification notification;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;            NotificationChannel channel = new NotificationChannel(&quot;leo&quot;, &quot;测试通知&quot;, NotificationManager.IMPORTANCE_HIGH);            manager.createNotificationChannel(channel);        &#125;        notification = new NotificationCompat.Builder(this, &quot;leo&quot;)                .setContentTitle(&quot;官方通知&quot;)                .setContentText(&quot;hello world&quot;)                .setSmallIcon(R.drawable.ic_launcher_foreground)                .build();    &#125;    public void fire_notification(View view) &#123;        manager.notify(1, notification);    &#125;    public void cancel_notification(View view) &#123;        manager.cancel(1);    &#125;&#125;</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center&quot;&gt;        &lt;Button            android:id=&quot;@+id/bt3&quot;            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot;            android:text=&quot;发起通知&quot;            android:textSize=&quot;10dp&quot;            android:onClick=&quot;fire_notification&quot;/&gt;        &lt;TextView            android:layout_width=&quot;10dp&quot;            android:layout_height=&quot;20dp&quot;/&gt;        &lt;Button            android:id=&quot;@+id/bt4&quot;            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot;            android:text=&quot;取消通知&quot;            android:textSize=&quot;10dp&quot;            android:onClick=&quot;cancel_notification&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742638439766.png" alt="1742638439766"></p><h1 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742647683114.png" alt="1742647683114"></p><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><ol><li>在布局文件中添加 Toolbar：</li></ol><pre><code class="xml">&lt;androidx.appcompat.widget.Toolbar    android:id=&quot;@+id/toolbar&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;?attr/actionBarSize&quot;    android:background=&quot;?attr/colorPrimary&quot;    android:elevation=&quot;4dp&quot;    android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt;    &lt;!-- 可以在这里添加自定义的视图或按钮 --&gt;&lt;/androidx.appcompat.widget.Toolbar&gt;</code></pre><ol start="2"><li>设置Toolbar点击事件</li></ol><pre><code class="java">tb = findViewById(R.id.tb);        tb.setNavigationOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                Log.e(&quot;leo&quot;, &quot;hello world&quot;);            &#125;        &#125;);</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742649370766.png" alt="1742649370766"></p><h1 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742649103353.png" alt="1742649103353"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742649344436.png" alt="1742649344436"></p><h2 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h2><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><pre><code class="java">package com.example.practice;import android.app.AlertDialog;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.content.DialogInterface;import android.os.Build;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.ProgressBar;import android.widget.TextView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.appcompat.widget.Toolbar;import androidx.core.app.NotificationCompat;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    private  View dialog_view;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        dialog_view = getLayoutInflater().inflate(R.layout.dialog_view, null);    &#125;    public void leoClick(View view) &#123;        AlertDialog.Builder dialog = new AlertDialog.Builder(this);        dialog.setIcon(R.mipmap.ic_launcher_round)                .setTitle(&quot;你好！！！&quot;)                .setMessage(&quot;今天天气怎么样&quot;)                .setView(dialog_view)                .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123;                    @Override                    public void onClick(DialogInterface dialog, int which) &#123;                        Log.e(&quot;leo&quot;, &quot;onClick: 点击了确定&quot;);                    &#125;                &#125;)                .setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123;                    @Override                    public void onClick(DialogInterface dialog, int which) &#123;                        Log.e(&quot;leo&quot;, &quot;onClick: 点击了取消&quot;);                    &#125;                &#125;)                .setNeutralButton(&quot;查看详细&quot;, new DialogInterface.OnClickListener() &#123;                    @Override                    public void onClick(DialogInterface dialog, int which) &#123;                        Log.e(&quot;leo&quot;, &quot;onClick: 点击了查看详细信息&quot;);                    &#125;                &#125;)                .create()                .show();    &#125;&#125;</code></pre><p><strong>注意：</strong>在链式构建dialog的时候create()，和show()的位置不能改变，因为它们的返回值不是builder。</p><h3 id="自定义布局"><a href="#自定义布局" class="headerlink" title="自定义布局"></a>自定义布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    android:gravity=&quot;center&quot;&gt;    &lt;ImageView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:src=&quot;@drawable/ic_launcher_foreground&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:gravity=&quot;center&quot;        android:text=&quot;你找到了全世界&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h3 id="主布局"><a href="#主布局" class="headerlink" title="主布局"></a>主布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;&gt;        &lt;Button            android:onClick=&quot;leoClick&quot;            android:layout_marginTop=&quot;10dp&quot;            android:textSize=&quot;10dp&quot;            android:text=&quot;显示dialog&quot;            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742651592045.png" alt="1742651592045"></p><h1 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742653749151.png" alt="1742653749151"></p><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><h3 id="java代码-1"><a href="#java代码-1" class="headerlink" title="java代码"></a>java代码</h3><pre><code class="java">package com.example.practice;import android.app.AlertDialog;import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.content.DialogInterface;import android.os.Build;import android.os.Bundle;import android.util.Log;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.PopupWindow;import android.widget.ProgressBar;import android.widget.TextView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.appcompat.widget.Toolbar;import androidx.core.app.NotificationCompat;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);    &#125;    public void leoClick(View view) &#123;        View popupview = getLayoutInflater().inflate(R.layout.poppupwindow_view, null);        PopupWindow popupwindow = new PopupWindow(popupview,                ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT,true);        popupwindow.showAsDropDown(view,-300,0);        Button bt1 = popupview.findViewById(R.id.bt1);        bt1.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                Log.e(&quot;leo&quot;, &quot;onClick: 欢迎来到北京&quot;);                popupwindow.dismiss();            &#125;        &#125;);    &#125;&#125;</code></pre><p>设置是否获取焦点可以让PopupWindow在点击空白处时自动关闭</p><h3 id="PopupWindow布局"><a href="#PopupWindow布局" class="headerlink" title="PopupWindow布局"></a>PopupWindow布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;    android:background=&quot;@drawable/ic_launcher_background&quot;&gt;    &lt;ImageView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:src=&quot;@drawable/ic_launcher_foreground&quot;/&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:gravity=&quot;center&quot;        android:text=&quot;你找到了全世界&quot;/&gt;    &lt;Button        android:id=&quot;@+id/bt1&quot;        android:layout_marginLeft=&quot;10dp&quot;        android:text=&quot;北京&quot;        android:gravity=&quot;center&quot;        android:textSize=&quot;10dp&quot;        android:layout_width=&quot;80dp&quot;        android:layout_height=&quot;40dp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h3 id="主布局-1"><a href="#主布局-1" class="headerlink" title="主布局"></a>主布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;        android:gravity=&quot;center_horizontal&quot;&gt;        &lt;Button            android:onClick=&quot;leoClick&quot;            android:layout_marginTop=&quot;10dp&quot;            android:textSize=&quot;10dp&quot;            android:text=&quot;显示Popupwindow&quot;            android:layout_width=&quot;100dp&quot;            android:layout_height=&quot;50dp&quot; /&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742655190094.png" alt="1742655190094"></p><h1 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742717494138.png" alt="1742717494138"></p><h2 id="代码实例（未优化）"><a href="#代码实例（未优化）" class="headerlink" title="代码实例（未优化）"></a>代码实例（未优化）</h2><h3 id="activity-main"><a href="#activity-main" class="headerlink" title="activity_main"></a>activity_main</h3><pre><code class="java">package com.example.practice;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.AdapterView;import android.widget.ListView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123;    private List&lt;Bean&gt; data = new ArrayList&lt;&gt;();    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        // 循环 100 次，创建 100 个 Bean 对象并设置其名称，然后添加到 data 列表中        for (int i = 0;i &lt; 100;i ++)&#123;            Bean bean = new Bean();            bean.setName(&quot;栏目&quot; + (i + 1));            data.add(bean);        &#125;        // 通过 findViewById 方法获取布局文件中 id 为 lv 的 ListView 实例        ListView listView = findViewById(R.id.lv);        // 为 ListView 设置适配器 MyAdapter，传入数据列表 data 和当前活动的上下文 this        listView.setAdapter(new MyAdapter(data,this));        // 为 ListView 设置项点击监听器        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;            @Override            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;                Log.e(&quot;zxy&quot;, &quot;onItemClick: &quot; + position );            &#125;        &#125;);    &#125;&#125;</code></pre><h3 id="MyAdapter"><a href="#MyAdapter" class="headerlink" title="MyAdapter"></a>MyAdapter</h3><pre><code class="java">package com.example.practice;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.TextView;import java.util.List;public class MyAdapter extends BaseAdapter &#123;    // 声明一个用于存储数据的 List，泛型为 Bean 类型    private List&lt;Bean&gt; data;    // 声明一个 Context 对象，用于获取系统资源等    private Context context;    // 构造函数，传入数据列表 data 和上下文 context    public MyAdapter(List&lt;Bean&gt; data,Context context) &#123;        this.context = context;        this.data = data;    &#125;    // 获取数据列表的大小，即列表项的数量    @Override    public int getCount() &#123;        return data.size();    &#125;    // 获取指定位置的列表项对象，这里返回 null（可能需要根据实际情况修改）    @Override    public Object getItem(int position) &#123;        return null;    &#125;    // 获取指定位置的列表项的唯一标识，这里简单返回位置索引    @Override    public long getItemId(int position) &#123;        return position;    &#125;    // 获取每个列表项的视图    @Override    public View getView(int position, View convertView, ViewGroup parent) &#123;        // 如果 convertView 为空，说明是第一次创建该列表项视图        if (convertView == null) &#123;            // 使用 LayoutInflater 从 context 中加载 list_item.xml 布局文件，并将其转换为视图对象            convertView = LayoutInflater.from(context).inflate(R.layout.list_item, parent, false);        &#125;        // 在 convertView 中找到 id 为 tv 的 TextView 实例        TextView textView = convertView.findViewById(R.id.tv);        // 设置 TextView 的文本为 data 列表中指定位置的 Bean 对象的名称        textView.setText(data.get(position).getName());        return convertView;    &#125;&#125;</code></pre><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><pre><code class="java">package com.example.practice;public class Bean &#123;    String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;</code></pre><h3 id="主布局-2"><a href="#主布局-2" class="headerlink" title="主布局"></a>主布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;       &lt;ListView           android:layout_width=&quot;match_parent&quot;           android:layout_height=&quot;match_parent&quot;           android:id=&quot;@+id/lv&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><h3 id="item布局"><a href="#item布局" class="headerlink" title="item布局"></a>item布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:id=&quot;@+id/tv&quot;        android:textSize=&quot;30sp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><h3 id="MyAdapter-1"><a href="#MyAdapter-1" class="headerlink" title="MyAdapter"></a>MyAdapter</h3><pre><code class="java">package com.example.practice;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.TextView;import java.util.List;public class MyAdapter extends BaseAdapter &#123;    private List&lt;Bean&gt; data;    private Context context;    public MyAdapter(List&lt;Bean&gt; data,Context context) &#123;        this.context = context;        this.data = data;    &#125;    @Override    public int getCount() &#123;        return data.size();    &#125;    @Override    public Object getItem(int position) &#123;        return null;    &#125;    @Override    public long getItemId(int position) &#123;        return position;    &#125;    @Override    public View getView(int position, View convertView, ViewGroup parent) &#123;        ViewHolder viewHolder;        if (convertView == null) &#123;            viewHolder = new ViewHolder();            convertView = LayoutInflater.from(context).inflate(R.layout.list_item, parent, false);            viewHolder.textView = convertView.findViewById(R.id.tv);            convertView.setTag(viewHolder);        &#125;        else &#123;            viewHolder = (ViewHolder) convertView.getTag();        &#125;        viewHolder.textView.setText(data.get(position).getName());        return convertView;    &#125;    private final class ViewHolder &#123;        TextView textView;    &#125;&#125;</code></pre><h1 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h1><p>使用前要导入recyclerview依赖包</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742718997143.png" alt="1742718997143"></p><h2 id="代码实例-2"><a href="#代码实例-2" class="headerlink" title="代码实例"></a>代码实例</h2><h3 id="activity-main-1"><a href="#activity-main-1" class="headerlink" title="activity_main"></a>activity_main</h3><pre><code class="java">package com.example.practice;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.AdapterView;import android.widget.LinearLayout;import android.widget.ListView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import androidx.recyclerview.widget.GridLayoutManager;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123;    private List&lt;Bean&gt; data = new ArrayList&lt;&gt;();    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        for (int i = 0;i &lt; 100;i ++)&#123;            Bean bean = new Bean();            bean.setName(&quot;栏目&quot; + (i + 1));            data.add(bean);        &#125;        RecyclerView recyclerView = findViewById(R.id.rv);      LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this);      recyclerView.setLayoutManager(linearLayoutManager);//        GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 2);//        recyclerView.setLayoutManager(gridLayoutManager);        MyAdapter myAdapter = new MyAdapter(data,this);        recyclerView.setAdapter(myAdapter);        myAdapter.setRecyclerItemClickListener(new MyAdapter.OnRecyclerItemClickListener() &#123;            @Override            public void onRecyclerItemClick(int position) &#123;                Log.e(&quot;zxy&quot;, &quot;onRecyclerItemClick: &quot; + position );            &#125;        &#125;);    &#125;&#125;</code></pre><h3 id="MyAdapter-2"><a href="#MyAdapter-2" class="headerlink" title="MyAdapter"></a>MyAdapter</h3><pre><code class="java">package com.example.practice;import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import java.util.List;public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123;    private  List&lt;Bean&gt; data;    private  Context context;    public MyAdapter(List&lt;Bean&gt; data,Context context) &#123;        this.context = context;        this.data = data;    &#125;    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        View view = View.inflate(context,R.layout.list_item,null);        return new MyViewHolder(view);    &#125;    @Override    public void onBindViewHolder(@NonNull MyViewHolder holder, int position) &#123;        holder.tv.setText(data.get(position).getName());    &#125;    @Override    public int getItemCount() &#123;        return data == null ? 0 : data.size();    &#125;    public class MyViewHolder extends RecyclerView.ViewHolder &#123;        private TextView tv;        public MyViewHolder(@NonNull View itemView)&#123;            super(itemView);            tv = itemView.findViewById(R.id.tv1);            itemView.setOnClickListener(new View.OnClickListener() &#123;                @Override                public void onClick(View v) &#123;                    if (mOnItemClickListener != null)&#123;                        mOnItemClickListener.onRecyclerItemClick(getAdapterPosition());                    &#125;                &#125;            &#125;);        &#125;    &#125;    private OnRecyclerItemClickListener mOnItemClickListener;    public void setRecyclerItemClickListener(OnRecyclerItemClickListener listener)&#123;        mOnItemClickListener = listener;    &#125;    public interface OnRecyclerItemClickListener &#123;        void onRecyclerItemClick(int position);    &#125;&#125;</code></pre><h3 id="主布局-3"><a href="#主布局-3" class="headerlink" title="主布局"></a>主布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;vertical&quot;&gt;       &lt;androidx.recyclerview.widget.RecyclerView           android:layout_width=&quot;match_parent&quot;           android:layout_height=&quot;match_parent&quot;           android:id=&quot;@+id/rv&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><h3 id="item布局-1"><a href="#item布局-1" class="headerlink" title="item布局"></a>item布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:id=&quot;@+id/tv&quot;        android:orientation=&quot;vertical&quot;&gt;        &lt;ImageView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:src=&quot;@drawable/ic_launcher_foreground&quot;/&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:id=&quot;@+id/tv1&quot;            android:gravity=&quot;center&quot;            android:layout_gravity=&quot;center&quot;            android:textSize=&quot;30sp&quot;/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;</code></pre><h4 id="其中"><a href="#其中" class="headerlink" title="其中"></a>其中</h4><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742737925025.png" alt="1742737925025"></p><p>可以通过更换<code>Manager</code>来变换<code>RecyclerView</code>的布局</p><p>例如：</p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742738011458.png" alt="1742738011458"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742738022538.png" alt="1742738022538"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742738052712.png" alt="1742738052712"></p><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1742738073741.png" alt="1742738073741"></p><h1 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h1><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1743053322919.png" alt="1743053322919"></p><h2 id="代码实例-3"><a href="#代码实例-3" class="headerlink" title="代码实例"></a>代码实例</h2><h3 id="主布局-4"><a href="#主布局-4" class="headerlink" title="主布局"></a>主布局</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;    android:orientation=&quot;vertical&quot;&gt;    &lt;androidx.viewpager.widget.ViewPager        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:id=&quot;@+id/vp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h3 id="main-java"><a href="#main-java" class="headerlink" title="main_java"></a>main_java</h3><pre><code class="java">package com.example.practice;import android.content.Intent;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import androidx.viewpager.widget.ViewPager;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123;    private ViewPager viewPager;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        LayoutInflater lf = getLayoutInflater().from(this);        View view1 = lf.inflate(R.layout.layout1,null);        View view2 = lf.inflate(R.layout.layout2,null);        View view3 = lf.inflate(R.layout.layout3,null);        List&lt;View&gt; viewList = new ArrayList&lt;&gt;();        viewList.add(view1);        viewList.add(view2);        viewList.add(view3);        MyAdapter myAdapter = new MyAdapter(viewList);        viewPager = findViewById(R.id.vp);        viewPager.setAdapter(myAdapter);    &#125;&#125;</code></pre><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><pre><code class="java">package com.example.practice;import android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.viewpager.widget.PagerAdapter;import java.util.List;public class MyAdapter extends PagerAdapter &#123;    private List&lt;View&gt; mListView;    public MyAdapter(List&lt;View&gt; mListView) &#123;        this.mListView = mListView;    &#125;    @NonNull    @Override    public Object instantiateItem(@NonNull ViewGroup container, int position) &#123;        container.addView(mListView.get(position), 0);        return mListView.get(position);    &#125;    @Override    public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123;        container.removeView(mListView.get(position));    &#125;    @Override    public int getCount() &#123;        return mListView.size();    &#125;    @Override    public boolean isViewFromObject(@NonNull View view, @NonNull Object object) &#123;        return view == object;    &#125;&#125;</code></pre><p><img src="/../images/Android%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/1743054423130.png" alt="1743054423130"></p><h1 id="ViewPager2"><a href="#ViewPager2" class="headerlink" title="ViewPager2"></a>ViewPager2</h1><p><code>main_java</code></p><pre><code class="java">package com.example.practice;import android.os.Bundle;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import androidx.viewpager2.widget.ViewPager2;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        EdgeToEdge.enable(this);        setContentView(R.layout.activity_main);        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);            return insets;        &#125;);        ViewPager2 viewPager = findViewById(R.id.vp);        List&lt;String&gt; titles = new ArrayList&lt;&gt;();        titles.add(&quot;热点&quot;);        titles.add(&quot;推荐&quot;);        titles.add(&quot;影视&quot;);        titles.add(&quot;音乐&quot;);        ViewPagerAdapter viewPagerAdapter = new ViewPagerAdapter(titles);        viewPager.setAdapter(viewPagerAdapter);    &#125;&#125;</code></pre><p>适配器</p><pre><code class="java">package com.example.practice;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import java.util.ArrayList;import java.util.List;public class ViewPagerAdapter extends RecyclerView.Adapter&lt;ViewPagerAdapter.ViewPagerViewHolder&gt; &#123;    private List&lt;String&gt; titles = new ArrayList&lt;&gt;();    public ViewPagerAdapter(List&lt;String&gt; titles) &#123;        this.titles = titles;    &#125;    @NonNull    @Override    public ViewPagerViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;        return new ViewPagerViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_pager,parent,false));    &#125;    @Override    public void onBindViewHolder(@NonNull ViewPagerViewHolder holder, int position) &#123;        holder.mTv.setText(titles.get(position));    &#125;    @Override    public int getItemCount() &#123;        return titles.size();    &#125;    class ViewPagerViewHolder extends RecyclerView.ViewHolder &#123;        TextView mTv;        LinearLayout mContainer;        public ViewPagerViewHolder(@NonNull View itemView) &#123;            super(itemView);            mContainer = itemView.findViewById(R.id.ly);            mTv = itemView.findViewById(R.id.tvTitle);        &#125;    &#125;&#125;</code></pre><p>主布局</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/main&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;androidx.viewpager2.widget.ViewPager2        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:id=&quot;@+id/vp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><p>item布局</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:id=&quot;@+id/ly&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tvTitle&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;center&quot;        android:gravity=&quot;center&quot;        android:text=&quot;Hello World&quot;        android:textColor=&quot;#ff4532&quot;        android:textSize=&quot;32dp&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h2 id="ViewPager2-Fragment"><a href="#ViewPager2-Fragment" class="headerlink" title="ViewPager2 + Fragment"></a>ViewPager2 + Fragment</h2><p>在<code>main_java</code>中</p><pre><code class="java">private ViewPager2 viewPager;private void initPager()&#123;        viewPager = findViewById(R.id.viewpager);        ArrayList&lt;Fragment&gt; fragments = new ArrayList&lt;&gt;();        fragments.add(BlankFragment.newInstance(&quot;热点&quot;));        fragments.add(BlankFragment.newInstance(&quot;推荐&quot;));        fragments.add(BlankFragment.newInstance(&quot;直播&quot;));        fragments.add(BlankFragment.newInstance(&quot;动画&quot;));        fragments.add(BlankFragment.newInstance(&quot;影视&quot;));        MyFragmentPagerAdapter pagerAdapter = new MyFragmentPagerAdapter(getSupportFragmentManager(), getLifecycle(),fragments);        viewPager.setAdapter(pagerAdapter);        viewPager.registerOnPageChangeCallback(new ViewPager2.OnPageChangeCallback() &#123;            @Override            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;                super.onPageScrolled(position, positionOffset, positionOffsetPixels);            &#125;            @Override            public void onPageSelected(int position) &#123;                super.onPageSelected(position);            &#125;            @Override            public void onPageScrollStateChanged(int state) &#123;                super.onPageScrollStateChanged(state);            &#125;        &#125;);    &#125;</code></pre><p><code>MyFragmentPagerAdapter</code>适配器</p><pre><code class="java">package com.example.bilibili;import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentPagerAdapter;import androidx.fragment.app.FragmentStatePagerAdapter;import androidx.fragment.app.ListFragment;import androidx.lifecycle.Lifecycle;import androidx.viewpager2.adapter.FragmentStateAdapter;import java.util.ArrayList;import java.util.List;public class MyFragmentPagerAdapter extends FragmentStateAdapter &#123;    List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;();    public MyFragmentPagerAdapter(@NonNull FragmentManager fragmentManager, @NonNull Lifecycle lifecycle,List&lt;Fragment&gt; fragments) &#123;        super(fragmentManager, lifecycle);        fragmentList = fragments;    &#125;    @NonNull    @Override    public Fragment createFragment(int position) &#123;        return fragmentList.get(position);    &#125;    @Override    public int getItemCount() &#123;        return fragmentList.size();    &#125;&#125;</code></pre><p><code>BlankFragment</code>空白Fragment</p><pre><code class="java">package MyFragment;import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import com.example.bilibili.R;public class BlankFragment extends Fragment &#123;        private static final String ARG_TEXT = &quot;param1&quot;;    private String mTextString;    View rootView;    public BlankFragment() &#123;    &#125;        public static BlankFragment newInstance(String param1) &#123;        BlankFragment fragment = new BlankFragment();        Bundle args = new Bundle();        args.putString(ARG_TEXT, param1);        fragment.setArguments(args);        return fragment;    &#125;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        if (getArguments() != null) &#123;            mTextString = getArguments().getString(ARG_TEXT);        &#125;    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        if (rootView == null) &#123;            rootView = inflater.inflate(R.layout.fragment_blank, container, false);        &#125;        initView();        return rootView;    &#125;    private void initView() &#123;        TextView textView = rootView.findViewById(R.id.text);        textView.setText(mTextString);    &#125;&#125;</code></pre><p>主布局加入<code>ViewPaper2</code>控件</p><pre><code class="xml">&lt;androidx.viewpager2.widget.ViewPager2        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:id=&quot;@+id/viewpager&quot;/&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;TextView，Button，EditText，ImageView，listview，viewpage 等等&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/study/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
</feed>
